
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4826      	ldr	r0, [pc, #152]	; (800025c <endfiniloop+0x6>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	4825      	ldr	r0, [pc, #148]	; (8000260 <endfiniloop+0xa>)
 80001ca:	f64e 5108 	movw	r1, #60680	; 0xed08
 80001ce:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	2002      	movs	r0, #2
 80001d6:	f380 8814 	msr	CONTROL, r0
 80001da:	f3bf 8f6f 	isb	sy
 80001de:	f00c f997 	bl	800c510 <__core_init>
 80001e2:	f007 fb45 	bl	8007870 <__early_init>
 80001e6:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 80001ea:	491e      	ldr	r1, [pc, #120]	; (8000264 <endfiniloop+0xe>)
 80001ec:	4a1e      	ldr	r2, [pc, #120]	; (8000268 <endfiniloop+0x12>)

080001ee <msloop>:
 80001ee:	4291      	cmp	r1, r2
 80001f0:	bf3c      	itt	cc
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f6:	e7fa      	bcc.n	80001ee <msloop>
 80001f8:	491c      	ldr	r1, [pc, #112]	; (800026c <endfiniloop+0x16>)
 80001fa:	4a18      	ldr	r2, [pc, #96]	; (800025c <endfiniloop+0x6>)

080001fc <psloop>:
 80001fc:	4291      	cmp	r1, r2
 80001fe:	bf3c      	itt	cc
 8000200:	f841 0b04 	strcc.w	r0, [r1], #4
 8000204:	e7fa      	bcc.n	80001fc <psloop>
 8000206:	491a      	ldr	r1, [pc, #104]	; (8000270 <endfiniloop+0x1a>)
 8000208:	4a1a      	ldr	r2, [pc, #104]	; (8000274 <endfiniloop+0x1e>)
 800020a:	4b1b      	ldr	r3, [pc, #108]	; (8000278 <endfiniloop+0x22>)

0800020c <dloop>:
 800020c:	429a      	cmp	r2, r3
 800020e:	bf3e      	ittt	cc
 8000210:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000214:	f842 0b04 	strcc.w	r0, [r2], #4
 8000218:	e7f8      	bcc.n	800020c <dloop>
 800021a:	2000      	movs	r0, #0
 800021c:	4917      	ldr	r1, [pc, #92]	; (800027c <endfiniloop+0x26>)
 800021e:	4a18      	ldr	r2, [pc, #96]	; (8000280 <endfiniloop+0x2a>)

08000220 <bloop>:
 8000220:	4291      	cmp	r1, r2
 8000222:	bf3c      	itt	cc
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
 8000228:	e7fa      	bcc.n	8000220 <bloop>
 800022a:	f00c f929 	bl	800c480 <__init_ram_areas>
 800022e:	f00c f967 	bl	800c500 <__late_init>
 8000232:	4c14      	ldr	r4, [pc, #80]	; (8000284 <endfiniloop+0x2e>)
 8000234:	4d14      	ldr	r5, [pc, #80]	; (8000288 <endfiniloop+0x32>)

08000236 <initloop>:
 8000236:	42ac      	cmp	r4, r5
 8000238:	da03      	bge.n	8000242 <endinitloop>
 800023a:	f854 1b04 	ldr.w	r1, [r4], #4
 800023e:	4788      	blx	r1
 8000240:	e7f9      	b.n	8000236 <initloop>

08000242 <endinitloop>:
 8000242:	f005 fb15 	bl	8005870 <main>
 8000246:	4c11      	ldr	r4, [pc, #68]	; (800028c <endfiniloop+0x36>)
 8000248:	4d11      	ldr	r5, [pc, #68]	; (8000290 <endfiniloop+0x3a>)

0800024a <finiloop>:
 800024a:	42ac      	cmp	r4, r5
 800024c:	da03      	bge.n	8000256 <endfiniloop>
 800024e:	f854 1b04 	ldr.w	r1, [r4], #4
 8000252:	4788      	blx	r1
 8000254:	e7f9      	b.n	800024a <finiloop>

08000256 <endfiniloop>:
 8000256:	f00c b94b 	b.w	800c4f0 <__default_exit>
 800025a:	0000      	.short	0x0000
 800025c:	20000800 	.word	0x20000800
 8000260:	08000000 	.word	0x08000000
 8000264:	20000000 	.word	0x20000000
 8000268:	20000400 	.word	0x20000400
 800026c:	20000400 	.word	0x20000400
 8000270:	08011a24 	.word	0x08011a24
 8000274:	20000800 	.word	0x20000800
 8000278:	20000804 	.word	0x20000804
 800027c:	20000808 	.word	0x20000808
 8000280:	2001b774 	.word	0x2001b774
 8000284:	080001c0 	.word	0x080001c0
 8000288:	080001c0 	.word	0x080001c0
 800028c:	080001c0 	.word	0x080001c0
 8000290:	080001c0 	.word	0x080001c0

08000294 <_port_switch>:
 8000294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000298:	f8c1 d00c 	str.w	sp, [r1, #12]
 800029c:	68c3      	ldr	r3, [r0, #12]
 800029e:	469d      	mov	sp, r3
 80002a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002a4 <_port_thread_start>:
 80002a4:	f00b ff5c 	bl	800c160 <_dbg_check_unlock>
 80002a8:	2300      	movs	r3, #0
 80002aa:	f383 8811 	msr	BASEPRI, r3
 80002ae:	4628      	mov	r0, r5
 80002b0:	47a0      	blx	r4
 80002b2:	2000      	movs	r0, #0
 80002b4:	f00c f86c 	bl	800c390 <chThdExit>

080002b8 <_port_switch_from_isr>:
 80002b8:	f00b ff62 	bl	800c180 <_dbg_check_lock>
 80002bc:	f00b fd28 	bl	800bd10 <chSchDoReschedule>
 80002c0:	f00b ff4e 	bl	800c160 <_dbg_check_unlock>

080002c4 <_port_exit_from_isr>:
 80002c4:	df00      	svc	0
 80002c6:	e7fe      	b.n	80002c6 <_port_exit_from_isr+0x2>

080002c8 <__aeabi_drsub>:
 80002c8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002cc:	e002      	b.n	80002d4 <__adddf3>
 80002ce:	bf00      	nop

080002d0 <__aeabi_dsub>:
 80002d0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002d4 <__adddf3>:
 80002d4:	b530      	push	{r4, r5, lr}
 80002d6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002da:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002de:	ea94 0f05 	teq	r4, r5
 80002e2:	bf08      	it	eq
 80002e4:	ea90 0f02 	teqeq	r0, r2
 80002e8:	bf1f      	itttt	ne
 80002ea:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002ee:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002f2:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002f6:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002fa:	f000 80e2 	beq.w	80004c2 <__adddf3+0x1ee>
 80002fe:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000302:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000306:	bfb8      	it	lt
 8000308:	426d      	neglt	r5, r5
 800030a:	dd0c      	ble.n	8000326 <__adddf3+0x52>
 800030c:	442c      	add	r4, r5
 800030e:	ea80 0202 	eor.w	r2, r0, r2
 8000312:	ea81 0303 	eor.w	r3, r1, r3
 8000316:	ea82 0000 	eor.w	r0, r2, r0
 800031a:	ea83 0101 	eor.w	r1, r3, r1
 800031e:	ea80 0202 	eor.w	r2, r0, r2
 8000322:	ea81 0303 	eor.w	r3, r1, r3
 8000326:	2d36      	cmp	r5, #54	; 0x36
 8000328:	bf88      	it	hi
 800032a:	bd30      	pophi	{r4, r5, pc}
 800032c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000330:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000334:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000338:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800033c:	d002      	beq.n	8000344 <__adddf3+0x70>
 800033e:	4240      	negs	r0, r0
 8000340:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000344:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000348:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800034c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000350:	d002      	beq.n	8000358 <__adddf3+0x84>
 8000352:	4252      	negs	r2, r2
 8000354:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000358:	ea94 0f05 	teq	r4, r5
 800035c:	f000 80a7 	beq.w	80004ae <__adddf3+0x1da>
 8000360:	f1a4 0401 	sub.w	r4, r4, #1
 8000364:	f1d5 0e20 	rsbs	lr, r5, #32
 8000368:	db0d      	blt.n	8000386 <__adddf3+0xb2>
 800036a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800036e:	fa22 f205 	lsr.w	r2, r2, r5
 8000372:	1880      	adds	r0, r0, r2
 8000374:	f141 0100 	adc.w	r1, r1, #0
 8000378:	fa03 f20e 	lsl.w	r2, r3, lr
 800037c:	1880      	adds	r0, r0, r2
 800037e:	fa43 f305 	asr.w	r3, r3, r5
 8000382:	4159      	adcs	r1, r3
 8000384:	e00e      	b.n	80003a4 <__adddf3+0xd0>
 8000386:	f1a5 0520 	sub.w	r5, r5, #32
 800038a:	f10e 0e20 	add.w	lr, lr, #32
 800038e:	2a01      	cmp	r2, #1
 8000390:	fa03 fc0e 	lsl.w	ip, r3, lr
 8000394:	bf28      	it	cs
 8000396:	f04c 0c02 	orrcs.w	ip, ip, #2
 800039a:	fa43 f305 	asr.w	r3, r3, r5
 800039e:	18c0      	adds	r0, r0, r3
 80003a0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003a4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003a8:	d507      	bpl.n	80003ba <__adddf3+0xe6>
 80003aa:	f04f 0e00 	mov.w	lr, #0
 80003ae:	f1dc 0c00 	rsbs	ip, ip, #0
 80003b2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003b6:	eb6e 0101 	sbc.w	r1, lr, r1
 80003ba:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003be:	d31b      	bcc.n	80003f8 <__adddf3+0x124>
 80003c0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003c4:	d30c      	bcc.n	80003e0 <__adddf3+0x10c>
 80003c6:	0849      	lsrs	r1, r1, #1
 80003c8:	ea5f 0030 	movs.w	r0, r0, rrx
 80003cc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003d0:	f104 0401 	add.w	r4, r4, #1
 80003d4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003d8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003dc:	f080 809a 	bcs.w	8000514 <__adddf3+0x240>
 80003e0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003e4:	bf08      	it	eq
 80003e6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003ea:	f150 0000 	adcs.w	r0, r0, #0
 80003ee:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003f2:	ea41 0105 	orr.w	r1, r1, r5
 80003f6:	bd30      	pop	{r4, r5, pc}
 80003f8:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003fc:	4140      	adcs	r0, r0
 80003fe:	eb41 0101 	adc.w	r1, r1, r1
 8000402:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000406:	f1a4 0401 	sub.w	r4, r4, #1
 800040a:	d1e9      	bne.n	80003e0 <__adddf3+0x10c>
 800040c:	f091 0f00 	teq	r1, #0
 8000410:	bf04      	itt	eq
 8000412:	4601      	moveq	r1, r0
 8000414:	2000      	moveq	r0, #0
 8000416:	fab1 f381 	clz	r3, r1
 800041a:	bf08      	it	eq
 800041c:	3320      	addeq	r3, #32
 800041e:	f1a3 030b 	sub.w	r3, r3, #11
 8000422:	f1b3 0220 	subs.w	r2, r3, #32
 8000426:	da0c      	bge.n	8000442 <__adddf3+0x16e>
 8000428:	320c      	adds	r2, #12
 800042a:	dd08      	ble.n	800043e <__adddf3+0x16a>
 800042c:	f102 0c14 	add.w	ip, r2, #20
 8000430:	f1c2 020c 	rsb	r2, r2, #12
 8000434:	fa01 f00c 	lsl.w	r0, r1, ip
 8000438:	fa21 f102 	lsr.w	r1, r1, r2
 800043c:	e00c      	b.n	8000458 <__adddf3+0x184>
 800043e:	f102 0214 	add.w	r2, r2, #20
 8000442:	bfd8      	it	le
 8000444:	f1c2 0c20 	rsble	ip, r2, #32
 8000448:	fa01 f102 	lsl.w	r1, r1, r2
 800044c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000450:	bfdc      	itt	le
 8000452:	ea41 010c 	orrle.w	r1, r1, ip
 8000456:	4090      	lslle	r0, r2
 8000458:	1ae4      	subs	r4, r4, r3
 800045a:	bfa2      	ittt	ge
 800045c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000460:	4329      	orrge	r1, r5
 8000462:	bd30      	popge	{r4, r5, pc}
 8000464:	ea6f 0404 	mvn.w	r4, r4
 8000468:	3c1f      	subs	r4, #31
 800046a:	da1c      	bge.n	80004a6 <__adddf3+0x1d2>
 800046c:	340c      	adds	r4, #12
 800046e:	dc0e      	bgt.n	800048e <__adddf3+0x1ba>
 8000470:	f104 0414 	add.w	r4, r4, #20
 8000474:	f1c4 0220 	rsb	r2, r4, #32
 8000478:	fa20 f004 	lsr.w	r0, r0, r4
 800047c:	fa01 f302 	lsl.w	r3, r1, r2
 8000480:	ea40 0003 	orr.w	r0, r0, r3
 8000484:	fa21 f304 	lsr.w	r3, r1, r4
 8000488:	ea45 0103 	orr.w	r1, r5, r3
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	f1c4 040c 	rsb	r4, r4, #12
 8000492:	f1c4 0220 	rsb	r2, r4, #32
 8000496:	fa20 f002 	lsr.w	r0, r0, r2
 800049a:	fa01 f304 	lsl.w	r3, r1, r4
 800049e:	ea40 0003 	orr.w	r0, r0, r3
 80004a2:	4629      	mov	r1, r5
 80004a4:	bd30      	pop	{r4, r5, pc}
 80004a6:	fa21 f004 	lsr.w	r0, r1, r4
 80004aa:	4629      	mov	r1, r5
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	f094 0f00 	teq	r4, #0
 80004b2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004b6:	bf06      	itte	eq
 80004b8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004bc:	3401      	addeq	r4, #1
 80004be:	3d01      	subne	r5, #1
 80004c0:	e74e      	b.n	8000360 <__adddf3+0x8c>
 80004c2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004c6:	bf18      	it	ne
 80004c8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004cc:	d029      	beq.n	8000522 <__adddf3+0x24e>
 80004ce:	ea94 0f05 	teq	r4, r5
 80004d2:	bf08      	it	eq
 80004d4:	ea90 0f02 	teqeq	r0, r2
 80004d8:	d005      	beq.n	80004e6 <__adddf3+0x212>
 80004da:	ea54 0c00 	orrs.w	ip, r4, r0
 80004de:	bf04      	itt	eq
 80004e0:	4619      	moveq	r1, r3
 80004e2:	4610      	moveq	r0, r2
 80004e4:	bd30      	pop	{r4, r5, pc}
 80004e6:	ea91 0f03 	teq	r1, r3
 80004ea:	bf1e      	ittt	ne
 80004ec:	2100      	movne	r1, #0
 80004ee:	2000      	movne	r0, #0
 80004f0:	bd30      	popne	{r4, r5, pc}
 80004f2:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004f6:	d105      	bne.n	8000504 <__adddf3+0x230>
 80004f8:	0040      	lsls	r0, r0, #1
 80004fa:	4149      	adcs	r1, r1
 80004fc:	bf28      	it	cs
 80004fe:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000502:	bd30      	pop	{r4, r5, pc}
 8000504:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000508:	bf3c      	itt	cc
 800050a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800050e:	bd30      	popcc	{r4, r5, pc}
 8000510:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000514:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000518:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800051c:	f04f 0000 	mov.w	r0, #0
 8000520:	bd30      	pop	{r4, r5, pc}
 8000522:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000526:	bf1a      	itte	ne
 8000528:	4619      	movne	r1, r3
 800052a:	4610      	movne	r0, r2
 800052c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000530:	bf1c      	itt	ne
 8000532:	460b      	movne	r3, r1
 8000534:	4602      	movne	r2, r0
 8000536:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800053a:	bf06      	itte	eq
 800053c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000540:	ea91 0f03 	teqeq	r1, r3
 8000544:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000548:	bd30      	pop	{r4, r5, pc}
 800054a:	bf00      	nop

0800054c <__aeabi_ui2d>:
 800054c:	f090 0f00 	teq	r0, #0
 8000550:	bf04      	itt	eq
 8000552:	2100      	moveq	r1, #0
 8000554:	4770      	bxeq	lr
 8000556:	b530      	push	{r4, r5, lr}
 8000558:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800055c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000560:	f04f 0500 	mov.w	r5, #0
 8000564:	f04f 0100 	mov.w	r1, #0
 8000568:	e750      	b.n	800040c <__adddf3+0x138>
 800056a:	bf00      	nop

0800056c <__aeabi_i2d>:
 800056c:	f090 0f00 	teq	r0, #0
 8000570:	bf04      	itt	eq
 8000572:	2100      	moveq	r1, #0
 8000574:	4770      	bxeq	lr
 8000576:	b530      	push	{r4, r5, lr}
 8000578:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800057c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000580:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8000584:	bf48      	it	mi
 8000586:	4240      	negmi	r0, r0
 8000588:	f04f 0100 	mov.w	r1, #0
 800058c:	e73e      	b.n	800040c <__adddf3+0x138>
 800058e:	bf00      	nop

08000590 <__aeabi_f2d>:
 8000590:	0042      	lsls	r2, r0, #1
 8000592:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8000596:	ea4f 0131 	mov.w	r1, r1, rrx
 800059a:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800059e:	bf1f      	itttt	ne
 80005a0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005a4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005a8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005ac:	4770      	bxne	lr
 80005ae:	f092 0f00 	teq	r2, #0
 80005b2:	bf14      	ite	ne
 80005b4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005b8:	4770      	bxeq	lr
 80005ba:	b530      	push	{r4, r5, lr}
 80005bc:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005c0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005c4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005c8:	e720      	b.n	800040c <__adddf3+0x138>
 80005ca:	bf00      	nop

080005cc <__aeabi_ul2d>:
 80005cc:	ea50 0201 	orrs.w	r2, r0, r1
 80005d0:	bf08      	it	eq
 80005d2:	4770      	bxeq	lr
 80005d4:	b530      	push	{r4, r5, lr}
 80005d6:	f04f 0500 	mov.w	r5, #0
 80005da:	e00a      	b.n	80005f2 <__aeabi_l2d+0x16>

080005dc <__aeabi_l2d>:
 80005dc:	ea50 0201 	orrs.w	r2, r0, r1
 80005e0:	bf08      	it	eq
 80005e2:	4770      	bxeq	lr
 80005e4:	b530      	push	{r4, r5, lr}
 80005e6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005ea:	d502      	bpl.n	80005f2 <__aeabi_l2d+0x16>
 80005ec:	4240      	negs	r0, r0
 80005ee:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005f2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005f6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005fa:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005fe:	f43f aedc 	beq.w	80003ba <__adddf3+0xe6>
 8000602:	f04f 0203 	mov.w	r2, #3
 8000606:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800060a:	bf18      	it	ne
 800060c:	3203      	addne	r2, #3
 800060e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000612:	bf18      	it	ne
 8000614:	3203      	addne	r2, #3
 8000616:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800061a:	f1c2 0320 	rsb	r3, r2, #32
 800061e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000622:	fa20 f002 	lsr.w	r0, r0, r2
 8000626:	fa01 fe03 	lsl.w	lr, r1, r3
 800062a:	ea40 000e 	orr.w	r0, r0, lr
 800062e:	fa21 f102 	lsr.w	r1, r1, r2
 8000632:	4414      	add	r4, r2
 8000634:	e6c1      	b.n	80003ba <__adddf3+0xe6>
 8000636:	bf00      	nop

08000638 <__aeabi_dmul>:
 8000638:	b570      	push	{r4, r5, r6, lr}
 800063a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800063e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000642:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000646:	bf1d      	ittte	ne
 8000648:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800064c:	ea94 0f0c 	teqne	r4, ip
 8000650:	ea95 0f0c 	teqne	r5, ip
 8000654:	f000 f8de 	bleq	8000814 <__aeabi_dmul+0x1dc>
 8000658:	442c      	add	r4, r5
 800065a:	ea81 0603 	eor.w	r6, r1, r3
 800065e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000662:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000666:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800066a:	bf18      	it	ne
 800066c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000670:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000674:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000678:	d038      	beq.n	80006ec <__aeabi_dmul+0xb4>
 800067a:	fba0 ce02 	umull	ip, lr, r0, r2
 800067e:	f04f 0500 	mov.w	r5, #0
 8000682:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000686:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800068a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800068e:	f04f 0600 	mov.w	r6, #0
 8000692:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000696:	f09c 0f00 	teq	ip, #0
 800069a:	bf18      	it	ne
 800069c:	f04e 0e01 	orrne.w	lr, lr, #1
 80006a0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006a4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006a8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006ac:	d204      	bcs.n	80006b8 <__aeabi_dmul+0x80>
 80006ae:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006b2:	416d      	adcs	r5, r5
 80006b4:	eb46 0606 	adc.w	r6, r6, r6
 80006b8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006bc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006c0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006c4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006c8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006cc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006d0:	bf88      	it	hi
 80006d2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006d6:	d81e      	bhi.n	8000716 <__aeabi_dmul+0xde>
 80006d8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006dc:	bf08      	it	eq
 80006de:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006e2:	f150 0000 	adcs.w	r0, r0, #0
 80006e6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006ea:	bd70      	pop	{r4, r5, r6, pc}
 80006ec:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006f0:	ea46 0101 	orr.w	r1, r6, r1
 80006f4:	ea40 0002 	orr.w	r0, r0, r2
 80006f8:	ea81 0103 	eor.w	r1, r1, r3
 80006fc:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000700:	bfc2      	ittt	gt
 8000702:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000706:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800070a:	bd70      	popgt	{r4, r5, r6, pc}
 800070c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000710:	f04f 0e00 	mov.w	lr, #0
 8000714:	3c01      	subs	r4, #1
 8000716:	f300 80ab 	bgt.w	8000870 <__aeabi_dmul+0x238>
 800071a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800071e:	bfde      	ittt	le
 8000720:	2000      	movle	r0, #0
 8000722:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000726:	bd70      	pople	{r4, r5, r6, pc}
 8000728:	f1c4 0400 	rsb	r4, r4, #0
 800072c:	3c20      	subs	r4, #32
 800072e:	da35      	bge.n	800079c <__aeabi_dmul+0x164>
 8000730:	340c      	adds	r4, #12
 8000732:	dc1b      	bgt.n	800076c <__aeabi_dmul+0x134>
 8000734:	f104 0414 	add.w	r4, r4, #20
 8000738:	f1c4 0520 	rsb	r5, r4, #32
 800073c:	fa00 f305 	lsl.w	r3, r0, r5
 8000740:	fa20 f004 	lsr.w	r0, r0, r4
 8000744:	fa01 f205 	lsl.w	r2, r1, r5
 8000748:	ea40 0002 	orr.w	r0, r0, r2
 800074c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000750:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000754:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000758:	fa21 f604 	lsr.w	r6, r1, r4
 800075c:	eb42 0106 	adc.w	r1, r2, r6
 8000760:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000764:	bf08      	it	eq
 8000766:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800076a:	bd70      	pop	{r4, r5, r6, pc}
 800076c:	f1c4 040c 	rsb	r4, r4, #12
 8000770:	f1c4 0520 	rsb	r5, r4, #32
 8000774:	fa00 f304 	lsl.w	r3, r0, r4
 8000778:	fa20 f005 	lsr.w	r0, r0, r5
 800077c:	fa01 f204 	lsl.w	r2, r1, r4
 8000780:	ea40 0002 	orr.w	r0, r0, r2
 8000784:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000788:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800078c:	f141 0100 	adc.w	r1, r1, #0
 8000790:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000794:	bf08      	it	eq
 8000796:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800079a:	bd70      	pop	{r4, r5, r6, pc}
 800079c:	f1c4 0520 	rsb	r5, r4, #32
 80007a0:	fa00 f205 	lsl.w	r2, r0, r5
 80007a4:	ea4e 0e02 	orr.w	lr, lr, r2
 80007a8:	fa20 f304 	lsr.w	r3, r0, r4
 80007ac:	fa01 f205 	lsl.w	r2, r1, r5
 80007b0:	ea43 0302 	orr.w	r3, r3, r2
 80007b4:	fa21 f004 	lsr.w	r0, r1, r4
 80007b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007bc:	fa21 f204 	lsr.w	r2, r1, r4
 80007c0:	ea20 0002 	bic.w	r0, r0, r2
 80007c4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007c8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007cc:	bf08      	it	eq
 80007ce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007d2:	bd70      	pop	{r4, r5, r6, pc}
 80007d4:	f094 0f00 	teq	r4, #0
 80007d8:	d10f      	bne.n	80007fa <__aeabi_dmul+0x1c2>
 80007da:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007de:	0040      	lsls	r0, r0, #1
 80007e0:	eb41 0101 	adc.w	r1, r1, r1
 80007e4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007e8:	bf08      	it	eq
 80007ea:	3c01      	subeq	r4, #1
 80007ec:	d0f7      	beq.n	80007de <__aeabi_dmul+0x1a6>
 80007ee:	ea41 0106 	orr.w	r1, r1, r6
 80007f2:	f095 0f00 	teq	r5, #0
 80007f6:	bf18      	it	ne
 80007f8:	4770      	bxne	lr
 80007fa:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007fe:	0052      	lsls	r2, r2, #1
 8000800:	eb43 0303 	adc.w	r3, r3, r3
 8000804:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000808:	bf08      	it	eq
 800080a:	3d01      	subeq	r5, #1
 800080c:	d0f7      	beq.n	80007fe <__aeabi_dmul+0x1c6>
 800080e:	ea43 0306 	orr.w	r3, r3, r6
 8000812:	4770      	bx	lr
 8000814:	ea94 0f0c 	teq	r4, ip
 8000818:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800081c:	bf18      	it	ne
 800081e:	ea95 0f0c 	teqne	r5, ip
 8000822:	d00c      	beq.n	800083e <__aeabi_dmul+0x206>
 8000824:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000828:	bf18      	it	ne
 800082a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800082e:	d1d1      	bne.n	80007d4 <__aeabi_dmul+0x19c>
 8000830:	ea81 0103 	eor.w	r1, r1, r3
 8000834:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000838:	f04f 0000 	mov.w	r0, #0
 800083c:	bd70      	pop	{r4, r5, r6, pc}
 800083e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000842:	bf06      	itte	eq
 8000844:	4610      	moveq	r0, r2
 8000846:	4619      	moveq	r1, r3
 8000848:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800084c:	d019      	beq.n	8000882 <__aeabi_dmul+0x24a>
 800084e:	ea94 0f0c 	teq	r4, ip
 8000852:	d102      	bne.n	800085a <__aeabi_dmul+0x222>
 8000854:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000858:	d113      	bne.n	8000882 <__aeabi_dmul+0x24a>
 800085a:	ea95 0f0c 	teq	r5, ip
 800085e:	d105      	bne.n	800086c <__aeabi_dmul+0x234>
 8000860:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000864:	bf1c      	itt	ne
 8000866:	4610      	movne	r0, r2
 8000868:	4619      	movne	r1, r3
 800086a:	d10a      	bne.n	8000882 <__aeabi_dmul+0x24a>
 800086c:	ea81 0103 	eor.w	r1, r1, r3
 8000870:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000874:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000878:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800087c:	f04f 0000 	mov.w	r0, #0
 8000880:	bd70      	pop	{r4, r5, r6, pc}
 8000882:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000886:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800088a:	bd70      	pop	{r4, r5, r6, pc}

0800088c <__aeabi_ddiv>:
 800088c:	b570      	push	{r4, r5, r6, lr}
 800088e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000892:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000896:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800089a:	bf1d      	ittte	ne
 800089c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008a0:	ea94 0f0c 	teqne	r4, ip
 80008a4:	ea95 0f0c 	teqne	r5, ip
 80008a8:	f000 f8a7 	bleq	80009fa <__aeabi_ddiv+0x16e>
 80008ac:	eba4 0405 	sub.w	r4, r4, r5
 80008b0:	ea81 0e03 	eor.w	lr, r1, r3
 80008b4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008b8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008bc:	f000 8088 	beq.w	80009d0 <__aeabi_ddiv+0x144>
 80008c0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008c4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008c8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008cc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008d0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008d4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008d8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008dc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008e0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008e4:	429d      	cmp	r5, r3
 80008e6:	bf08      	it	eq
 80008e8:	4296      	cmpeq	r6, r2
 80008ea:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008ee:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008f2:	d202      	bcs.n	80008fa <__aeabi_ddiv+0x6e>
 80008f4:	085b      	lsrs	r3, r3, #1
 80008f6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008fa:	1ab6      	subs	r6, r6, r2
 80008fc:	eb65 0503 	sbc.w	r5, r5, r3
 8000900:	085b      	lsrs	r3, r3, #1
 8000902:	ea4f 0232 	mov.w	r2, r2, rrx
 8000906:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800090a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000950:	085b      	lsrs	r3, r3, #1
 8000952:	ea4f 0232 	mov.w	r2, r2, rrx
 8000956:	ebb6 0e02 	subs.w	lr, r6, r2
 800095a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800095e:	bf22      	ittt	cs
 8000960:	1ab6      	subcs	r6, r6, r2
 8000962:	4675      	movcs	r5, lr
 8000964:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000968:	ea55 0e06 	orrs.w	lr, r5, r6
 800096c:	d018      	beq.n	80009a0 <__aeabi_ddiv+0x114>
 800096e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000972:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000976:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800097a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800097e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000982:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000986:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800098a:	d1c0      	bne.n	800090e <__aeabi_ddiv+0x82>
 800098c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000990:	d10b      	bne.n	80009aa <__aeabi_ddiv+0x11e>
 8000992:	ea41 0100 	orr.w	r1, r1, r0
 8000996:	f04f 0000 	mov.w	r0, #0
 800099a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800099e:	e7b6      	b.n	800090e <__aeabi_ddiv+0x82>
 80009a0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009a4:	bf04      	itt	eq
 80009a6:	4301      	orreq	r1, r0
 80009a8:	2000      	moveq	r0, #0
 80009aa:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009ae:	bf88      	it	hi
 80009b0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009b4:	f63f aeaf 	bhi.w	8000716 <__aeabi_dmul+0xde>
 80009b8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009bc:	bf04      	itt	eq
 80009be:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009c2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009c6:	f150 0000 	adcs.w	r0, r0, #0
 80009ca:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009ce:	bd70      	pop	{r4, r5, r6, pc}
 80009d0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009d4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009d8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009dc:	bfc2      	ittt	gt
 80009de:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009e2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009e6:	bd70      	popgt	{r4, r5, r6, pc}
 80009e8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009ec:	f04f 0e00 	mov.w	lr, #0
 80009f0:	3c01      	subs	r4, #1
 80009f2:	e690      	b.n	8000716 <__aeabi_dmul+0xde>
 80009f4:	ea45 0e06 	orr.w	lr, r5, r6
 80009f8:	e68d      	b.n	8000716 <__aeabi_dmul+0xde>
 80009fa:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009fe:	ea94 0f0c 	teq	r4, ip
 8000a02:	bf08      	it	eq
 8000a04:	ea95 0f0c 	teqeq	r5, ip
 8000a08:	f43f af3b 	beq.w	8000882 <__aeabi_dmul+0x24a>
 8000a0c:	ea94 0f0c 	teq	r4, ip
 8000a10:	d10a      	bne.n	8000a28 <__aeabi_ddiv+0x19c>
 8000a12:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a16:	f47f af34 	bne.w	8000882 <__aeabi_dmul+0x24a>
 8000a1a:	ea95 0f0c 	teq	r5, ip
 8000a1e:	f47f af25 	bne.w	800086c <__aeabi_dmul+0x234>
 8000a22:	4610      	mov	r0, r2
 8000a24:	4619      	mov	r1, r3
 8000a26:	e72c      	b.n	8000882 <__aeabi_dmul+0x24a>
 8000a28:	ea95 0f0c 	teq	r5, ip
 8000a2c:	d106      	bne.n	8000a3c <__aeabi_ddiv+0x1b0>
 8000a2e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a32:	f43f aefd 	beq.w	8000830 <__aeabi_dmul+0x1f8>
 8000a36:	4610      	mov	r0, r2
 8000a38:	4619      	mov	r1, r3
 8000a3a:	e722      	b.n	8000882 <__aeabi_dmul+0x24a>
 8000a3c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a40:	bf18      	it	ne
 8000a42:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a46:	f47f aec5 	bne.w	80007d4 <__aeabi_dmul+0x19c>
 8000a4a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a4e:	f47f af0d 	bne.w	800086c <__aeabi_dmul+0x234>
 8000a52:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a56:	f47f aeeb 	bne.w	8000830 <__aeabi_dmul+0x1f8>
 8000a5a:	e712      	b.n	8000882 <__aeabi_dmul+0x24a>

08000a5c <__aeabi_d2uiz>:
 8000a5c:	004a      	lsls	r2, r1, #1
 8000a5e:	d211      	bcs.n	8000a84 <__aeabi_d2uiz+0x28>
 8000a60:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a64:	d211      	bcs.n	8000a8a <__aeabi_d2uiz+0x2e>
 8000a66:	d50d      	bpl.n	8000a84 <__aeabi_d2uiz+0x28>
 8000a68:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a6c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a70:	d40e      	bmi.n	8000a90 <__aeabi_d2uiz+0x34>
 8000a72:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a76:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a7a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a7e:	fa23 f002 	lsr.w	r0, r3, r2
 8000a82:	4770      	bx	lr
 8000a84:	f04f 0000 	mov.w	r0, #0
 8000a88:	4770      	bx	lr
 8000a8a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a8e:	d102      	bne.n	8000a96 <__aeabi_d2uiz+0x3a>
 8000a90:	f04f 30ff 	mov.w	r0, #4294967295
 8000a94:	4770      	bx	lr
 8000a96:	f04f 0000 	mov.w	r0, #0
 8000a9a:	4770      	bx	lr

08000a9c <__aeabi_frsub>:
 8000a9c:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000aa0:	e002      	b.n	8000aa8 <__addsf3>
 8000aa2:	bf00      	nop

08000aa4 <__aeabi_fsub>:
 8000aa4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000aa8 <__addsf3>:
 8000aa8:	0042      	lsls	r2, r0, #1
 8000aaa:	bf1f      	itttt	ne
 8000aac:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000ab0:	ea92 0f03 	teqne	r2, r3
 8000ab4:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000ab8:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000abc:	d06a      	beq.n	8000b94 <__addsf3+0xec>
 8000abe:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000ac2:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000ac6:	bfc1      	itttt	gt
 8000ac8:	18d2      	addgt	r2, r2, r3
 8000aca:	4041      	eorgt	r1, r0
 8000acc:	4048      	eorgt	r0, r1
 8000ace:	4041      	eorgt	r1, r0
 8000ad0:	bfb8      	it	lt
 8000ad2:	425b      	neglt	r3, r3
 8000ad4:	2b19      	cmp	r3, #25
 8000ad6:	bf88      	it	hi
 8000ad8:	4770      	bxhi	lr
 8000ada:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000ade:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ae2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000ae6:	bf18      	it	ne
 8000ae8:	4240      	negne	r0, r0
 8000aea:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000aee:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000af2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000af6:	bf18      	it	ne
 8000af8:	4249      	negne	r1, r1
 8000afa:	ea92 0f03 	teq	r2, r3
 8000afe:	d03f      	beq.n	8000b80 <__addsf3+0xd8>
 8000b00:	f1a2 0201 	sub.w	r2, r2, #1
 8000b04:	fa41 fc03 	asr.w	ip, r1, r3
 8000b08:	eb10 000c 	adds.w	r0, r0, ip
 8000b0c:	f1c3 0320 	rsb	r3, r3, #32
 8000b10:	fa01 f103 	lsl.w	r1, r1, r3
 8000b14:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000b18:	d502      	bpl.n	8000b20 <__addsf3+0x78>
 8000b1a:	4249      	negs	r1, r1
 8000b1c:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000b20:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000b24:	d313      	bcc.n	8000b4e <__addsf3+0xa6>
 8000b26:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000b2a:	d306      	bcc.n	8000b3a <__addsf3+0x92>
 8000b2c:	0840      	lsrs	r0, r0, #1
 8000b2e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000b32:	f102 0201 	add.w	r2, r2, #1
 8000b36:	2afe      	cmp	r2, #254	; 0xfe
 8000b38:	d251      	bcs.n	8000bde <__addsf3+0x136>
 8000b3a:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000b3e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000b42:	bf08      	it	eq
 8000b44:	f020 0001 	biceq.w	r0, r0, #1
 8000b48:	ea40 0003 	orr.w	r0, r0, r3
 8000b4c:	4770      	bx	lr
 8000b4e:	0049      	lsls	r1, r1, #1
 8000b50:	eb40 0000 	adc.w	r0, r0, r0
 8000b54:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8000b58:	f1a2 0201 	sub.w	r2, r2, #1
 8000b5c:	d1ed      	bne.n	8000b3a <__addsf3+0x92>
 8000b5e:	fab0 fc80 	clz	ip, r0
 8000b62:	f1ac 0c08 	sub.w	ip, ip, #8
 8000b66:	ebb2 020c 	subs.w	r2, r2, ip
 8000b6a:	fa00 f00c 	lsl.w	r0, r0, ip
 8000b6e:	bfaa      	itet	ge
 8000b70:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000b74:	4252      	neglt	r2, r2
 8000b76:	4318      	orrge	r0, r3
 8000b78:	bfbc      	itt	lt
 8000b7a:	40d0      	lsrlt	r0, r2
 8000b7c:	4318      	orrlt	r0, r3
 8000b7e:	4770      	bx	lr
 8000b80:	f092 0f00 	teq	r2, #0
 8000b84:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000b88:	bf06      	itte	eq
 8000b8a:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000b8e:	3201      	addeq	r2, #1
 8000b90:	3b01      	subne	r3, #1
 8000b92:	e7b5      	b.n	8000b00 <__addsf3+0x58>
 8000b94:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000b98:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000b9c:	bf18      	it	ne
 8000b9e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000ba2:	d021      	beq.n	8000be8 <__addsf3+0x140>
 8000ba4:	ea92 0f03 	teq	r2, r3
 8000ba8:	d004      	beq.n	8000bb4 <__addsf3+0x10c>
 8000baa:	f092 0f00 	teq	r2, #0
 8000bae:	bf08      	it	eq
 8000bb0:	4608      	moveq	r0, r1
 8000bb2:	4770      	bx	lr
 8000bb4:	ea90 0f01 	teq	r0, r1
 8000bb8:	bf1c      	itt	ne
 8000bba:	2000      	movne	r0, #0
 8000bbc:	4770      	bxne	lr
 8000bbe:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000bc2:	d104      	bne.n	8000bce <__addsf3+0x126>
 8000bc4:	0040      	lsls	r0, r0, #1
 8000bc6:	bf28      	it	cs
 8000bc8:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000bcc:	4770      	bx	lr
 8000bce:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000bd2:	bf3c      	itt	cc
 8000bd4:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000bd8:	4770      	bxcc	lr
 8000bda:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000bde:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000be2:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000be6:	4770      	bx	lr
 8000be8:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000bec:	bf16      	itet	ne
 8000bee:	4608      	movne	r0, r1
 8000bf0:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000bf4:	4601      	movne	r1, r0
 8000bf6:	0242      	lsls	r2, r0, #9
 8000bf8:	bf06      	itte	eq
 8000bfa:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000bfe:	ea90 0f01 	teqeq	r0, r1
 8000c02:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000c06:	4770      	bx	lr

08000c08 <__aeabi_ui2f>:
 8000c08:	f04f 0300 	mov.w	r3, #0
 8000c0c:	e004      	b.n	8000c18 <__aeabi_i2f+0x8>
 8000c0e:	bf00      	nop

08000c10 <__aeabi_i2f>:
 8000c10:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000c14:	bf48      	it	mi
 8000c16:	4240      	negmi	r0, r0
 8000c18:	ea5f 0c00 	movs.w	ip, r0
 8000c1c:	bf08      	it	eq
 8000c1e:	4770      	bxeq	lr
 8000c20:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000c24:	4601      	mov	r1, r0
 8000c26:	f04f 0000 	mov.w	r0, #0
 8000c2a:	e01c      	b.n	8000c66 <__aeabi_l2f+0x2a>

08000c2c <__aeabi_ul2f>:
 8000c2c:	ea50 0201 	orrs.w	r2, r0, r1
 8000c30:	bf08      	it	eq
 8000c32:	4770      	bxeq	lr
 8000c34:	f04f 0300 	mov.w	r3, #0
 8000c38:	e00a      	b.n	8000c50 <__aeabi_l2f+0x14>
 8000c3a:	bf00      	nop

08000c3c <__aeabi_l2f>:
 8000c3c:	ea50 0201 	orrs.w	r2, r0, r1
 8000c40:	bf08      	it	eq
 8000c42:	4770      	bxeq	lr
 8000c44:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000c48:	d502      	bpl.n	8000c50 <__aeabi_l2f+0x14>
 8000c4a:	4240      	negs	r0, r0
 8000c4c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000c50:	ea5f 0c01 	movs.w	ip, r1
 8000c54:	bf02      	ittt	eq
 8000c56:	4684      	moveq	ip, r0
 8000c58:	4601      	moveq	r1, r0
 8000c5a:	2000      	moveq	r0, #0
 8000c5c:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000c60:	bf08      	it	eq
 8000c62:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000c66:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000c6a:	fabc f28c 	clz	r2, ip
 8000c6e:	3a08      	subs	r2, #8
 8000c70:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000c74:	db10      	blt.n	8000c98 <__aeabi_l2f+0x5c>
 8000c76:	fa01 fc02 	lsl.w	ip, r1, r2
 8000c7a:	4463      	add	r3, ip
 8000c7c:	fa00 fc02 	lsl.w	ip, r0, r2
 8000c80:	f1c2 0220 	rsb	r2, r2, #32
 8000c84:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000c88:	fa20 f202 	lsr.w	r2, r0, r2
 8000c8c:	eb43 0002 	adc.w	r0, r3, r2
 8000c90:	bf08      	it	eq
 8000c92:	f020 0001 	biceq.w	r0, r0, #1
 8000c96:	4770      	bx	lr
 8000c98:	f102 0220 	add.w	r2, r2, #32
 8000c9c:	fa01 fc02 	lsl.w	ip, r1, r2
 8000ca0:	f1c2 0220 	rsb	r2, r2, #32
 8000ca4:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000ca8:	fa21 f202 	lsr.w	r2, r1, r2
 8000cac:	eb43 0002 	adc.w	r0, r3, r2
 8000cb0:	bf08      	it	eq
 8000cb2:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000cb6:	4770      	bx	lr

08000cb8 <__aeabi_fmul>:
 8000cb8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000cbc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000cc0:	bf1e      	ittt	ne
 8000cc2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000cc6:	ea92 0f0c 	teqne	r2, ip
 8000cca:	ea93 0f0c 	teqne	r3, ip
 8000cce:	d06f      	beq.n	8000db0 <__aeabi_fmul+0xf8>
 8000cd0:	441a      	add	r2, r3
 8000cd2:	ea80 0c01 	eor.w	ip, r0, r1
 8000cd6:	0240      	lsls	r0, r0, #9
 8000cd8:	bf18      	it	ne
 8000cda:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000cde:	d01e      	beq.n	8000d1e <__aeabi_fmul+0x66>
 8000ce0:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000ce4:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000ce8:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000cec:	fba0 3101 	umull	r3, r1, r0, r1
 8000cf0:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000cf4:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000cf8:	bf3e      	ittt	cc
 8000cfa:	0049      	lslcc	r1, r1, #1
 8000cfc:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000d00:	005b      	lslcc	r3, r3, #1
 8000d02:	ea40 0001 	orr.w	r0, r0, r1
 8000d06:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000d0a:	2afd      	cmp	r2, #253	; 0xfd
 8000d0c:	d81d      	bhi.n	8000d4a <__aeabi_fmul+0x92>
 8000d0e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000d12:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000d16:	bf08      	it	eq
 8000d18:	f020 0001 	biceq.w	r0, r0, #1
 8000d1c:	4770      	bx	lr
 8000d1e:	f090 0f00 	teq	r0, #0
 8000d22:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000d26:	bf08      	it	eq
 8000d28:	0249      	lsleq	r1, r1, #9
 8000d2a:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000d2e:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000d32:	3a7f      	subs	r2, #127	; 0x7f
 8000d34:	bfc2      	ittt	gt
 8000d36:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000d3a:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000d3e:	4770      	bxgt	lr
 8000d40:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000d44:	f04f 0300 	mov.w	r3, #0
 8000d48:	3a01      	subs	r2, #1
 8000d4a:	dc5d      	bgt.n	8000e08 <__aeabi_fmul+0x150>
 8000d4c:	f112 0f19 	cmn.w	r2, #25
 8000d50:	bfdc      	itt	le
 8000d52:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000d56:	4770      	bxle	lr
 8000d58:	f1c2 0200 	rsb	r2, r2, #0
 8000d5c:	0041      	lsls	r1, r0, #1
 8000d5e:	fa21 f102 	lsr.w	r1, r1, r2
 8000d62:	f1c2 0220 	rsb	r2, r2, #32
 8000d66:	fa00 fc02 	lsl.w	ip, r0, r2
 8000d6a:	ea5f 0031 	movs.w	r0, r1, rrx
 8000d6e:	f140 0000 	adc.w	r0, r0, #0
 8000d72:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000d76:	bf08      	it	eq
 8000d78:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000d7c:	4770      	bx	lr
 8000d7e:	f092 0f00 	teq	r2, #0
 8000d82:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000d86:	bf02      	ittt	eq
 8000d88:	0040      	lsleq	r0, r0, #1
 8000d8a:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000d8e:	3a01      	subeq	r2, #1
 8000d90:	d0f9      	beq.n	8000d86 <__aeabi_fmul+0xce>
 8000d92:	ea40 000c 	orr.w	r0, r0, ip
 8000d96:	f093 0f00 	teq	r3, #0
 8000d9a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000d9e:	bf02      	ittt	eq
 8000da0:	0049      	lsleq	r1, r1, #1
 8000da2:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000da6:	3b01      	subeq	r3, #1
 8000da8:	d0f9      	beq.n	8000d9e <__aeabi_fmul+0xe6>
 8000daa:	ea41 010c 	orr.w	r1, r1, ip
 8000dae:	e78f      	b.n	8000cd0 <__aeabi_fmul+0x18>
 8000db0:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000db4:	ea92 0f0c 	teq	r2, ip
 8000db8:	bf18      	it	ne
 8000dba:	ea93 0f0c 	teqne	r3, ip
 8000dbe:	d00a      	beq.n	8000dd6 <__aeabi_fmul+0x11e>
 8000dc0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000dc4:	bf18      	it	ne
 8000dc6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000dca:	d1d8      	bne.n	8000d7e <__aeabi_fmul+0xc6>
 8000dcc:	ea80 0001 	eor.w	r0, r0, r1
 8000dd0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000dd4:	4770      	bx	lr
 8000dd6:	f090 0f00 	teq	r0, #0
 8000dda:	bf17      	itett	ne
 8000ddc:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000de0:	4608      	moveq	r0, r1
 8000de2:	f091 0f00 	teqne	r1, #0
 8000de6:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000dea:	d014      	beq.n	8000e16 <__aeabi_fmul+0x15e>
 8000dec:	ea92 0f0c 	teq	r2, ip
 8000df0:	d101      	bne.n	8000df6 <__aeabi_fmul+0x13e>
 8000df2:	0242      	lsls	r2, r0, #9
 8000df4:	d10f      	bne.n	8000e16 <__aeabi_fmul+0x15e>
 8000df6:	ea93 0f0c 	teq	r3, ip
 8000dfa:	d103      	bne.n	8000e04 <__aeabi_fmul+0x14c>
 8000dfc:	024b      	lsls	r3, r1, #9
 8000dfe:	bf18      	it	ne
 8000e00:	4608      	movne	r0, r1
 8000e02:	d108      	bne.n	8000e16 <__aeabi_fmul+0x15e>
 8000e04:	ea80 0001 	eor.w	r0, r0, r1
 8000e08:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000e0c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000e10:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000e14:	4770      	bx	lr
 8000e16:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000e1a:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000e1e:	4770      	bx	lr

08000e20 <__aeabi_fdiv>:
 8000e20:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000e24:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000e28:	bf1e      	ittt	ne
 8000e2a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000e2e:	ea92 0f0c 	teqne	r2, ip
 8000e32:	ea93 0f0c 	teqne	r3, ip
 8000e36:	d069      	beq.n	8000f0c <__aeabi_fdiv+0xec>
 8000e38:	eba2 0203 	sub.w	r2, r2, r3
 8000e3c:	ea80 0c01 	eor.w	ip, r0, r1
 8000e40:	0249      	lsls	r1, r1, #9
 8000e42:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000e46:	d037      	beq.n	8000eb8 <__aeabi_fdiv+0x98>
 8000e48:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000e4c:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000e50:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000e54:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000e58:	428b      	cmp	r3, r1
 8000e5a:	bf38      	it	cc
 8000e5c:	005b      	lslcc	r3, r3, #1
 8000e5e:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000e62:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000e66:	428b      	cmp	r3, r1
 8000e68:	bf24      	itt	cs
 8000e6a:	1a5b      	subcs	r3, r3, r1
 8000e6c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000e70:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000e74:	bf24      	itt	cs
 8000e76:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000e7a:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000e7e:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000e82:	bf24      	itt	cs
 8000e84:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000e88:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000e8c:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000e90:	bf24      	itt	cs
 8000e92:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000e96:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000e9a:	011b      	lsls	r3, r3, #4
 8000e9c:	bf18      	it	ne
 8000e9e:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000ea2:	d1e0      	bne.n	8000e66 <__aeabi_fdiv+0x46>
 8000ea4:	2afd      	cmp	r2, #253	; 0xfd
 8000ea6:	f63f af50 	bhi.w	8000d4a <__aeabi_fmul+0x92>
 8000eaa:	428b      	cmp	r3, r1
 8000eac:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000eb0:	bf08      	it	eq
 8000eb2:	f020 0001 	biceq.w	r0, r0, #1
 8000eb6:	4770      	bx	lr
 8000eb8:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000ebc:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000ec0:	327f      	adds	r2, #127	; 0x7f
 8000ec2:	bfc2      	ittt	gt
 8000ec4:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000ec8:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000ecc:	4770      	bxgt	lr
 8000ece:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ed2:	f04f 0300 	mov.w	r3, #0
 8000ed6:	3a01      	subs	r2, #1
 8000ed8:	e737      	b.n	8000d4a <__aeabi_fmul+0x92>
 8000eda:	f092 0f00 	teq	r2, #0
 8000ede:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000ee2:	bf02      	ittt	eq
 8000ee4:	0040      	lsleq	r0, r0, #1
 8000ee6:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000eea:	3a01      	subeq	r2, #1
 8000eec:	d0f9      	beq.n	8000ee2 <__aeabi_fdiv+0xc2>
 8000eee:	ea40 000c 	orr.w	r0, r0, ip
 8000ef2:	f093 0f00 	teq	r3, #0
 8000ef6:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000efa:	bf02      	ittt	eq
 8000efc:	0049      	lsleq	r1, r1, #1
 8000efe:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000f02:	3b01      	subeq	r3, #1
 8000f04:	d0f9      	beq.n	8000efa <__aeabi_fdiv+0xda>
 8000f06:	ea41 010c 	orr.w	r1, r1, ip
 8000f0a:	e795      	b.n	8000e38 <__aeabi_fdiv+0x18>
 8000f0c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000f10:	ea92 0f0c 	teq	r2, ip
 8000f14:	d108      	bne.n	8000f28 <__aeabi_fdiv+0x108>
 8000f16:	0242      	lsls	r2, r0, #9
 8000f18:	f47f af7d 	bne.w	8000e16 <__aeabi_fmul+0x15e>
 8000f1c:	ea93 0f0c 	teq	r3, ip
 8000f20:	f47f af70 	bne.w	8000e04 <__aeabi_fmul+0x14c>
 8000f24:	4608      	mov	r0, r1
 8000f26:	e776      	b.n	8000e16 <__aeabi_fmul+0x15e>
 8000f28:	ea93 0f0c 	teq	r3, ip
 8000f2c:	d104      	bne.n	8000f38 <__aeabi_fdiv+0x118>
 8000f2e:	024b      	lsls	r3, r1, #9
 8000f30:	f43f af4c 	beq.w	8000dcc <__aeabi_fmul+0x114>
 8000f34:	4608      	mov	r0, r1
 8000f36:	e76e      	b.n	8000e16 <__aeabi_fmul+0x15e>
 8000f38:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000f3c:	bf18      	it	ne
 8000f3e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000f42:	d1ca      	bne.n	8000eda <__aeabi_fdiv+0xba>
 8000f44:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8000f48:	f47f af5c 	bne.w	8000e04 <__aeabi_fmul+0x14c>
 8000f4c:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8000f50:	f47f af3c 	bne.w	8000dcc <__aeabi_fmul+0x114>
 8000f54:	e75f      	b.n	8000e16 <__aeabi_fmul+0x15e>
 8000f56:	bf00      	nop

08000f58 <__aeabi_f2uiz>:
 8000f58:	0042      	lsls	r2, r0, #1
 8000f5a:	d20e      	bcs.n	8000f7a <__aeabi_f2uiz+0x22>
 8000f5c:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8000f60:	d30b      	bcc.n	8000f7a <__aeabi_f2uiz+0x22>
 8000f62:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8000f66:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8000f6a:	d409      	bmi.n	8000f80 <__aeabi_f2uiz+0x28>
 8000f6c:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000f70:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000f74:	fa23 f002 	lsr.w	r0, r3, r2
 8000f78:	4770      	bx	lr
 8000f7a:	f04f 0000 	mov.w	r0, #0
 8000f7e:	4770      	bx	lr
 8000f80:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8000f84:	d101      	bne.n	8000f8a <__aeabi_f2uiz+0x32>
 8000f86:	0242      	lsls	r2, r0, #9
 8000f88:	d102      	bne.n	8000f90 <__aeabi_f2uiz+0x38>
 8000f8a:	f04f 30ff 	mov.w	r0, #4294967295
 8000f8e:	4770      	bx	lr
 8000f90:	f04f 0000 	mov.w	r0, #0
 8000f94:	4770      	bx	lr
 8000f96:	bf00      	nop

08000f98 <__aeabi_ldivmod>:
 8000f98:	b97b      	cbnz	r3, 8000fba <__aeabi_ldivmod+0x22>
 8000f9a:	b972      	cbnz	r2, 8000fba <__aeabi_ldivmod+0x22>
 8000f9c:	2900      	cmp	r1, #0
 8000f9e:	bfbe      	ittt	lt
 8000fa0:	2000      	movlt	r0, #0
 8000fa2:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8000fa6:	e006      	blt.n	8000fb6 <__aeabi_ldivmod+0x1e>
 8000fa8:	bf08      	it	eq
 8000faa:	2800      	cmpeq	r0, #0
 8000fac:	bf1c      	itt	ne
 8000fae:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 8000fb2:	f04f 30ff 	movne.w	r0, #4294967295
 8000fb6:	f000 b9c9 	b.w	800134c <__aeabi_idiv0>
 8000fba:	f1ad 0c08 	sub.w	ip, sp, #8
 8000fbe:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000fc2:	2900      	cmp	r1, #0
 8000fc4:	db09      	blt.n	8000fda <__aeabi_ldivmod+0x42>
 8000fc6:	2b00      	cmp	r3, #0
 8000fc8:	db1a      	blt.n	8001000 <__aeabi_ldivmod+0x68>
 8000fca:	f000 f84d 	bl	8001068 <__udivmoddi4>
 8000fce:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000fd2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000fd6:	b004      	add	sp, #16
 8000fd8:	4770      	bx	lr
 8000fda:	4240      	negs	r0, r0
 8000fdc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000fe0:	2b00      	cmp	r3, #0
 8000fe2:	db1b      	blt.n	800101c <__aeabi_ldivmod+0x84>
 8000fe4:	f000 f840 	bl	8001068 <__udivmoddi4>
 8000fe8:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000fec:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000ff0:	b004      	add	sp, #16
 8000ff2:	4240      	negs	r0, r0
 8000ff4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000ff8:	4252      	negs	r2, r2
 8000ffa:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000ffe:	4770      	bx	lr
 8001000:	4252      	negs	r2, r2
 8001002:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001006:	f000 f82f 	bl	8001068 <__udivmoddi4>
 800100a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800100e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001012:	b004      	add	sp, #16
 8001014:	4240      	negs	r0, r0
 8001016:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800101a:	4770      	bx	lr
 800101c:	4252      	negs	r2, r2
 800101e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001022:	f000 f821 	bl	8001068 <__udivmoddi4>
 8001026:	f8dd e004 	ldr.w	lr, [sp, #4]
 800102a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800102e:	b004      	add	sp, #16
 8001030:	4252      	negs	r2, r2
 8001032:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8001036:	4770      	bx	lr

08001038 <__aeabi_uldivmod>:
 8001038:	b953      	cbnz	r3, 8001050 <__aeabi_uldivmod+0x18>
 800103a:	b94a      	cbnz	r2, 8001050 <__aeabi_uldivmod+0x18>
 800103c:	2900      	cmp	r1, #0
 800103e:	bf08      	it	eq
 8001040:	2800      	cmpeq	r0, #0
 8001042:	bf1c      	itt	ne
 8001044:	f04f 31ff 	movne.w	r1, #4294967295
 8001048:	f04f 30ff 	movne.w	r0, #4294967295
 800104c:	f000 b97e 	b.w	800134c <__aeabi_idiv0>
 8001050:	f1ad 0c08 	sub.w	ip, sp, #8
 8001054:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8001058:	f000 f806 	bl	8001068 <__udivmoddi4>
 800105c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8001060:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8001064:	b004      	add	sp, #16
 8001066:	4770      	bx	lr

08001068 <__udivmoddi4>:
 8001068:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800106c:	468c      	mov	ip, r1
 800106e:	460e      	mov	r6, r1
 8001070:	4604      	mov	r4, r0
 8001072:	9d08      	ldr	r5, [sp, #32]
 8001074:	2b00      	cmp	r3, #0
 8001076:	d150      	bne.n	800111a <__udivmoddi4+0xb2>
 8001078:	428a      	cmp	r2, r1
 800107a:	4617      	mov	r7, r2
 800107c:	d96c      	bls.n	8001158 <__udivmoddi4+0xf0>
 800107e:	fab2 fe82 	clz	lr, r2
 8001082:	f1be 0f00 	cmp.w	lr, #0
 8001086:	d00b      	beq.n	80010a0 <__udivmoddi4+0x38>
 8001088:	f1ce 0420 	rsb	r4, lr, #32
 800108c:	fa20 f404 	lsr.w	r4, r0, r4
 8001090:	fa01 f60e 	lsl.w	r6, r1, lr
 8001094:	ea44 0c06 	orr.w	ip, r4, r6
 8001098:	fa02 f70e 	lsl.w	r7, r2, lr
 800109c:	fa00 f40e 	lsl.w	r4, r0, lr
 80010a0:	ea4f 4917 	mov.w	r9, r7, lsr #16
 80010a4:	0c22      	lsrs	r2, r4, #16
 80010a6:	fbbc f0f9 	udiv	r0, ip, r9
 80010aa:	fa1f f887 	uxth.w	r8, r7
 80010ae:	fb09 c610 	mls	r6, r9, r0, ip
 80010b2:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 80010b6:	fb00 f308 	mul.w	r3, r0, r8
 80010ba:	42b3      	cmp	r3, r6
 80010bc:	d909      	bls.n	80010d2 <__udivmoddi4+0x6a>
 80010be:	19f6      	adds	r6, r6, r7
 80010c0:	f100 32ff 	add.w	r2, r0, #4294967295
 80010c4:	f080 8122 	bcs.w	800130c <__udivmoddi4+0x2a4>
 80010c8:	42b3      	cmp	r3, r6
 80010ca:	f240 811f 	bls.w	800130c <__udivmoddi4+0x2a4>
 80010ce:	3802      	subs	r0, #2
 80010d0:	443e      	add	r6, r7
 80010d2:	1af6      	subs	r6, r6, r3
 80010d4:	b2a2      	uxth	r2, r4
 80010d6:	fbb6 f3f9 	udiv	r3, r6, r9
 80010da:	fb09 6613 	mls	r6, r9, r3, r6
 80010de:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 80010e2:	fb03 f808 	mul.w	r8, r3, r8
 80010e6:	45a0      	cmp	r8, r4
 80010e8:	d909      	bls.n	80010fe <__udivmoddi4+0x96>
 80010ea:	19e4      	adds	r4, r4, r7
 80010ec:	f103 32ff 	add.w	r2, r3, #4294967295
 80010f0:	f080 810a 	bcs.w	8001308 <__udivmoddi4+0x2a0>
 80010f4:	45a0      	cmp	r8, r4
 80010f6:	f240 8107 	bls.w	8001308 <__udivmoddi4+0x2a0>
 80010fa:	3b02      	subs	r3, #2
 80010fc:	443c      	add	r4, r7
 80010fe:	ebc8 0404 	rsb	r4, r8, r4
 8001102:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8001106:	2100      	movs	r1, #0
 8001108:	2d00      	cmp	r5, #0
 800110a:	d062      	beq.n	80011d2 <__udivmoddi4+0x16a>
 800110c:	fa24 f40e 	lsr.w	r4, r4, lr
 8001110:	2300      	movs	r3, #0
 8001112:	602c      	str	r4, [r5, #0]
 8001114:	606b      	str	r3, [r5, #4]
 8001116:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800111a:	428b      	cmp	r3, r1
 800111c:	d907      	bls.n	800112e <__udivmoddi4+0xc6>
 800111e:	2d00      	cmp	r5, #0
 8001120:	d055      	beq.n	80011ce <__udivmoddi4+0x166>
 8001122:	2100      	movs	r1, #0
 8001124:	e885 0041 	stmia.w	r5, {r0, r6}
 8001128:	4608      	mov	r0, r1
 800112a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800112e:	fab3 f183 	clz	r1, r3
 8001132:	2900      	cmp	r1, #0
 8001134:	f040 8090 	bne.w	8001258 <__udivmoddi4+0x1f0>
 8001138:	42b3      	cmp	r3, r6
 800113a:	d302      	bcc.n	8001142 <__udivmoddi4+0xda>
 800113c:	4282      	cmp	r2, r0
 800113e:	f200 80f8 	bhi.w	8001332 <__udivmoddi4+0x2ca>
 8001142:	1a84      	subs	r4, r0, r2
 8001144:	eb66 0603 	sbc.w	r6, r6, r3
 8001148:	2001      	movs	r0, #1
 800114a:	46b4      	mov	ip, r6
 800114c:	2d00      	cmp	r5, #0
 800114e:	d040      	beq.n	80011d2 <__udivmoddi4+0x16a>
 8001150:	e885 1010 	stmia.w	r5, {r4, ip}
 8001154:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001158:	b912      	cbnz	r2, 8001160 <__udivmoddi4+0xf8>
 800115a:	2701      	movs	r7, #1
 800115c:	fbb7 f7f2 	udiv	r7, r7, r2
 8001160:	fab7 fe87 	clz	lr, r7
 8001164:	f1be 0f00 	cmp.w	lr, #0
 8001168:	d135      	bne.n	80011d6 <__udivmoddi4+0x16e>
 800116a:	1bf3      	subs	r3, r6, r7
 800116c:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8001170:	fa1f fc87 	uxth.w	ip, r7
 8001174:	2101      	movs	r1, #1
 8001176:	fbb3 f0f8 	udiv	r0, r3, r8
 800117a:	0c22      	lsrs	r2, r4, #16
 800117c:	fb08 3610 	mls	r6, r8, r0, r3
 8001180:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
 8001184:	fb0c f300 	mul.w	r3, ip, r0
 8001188:	42b3      	cmp	r3, r6
 800118a:	d907      	bls.n	800119c <__udivmoddi4+0x134>
 800118c:	19f6      	adds	r6, r6, r7
 800118e:	f100 32ff 	add.w	r2, r0, #4294967295
 8001192:	d202      	bcs.n	800119a <__udivmoddi4+0x132>
 8001194:	42b3      	cmp	r3, r6
 8001196:	f200 80ce 	bhi.w	8001336 <__udivmoddi4+0x2ce>
 800119a:	4610      	mov	r0, r2
 800119c:	1af6      	subs	r6, r6, r3
 800119e:	b2a2      	uxth	r2, r4
 80011a0:	fbb6 f3f8 	udiv	r3, r6, r8
 80011a4:	fb08 6613 	mls	r6, r8, r3, r6
 80011a8:	ea42 4406 	orr.w	r4, r2, r6, lsl #16
 80011ac:	fb0c fc03 	mul.w	ip, ip, r3
 80011b0:	45a4      	cmp	ip, r4
 80011b2:	d907      	bls.n	80011c4 <__udivmoddi4+0x15c>
 80011b4:	19e4      	adds	r4, r4, r7
 80011b6:	f103 32ff 	add.w	r2, r3, #4294967295
 80011ba:	d202      	bcs.n	80011c2 <__udivmoddi4+0x15a>
 80011bc:	45a4      	cmp	ip, r4
 80011be:	f200 80b5 	bhi.w	800132c <__udivmoddi4+0x2c4>
 80011c2:	4613      	mov	r3, r2
 80011c4:	ebcc 0404 	rsb	r4, ip, r4
 80011c8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80011cc:	e79c      	b.n	8001108 <__udivmoddi4+0xa0>
 80011ce:	4629      	mov	r1, r5
 80011d0:	4628      	mov	r0, r5
 80011d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80011d6:	f1ce 0120 	rsb	r1, lr, #32
 80011da:	fa06 f30e 	lsl.w	r3, r6, lr
 80011de:	fa07 f70e 	lsl.w	r7, r7, lr
 80011e2:	fa20 f901 	lsr.w	r9, r0, r1
 80011e6:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80011ea:	40ce      	lsrs	r6, r1
 80011ec:	ea49 0903 	orr.w	r9, r9, r3
 80011f0:	fbb6 faf8 	udiv	sl, r6, r8
 80011f4:	ea4f 4419 	mov.w	r4, r9, lsr #16
 80011f8:	fb08 661a 	mls	r6, r8, sl, r6
 80011fc:	fa1f fc87 	uxth.w	ip, r7
 8001200:	ea44 4306 	orr.w	r3, r4, r6, lsl #16
 8001204:	fb0a f20c 	mul.w	r2, sl, ip
 8001208:	429a      	cmp	r2, r3
 800120a:	fa00 f40e 	lsl.w	r4, r0, lr
 800120e:	d90a      	bls.n	8001226 <__udivmoddi4+0x1be>
 8001210:	19db      	adds	r3, r3, r7
 8001212:	f10a 31ff 	add.w	r1, sl, #4294967295
 8001216:	f080 8087 	bcs.w	8001328 <__udivmoddi4+0x2c0>
 800121a:	429a      	cmp	r2, r3
 800121c:	f240 8084 	bls.w	8001328 <__udivmoddi4+0x2c0>
 8001220:	f1aa 0a02 	sub.w	sl, sl, #2
 8001224:	443b      	add	r3, r7
 8001226:	1a9b      	subs	r3, r3, r2
 8001228:	fa1f f989 	uxth.w	r9, r9
 800122c:	fbb3 f1f8 	udiv	r1, r3, r8
 8001230:	fb08 3311 	mls	r3, r8, r1, r3
 8001234:	ea49 4303 	orr.w	r3, r9, r3, lsl #16
 8001238:	fb01 f60c 	mul.w	r6, r1, ip
 800123c:	429e      	cmp	r6, r3
 800123e:	d907      	bls.n	8001250 <__udivmoddi4+0x1e8>
 8001240:	19db      	adds	r3, r3, r7
 8001242:	f101 32ff 	add.w	r2, r1, #4294967295
 8001246:	d26b      	bcs.n	8001320 <__udivmoddi4+0x2b8>
 8001248:	429e      	cmp	r6, r3
 800124a:	d969      	bls.n	8001320 <__udivmoddi4+0x2b8>
 800124c:	3902      	subs	r1, #2
 800124e:	443b      	add	r3, r7
 8001250:	1b9b      	subs	r3, r3, r6
 8001252:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 8001256:	e78e      	b.n	8001176 <__udivmoddi4+0x10e>
 8001258:	f1c1 0e20 	rsb	lr, r1, #32
 800125c:	fa22 f40e 	lsr.w	r4, r2, lr
 8001260:	408b      	lsls	r3, r1
 8001262:	4323      	orrs	r3, r4
 8001264:	fa20 f70e 	lsr.w	r7, r0, lr
 8001268:	fa06 f401 	lsl.w	r4, r6, r1
 800126c:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8001270:	fa26 f60e 	lsr.w	r6, r6, lr
 8001274:	433c      	orrs	r4, r7
 8001276:	fbb6 f9fc 	udiv	r9, r6, ip
 800127a:	0c27      	lsrs	r7, r4, #16
 800127c:	fb0c 6619 	mls	r6, ip, r9, r6
 8001280:	fa1f f883 	uxth.w	r8, r3
 8001284:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
 8001288:	fb09 f708 	mul.w	r7, r9, r8
 800128c:	42b7      	cmp	r7, r6
 800128e:	fa02 f201 	lsl.w	r2, r2, r1
 8001292:	fa00 fa01 	lsl.w	sl, r0, r1
 8001296:	d908      	bls.n	80012aa <__udivmoddi4+0x242>
 8001298:	18f6      	adds	r6, r6, r3
 800129a:	f109 30ff 	add.w	r0, r9, #4294967295
 800129e:	d241      	bcs.n	8001324 <__udivmoddi4+0x2bc>
 80012a0:	42b7      	cmp	r7, r6
 80012a2:	d93f      	bls.n	8001324 <__udivmoddi4+0x2bc>
 80012a4:	f1a9 0902 	sub.w	r9, r9, #2
 80012a8:	441e      	add	r6, r3
 80012aa:	1bf6      	subs	r6, r6, r7
 80012ac:	b2a0      	uxth	r0, r4
 80012ae:	fbb6 f4fc 	udiv	r4, r6, ip
 80012b2:	fb0c 6614 	mls	r6, ip, r4, r6
 80012b6:	ea40 4706 	orr.w	r7, r0, r6, lsl #16
 80012ba:	fb04 f808 	mul.w	r8, r4, r8
 80012be:	45b8      	cmp	r8, r7
 80012c0:	d907      	bls.n	80012d2 <__udivmoddi4+0x26a>
 80012c2:	18ff      	adds	r7, r7, r3
 80012c4:	f104 30ff 	add.w	r0, r4, #4294967295
 80012c8:	d228      	bcs.n	800131c <__udivmoddi4+0x2b4>
 80012ca:	45b8      	cmp	r8, r7
 80012cc:	d926      	bls.n	800131c <__udivmoddi4+0x2b4>
 80012ce:	3c02      	subs	r4, #2
 80012d0:	441f      	add	r7, r3
 80012d2:	ea44 4009 	orr.w	r0, r4, r9, lsl #16
 80012d6:	ebc8 0707 	rsb	r7, r8, r7
 80012da:	fba0 8902 	umull	r8, r9, r0, r2
 80012de:	454f      	cmp	r7, r9
 80012e0:	4644      	mov	r4, r8
 80012e2:	464e      	mov	r6, r9
 80012e4:	d314      	bcc.n	8001310 <__udivmoddi4+0x2a8>
 80012e6:	d029      	beq.n	800133c <__udivmoddi4+0x2d4>
 80012e8:	b365      	cbz	r5, 8001344 <__udivmoddi4+0x2dc>
 80012ea:	ebba 0304 	subs.w	r3, sl, r4
 80012ee:	eb67 0706 	sbc.w	r7, r7, r6
 80012f2:	fa07 fe0e 	lsl.w	lr, r7, lr
 80012f6:	40cb      	lsrs	r3, r1
 80012f8:	40cf      	lsrs	r7, r1
 80012fa:	ea4e 0303 	orr.w	r3, lr, r3
 80012fe:	e885 0088 	stmia.w	r5, {r3, r7}
 8001302:	2100      	movs	r1, #0
 8001304:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001308:	4613      	mov	r3, r2
 800130a:	e6f8      	b.n	80010fe <__udivmoddi4+0x96>
 800130c:	4610      	mov	r0, r2
 800130e:	e6e0      	b.n	80010d2 <__udivmoddi4+0x6a>
 8001310:	ebb8 0402 	subs.w	r4, r8, r2
 8001314:	eb69 0603 	sbc.w	r6, r9, r3
 8001318:	3801      	subs	r0, #1
 800131a:	e7e5      	b.n	80012e8 <__udivmoddi4+0x280>
 800131c:	4604      	mov	r4, r0
 800131e:	e7d8      	b.n	80012d2 <__udivmoddi4+0x26a>
 8001320:	4611      	mov	r1, r2
 8001322:	e795      	b.n	8001250 <__udivmoddi4+0x1e8>
 8001324:	4681      	mov	r9, r0
 8001326:	e7c0      	b.n	80012aa <__udivmoddi4+0x242>
 8001328:	468a      	mov	sl, r1
 800132a:	e77c      	b.n	8001226 <__udivmoddi4+0x1be>
 800132c:	3b02      	subs	r3, #2
 800132e:	443c      	add	r4, r7
 8001330:	e748      	b.n	80011c4 <__udivmoddi4+0x15c>
 8001332:	4608      	mov	r0, r1
 8001334:	e70a      	b.n	800114c <__udivmoddi4+0xe4>
 8001336:	3802      	subs	r0, #2
 8001338:	443e      	add	r6, r7
 800133a:	e72f      	b.n	800119c <__udivmoddi4+0x134>
 800133c:	45c2      	cmp	sl, r8
 800133e:	d3e7      	bcc.n	8001310 <__udivmoddi4+0x2a8>
 8001340:	463e      	mov	r6, r7
 8001342:	e7d1      	b.n	80012e8 <__udivmoddi4+0x280>
 8001344:	4629      	mov	r1, r5
 8001346:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800134a:	bf00      	nop

0800134c <__aeabi_idiv0>:
 800134c:	4770      	bx	lr
 800134e:	bf00      	nop

08001350 <memcpy>:
 8001350:	4684      	mov	ip, r0
 8001352:	ea41 0300 	orr.w	r3, r1, r0
 8001356:	f013 0303 	ands.w	r3, r3, #3
 800135a:	d16d      	bne.n	8001438 <memcpy+0xe8>
 800135c:	3a40      	subs	r2, #64	; 0x40
 800135e:	d341      	bcc.n	80013e4 <memcpy+0x94>
 8001360:	f851 3b04 	ldr.w	r3, [r1], #4
 8001364:	f840 3b04 	str.w	r3, [r0], #4
 8001368:	f851 3b04 	ldr.w	r3, [r1], #4
 800136c:	f840 3b04 	str.w	r3, [r0], #4
 8001370:	f851 3b04 	ldr.w	r3, [r1], #4
 8001374:	f840 3b04 	str.w	r3, [r0], #4
 8001378:	f851 3b04 	ldr.w	r3, [r1], #4
 800137c:	f840 3b04 	str.w	r3, [r0], #4
 8001380:	f851 3b04 	ldr.w	r3, [r1], #4
 8001384:	f840 3b04 	str.w	r3, [r0], #4
 8001388:	f851 3b04 	ldr.w	r3, [r1], #4
 800138c:	f840 3b04 	str.w	r3, [r0], #4
 8001390:	f851 3b04 	ldr.w	r3, [r1], #4
 8001394:	f840 3b04 	str.w	r3, [r0], #4
 8001398:	f851 3b04 	ldr.w	r3, [r1], #4
 800139c:	f840 3b04 	str.w	r3, [r0], #4
 80013a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80013a4:	f840 3b04 	str.w	r3, [r0], #4
 80013a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80013ac:	f840 3b04 	str.w	r3, [r0], #4
 80013b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80013b4:	f840 3b04 	str.w	r3, [r0], #4
 80013b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80013bc:	f840 3b04 	str.w	r3, [r0], #4
 80013c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80013c4:	f840 3b04 	str.w	r3, [r0], #4
 80013c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80013cc:	f840 3b04 	str.w	r3, [r0], #4
 80013d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80013d4:	f840 3b04 	str.w	r3, [r0], #4
 80013d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80013dc:	f840 3b04 	str.w	r3, [r0], #4
 80013e0:	3a40      	subs	r2, #64	; 0x40
 80013e2:	d2bd      	bcs.n	8001360 <memcpy+0x10>
 80013e4:	3230      	adds	r2, #48	; 0x30
 80013e6:	d311      	bcc.n	800140c <memcpy+0xbc>
 80013e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80013ec:	f840 3b04 	str.w	r3, [r0], #4
 80013f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80013f4:	f840 3b04 	str.w	r3, [r0], #4
 80013f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80013fc:	f840 3b04 	str.w	r3, [r0], #4
 8001400:	f851 3b04 	ldr.w	r3, [r1], #4
 8001404:	f840 3b04 	str.w	r3, [r0], #4
 8001408:	3a10      	subs	r2, #16
 800140a:	d2ed      	bcs.n	80013e8 <memcpy+0x98>
 800140c:	320c      	adds	r2, #12
 800140e:	d305      	bcc.n	800141c <memcpy+0xcc>
 8001410:	f851 3b04 	ldr.w	r3, [r1], #4
 8001414:	f840 3b04 	str.w	r3, [r0], #4
 8001418:	3a04      	subs	r2, #4
 800141a:	d2f9      	bcs.n	8001410 <memcpy+0xc0>
 800141c:	3204      	adds	r2, #4
 800141e:	d008      	beq.n	8001432 <memcpy+0xe2>
 8001420:	07d2      	lsls	r2, r2, #31
 8001422:	bf1c      	itt	ne
 8001424:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8001428:	f800 3b01 	strbne.w	r3, [r0], #1
 800142c:	d301      	bcc.n	8001432 <memcpy+0xe2>
 800142e:	880b      	ldrh	r3, [r1, #0]
 8001430:	8003      	strh	r3, [r0, #0]
 8001432:	4660      	mov	r0, ip
 8001434:	4770      	bx	lr
 8001436:	bf00      	nop
 8001438:	2a08      	cmp	r2, #8
 800143a:	d313      	bcc.n	8001464 <memcpy+0x114>
 800143c:	078b      	lsls	r3, r1, #30
 800143e:	d08d      	beq.n	800135c <memcpy+0xc>
 8001440:	f010 0303 	ands.w	r3, r0, #3
 8001444:	d08a      	beq.n	800135c <memcpy+0xc>
 8001446:	f1c3 0304 	rsb	r3, r3, #4
 800144a:	1ad2      	subs	r2, r2, r3
 800144c:	07db      	lsls	r3, r3, #31
 800144e:	bf1c      	itt	ne
 8001450:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8001454:	f800 3b01 	strbne.w	r3, [r0], #1
 8001458:	d380      	bcc.n	800135c <memcpy+0xc>
 800145a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800145e:	f820 3b02 	strh.w	r3, [r0], #2
 8001462:	e77b      	b.n	800135c <memcpy+0xc>
 8001464:	3a04      	subs	r2, #4
 8001466:	d3d9      	bcc.n	800141c <memcpy+0xcc>
 8001468:	3a01      	subs	r2, #1
 800146a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800146e:	f800 3b01 	strb.w	r3, [r0], #1
 8001472:	d2f9      	bcs.n	8001468 <memcpy+0x118>
 8001474:	780b      	ldrb	r3, [r1, #0]
 8001476:	7003      	strb	r3, [r0, #0]
 8001478:	784b      	ldrb	r3, [r1, #1]
 800147a:	7043      	strb	r3, [r0, #1]
 800147c:	788b      	ldrb	r3, [r1, #2]
 800147e:	7083      	strb	r3, [r0, #2]
 8001480:	4660      	mov	r0, ip
 8001482:	4770      	bx	lr
	...
 80014a0:	eba2 0003 	sub.w	r0, r2, r3
 80014a4:	4770      	bx	lr
 80014a6:	bf00      	nop

080014a8 <strcmp>:
 80014a8:	7802      	ldrb	r2, [r0, #0]
 80014aa:	780b      	ldrb	r3, [r1, #0]
 80014ac:	2a01      	cmp	r2, #1
 80014ae:	bf28      	it	cs
 80014b0:	429a      	cmpcs	r2, r3
 80014b2:	d1f5      	bne.n	80014a0 <memcpy+0x150>
 80014b4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 80014b8:	ea40 0401 	orr.w	r4, r0, r1
 80014bc:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80014c0:	f06f 0c00 	mvn.w	ip, #0
 80014c4:	ea4f 7244 	mov.w	r2, r4, lsl #29
 80014c8:	b312      	cbz	r2, 8001510 <strcmp+0x68>
 80014ca:	ea80 0401 	eor.w	r4, r0, r1
 80014ce:	f014 0f07 	tst.w	r4, #7
 80014d2:	d16a      	bne.n	80015aa <strcmp+0x102>
 80014d4:	f000 0407 	and.w	r4, r0, #7
 80014d8:	f020 0007 	bic.w	r0, r0, #7
 80014dc:	f004 0503 	and.w	r5, r4, #3
 80014e0:	f021 0107 	bic.w	r1, r1, #7
 80014e4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 80014e8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 80014ec:	f014 0f04 	tst.w	r4, #4
 80014f0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 80014f4:	fa0c f405 	lsl.w	r4, ip, r5
 80014f8:	ea62 0204 	orn	r2, r2, r4
 80014fc:	ea66 0604 	orn	r6, r6, r4
 8001500:	d00a      	beq.n	8001518 <strcmp+0x70>
 8001502:	ea63 0304 	orn	r3, r3, r4
 8001506:	4662      	mov	r2, ip
 8001508:	ea67 0704 	orn	r7, r7, r4
 800150c:	4666      	mov	r6, ip
 800150e:	e003      	b.n	8001518 <strcmp+0x70>
 8001510:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8001514:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8001518:	fa82 f54c 	uadd8	r5, r2, ip
 800151c:	ea82 0406 	eor.w	r4, r2, r6
 8001520:	faa4 f48c 	sel	r4, r4, ip
 8001524:	bb6c      	cbnz	r4, 8001582 <strcmp+0xda>
 8001526:	fa83 f54c 	uadd8	r5, r3, ip
 800152a:	ea83 0507 	eor.w	r5, r3, r7
 800152e:	faa5 f58c 	sel	r5, r5, ip
 8001532:	b995      	cbnz	r5, 800155a <strcmp+0xb2>
 8001534:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8001538:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 800153c:	fa82 f54c 	uadd8	r5, r2, ip
 8001540:	ea82 0406 	eor.w	r4, r2, r6
 8001544:	faa4 f48c 	sel	r4, r4, ip
 8001548:	fa83 f54c 	uadd8	r5, r3, ip
 800154c:	ea83 0507 	eor.w	r5, r3, r7
 8001550:	faa5 f58c 	sel	r5, r5, ip
 8001554:	4325      	orrs	r5, r4
 8001556:	d0db      	beq.n	8001510 <strcmp+0x68>
 8001558:	b99c      	cbnz	r4, 8001582 <strcmp+0xda>
 800155a:	ba2d      	rev	r5, r5
 800155c:	fab5 f485 	clz	r4, r5
 8001560:	f024 0407 	bic.w	r4, r4, #7
 8001564:	fa27 f104 	lsr.w	r1, r7, r4
 8001568:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 800156c:	fa23 f304 	lsr.w	r3, r3, r4
 8001570:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8001574:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8001578:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 800157c:	eba0 0001 	sub.w	r0, r0, r1
 8001580:	4770      	bx	lr
 8001582:	ba24      	rev	r4, r4
 8001584:	fab4 f484 	clz	r4, r4
 8001588:	f024 0407 	bic.w	r4, r4, #7
 800158c:	fa26 f104 	lsr.w	r1, r6, r4
 8001590:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8001594:	fa22 f204 	lsr.w	r2, r2, r4
 8001598:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 800159c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80015a0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80015a4:	eba0 0001 	sub.w	r0, r0, r1
 80015a8:	4770      	bx	lr
 80015aa:	f014 0f03 	tst.w	r4, #3
 80015ae:	d13c      	bne.n	800162a <strcmp+0x182>
 80015b0:	f010 0403 	ands.w	r4, r0, #3
 80015b4:	d128      	bne.n	8001608 <strcmp+0x160>
 80015b6:	f850 2b08 	ldr.w	r2, [r0], #8
 80015ba:	f851 3b08 	ldr.w	r3, [r1], #8
 80015be:	fa82 f54c 	uadd8	r5, r2, ip
 80015c2:	ea82 0503 	eor.w	r5, r2, r3
 80015c6:	faa5 f58c 	sel	r5, r5, ip
 80015ca:	b95d      	cbnz	r5, 80015e4 <strcmp+0x13c>
 80015cc:	f850 2c04 	ldr.w	r2, [r0, #-4]
 80015d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80015d4:	fa82 f54c 	uadd8	r5, r2, ip
 80015d8:	ea82 0503 	eor.w	r5, r2, r3
 80015dc:	faa5 f58c 	sel	r5, r5, ip
 80015e0:	2d00      	cmp	r5, #0
 80015e2:	d0e8      	beq.n	80015b6 <strcmp+0x10e>
 80015e4:	ba2d      	rev	r5, r5
 80015e6:	fab5 f485 	clz	r4, r5
 80015ea:	f024 0407 	bic.w	r4, r4, #7
 80015ee:	fa23 f104 	lsr.w	r1, r3, r4
 80015f2:	fa22 f204 	lsr.w	r2, r2, r4
 80015f6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 80015fa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80015fe:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001602:	eba0 0001 	sub.w	r0, r0, r1
 8001606:	4770      	bx	lr
 8001608:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 800160c:	f020 0003 	bic.w	r0, r0, #3
 8001610:	f850 2b08 	ldr.w	r2, [r0], #8
 8001614:	f021 0103 	bic.w	r1, r1, #3
 8001618:	f851 3b08 	ldr.w	r3, [r1], #8
 800161c:	fa0c f404 	lsl.w	r4, ip, r4
 8001620:	ea62 0204 	orn	r2, r2, r4
 8001624:	ea63 0304 	orn	r3, r3, r4
 8001628:	e7c9      	b.n	80015be <strcmp+0x116>
 800162a:	f010 0403 	ands.w	r4, r0, #3
 800162e:	d01a      	beq.n	8001666 <strcmp+0x1be>
 8001630:	eba1 0104 	sub.w	r1, r1, r4
 8001634:	f020 0003 	bic.w	r0, r0, #3
 8001638:	07e4      	lsls	r4, r4, #31
 800163a:	f850 2b04 	ldr.w	r2, [r0], #4
 800163e:	d006      	beq.n	800164e <strcmp+0x1a6>
 8001640:	d20f      	bcs.n	8001662 <strcmp+0x1ba>
 8001642:	788b      	ldrb	r3, [r1, #2]
 8001644:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8001648:	1ae4      	subs	r4, r4, r3
 800164a:	d106      	bne.n	800165a <strcmp+0x1b2>
 800164c:	b12b      	cbz	r3, 800165a <strcmp+0x1b2>
 800164e:	78cb      	ldrb	r3, [r1, #3]
 8001650:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8001654:	1ae4      	subs	r4, r4, r3
 8001656:	d100      	bne.n	800165a <strcmp+0x1b2>
 8001658:	b91b      	cbnz	r3, 8001662 <strcmp+0x1ba>
 800165a:	4620      	mov	r0, r4
 800165c:	f85d 4b10 	ldr.w	r4, [sp], #16
 8001660:	4770      	bx	lr
 8001662:	f101 0104 	add.w	r1, r1, #4
 8001666:	f850 2b04 	ldr.w	r2, [r0], #4
 800166a:	07cc      	lsls	r4, r1, #31
 800166c:	f021 0103 	bic.w	r1, r1, #3
 8001670:	f851 3b04 	ldr.w	r3, [r1], #4
 8001674:	d848      	bhi.n	8001708 <strcmp+0x260>
 8001676:	d224      	bcs.n	80016c2 <strcmp+0x21a>
 8001678:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 800167c:	fa82 f54c 	uadd8	r5, r2, ip
 8001680:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8001684:	faa5 f58c 	sel	r5, r5, ip
 8001688:	d10a      	bne.n	80016a0 <strcmp+0x1f8>
 800168a:	b965      	cbnz	r5, 80016a6 <strcmp+0x1fe>
 800168c:	f851 3b04 	ldr.w	r3, [r1], #4
 8001690:	ea84 0402 	eor.w	r4, r4, r2
 8001694:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8001698:	d10e      	bne.n	80016b8 <strcmp+0x210>
 800169a:	f850 2b04 	ldr.w	r2, [r0], #4
 800169e:	e7eb      	b.n	8001678 <strcmp+0x1d0>
 80016a0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80016a4:	e055      	b.n	8001752 <strcmp+0x2aa>
 80016a6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 80016aa:	d14d      	bne.n	8001748 <strcmp+0x2a0>
 80016ac:	7808      	ldrb	r0, [r1, #0]
 80016ae:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 80016b2:	f1c0 0000 	rsb	r0, r0, #0
 80016b6:	4770      	bx	lr
 80016b8:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80016bc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80016c0:	e047      	b.n	8001752 <strcmp+0x2aa>
 80016c2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 80016c6:	fa82 f54c 	uadd8	r5, r2, ip
 80016ca:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 80016ce:	faa5 f58c 	sel	r5, r5, ip
 80016d2:	d10a      	bne.n	80016ea <strcmp+0x242>
 80016d4:	b965      	cbnz	r5, 80016f0 <strcmp+0x248>
 80016d6:	f851 3b04 	ldr.w	r3, [r1], #4
 80016da:	ea84 0402 	eor.w	r4, r4, r2
 80016de:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 80016e2:	d10c      	bne.n	80016fe <strcmp+0x256>
 80016e4:	f850 2b04 	ldr.w	r2, [r0], #4
 80016e8:	e7eb      	b.n	80016c2 <strcmp+0x21a>
 80016ea:	ea4f 4313 	mov.w	r3, r3, lsr #16
 80016ee:	e030      	b.n	8001752 <strcmp+0x2aa>
 80016f0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 80016f4:	d128      	bne.n	8001748 <strcmp+0x2a0>
 80016f6:	880b      	ldrh	r3, [r1, #0]
 80016f8:	ea4f 4212 	mov.w	r2, r2, lsr #16
 80016fc:	e029      	b.n	8001752 <strcmp+0x2aa>
 80016fe:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8001702:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8001706:	e024      	b.n	8001752 <strcmp+0x2aa>
 8001708:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 800170c:	fa82 f54c 	uadd8	r5, r2, ip
 8001710:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8001714:	faa5 f58c 	sel	r5, r5, ip
 8001718:	d10a      	bne.n	8001730 <strcmp+0x288>
 800171a:	b965      	cbnz	r5, 8001736 <strcmp+0x28e>
 800171c:	f851 3b04 	ldr.w	r3, [r1], #4
 8001720:	ea84 0402 	eor.w	r4, r4, r2
 8001724:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8001728:	d109      	bne.n	800173e <strcmp+0x296>
 800172a:	f850 2b04 	ldr.w	r2, [r0], #4
 800172e:	e7eb      	b.n	8001708 <strcmp+0x260>
 8001730:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8001734:	e00d      	b.n	8001752 <strcmp+0x2aa>
 8001736:	f015 0fff 	tst.w	r5, #255	; 0xff
 800173a:	d105      	bne.n	8001748 <strcmp+0x2a0>
 800173c:	680b      	ldr	r3, [r1, #0]
 800173e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8001742:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8001746:	e004      	b.n	8001752 <strcmp+0x2aa>
 8001748:	f04f 0000 	mov.w	r0, #0
 800174c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001750:	4770      	bx	lr
 8001752:	ba12      	rev	r2, r2
 8001754:	ba1b      	rev	r3, r3
 8001756:	fa82 f44c 	uadd8	r4, r2, ip
 800175a:	ea82 0403 	eor.w	r4, r2, r3
 800175e:	faa4 f58c 	sel	r5, r4, ip
 8001762:	fab5 f485 	clz	r4, r5
 8001766:	fa02 f204 	lsl.w	r2, r2, r4
 800176a:	fa03 f304 	lsl.w	r3, r3, r4
 800176e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8001772:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8001776:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 800177a:	4770      	bx	lr
 800177c:	0000      	movs	r0, r0
	...

08001780 <strlen>:
 8001780:	f890 f000 	pld	[r0]
 8001784:	e96d 4502 	strd	r4, r5, [sp, #-8]!
 8001788:	f020 0107 	bic.w	r1, r0, #7
 800178c:	f06f 0c00 	mvn.w	ip, #0
 8001790:	f010 0407 	ands.w	r4, r0, #7
 8001794:	f891 f020 	pld	[r1, #32]
 8001798:	f040 8049 	bne.w	800182e <strlen+0xae>
 800179c:	f04f 0400 	mov.w	r4, #0
 80017a0:	f06f 0007 	mvn.w	r0, #7
 80017a4:	e9d1 2300 	ldrd	r2, r3, [r1]
 80017a8:	f891 f040 	pld	[r1, #64]	; 0x40
 80017ac:	f100 0008 	add.w	r0, r0, #8
 80017b0:	fa82 f24c 	uadd8	r2, r2, ip
 80017b4:	faa4 f28c 	sel	r2, r4, ip
 80017b8:	fa83 f34c 	uadd8	r3, r3, ip
 80017bc:	faa2 f38c 	sel	r3, r2, ip
 80017c0:	bb4b      	cbnz	r3, 8001816 <strlen+0x96>
 80017c2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
 80017c6:	fa82 f24c 	uadd8	r2, r2, ip
 80017ca:	f100 0008 	add.w	r0, r0, #8
 80017ce:	faa4 f28c 	sel	r2, r4, ip
 80017d2:	fa83 f34c 	uadd8	r3, r3, ip
 80017d6:	faa2 f38c 	sel	r3, r2, ip
 80017da:	b9e3      	cbnz	r3, 8001816 <strlen+0x96>
 80017dc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
 80017e0:	fa82 f24c 	uadd8	r2, r2, ip
 80017e4:	f100 0008 	add.w	r0, r0, #8
 80017e8:	faa4 f28c 	sel	r2, r4, ip
 80017ec:	fa83 f34c 	uadd8	r3, r3, ip
 80017f0:	faa2 f38c 	sel	r3, r2, ip
 80017f4:	b97b      	cbnz	r3, 8001816 <strlen+0x96>
 80017f6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
 80017fa:	f101 0120 	add.w	r1, r1, #32
 80017fe:	fa82 f24c 	uadd8	r2, r2, ip
 8001802:	f100 0008 	add.w	r0, r0, #8
 8001806:	faa4 f28c 	sel	r2, r4, ip
 800180a:	fa83 f34c 	uadd8	r3, r3, ip
 800180e:	faa2 f38c 	sel	r3, r2, ip
 8001812:	2b00      	cmp	r3, #0
 8001814:	d0c6      	beq.n	80017a4 <strlen+0x24>
 8001816:	2a00      	cmp	r2, #0
 8001818:	bf04      	itt	eq
 800181a:	3004      	addeq	r0, #4
 800181c:	461a      	moveq	r2, r3
 800181e:	ba12      	rev	r2, r2
 8001820:	fab2 f282 	clz	r2, r2
 8001824:	e8fd 4502 	ldrd	r4, r5, [sp], #8
 8001828:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 800182c:	4770      	bx	lr
 800182e:	e9d1 2300 	ldrd	r2, r3, [r1]
 8001832:	f004 0503 	and.w	r5, r4, #3
 8001836:	f1c4 0000 	rsb	r0, r4, #0
 800183a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 800183e:	f014 0f04 	tst.w	r4, #4
 8001842:	f891 f040 	pld	[r1, #64]	; 0x40
 8001846:	fa0c f505 	lsl.w	r5, ip, r5
 800184a:	ea62 0205 	orn	r2, r2, r5
 800184e:	bf1c      	itt	ne
 8001850:	ea63 0305 	ornne	r3, r3, r5
 8001854:	4662      	movne	r2, ip
 8001856:	f04f 0400 	mov.w	r4, #0
 800185a:	e7a9      	b.n	80017b0 <strlen+0x30>
 800185c:	0000      	movs	r0, r0
	...

08001860 <encode_ssdv>:

static uint32_t gimage_id;
mutex_t camera_mtx;

void encode_ssdv(uint8_t *image, uint32_t image_len, module_conf_t* config, uint8_t image_id)
{
 8001860:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001864:	f6ad 1d8c 	subw	sp, sp, #2444	; 0x98c
 8001868:	4616      	mov	r6, r2
	return(SSDV_OK);
}

char ssdv_enc_init(ssdv_t *s, uint8_t type, char *callsign, uint8_t image_id)
{
	memset(s, 0, sizeof(ssdv_t));
 800186a:	f20d 4b7c 	addw	fp, sp, #1148	; 0x47c
 800186e:	461d      	mov	r5, r3
 8001870:	9208      	str	r2, [sp, #32]
 8001872:	9003      	str	r0, [sp, #12]
 8001874:	9104      	str	r1, [sp, #16]
 8001876:	4658      	mov	r0, fp
 8001878:	2100      	movs	r1, #0
 800187a:	f240 520c 	movw	r2, #1292	; 0x50c
	uint8_t *b;
	uint32_t bi = 0;
	uint8_t c = SSDV_OK;

	// Init SSDV (FEC at 2FSK, non FEC at APRS)
	ssdv_enc_init(&ssdv, SSDV_TYPE_NORMAL, config->ssdv_config.callsign, image_id);
 800187e:	f506 7486 	add.w	r4, r6, #268	; 0x10c
 8001882:	f00c ff15 	bl	800e6b0 <memset>
	s->image_id = image_id;
 8001886:	f88b 5010 	strb.w	r5, [fp, #16]
 800188a:	4623      	mov	r3, r4
 800188c:	f506 7189 	add.w	r1, r6, #274	; 0x112
 8001890:	461a      	mov	r2, r3
 8001892:	3301      	adds	r3, #1
{
	uint32_t x;
	char *c;
	
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
 8001894:	7810      	ldrb	r0, [r2, #0]
 8001896:	b110      	cbz	r0, 800189e <encode_ssdv+0x3e>
 8001898:	428b      	cmp	r3, r1
 800189a:	461a      	mov	r2, r3
 800189c:	d1f8      	bne.n	8001890 <encode_ssdv+0x30>
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 800189e:	1e53      	subs	r3, r2, #1
 80018a0:	429c      	cmp	r4, r3
 80018a2:	f04f 0300 	mov.w	r3, #0
 80018a6:	d903      	bls.n	80018b0 <encode_ssdv+0x50>
 80018a8:	e01a      	b.n	80018e0 <encode_ssdv+0x80>
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 80018aa:	180b      	adds	r3, r1, r0
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 80018ac:	4294      	cmp	r4, r2
 80018ae:	d017      	beq.n	80018e0 <encode_ssdv+0x80>
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 80018b0:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
 80018b4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 80018b8:	f1a1 0041 	sub.w	r0, r1, #65	; 0x41
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
 80018bc:	00db      	lsls	r3, r3, #3
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 80018be:	2819      	cmp	r0, #25
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 80018c0:	f1a1 0561 	sub.w	r5, r1, #97	; 0x61
 80018c4:	f1a3 0033 	sub.w	r0, r3, #51	; 0x33
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
 80018c8:	d9ef      	bls.n	80018aa <encode_ssdv+0x4a>
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 80018ca:	2d19      	cmp	r5, #25
		else if(*c >= '0' && *c <= '9') x += *c - '0' + 1;
 80018cc:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
 80018d0:	f1a3 0553 	sub.w	r5, r3, #83	; 0x53
	x = 0;
	for(c--; c >= callsign; c--)
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 80018d4:	f200 8095 	bhi.w	8001a02 <encode_ssdv+0x1a2>
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 80018d8:	4294      	cmp	r4, r2
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
 80018da:	eb01 0305 	add.w	r3, r1, r5
	/* Point c at the end of the callsign, maximum of 6 characters */
	for(x = 0, c = callsign; x < SSDV_MAX_CALLSIGN && *c; x++, c++);
	
	/* Encode it backwards */
	x = 0;
	for(c--; c >= callsign; c--)
 80018de:	d1e7      	bne.n	80018b0 <encode_ssdv+0x50>
 80018e0:	f20d 744a 	addw	r4, sp, #1866	; 0x74a
 80018e4:	4620      	mov	r0, r4
{
	/* Configure the payload size and CRC position */
	switch(s->type)
	{
	case SSDV_TYPE_NORMAL:
		s->pkt_size_payload = SSDV_PKT_SIZE - SSDV_PKT_SIZE_HEADER - SSDV_PKT_SIZE_CRC - SSDV_PKT_SIZE_RSCODES;
 80018e6:	25cd      	movs	r5, #205	; 0xcd
		s->pkt_size_crcdata = SSDV_PKT_SIZE_HEADER + s->pkt_size_payload - 1;
 80018e8:	27db      	movs	r7, #219	; 0xdb
 80018ea:	2241      	movs	r2, #65	; 0x41
 80018ec:	494d      	ldr	r1, [pc, #308]	; (8001a24 <encode_ssdv+0x1c4>)

char ssdv_enc_init(ssdv_t *s, uint8_t type, char *callsign, uint8_t image_id)
{
	memset(s, 0, sizeof(ssdv_t));
	s->image_id = image_id;
	s->callsign = encode_callsign(callsign);
 80018ee:	f8cb 300c 	str.w	r3, [fp, #12]
 80018f2:	f20d 768b 	addw	r6, sp, #1931	; 0x78b
	/* Configure the payload size and CRC position */
	switch(s->type)
	{
	case SSDV_TYPE_NORMAL:
		s->pkt_size_payload = SSDV_PKT_SIZE - SSDV_PKT_SIZE_HEADER - SSDV_PKT_SIZE_CRC - SSDV_PKT_SIZE_RSCODES;
		s->pkt_size_crcdata = SSDV_PKT_SIZE_HEADER + s->pkt_size_payload - 1;
 80018f6:	f8ab 7004 	strh.w	r7, [fp, #4]
{
	/* Configure the payload size and CRC position */
	switch(s->type)
	{
	case SSDV_TYPE_NORMAL:
		s->pkt_size_payload = SSDV_PKT_SIZE - SSDV_PKT_SIZE_HEADER - SSDV_PKT_SIZE_CRC - SSDV_PKT_SIZE_RSCODES;
 80018fa:	f8ab 5002 	strh.w	r5, [fp, #2]
 80018fe:	f7ff fd27 	bl	8001350 <memcpy>
	s->mode = S_ENCODING;
	s->type = type;
	ssdv_set_packet_conf(s);
	
	/* Prepare the output JPEG tables */
	s->ddqt[0] = dtblcpy(s, std_dqt0, sizeof(std_dqt0));
 8001902:	f8cb 4500 	str.w	r4, [fp, #1280]	; 0x500
 8001906:	4c48      	ldr	r4, [pc, #288]	; (8001a28 <encode_ssdv+0x1c8>)
 8001908:	4948      	ldr	r1, [pc, #288]	; (8001a2c <encode_ssdv+0x1cc>)
 800190a:	4630      	mov	r0, r6
 800190c:	2241      	movs	r2, #65	; 0x41
 800190e:	f7ff fd1f 	bl	8001350 <memcpy>
 8001912:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
	s->ddqt[1] = dtblcpy(s, std_dqt1, sizeof(std_dqt1));
 8001914:	f8cb 6504 	str.w	r6, [fp, #1284]	; 0x504
 8001918:	f20d 76cc 	addw	r6, sp, #1996	; 0x7cc
 800191c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800191e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8001922:	c607      	stmia	r6!, {r0, r1, r2}
 8001924:	4c42      	ldr	r4, [pc, #264]	; (8001a30 <encode_ssdv+0x1d0>)
 8001926:	7033      	strb	r3, [r6, #0]
 8001928:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800192a:	f8cd 07e9 	str.w	r0, [sp, #2025]	; 0x7e9
 800192e:	f8cd 17ed 	str.w	r1, [sp, #2029]	; 0x7ed
 8001932:	f8cd 27f1 	str.w	r2, [sp, #2033]	; 0x7f1
 8001936:	cc07      	ldmia	r4!, {r0, r1, r2}
	s->ddht[0][0] = dtblcpy(s, std_dht00, sizeof(std_dht00));
 8001938:	f20d 77cc 	addw	r7, sp, #1996	; 0x7cc
 800193c:	f8cd 37f5 	str.w	r3, [sp, #2037]	; 0x7f5
 8001940:	f8cd 07f9 	str.w	r0, [sp, #2041]	; 0x7f9
 8001944:	f60d 0306 	addw	r3, sp, #2054	; 0x806
 8001948:	f8cd 17fd 	str.w	r1, [sp, #2045]	; 0x7fd
 800194c:	f8cd 2801 	str.w	r2, [sp, #2049]	; 0x801
 8001950:	f8cb 74f0 	str.w	r7, [fp, #1264]	; 0x4f0
 8001954:	7822      	ldrb	r2, [r4, #0]
 8001956:	4937      	ldr	r1, [pc, #220]	; (8001a34 <encode_ssdv+0x1d4>)
 8001958:	f88d 2805 	strb.w	r2, [sp, #2053]	; 0x805
 800195c:	f20d 76e9 	addw	r6, sp, #2025	; 0x7e9
 8001960:	4618      	mov	r0, r3
 8001962:	22b3      	movs	r2, #179	; 0xb3
	s->ddht[0][1] = dtblcpy(s, std_dht01, sizeof(std_dht01));
 8001964:	f8cb 64f4 	str.w	r6, [fp, #1268]	; 0x4f4
 8001968:	f7ff fcf2 	bl	8001350 <memcpy>
 800196c:	f60d 04b9 	addw	r4, sp, #2233	; 0x8b9
 8001970:	4603      	mov	r3, r0
 8001972:	22b3      	movs	r2, #179	; 0xb3
 8001974:	4930      	ldr	r1, [pc, #192]	; (8001a38 <encode_ssdv+0x1d8>)
	s->ddht[1][0] = dtblcpy(s, std_dht10, sizeof(std_dht10));
 8001976:	f8cb 34f8 	str.w	r3, [fp, #1272]	; 0x4f8
 800197a:	4620      	mov	r0, r4
 800197c:	f7ff fce8 	bl	8001350 <memcpy>
static void *dtblcpy(ssdv_t *s, const void *src, size_t n)
{
	void *r;
	if(s->dtbl_len + n > TBL_LEN) return(NULL);
	r = memcpy(&s->dtbls[s->dtbl_len], src, n);
	s->dtbl_len += n;
 8001980:	f240 2622 	movw	r6, #546	; 0x222
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 8001984:	f10d 035f 	add.w	r3, sp, #95	; 0x5f
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 8001988:	a814      	add	r0, sp, #80	; 0x50
 800198a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800198e:	2100      	movs	r1, #0
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 8001990:	f8cb 3038 	str.w	r3, [fp, #56]	; 0x38
	s->out_len = s->pkt_size_payload;
 8001994:	f8cb 503c 	str.w	r5, [fp, #60]	; 0x3c
	s->ddqt[0] = dtblcpy(s, std_dqt0, sizeof(std_dqt0));
	s->ddqt[1] = dtblcpy(s, std_dqt1, sizeof(std_dqt1));
	s->ddht[0][0] = dtblcpy(s, std_dht00, sizeof(std_dht00));
	s->ddht[0][1] = dtblcpy(s, std_dht01, sizeof(std_dht01));
	s->ddht[1][0] = dtblcpy(s, std_dht10, sizeof(std_dht10));
	s->ddht[1][1] = dtblcpy(s, std_dht11, sizeof(std_dht11));
 8001998:	f8cb 44fc 	str.w	r4, [fp, #1276]	; 0x4fc
	return(SSDV_OK);
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
 800199c:	f8cb 0034 	str.w	r0, [fp, #52]	; 0x34
static void *dtblcpy(ssdv_t *s, const void *src, size_t n)
{
	void *r;
	if(s->dtbl_len + n > TBL_LEN) return(NULL);
	r = memcpy(&s->dtbls[s->dtbl_len], src, n);
	s->dtbl_len += n;
 80019a0:	f8ab 6508 	strh.w	r6, [fp, #1288]	; 0x508
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 80019a4:	f00c fe84 	bl	800e6b0 <memset>
	
	/* Flush the output bits */
	ssdv_outbits(s, 0, 0);
 80019a8:	2200      	movs	r2, #0
 80019aa:	4611      	mov	r1, r2
 80019ac:	4658      	mov	r0, fp
 80019ae:	f00a ff87 	bl	800c8c0 <ssdv_outbits.lto_priv.142>
 80019b2:	2300      	movs	r3, #0
 80019b4:	9305      	str	r3, [sp, #20]
	ssdv_t ssdv;
	uint8_t pkt[SSDV_PKT_SIZE];
	uint8_t pkt_base91[BASE91LEN(SSDV_PKT_SIZE-37)];
	uint16_t i = 0;
	uint8_t *b;
	uint32_t bi = 0;
 80019b6:	9302      	str	r3, [sp, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80019b8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 80019bc:	f89b 3049 	ldrb.w	r3, [fp, #73]	; 0x49
	ssdv_enc_init(&ssdv, SSDV_TYPE_NORMAL, config->ssdv_config.callsign, image_id);
	ssdv_enc_set_buffer(&ssdv, pkt);

	while(true)
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer
 80019c0:	9908      	ldr	r1, [sp, #32]
 80019c2:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80019c4:	f8c1 21b0 	str.w	r2, [r1, #432]	; 0x1b0
 80019c8:	2b05      	cmp	r3, #5
 80019ca:	f000 8251 	beq.w	8001e70 <encode_ssdv+0x610>
	
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
 80019ce:	f8db 403c 	ldr.w	r4, [fp, #60]	; 0x3c
 80019d2:	2c00      	cmp	r4, #0
 80019d4:	f001 8003 	beq.w	80029de <encode_ssdv+0x117e>
 80019d8:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
	
	while(s->in_len)
 80019dc:	2b00      	cmp	r3, #0
 80019de:	f000 822d 	beq.w	8001e3c <encode_ssdv+0x5dc>
	{
		b = *(s->inp++);
 80019e2:	f8db 2020 	ldr.w	r2, [fp, #32]
		s->in_len--;
		
		/* Skip bytes if necessary */
		if(s->in_skip) { s->in_skip--; continue; }
 80019e6:	f8db 6028 	ldr.w	r6, [fp, #40]	; 0x28
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
	
	while(s->in_len)
	{
		b = *(s->inp++);
 80019ea:	1c51      	adds	r1, r2, #1
		s->in_len--;
 80019ec:	3b01      	subs	r3, #1
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
	
	while(s->in_len)
	{
		b = *(s->inp++);
 80019ee:	f8cb 1020 	str.w	r1, [fp, #32]
 80019f2:	7811      	ldrb	r1, [r2, #0]
		s->in_len--;
 80019f4:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
		
		/* Skip bytes if necessary */
		if(s->in_skip) { s->in_skip--; continue; }
 80019f8:	b146      	cbz	r6, 8001a0c <encode_ssdv+0x1ac>
 80019fa:	3e01      	subs	r6, #1
 80019fc:	f8cb 6028 	str.w	r6, [fp, #40]	; 0x28
 8001a00:	e7ec      	b.n	80019dc <encode_ssdv+0x17c>
	for(c--; c >= callsign; c--)
	{
		x *= 40;
		if(*c >= 'A' && *c <= 'Z') x += *c - 'A' + 14;
		else if(*c >= 'a' && *c <= 'z') x += *c - 'a' + 14;
		else if(*c >= '0' && *c <= '9') x += *c - '0' + 1;
 8001a02:	2809      	cmp	r0, #9
 8001a04:	bf9c      	itt	ls
 8001a06:	3b2f      	subls	r3, #47	; 0x2f
 8001a08:	185b      	addls	r3, r3, r1
 8001a0a:	e74f      	b.n	80018ac <encode_ssdv+0x4c>
		s->in_len--;
		
		/* Skip bytes if necessary */
		if(s->in_skip) { s->in_skip--; continue; }
		
		switch(s->state)
 8001a0c:	f89b 2049 	ldrb.w	r2, [fp, #73]	; 0x49
 8001a10:	2a04      	cmp	r2, #4
 8001a12:	d8e3      	bhi.n	80019dc <encode_ssdv+0x17c>
 8001a14:	e8df f012 	tbh	[pc, r2, lsl #1]
 8001a18:	01f601ba 	.word	0x01f601ba
 8001a1c:	00120180 	.word	0x00120180
 8001a20:	0012      	.short	0x0012
 8001a22:	bf00      	nop
 8001a24:	0800e9a4 	.word	0x0800e9a4
 8001a28:	0800f0d0 	.word	0x0800f0d0
 8001a2c:	0800e9e8 	.word	0x0800e9e8
 8001a30:	0800f0f0 	.word	0x0800f0f0
 8001a34:	0800e83c 	.word	0x0800e83c
 8001a38:	0800e8f0 	.word	0x0800e8f0
		
		case S_HUFF:
		case S_INT:
			/* Is the next byte a stuffing byte? Skip it */
			/* TODO: Test the next byte is actually 0x00 */
			if(b == 0xFF) s->in_skip++;
 8001a3c:	29ff      	cmp	r1, #255	; 0xff
 8001a3e:	bf04      	itt	eq
 8001a40:	2301      	moveq	r3, #1
 8001a42:	f8cb 3028 	streq.w	r3, [fp, #40]	; 0x28
			
			/* Add the new byte to the work area */
			s->workbits = (s->workbits << 8) | b;
 8001a46:	f8db 002c 	ldr.w	r0, [fp, #44]	; 0x2c
			s->worklen += 8;
 8001a4a:	f89b 3030 	ldrb.w	r3, [fp, #48]	; 0x30
			/* Is the next byte a stuffing byte? Skip it */
			/* TODO: Test the next byte is actually 0x00 */
			if(b == 0xFF) s->in_skip++;
			
			/* Add the new byte to the work area */
			s->workbits = (s->workbits << 8) | b;
 8001a4e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			s->worklen += 8;
 8001a52:	3308      	adds	r3, #8
	return(SSDV_OK);
}

static char ssdv_process(ssdv_t *s)
{
	if(s->state == S_HUFF)
 8001a54:	2a03      	cmp	r2, #3
			/* Is the next byte a stuffing byte? Skip it */
			/* TODO: Test the next byte is actually 0x00 */
			if(b == 0xFF) s->in_skip++;
			
			/* Add the new byte to the work area */
			s->workbits = (s->workbits << 8) | b;
 8001a56:	f8cb 102c 	str.w	r1, [fp, #44]	; 0x2c
			s->worklen += 8;
 8001a5a:	f88b 3030 	strb.w	r3, [fp, #48]	; 0x30
	return(SSDV_ERROR);
}

static inline int jpeg_int(int bits, int width)
{
	int b = (1 << width) - 1;
 8001a5e:	f04f 0501 	mov.w	r5, #1
	return(SSDV_OK);
}

static char ssdv_process(ssdv_t *s)
{
	if(s->state == S_HUFF)
 8001a62:	f000 84f0 	beq.w	8002446 <encode_ssdv+0xbe6>
		
		/* Clear processed bits */
		s->worklen -= width;
		s->workbits &= (1 << s->worklen) - 1;
	}
	else if(s->state == S_INT)
 8001a66:	2a04      	cmp	r2, #4
 8001a68:	f000 8588 	beq.w	800257c <encode_ssdv+0xd1c>
 8001a6c:	f89b 4059 	ldrb.w	r4, [fp, #89]	; 0x59
		/* Clear processed bits */
		s->worklen -= s->needbits;
		s->workbits &= (1 << s->worklen) - 1;
	}
	
	if(s->acpart >= 64)
 8001a70:	2c3f      	cmp	r4, #63	; 0x3f
 8001a72:	d917      	bls.n	8001aa4 <encode_ssdv+0x244>
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
 8001a74:	f89b 3058 	ldrb.w	r3, [fp, #88]	; 0x58
 8001a78:	f89b 2057 	ldrb.w	r2, [fp, #87]	; 0x57
 8001a7c:	3301      	adds	r3, #1
 8001a7e:	b2db      	uxtb	r3, r3
 8001a80:	1c91      	adds	r1, r2, #2
 8001a82:	428b      	cmp	r3, r1
 8001a84:	f88b 3058 	strb.w	r3, [fp, #88]	; 0x58
 8001a88:	f000 85f5 	beq.w	8002676 <encode_ssdv+0xe16>
				s->state = S_MARKER;
				return(SSDV_FEED_ME);
			}
		}
		
		if(s->mcupart < s->ycparts) s->component = 0;
 8001a8c:	4293      	cmp	r3, r2
		else s->component = s->mcupart - s->ycparts + 1;
 8001a8e:	bf2a      	itet	cs
 8001a90:	3301      	addcs	r3, #1
				s->state = S_MARKER;
				return(SSDV_FEED_ME);
			}
		}
		
		if(s->mcupart < s->ycparts) s->component = 0;
 8001a92:	2300      	movcc	r3, #0
		else s->component = s->mcupart - s->ycparts + 1;
 8001a94:	1a9b      	subcs	r3, r3, r2
 8001a96:	f88b 3056 	strb.w	r3, [fp, #86]	; 0x56
		
		s->acpart = 0;
 8001a9a:	2300      	movs	r3, #0
 8001a9c:	f88b 3059 	strb.w	r3, [fp, #89]	; 0x59
		s->accrle = 0;
 8001aa0:	f88b 3075 	strb.w	r3, [fp, #117]	; 0x75
	}
	
	if(s->out_len == 0) return(SSDV_BUFFER_FULL);
 8001aa4:	f8db 303c 	ldr.w	r3, [fp, #60]	; 0x3c
 8001aa8:	2b00      	cmp	r3, #0
 8001aaa:	f040 84c7 	bne.w	800243c <encode_ssdv+0xbdc>
			while((r = ssdv_process(s)) == SSDV_OK);
			
			if(r == SSDV_BUFFER_FULL || r == SSDV_EOI)
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
 8001aae:	f89b 301c 	ldrb.w	r3, [fp, #28]
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 8001ab2:	2bff      	cmp	r3, #255	; 0xff
		
		s->acpart = 0;
		s->accrle = 0;
	}
	
	if(s->out_len == 0) return(SSDV_BUFFER_FULL);
 8001ab4:	f04f 0403 	mov.w	r4, #3
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 8001ab8:	f000 86a1 	beq.w	80027fe <encode_ssdv+0xf9e>
 8001abc:	f8bb 2002 	ldrh.w	r2, [fp, #2]
 8001ac0:	4293      	cmp	r3, r2
 8001ac2:	f0c0 869c 	bcc.w	80027fe <encode_ssdv+0xf9e>
				{
					/* The first MCU begins in the next packet, not this one */
					mcu_id = 0xFFFF;
					mcu_offset = 0xFF;
					s->packet_mcu_offset -= s->pkt_size_payload;
 8001ac6:	1a9b      	subs	r3, r3, r2
 8001ac8:	21ff      	movs	r1, #255	; 0xff
 8001aca:	f88b 301c 	strb.w	r3, [fp, #28]
 8001ace:	468e      	mov	lr, r1
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
				{
					/* The first MCU begins in the next packet, not this one */
					mcu_id = 0xFFFF;
					mcu_offset = 0xFF;
 8001ad0:	460b      	mov	r3, r1
					s->packet_mcu_id = 0xFFFF;
					s->packet_mcu_offset = 0xFF;
				}
				
				/* A packet is ready, create the headers */
				s->out[0]   = 0x55;                /* Sync */
 8001ad2:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001ad6:	2055      	movs	r0, #85	; 0x55
 8001ad8:	7010      	strb	r0, [r2, #0]
				s->out[1]   = 0x66 + s->type;      /* Type */
 8001ada:	f89b 2000 	ldrb.w	r2, [fp]
 8001ade:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
 8001ae2:	3266      	adds	r2, #102	; 0x66
 8001ae4:	7042      	strb	r2, [r0, #1]
				s->out[2]   = s->callsign >> 24;
 8001ae6:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001aea:	f89b 000f 	ldrb.w	r0, [fp, #15]
 8001aee:	7090      	strb	r0, [r2, #2]
				s->out[3]   = s->callsign >> 16;
 8001af0:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001af4:	f8bb 000e 	ldrh.w	r0, [fp, #14]
 8001af8:	70d0      	strb	r0, [r2, #3]
				s->out[4]   = s->callsign >> 8;
 8001afa:	f8db 200c 	ldr.w	r2, [fp, #12]
 8001afe:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
 8001b02:	0a12      	lsrs	r2, r2, #8
 8001b04:	7102      	strb	r2, [r0, #4]
				s->out[5]   = s->callsign;
 8001b06:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001b0a:	f8db 000c 	ldr.w	r0, [fp, #12]
 8001b0e:	7150      	strb	r0, [r2, #5]
				s->out[6]   = s->image_id;         /* Image ID */
 8001b10:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001b14:	f89b 0010 	ldrb.w	r0, [fp, #16]
 8001b18:	7190      	strb	r0, [r2, #6]
				s->out[7]   = s->packet_id >> 8;   /* Packet ID MSB */
 8001b1a:	f8bb 2012 	ldrh.w	r2, [fp, #18]
 8001b1e:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
 8001b22:	0a12      	lsrs	r2, r2, #8
 8001b24:	71c2      	strb	r2, [r0, #7]
				s->out[8]   = s->packet_id & 0xFF; /* Packet ID LSB */
 8001b26:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001b2a:	f8bb 0012 	ldrh.w	r0, [fp, #18]
 8001b2e:	7210      	strb	r0, [r2, #8]
				s->out[9]   = s->width >> 4;       /* Width / 16 */
 8001b30:	f8bb 2006 	ldrh.w	r2, [fp, #6]
 8001b34:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
 8001b38:	0912      	lsrs	r2, r2, #4
 8001b3a:	7242      	strb	r2, [r0, #9]
				s->out[10]  = s->height >> 4;      /* Height / 16 */
 8001b3c:	f8bb 2008 	ldrh.w	r2, [fp, #8]
 8001b40:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
 8001b44:	0912      	lsrs	r2, r2, #4
 8001b46:	7282      	strb	r2, [r0, #10]
				s->out[11]  = 0x00;
 8001b48:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
 8001b4c:	2200      	movs	r2, #0
 8001b4e:	72c2      	strb	r2, [r0, #11]
				s->out[11] |= (r == SSDV_EOI ? 1 : 0) << 2; /* EOI flag (1 bit) */
 8001b50:	f8db 5034 	ldr.w	r5, [fp, #52]	; 0x34
 8001b54:	2c04      	cmp	r4, #4
 8001b56:	f995 700b 	ldrsb.w	r7, [r5, #11]
 8001b5a:	bf14      	ite	ne
 8001b5c:	4610      	movne	r0, r2
 8001b5e:	2004      	moveq	r0, #4
 8001b60:	4338      	orrs	r0, r7
 8001b62:	72e8      	strb	r0, [r5, #11]
				s->out[11] |= s->mcu_mode & 0x03;  /* MCU mode (2 bits) */
 8001b64:	f8db 7034 	ldr.w	r7, [fp, #52]	; 0x34
 8001b68:	f89b 5014 	ldrb.w	r5, [fp, #20]
 8001b6c:	7af8      	ldrb	r0, [r7, #11]
 8001b6e:	f005 0503 	and.w	r5, r5, #3
 8001b72:	4328      	orrs	r0, r5
 8001b74:	72f8      	strb	r0, [r7, #11]
				s->out[12]  = mcu_offset;          /* Next MCU offset */
 8001b76:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34
 8001b7a:	7303      	strb	r3, [r0, #12]
				s->out[13]  = mcu_id >> 8;         /* MCU ID MSB */
 8001b7c:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8001b80:	f883 e00d 	strb.w	lr, [r3, #13]
				s->out[14]  = mcu_id & 0xFF;       /* MCU ID LSB */
 8001b84:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 8001b88:	7399      	strb	r1, [r3, #14]
				
				/* Fill any remaining bytes with noise */
				if(s->out_len > 0) ssdv_memset_prng(s->outp, s->out_len);
 8001b8a:	f8db 003c 	ldr.w	r0, [fp, #60]	; 0x3c
 8001b8e:	b180      	cbz	r0, 8001bb2 <encode_ssdv+0x352>
 8001b90:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
/*****************************************************************************/

static void ssdv_memset_prng(uint8_t *s, size_t n)
{
	/* A very simple PRNG for noise whitening */
	uint8_t l = 0x00;
 8001b94:	4613      	mov	r3, r2
 8001b96:	180a      	adds	r2, r1, r0
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
 8001b98:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001b9c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001ba0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 8001ba4:	332d      	adds	r3, #45	; 0x2d
 8001ba6:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8001baa:	f801 3b01 	strb.w	r3, [r1], #1
 8001bae:	4291      	cmp	r1, r2
 8001bb0:	d1f2      	bne.n	8001b98 <encode_ssdv+0x338>
				
				/* Fill any remaining bytes with noise */
				if(s->out_len > 0) ssdv_memset_prng(s->outp, s->out_len);
				
				/* Calculate the CRC codes */
				x = crc32(&s->out[1], s->pkt_size_crcdata);
 8001bb2:	f8bb 5004 	ldrh.w	r5, [fp, #4]
 8001bb6:	f8db 8034 	ldr.w	r8, [fp, #52]	; 0x34
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 8001bba:	2d00      	cmp	r5, #0
 8001bbc:	f001 840e 	beq.w	80033dc <encode_ssdv+0x1b7c>
 8001bc0:	4647      	mov	r7, r8
 8001bc2:	eb08 0e05 	add.w	lr, r8, r5
 8001bc6:	f04f 30ff 	mov.w	r0, #4294967295
	{
		x = (crc ^ *(d++)) & 0xFF;
 8001bca:	f817 3f01 	ldrb.w	r3, [r7, #1]!
 8001bce:	4043      	eors	r3, r0
 8001bd0:	b2db      	uxtb	r3, r3
 8001bd2:	2208      	movs	r2, #8
		for(i = 8; i > 0; i--)
		{
			if(x & 1) x = (x >> 1) ^ 0xEDB88320;
 8001bd4:	f013 0f01 	tst.w	r3, #1
 8001bd8:	ea4f 0153 	mov.w	r1, r3, lsr #1
 8001bdc:	bf18      	it	ne
 8001bde:	4b7c      	ldrne	r3, [pc, #496]	; (8001dd0 <encode_ssdv+0x570>)
 8001be0:	f102 32ff 	add.w	r2, r2, #4294967295
 8001be4:	bf14      	ite	ne
 8001be6:	404b      	eorne	r3, r1
			else x >>= 1;
 8001be8:	085b      	lsreq	r3, r3, #1
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
	{
		x = (crc ^ *(d++)) & 0xFF;
		for(i = 8; i > 0; i--)
 8001bea:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
 8001bee:	d1f1      	bne.n	8001bd4 <encode_ssdv+0x374>
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 8001bf0:	4577      	cmp	r7, lr
		for(i = 8; i > 0; i--)
		{
			if(x & 1) x = (x >> 1) ^ 0xEDB88320;
			else x >>= 1;
		}
		crc = (crc >> 8) ^ x;
 8001bf2:	ea83 2010 	eor.w	r0, r3, r0, lsr #8
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 8001bf6:	d1e8      	bne.n	8001bca <encode_ssdv+0x36a>
 8001bf8:	43c0      	mvns	r0, r0
 8001bfa:	ea4f 6c10 	mov.w	ip, r0, lsr #24
 8001bfe:	f3c0 4107 	ubfx	r1, r0, #16, #8
 8001c02:	f3c0 2e07 	ubfx	lr, r0, #8, #8
 8001c06:	b2c0      	uxtb	r0, r0
				if(s->out_len > 0) ssdv_memset_prng(s->outp, s->out_len);
				
				/* Calculate the CRC codes */
				x = crc32(&s->out[1], s->pkt_size_crcdata);
				
				i = 1 + s->pkt_size_crcdata;
 8001c08:	b2ef      	uxtb	r7, r5
				s->out[i++] = (x >> 24) & 0xFF;
 8001c0a:	1c7a      	adds	r2, r7, #1
 8001c0c:	b2d2      	uxtb	r2, r2
				s->out[i++] = (x >> 16) & 0xFF;
 8001c0e:	1cbb      	adds	r3, r7, #2
				
				/* Calculate the CRC codes */
				x = crc32(&s->out[1], s->pkt_size_crcdata);
				
				i = 1 + s->pkt_size_crcdata;
				s->out[i++] = (x >> 24) & 0xFF;
 8001c10:	f808 c002 	strb.w	ip, [r8, r2]
				s->out[i++] = (x >> 16) & 0xFF;
 8001c14:	b2db      	uxtb	r3, r3
 8001c16:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001c1a:	54d1      	strb	r1, [r2, r3]
				s->out[i++] = (x >> 8) & 0xFF;
 8001c1c:	1cfa      	adds	r2, r7, #3
 8001c1e:	f8db 1034 	ldr.w	r1, [fp, #52]	; 0x34
 8001c22:	b2d2      	uxtb	r2, r2
				s->out[i++] = x & 0xFF;
 8001c24:	1d3b      	adds	r3, r7, #4
				x = crc32(&s->out[1], s->pkt_size_crcdata);
				
				i = 1 + s->pkt_size_crcdata;
				s->out[i++] = (x >> 24) & 0xFF;
				s->out[i++] = (x >> 16) & 0xFF;
				s->out[i++] = (x >> 8) & 0xFF;
 8001c26:	f801 e002 	strb.w	lr, [r1, r2]
				s->out[i++] = x & 0xFF;
 8001c2a:	b2db      	uxtb	r3, r3
 8001c2c:	f8db 2034 	ldr.w	r2, [fp, #52]	; 0x34
 8001c30:	54d0      	strb	r0, [r2, r3]
				
				/* Generate the RS codes */
				if(s->type == SSDV_TYPE_NORMAL)
 8001c32:	f89b 1000 	ldrb.w	r1, [fp]
 8001c36:	2900      	cmp	r1, #0
 8001c38:	f001 8255 	beq.w	80030e6 <encode_ssdv+0x1886>
					encode_rs_8(&s->out[1], &s->out[i], 0);
				
				s->packet_id++;
 8001c3c:	f8bb 3012 	ldrh.w	r3, [fp, #18]
				
				/* Have we reached the end of the image data? */
				if(r == SSDV_EOI) s->state = S_EOI;
 8001c40:	2c04      	cmp	r4, #4
				
				/* Generate the RS codes */
				if(s->type == SSDV_TYPE_NORMAL)
					encode_rs_8(&s->out[1], &s->out[i], 0);
				
				s->packet_id++;
 8001c42:	f103 0301 	add.w	r3, r3, #1
 8001c46:	f8ab 3012 	strh.w	r3, [fp, #18]
				
				/* Have we reached the end of the image data? */
				if(r == SSDV_EOI) s->state = S_EOI;
 8001c4a:	f001 8247 	beq.w	80030dc <encode_ssdv+0x187c>

uint32_t getFrequency(freuquency_config_t *config)
{
	uint32_t (*fptr)(void);

	switch(config->type) {
 8001c4e:	9b08      	ldr	r3, [sp, #32]
 8001c50:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8001c54:	2b00      	cmp	r3, #0
 8001c56:	f001 8199 	beq.w	8002f8c <encode_ssdv+0x172c>
 8001c5a:	2b01      	cmp	r3, #1
 8001c5c:	f041 8193 	bne.w	8002f86 <encode_ssdv+0x1726>
		case FREQ_DYNAMIC: // Dynamic frequency determination
			fptr = config->method;
			uint32_t ret = (*fptr)();
 8001c60:	9c08      	ldr	r4, [sp, #32]
 8001c62:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001c64:	4798      	blx	r3
			if(!ret) // Use default frequency
 8001c66:	2800      	cmp	r0, #0
 8001c68:	f041 8281 	bne.w	800316e <encode_ssdv+0x190e>
				return config->hz;
 8001c6c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		// Transmit packet
		radioMSG_t msg;
		msg.freq = getFrequency(&config->frequency);
		msg.power = config->power;

		switch(config->protocol) {
 8001c6e:	9808      	ldr	r0, [sp, #32]
			return;
		}

		// Transmit packet
		radioMSG_t msg;
		msg.freq = getFrequency(&config->frequency);
 8001c70:	f8cd 3464 	str.w	r3, [sp, #1124]	; 0x464
 8001c74:	f50d 7818 	add.w	r8, sp, #608	; 0x260
		msg.power = config->power;

		switch(config->protocol) {
 8001c78:	f890 2030 	ldrb.w	r2, [r0, #48]	; 0x30
		}

		// Transmit packet
		radioMSG_t msg;
		msg.freq = getFrequency(&config->frequency);
		msg.power = config->power;
 8001c7c:	f890 1020 	ldrb.w	r1, [r0, #32]
 8001c80:	f888 1208 	strb.w	r1, [r8, #520]	; 0x208

		switch(config->protocol) {
 8001c84:	2a00      	cmp	r2, #0
 8001c86:	f001 8168 	beq.w	8002f5a <encode_ssdv+0x16fa>
 8001c8a:	2a02      	cmp	r2, #2
 8001c8c:	f240 8750 	bls.w	8002b30 <encode_ssdv+0x12d0>

				transmitOnRadio(&msg);
				break;

			default:
				TRACE_ERROR("IMG  > Unsupported protocol selected for module IMAGE");
 8001c90:	4850      	ldr	r0, [pc, #320]	; (8001dd4 <encode_ssdv+0x574>)
 8001c92:	f00a fa85 	bl	800c1a0 <chMtxLock>
 8001c96:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001c9a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8001c9e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001ca0:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001ca2:	4b4d      	ldr	r3, [pc, #308]	; (8001dd8 <encode_ssdv+0x578>)
 8001ca4:	494d      	ldr	r1, [pc, #308]	; (8001ddc <encode_ssdv+0x57c>)
 8001ca6:	fb04 f000 	mul.w	r0, r4, r0
 8001caa:	fba3 3000 	umull	r3, r0, r3, r0
 8001cae:	4b4c      	ldr	r3, [pc, #304]	; (8001de0 <encode_ssdv+0x580>)
 8001cb0:	0b40      	lsrs	r0, r0, #13
 8001cb2:	fba3 5300 	umull	r5, r3, r3, r0
 8001cb6:	4d48      	ldr	r5, [pc, #288]	; (8001dd8 <encode_ssdv+0x578>)
 8001cb8:	099b      	lsrs	r3, r3, #6
 8001cba:	fba5 5202 	umull	r5, r2, r5, r2
 8001cbe:	fb04 0313 	mls	r3, r4, r3, r0
 8001cc2:	0b52      	lsrs	r2, r2, #13
 8001cc4:	4847      	ldr	r0, [pc, #284]	; (8001de4 <encode_ssdv+0x584>)
 8001cc6:	f008 fce3 	bl	800a690 <chprintf.constprop.26>
 8001cca:	4a47      	ldr	r2, [pc, #284]	; (8001de8 <encode_ssdv+0x588>)
 8001ccc:	4947      	ldr	r1, [pc, #284]	; (8001dec <encode_ssdv+0x58c>)
 8001cce:	4845      	ldr	r0, [pc, #276]	; (8001de4 <encode_ssdv+0x584>)
 8001cd0:	f008 fcde 	bl	800a690 <chprintf.constprop.26>
 8001cd4:	235d      	movs	r3, #93	; 0x5d
 8001cd6:	4a46      	ldr	r2, [pc, #280]	; (8001df0 <encode_ssdv+0x590>)
 8001cd8:	4946      	ldr	r1, [pc, #280]	; (8001df4 <encode_ssdv+0x594>)
 8001cda:	4842      	ldr	r0, [pc, #264]	; (8001de4 <encode_ssdv+0x584>)
 8001cdc:	f008 fcd8 	bl	800a690 <chprintf.constprop.26>
 8001ce0:	4945      	ldr	r1, [pc, #276]	; (8001df8 <encode_ssdv+0x598>)
 8001ce2:	4840      	ldr	r0, [pc, #256]	; (8001de4 <encode_ssdv+0x584>)
 8001ce4:	f008 fcd4 	bl	800a690 <chprintf.constprop.26>
 8001ce8:	4944      	ldr	r1, [pc, #272]	; (8001dfc <encode_ssdv+0x59c>)
 8001cea:	483e      	ldr	r0, [pc, #248]	; (8001de4 <encode_ssdv+0x584>)
 8001cec:	f008 fcd0 	bl	800a690 <chprintf.constprop.26>
 8001cf0:	4943      	ldr	r1, [pc, #268]	; (8001e00 <encode_ssdv+0x5a0>)
 8001cf2:	483c      	ldr	r0, [pc, #240]	; (8001de4 <encode_ssdv+0x584>)
 8001cf4:	f008 fccc 	bl	800a690 <chprintf.constprop.26>
 8001cf8:	4836      	ldr	r0, [pc, #216]	; (8001dd4 <encode_ssdv+0x574>)
 8001cfa:	f007 fc41 	bl	8009580 <chMtxUnlock>
 8001cfe:	215d      	movs	r1, #93	; 0x5d
 8001d00:	483b      	ldr	r0, [pc, #236]	; (8001df0 <encode_ssdv+0x590>)
 8001d02:	f00a fe3d 	bl	800c980 <log_error>
		}

		// Packet spacing (delay)
		if(config->packet_spacing)
 8001d06:	9b08      	ldr	r3, [sp, #32]
 8001d08:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8001d0a:	2800      	cmp	r0, #0
 8001d0c:	f041 80cb 	bne.w	8002ea6 <encode_ssdv+0x1646>
 8001d10:	9b05      	ldr	r3, [sp, #20]
 8001d12:	3301      	adds	r3, #1
 8001d14:	9305      	str	r3, [sp, #20]
 8001d16:	e64f      	b.n	80019b8 <encode_ssdv+0x158>
				if(r != SSDV_OK) return(r);
			}
			break;
		
		case S_MARKER_DATA:
			s->marker_data[s->marker_data_len++] = b;
 8001d18:	f8bb 3054 	ldrh.w	r3, [fp, #84]	; 0x54
 8001d1c:	f8db 2050 	ldr.w	r2, [fp, #80]	; 0x50
 8001d20:	1c58      	adds	r0, r3, #1
 8001d22:	f8ab 0054 	strh.w	r0, [fp, #84]	; 0x54
 8001d26:	54d1      	strb	r1, [r2, r3]
			if(s->marker_data_len == s->marker_len)
 8001d28:	f8bb 3054 	ldrh.w	r3, [fp, #84]	; 0x54
 8001d2c:	f8bb 204c 	ldrh.w	r2, [fp, #76]	; 0x4c
 8001d30:	429a      	cmp	r2, r3
 8001d32:	f47f ae51 	bne.w	80019d8 <encode_ssdv+0x178>
{
	uint8_t *d = s->marker_data;
	size_t l = s->marker_len;
	int i;
	
	switch(s->marker)
 8001d36:	f8bb 204a 	ldrh.w	r2, [fp, #74]	; 0x4a
	return(SSDV_OK);
}

static char ssdv_have_marker_data(ssdv_t *s)
{
	uint8_t *d = s->marker_data;
 8001d3a:	f8db 4050 	ldr.w	r4, [fp, #80]	; 0x50
	size_t l = s->marker_len;
	int i;
	
	switch(s->marker)
 8001d3e:	f5a2 427f 	sub.w	r2, r2, #65280	; 0xff00
 8001d42:	3ac0      	subs	r2, #192	; 0xc0
}

static char ssdv_have_marker_data(ssdv_t *s)
{
	uint8_t *d = s->marker_data;
	size_t l = s->marker_len;
 8001d44:	461d      	mov	r5, r3
	int i;
	
	switch(s->marker)
 8001d46:	2a1d      	cmp	r2, #29
 8001d48:	f200 8144 	bhi.w	8001fd4 <encode_ssdv+0x774>
 8001d4c:	e8df f012 	tbh	[pc, r2, lsl #1]
 8001d50:	01420282 	.word	0x01420282
 8001d54:	01420142 	.word	0x01420142
 8001d58:	01420234 	.word	0x01420234
 8001d5c:	01420142 	.word	0x01420142
 8001d60:	01420142 	.word	0x01420142
 8001d64:	01420142 	.word	0x01420142
 8001d68:	01420142 	.word	0x01420142
 8001d6c:	01420142 	.word	0x01420142
 8001d70:	01420142 	.word	0x01420142
 8001d74:	01420142 	.word	0x01420142
 8001d78:	01420142 	.word	0x01420142
 8001d7c:	01420142 	.word	0x01420142
 8001d80:	01420142 	.word	0x01420142
 8001d84:	0146017c 	.word	0x0146017c
 8001d88:	00fd0142 	.word	0x00fd0142
		if(s->in_skip) { s->in_skip--; continue; }
		
		switch(s->state)
		{
		case S_MARKER:
			s->marker = (s->marker << 8) | b;
 8001d8c:	f8bb 204a 	ldrh.w	r2, [fp, #74]	; 0x4a
 8001d90:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 8001d94:	b289      	uxth	r1, r1
			
			if(s->marker == J_TEM ||
 8001d96:	f64f 7201 	movw	r2, #65281	; 0xff01
 8001d9a:	4291      	cmp	r1, r2
		if(s->in_skip) { s->in_skip--; continue; }
		
		switch(s->state)
		{
		case S_MARKER:
			s->marker = (s->marker << 8) | b;
 8001d9c:	f8ab 104a 	strh.w	r1, [fp, #74]	; 0x4a
			
			if(s->marker == J_TEM ||
 8001da0:	f000 853a 	beq.w	8002818 <encode_ssdv+0xfb8>
 8001da4:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8001da8:	b292      	uxth	r2, r2
 8001daa:	2a09      	cmp	r2, #9
 8001dac:	f240 8534 	bls.w	8002818 <encode_ssdv+0xfb8>
				/* Marker without data */
				s->marker_len = 0;
				r = ssdv_have_marker(s);
				if(r != SSDV_OK) return(r);
			}
			else if(s->marker >= J_SOF0 && s->marker <= J_COM)
 8001db0:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8001db4:	b292      	uxth	r2, r2
 8001db6:	2a3e      	cmp	r2, #62	; 0x3e
 8001db8:	f63f ae10 	bhi.w	80019dc <encode_ssdv+0x17c>
			{
				/* All other markers are followed by data */
				s->marker_len = 0;
 8001dbc:	2000      	movs	r0, #0
				s->state = S_MARKER_LEN;
 8001dbe:	2101      	movs	r1, #1
				s->needbits = 16;
 8001dc0:	2210      	movs	r2, #16
				if(r != SSDV_OK) return(r);
			}
			else if(s->marker >= J_SOF0 && s->marker <= J_COM)
			{
				/* All other markers are followed by data */
				s->marker_len = 0;
 8001dc2:	f8ab 004c 	strh.w	r0, [fp, #76]	; 0x4c
				s->state = S_MARKER_LEN;
 8001dc6:	f88b 1049 	strb.w	r1, [fp, #73]	; 0x49
				s->needbits = 16;
 8001dca:	f88b 2080 	strb.w	r2, [fp, #128]	; 0x80
 8001dce:	e605      	b.n	80019dc <encode_ssdv+0x17c>
 8001dd0:	edb88320 	.word	0xedb88320
 8001dd4:	2001b720 	.word	0x2001b720
 8001dd8:	d1b71759 	.word	0xd1b71759
 8001ddc:	0800ea50 	.word	0x0800ea50
 8001de0:	10624dd3 	.word	0x10624dd3
 8001de4:	2001ac28 	.word	0x2001ac28
 8001de8:	0800ea5c 	.word	0x0800ea5c
 8001dec:	0800ea64 	.word	0x0800ea64
 8001df0:	0800ea74 	.word	0x0800ea74
 8001df4:	0800ea7c 	.word	0x0800ea7c
 8001df8:	0800f1e0 	.word	0x0800f1e0
 8001dfc:	0800ede0 	.word	0x0800ede0
 8001e00:	0800eaa8 	.word	0x0800eaa8
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8001e04:	f8bb 004c 	ldrh.w	r0, [fp, #76]	; 0x4c
			if((s->needbits -= 8) == 0)
 8001e08:	f89b 2080 	ldrb.w	r2, [fp, #128]	; 0x80
				s->needbits = 16;
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8001e0c:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			if((s->needbits -= 8) == 0)
 8001e10:	3a08      	subs	r2, #8
				s->needbits = 16;
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8001e12:	b289      	uxth	r1, r1
			if((s->needbits -= 8) == 0)
 8001e14:	b2d2      	uxtb	r2, r2
				s->needbits = 16;
			}
			break;
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
 8001e16:	f8ab 104c 	strh.w	r1, [fp, #76]	; 0x4c
			if((s->needbits -= 8) == 0)
 8001e1a:	f88b 2080 	strb.w	r2, [fp, #128]	; 0x80
 8001e1e:	2a00      	cmp	r2, #0
 8001e20:	f47f addc 	bne.w	80019dc <encode_ssdv+0x17c>
			{
				s->marker_len -= 2;
 8001e24:	3902      	subs	r1, #2
				r = ssdv_have_marker(s);
 8001e26:	4658      	mov	r0, fp
		
		case S_MARKER_LEN:
			s->marker_len = (s->marker_len << 8) | b;
			if((s->needbits -= 8) == 0)
			{
				s->marker_len -= 2;
 8001e28:	f8ab 104c 	strh.w	r1, [fp, #76]	; 0x4c
				r = ssdv_have_marker(s);
 8001e2c:	f00a fde8 	bl	800ca00 <ssdv_have_marker.lto_priv.141>
				if(r != SSDV_OK) return(r);
 8001e30:	2800      	cmp	r0, #0
 8001e32:	f43f add1 	beq.w	80019d8 <encode_ssdv+0x178>

	while(true)
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
 8001e36:	2801      	cmp	r0, #1
 8001e38:	f040 84fa 	bne.w	8002830 <encode_ssdv+0xfd0>
		{
			b = &image[bi];
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
 8001e3c:	9c04      	ldr	r4, [sp, #16]
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
		{
			b = &image[bi];
 8001e3e:	9902      	ldr	r1, [sp, #8]
 8001e40:	9803      	ldr	r0, [sp, #12]
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
 8001e42:	f1a4 0380 	sub.w	r3, r4, #128	; 0x80
 8001e46:	428b      	cmp	r3, r1
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
		{
			b = &image[bi];
 8001e48:	eb00 0201 	add.w	r2, r0, r1
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
 8001e4c:	f200 857d 	bhi.w	800294a <encode_ssdv+0x10ea>
 8001e50:	1a63      	subs	r3, r4, r1
 8001e52:	b2db      	uxtb	r3, r3
			bi += r;
 8001e54:	4419      	add	r1, r3
 8001e56:	9102      	str	r1, [sp, #8]

			if(r <= 0)
 8001e58:	2b00      	cmp	r3, #0
 8001e5a:	f000 862c 	beq.w	8002ab6 <encode_ssdv+0x1256>
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 8001e5e:	f89b 1049 	ldrb.w	r1, [fp, #73]	; 0x49
	return(SSDV_FEED_ME);
}

char ssdv_enc_feed(ssdv_t *s, uint8_t *buffer, size_t length)
{
	s->inp    = buffer;
 8001e62:	f8cb 2020 	str.w	r2, [fp, #32]
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 8001e66:	2905      	cmp	r1, #5
}

char ssdv_enc_feed(ssdv_t *s, uint8_t *buffer, size_t length)
{
	s->inp    = buffer;
	s->in_len = length;
 8001e68:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
{
	int r;
	uint8_t b;
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
 8001e6c:	f47f adaf 	bne.w	80019ce <encode_ssdv+0x16e>
 8001e70:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
			ssdv_enc_feed(&ssdv, b, r);
		}

		if(c == SSDV_EOI)
		{
			TRACE_INFO("SSDV > ssdv_enc_get_packet said EOI");
 8001e74:	4864      	ldr	r0, [pc, #400]	; (8002008 <encode_ssdv+0x7a8>)
 8001e76:	4e65      	ldr	r6, [pc, #404]	; (800200c <encode_ssdv+0x7ac>)
 8001e78:	4c65      	ldr	r4, [pc, #404]	; (8002010 <encode_ssdv+0x7b0>)
 8001e7a:	f00a f991 	bl	800c1a0 <chMtxLock>
 8001e7e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001e80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001e82:	4964      	ldr	r1, [pc, #400]	; (8002014 <encode_ssdv+0x7b4>)
 8001e84:	4864      	ldr	r0, [pc, #400]	; (8002018 <encode_ssdv+0x7b8>)
 8001e86:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8001e8a:	fb05 f303 	mul.w	r3, r5, r3
 8001e8e:	fba6 e303 	umull	lr, r3, r6, r3
 8001e92:	0b5b      	lsrs	r3, r3, #13
 8001e94:	fba4 ce03 	umull	ip, lr, r4, r3
 8001e98:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8001e9c:	fba6 c202 	umull	ip, r2, r6, r2
 8001ea0:	fb05 331e 	mls	r3, r5, lr, r3
 8001ea4:	0b52      	lsrs	r2, r2, #13
 8001ea6:	f008 fbf3 	bl	800a690 <chprintf.constprop.26>
 8001eaa:	4a5c      	ldr	r2, [pc, #368]	; (800201c <encode_ssdv+0x7bc>)
 8001eac:	495c      	ldr	r1, [pc, #368]	; (8002020 <encode_ssdv+0x7c0>)
 8001eae:	485a      	ldr	r0, [pc, #360]	; (8002018 <encode_ssdv+0x7b8>)
 8001eb0:	f008 fbee 	bl	800a690 <chprintf.constprop.26>
 8001eb4:	2335      	movs	r3, #53	; 0x35
 8001eb6:	4a5b      	ldr	r2, [pc, #364]	; (8002024 <encode_ssdv+0x7c4>)
 8001eb8:	495b      	ldr	r1, [pc, #364]	; (8002028 <encode_ssdv+0x7c8>)
 8001eba:	4857      	ldr	r0, [pc, #348]	; (8002018 <encode_ssdv+0x7b8>)
 8001ebc:	f008 fbe8 	bl	800a690 <chprintf.constprop.26>
 8001ec0:	495a      	ldr	r1, [pc, #360]	; (800202c <encode_ssdv+0x7cc>)
 8001ec2:	4855      	ldr	r0, [pc, #340]	; (8002018 <encode_ssdv+0x7b8>)
 8001ec4:	f008 fbe4 	bl	800a690 <chprintf.constprop.26>
 8001ec8:	4959      	ldr	r1, [pc, #356]	; (8002030 <encode_ssdv+0x7d0>)
 8001eca:	4853      	ldr	r0, [pc, #332]	; (8002018 <encode_ssdv+0x7b8>)
 8001ecc:	f008 fbe0 	bl	800a690 <chprintf.constprop.26>
 8001ed0:	4958      	ldr	r1, [pc, #352]	; (8002034 <encode_ssdv+0x7d4>)
 8001ed2:	4851      	ldr	r0, [pc, #324]	; (8002018 <encode_ssdv+0x7b8>)
 8001ed4:	f008 fbdc 	bl	800a690 <chprintf.constprop.26>
 8001ed8:	484b      	ldr	r0, [pc, #300]	; (8002008 <encode_ssdv+0x7a8>)
 8001eda:	f007 fb51 	bl	8009580 <chMtxUnlock>
			chThdSleepMilliseconds(config->packet_spacing);

		i++;
	}

	TRACE_INFO("SSDV > %i packets", i);
 8001ede:	484a      	ldr	r0, [pc, #296]	; (8002008 <encode_ssdv+0x7a8>)
 8001ee0:	f00a f95e 	bl	800c1a0 <chMtxLock>
 8001ee4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001ee6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001ee8:	494a      	ldr	r1, [pc, #296]	; (8002014 <encode_ssdv+0x7b4>)
 8001eea:	484b      	ldr	r0, [pc, #300]	; (8002018 <encode_ssdv+0x7b8>)
 8001eec:	fb05 f303 	mul.w	r3, r5, r3
 8001ef0:	fba6 7303 	umull	r7, r3, r6, r3
 8001ef4:	0b5b      	lsrs	r3, r3, #13
 8001ef6:	fba4 7403 	umull	r7, r4, r4, r3
 8001efa:	09a4      	lsrs	r4, r4, #6
 8001efc:	fba6 6202 	umull	r6, r2, r6, r2
 8001f00:	fb05 3314 	mls	r3, r5, r4, r3
 8001f04:	0b52      	lsrs	r2, r2, #13
 8001f06:	f008 fbc3 	bl	800a690 <chprintf.constprop.26>
 8001f0a:	4a44      	ldr	r2, [pc, #272]	; (800201c <encode_ssdv+0x7bc>)
 8001f0c:	4944      	ldr	r1, [pc, #272]	; (8002020 <encode_ssdv+0x7c0>)
 8001f0e:	4842      	ldr	r0, [pc, #264]	; (8002018 <encode_ssdv+0x7b8>)
 8001f10:	f008 fbbe 	bl	800a690 <chprintf.constprop.26>
 8001f14:	2367      	movs	r3, #103	; 0x67
 8001f16:	4a43      	ldr	r2, [pc, #268]	; (8002024 <encode_ssdv+0x7c4>)
 8001f18:	4943      	ldr	r1, [pc, #268]	; (8002028 <encode_ssdv+0x7c8>)
 8001f1a:	483f      	ldr	r0, [pc, #252]	; (8002018 <encode_ssdv+0x7b8>)
 8001f1c:	f008 fbb8 	bl	800a690 <chprintf.constprop.26>
 8001f20:	4942      	ldr	r1, [pc, #264]	; (800202c <encode_ssdv+0x7cc>)
 8001f22:	483d      	ldr	r0, [pc, #244]	; (8002018 <encode_ssdv+0x7b8>)
 8001f24:	f008 fbb4 	bl	800a690 <chprintf.constprop.26>
 8001f28:	f8bd 2014 	ldrh.w	r2, [sp, #20]
 8001f2c:	4942      	ldr	r1, [pc, #264]	; (8002038 <encode_ssdv+0x7d8>)
 8001f2e:	483a      	ldr	r0, [pc, #232]	; (8002018 <encode_ssdv+0x7b8>)
 8001f30:	f008 fbae 	bl	800a690 <chprintf.constprop.26>
 8001f34:	493f      	ldr	r1, [pc, #252]	; (8002034 <encode_ssdv+0x7d4>)
 8001f36:	4838      	ldr	r0, [pc, #224]	; (8002018 <encode_ssdv+0x7b8>)
 8001f38:	f008 fbaa 	bl	800a690 <chprintf.constprop.26>
 8001f3c:	4832      	ldr	r0, [pc, #200]	; (8002008 <encode_ssdv+0x7a8>)
 8001f3e:	f007 fb1f 	bl	8009580 <chMtxUnlock>
}
 8001f42:	f60d 1d8c 	addw	sp, sp, #2444	; 0x98c
 8001f46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			d += 65;
		}
		break;
	
	case J_DRI:
		s->dri = (d[0] << 8) + d[1];
 8001f4a:	7822      	ldrb	r2, [r4, #0]
 8001f4c:	7863      	ldrb	r3, [r4, #1]
		TRACE_ERROR("SSDV > Reset interval: %i blocks", s->dri);
 8001f4e:	482e      	ldr	r0, [pc, #184]	; (8002008 <encode_ssdv+0x7a8>)
			d += 65;
		}
		break;
	
	case J_DRI:
		s->dri = (d[0] << 8) + d[1];
 8001f50:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8001f54:	f8ab 3076 	strh.w	r3, [fp, #118]	; 0x76
		TRACE_ERROR("SSDV > Reset interval: %i blocks", s->dri);
 8001f58:	f00a f922 	bl	800c1a0 <chMtxLock>
 8001f5c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001f60:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8001f64:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001f66:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001f68:	4b28      	ldr	r3, [pc, #160]	; (800200c <encode_ssdv+0x7ac>)
 8001f6a:	492a      	ldr	r1, [pc, #168]	; (8002014 <encode_ssdv+0x7b4>)
 8001f6c:	fb04 f000 	mul.w	r0, r4, r0
 8001f70:	fba3 3000 	umull	r3, r0, r3, r0
 8001f74:	4b26      	ldr	r3, [pc, #152]	; (8002010 <encode_ssdv+0x7b0>)
 8001f76:	0b40      	lsrs	r0, r0, #13
 8001f78:	fba3 5300 	umull	r5, r3, r3, r0
 8001f7c:	4d23      	ldr	r5, [pc, #140]	; (800200c <encode_ssdv+0x7ac>)
 8001f7e:	099b      	lsrs	r3, r3, #6
 8001f80:	fba5 5202 	umull	r5, r2, r5, r2
 8001f84:	fb04 0313 	mls	r3, r4, r3, r0
 8001f88:	0b52      	lsrs	r2, r2, #13
 8001f8a:	4823      	ldr	r0, [pc, #140]	; (8002018 <encode_ssdv+0x7b8>)
 8001f8c:	f008 fb80 	bl	800a690 <chprintf.constprop.26>
 8001f90:	4a2a      	ldr	r2, [pc, #168]	; (800203c <encode_ssdv+0x7dc>)
 8001f92:	4923      	ldr	r1, [pc, #140]	; (8002020 <encode_ssdv+0x7c0>)
 8001f94:	4820      	ldr	r0, [pc, #128]	; (8002018 <encode_ssdv+0x7b8>)
 8001f96:	f008 fb7b 	bl	800a690 <chprintf.constprop.26>
 8001f9a:	f240 333b 	movw	r3, #827	; 0x33b
 8001f9e:	4a28      	ldr	r2, [pc, #160]	; (8002040 <encode_ssdv+0x7e0>)
 8001fa0:	4921      	ldr	r1, [pc, #132]	; (8002028 <encode_ssdv+0x7c8>)
 8001fa2:	481d      	ldr	r0, [pc, #116]	; (8002018 <encode_ssdv+0x7b8>)
 8001fa4:	f008 fb74 	bl	800a690 <chprintf.constprop.26>
 8001fa8:	4920      	ldr	r1, [pc, #128]	; (800202c <encode_ssdv+0x7cc>)
 8001faa:	481b      	ldr	r0, [pc, #108]	; (8002018 <encode_ssdv+0x7b8>)
 8001fac:	f008 fb70 	bl	800a690 <chprintf.constprop.26>
 8001fb0:	f8bb 2076 	ldrh.w	r2, [fp, #118]	; 0x76
 8001fb4:	4923      	ldr	r1, [pc, #140]	; (8002044 <encode_ssdv+0x7e4>)
 8001fb6:	4818      	ldr	r0, [pc, #96]	; (8002018 <encode_ssdv+0x7b8>)
 8001fb8:	f008 fb6a 	bl	800a690 <chprintf.constprop.26>
 8001fbc:	491d      	ldr	r1, [pc, #116]	; (8002034 <encode_ssdv+0x7d4>)
 8001fbe:	4816      	ldr	r0, [pc, #88]	; (8002018 <encode_ssdv+0x7b8>)
 8001fc0:	f008 fb66 	bl	800a690 <chprintf.constprop.26>
 8001fc4:	4810      	ldr	r0, [pc, #64]	; (8002008 <encode_ssdv+0x7a8>)
 8001fc6:	f007 fadb 	bl	8009580 <chMtxUnlock>
 8001fca:	f240 313b 	movw	r1, #827	; 0x33b
 8001fce:	481c      	ldr	r0, [pc, #112]	; (8002040 <encode_ssdv+0x7e0>)
 8001fd0:	f00a fcd6 	bl	800c980 <log_error>
		break;
	}
	
	s->state = S_MARKER;
 8001fd4:	2300      	movs	r3, #0
 8001fd6:	f88b 3049 	strb.w	r3, [fp, #73]	; 0x49
 8001fda:	e4fd      	b.n	80019d8 <encode_ssdv+0x178>
			d += j;
		}
		break;
	
	case J_DQT:
		s->stbl_len += l;
 8001fdc:	f8bb 22cc 	ldrh.w	r2, [fp, #716]	; 0x2cc
 8001fe0:	441a      	add	r2, r3
 8001fe2:	f8ab 22cc 	strh.w	r2, [fp, #716]	; 0x2cc
		while(l > 0)
 8001fe6:	2b00      	cmp	r3, #0
 8001fe8:	d0f4      	beq.n	8001fd4 <encode_ssdv+0x774>
 8001fea:	4423      	add	r3, r4
 8001fec:	e006      	b.n	8001ffc <encode_ssdv+0x79c>
		{
			switch(d[0])
 8001fee:	2a01      	cmp	r2, #1
 8001ff0:	d101      	bne.n	8001ff6 <encode_ssdv+0x796>
			{
			case 0x00: s->sdqt[0] = d; break;
			case 0x01: s->sdqt[1] = d; break;
 8001ff2:	f8cb 42c8 	str.w	r4, [fp, #712]	; 0x2c8
			}
			
			/* Skip to the next one, if present */
			l -= 65;
			d += 65;
 8001ff6:	3441      	adds	r4, #65	; 0x41
		}
		break;
	
	case J_DQT:
		s->stbl_len += l;
		while(l > 0)
 8001ff8:	429c      	cmp	r4, r3
 8001ffa:	d0eb      	beq.n	8001fd4 <encode_ssdv+0x774>
		{
			switch(d[0])
 8001ffc:	7822      	ldrb	r2, [r4, #0]
 8001ffe:	2a00      	cmp	r2, #0
 8002000:	d1f5      	bne.n	8001fee <encode_ssdv+0x78e>
			{
			case 0x00: s->sdqt[0] = d; break;
 8002002:	f8cb 42c4 	str.w	r4, [fp, #708]	; 0x2c4
 8002006:	e7f6      	b.n	8001ff6 <encode_ssdv+0x796>
 8002008:	2001b720 	.word	0x2001b720
 800200c:	d1b71759 	.word	0xd1b71759
 8002010:	10624dd3 	.word	0x10624dd3
 8002014:	0800ea50 	.word	0x0800ea50
 8002018:	2001ac28 	.word	0x2001ac28
 800201c:	0800f1dc 	.word	0x0800f1dc
 8002020:	0800ea64 	.word	0x0800ea64
 8002024:	0800ea74 	.word	0x0800ea74
 8002028:	0800ea7c 	.word	0x0800ea7c
 800202c:	0800f1e0 	.word	0x0800f1e0
 8002030:	0800ee18 	.word	0x0800ee18
 8002034:	0800eaa8 	.word	0x0800eaa8
 8002038:	0800ee3c 	.word	0x0800ee3c
 800203c:	0800ea5c 	.word	0x0800ea5c
 8002040:	0800eabb 	.word	0x0800eabb
 8002044:	0800ed88 	.word	0x0800ed88
 8002048:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
		s->mcu_count = l;
		
		break;
	
	case J_SOS:
		TRACE_INFO("SSDV > Components: %i", d[0]);
 800204c:	4871      	ldr	r0, [pc, #452]	; (8002214 <encode_ssdv+0x9b4>)
 800204e:	4f72      	ldr	r7, [pc, #456]	; (8002218 <encode_ssdv+0x9b8>)
 8002050:	f8df 81cc 	ldr.w	r8, [pc, #460]	; 8002220 <encode_ssdv+0x9c0>
 8002054:	f00a f8a4 	bl	800c1a0 <chMtxLock>
 8002058:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800205a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800205c:	496f      	ldr	r1, [pc, #444]	; (800221c <encode_ssdv+0x9bc>)
 800205e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8002062:	4638      	mov	r0, r7
 8002064:	fb06 f303 	mul.w	r3, r6, r3
 8002068:	fba0 0303 	umull	r0, r3, r0, r3
 800206c:	486c      	ldr	r0, [pc, #432]	; (8002220 <encode_ssdv+0x9c0>)
 800206e:	0b5b      	lsrs	r3, r3, #13
 8002070:	fba0 0e03 	umull	r0, lr, r0, r3
 8002074:	4638      	mov	r0, r7
 8002076:	fba0 0202 	umull	r0, r2, r0, r2
 800207a:	ea4f 109e 	mov.w	r0, lr, lsr #6
 800207e:	fb06 3310 	mls	r3, r6, r0, r3
 8002082:	0b52      	lsrs	r2, r2, #13
 8002084:	4867      	ldr	r0, [pc, #412]	; (8002224 <encode_ssdv+0x9c4>)
 8002086:	f008 fb03 	bl	800a690 <chprintf.constprop.26>
 800208a:	4a67      	ldr	r2, [pc, #412]	; (8002228 <encode_ssdv+0x9c8>)
 800208c:	4967      	ldr	r1, [pc, #412]	; (800222c <encode_ssdv+0x9cc>)
 800208e:	4865      	ldr	r0, [pc, #404]	; (8002224 <encode_ssdv+0x9c4>)
 8002090:	f008 fafe 	bl	800a690 <chprintf.constprop.26>
 8002094:	f240 23e7 	movw	r3, #743	; 0x2e7
 8002098:	4a65      	ldr	r2, [pc, #404]	; (8002230 <encode_ssdv+0x9d0>)
 800209a:	4966      	ldr	r1, [pc, #408]	; (8002234 <encode_ssdv+0x9d4>)
 800209c:	4861      	ldr	r0, [pc, #388]	; (8002224 <encode_ssdv+0x9c4>)
 800209e:	f008 faf7 	bl	800a690 <chprintf.constprop.26>
 80020a2:	4965      	ldr	r1, [pc, #404]	; (8002238 <encode_ssdv+0x9d8>)
 80020a4:	485f      	ldr	r0, [pc, #380]	; (8002224 <encode_ssdv+0x9c4>)
 80020a6:	f008 faf3 	bl	800a690 <chprintf.constprop.26>
 80020aa:	7822      	ldrb	r2, [r4, #0]
 80020ac:	4963      	ldr	r1, [pc, #396]	; (800223c <encode_ssdv+0x9dc>)
 80020ae:	485d      	ldr	r0, [pc, #372]	; (8002224 <encode_ssdv+0x9c4>)
 80020b0:	f008 faee 	bl	800a690 <chprintf.constprop.26>
 80020b4:	4962      	ldr	r1, [pc, #392]	; (8002240 <encode_ssdv+0x9e0>)
 80020b6:	485b      	ldr	r0, [pc, #364]	; (8002224 <encode_ssdv+0x9c4>)
 80020b8:	f008 faea 	bl	800a690 <chprintf.constprop.26>
 80020bc:	4855      	ldr	r0, [pc, #340]	; (8002214 <encode_ssdv+0x9b4>)
 80020be:	f007 fa5f 	bl	8009580 <chMtxUnlock>
		
		/* The image must have 3 components (Y'Cb'Cr) */
		if(d[0] != 3)
 80020c2:	7823      	ldrb	r3, [r4, #0]
 80020c4:	2b03      	cmp	r3, #3
 80020c6:	f000 876b 	beq.w	8002fa0 <encode_ssdv+0x1740>
		{
			TRACE_ERROR("SSDV > The image must have 3 components");
 80020ca:	4852      	ldr	r0, [pc, #328]	; (8002214 <encode_ssdv+0x9b4>)
 80020cc:	f00a f868 	bl	800c1a0 <chMtxLock>
 80020d0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80020d2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80020d4:	4951      	ldr	r1, [pc, #324]	; (800221c <encode_ssdv+0x9bc>)
 80020d6:	4853      	ldr	r0, [pc, #332]	; (8002224 <encode_ssdv+0x9c4>)
 80020d8:	fb06 f303 	mul.w	r3, r6, r3
 80020dc:	fba7 4303 	umull	r4, r3, r7, r3
 80020e0:	0b5b      	lsrs	r3, r3, #13
 80020e2:	fba8 5403 	umull	r5, r4, r8, r3
 80020e6:	09a4      	lsrs	r4, r4, #6
 80020e8:	fba7 5202 	umull	r5, r2, r7, r2
 80020ec:	fb06 3314 	mls	r3, r6, r4, r3
 80020f0:	0b52      	lsrs	r2, r2, #13
 80020f2:	f008 facd 	bl	800a690 <chprintf.constprop.26>
 80020f6:	4a53      	ldr	r2, [pc, #332]	; (8002244 <encode_ssdv+0x9e4>)
 80020f8:	494c      	ldr	r1, [pc, #304]	; (800222c <encode_ssdv+0x9cc>)
 80020fa:	484a      	ldr	r0, [pc, #296]	; (8002224 <encode_ssdv+0x9c4>)
 80020fc:	f008 fac8 	bl	800a690 <chprintf.constprop.26>
 8002100:	f44f 733b 	mov.w	r3, #748	; 0x2ec
 8002104:	4a4a      	ldr	r2, [pc, #296]	; (8002230 <encode_ssdv+0x9d0>)
 8002106:	494b      	ldr	r1, [pc, #300]	; (8002234 <encode_ssdv+0x9d4>)
 8002108:	4846      	ldr	r0, [pc, #280]	; (8002224 <encode_ssdv+0x9c4>)
 800210a:	f008 fac1 	bl	800a690 <chprintf.constprop.26>
 800210e:	494a      	ldr	r1, [pc, #296]	; (8002238 <encode_ssdv+0x9d8>)
 8002110:	4844      	ldr	r0, [pc, #272]	; (8002224 <encode_ssdv+0x9c4>)
 8002112:	f008 fabd 	bl	800a690 <chprintf.constprop.26>
 8002116:	494c      	ldr	r1, [pc, #304]	; (8002248 <encode_ssdv+0x9e8>)
 8002118:	4842      	ldr	r0, [pc, #264]	; (8002224 <encode_ssdv+0x9c4>)
 800211a:	f008 fab9 	bl	800a690 <chprintf.constprop.26>
 800211e:	4948      	ldr	r1, [pc, #288]	; (8002240 <encode_ssdv+0x9e0>)
 8002120:	4840      	ldr	r0, [pc, #256]	; (8002224 <encode_ssdv+0x9c4>)
 8002122:	f008 fab5 	bl	800a690 <chprintf.constprop.26>
 8002126:	483b      	ldr	r0, [pc, #236]	; (8002214 <encode_ssdv+0x9b4>)
 8002128:	f007 fa2a 	bl	8009580 <chMtxUnlock>
 800212c:	f44f 713b 	mov.w	r1, #748	; 0x2ec
 8002130:	483f      	ldr	r0, [pc, #252]	; (8002230 <encode_ssdv+0x9d0>)
 8002132:	f00a fc25 	bl	800c980 <log_error>
	memset(parity, 0, NROOTS * sizeof(uint8_t));
	
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
 8002136:	20ff      	movs	r0, #255	; 0xff
 8002138:	4604      	mov	r4, r0
		if(c == SSDV_EOI)
		{
			TRACE_INFO("SSDV > ssdv_enc_get_packet said EOI");
			break;
		} else if(c != SSDV_OK) {
			TRACE_ERROR("SSDV > ssdv_enc_get_packet failed: %i", c);
 800213a:	4836      	ldr	r0, [pc, #216]	; (8002214 <encode_ssdv+0x9b4>)
 800213c:	4f36      	ldr	r7, [pc, #216]	; (8002218 <encode_ssdv+0x9b8>)
 800213e:	f00a f82f 	bl	800c1a0 <chMtxLock>
 8002142:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002146:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800214a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800214c:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 800214e:	4b34      	ldr	r3, [pc, #208]	; (8002220 <encode_ssdv+0x9c0>)
 8002150:	4932      	ldr	r1, [pc, #200]	; (800221c <encode_ssdv+0x9bc>)
 8002152:	4834      	ldr	r0, [pc, #208]	; (8002224 <encode_ssdv+0x9c4>)
 8002154:	fb06 f505 	mul.w	r5, r6, r5
 8002158:	fba7 e505 	umull	lr, r5, r7, r5
 800215c:	0b6d      	lsrs	r5, r5, #13
 800215e:	fba3 e305 	umull	lr, r3, r3, r5
 8002162:	fba7 7202 	umull	r7, r2, r7, r2
 8002166:	099b      	lsrs	r3, r3, #6
 8002168:	fb06 5313 	mls	r3, r6, r3, r5
 800216c:	0b52      	lsrs	r2, r2, #13
 800216e:	f008 fa8f 	bl	800a690 <chprintf.constprop.26>
 8002172:	4a34      	ldr	r2, [pc, #208]	; (8002244 <encode_ssdv+0x9e4>)
 8002174:	492d      	ldr	r1, [pc, #180]	; (800222c <encode_ssdv+0x9cc>)
 8002176:	482b      	ldr	r0, [pc, #172]	; (8002224 <encode_ssdv+0x9c4>)
 8002178:	f008 fa8a 	bl	800a690 <chprintf.constprop.26>
 800217c:	2338      	movs	r3, #56	; 0x38
 800217e:	4a33      	ldr	r2, [pc, #204]	; (800224c <encode_ssdv+0x9ec>)
 8002180:	492c      	ldr	r1, [pc, #176]	; (8002234 <encode_ssdv+0x9d4>)
 8002182:	4828      	ldr	r0, [pc, #160]	; (8002224 <encode_ssdv+0x9c4>)
 8002184:	f008 fa84 	bl	800a690 <chprintf.constprop.26>
 8002188:	492b      	ldr	r1, [pc, #172]	; (8002238 <encode_ssdv+0x9d8>)
 800218a:	4826      	ldr	r0, [pc, #152]	; (8002224 <encode_ssdv+0x9c4>)
 800218c:	f008 fa80 	bl	800a690 <chprintf.constprop.26>
 8002190:	4622      	mov	r2, r4
 8002192:	492f      	ldr	r1, [pc, #188]	; (8002250 <encode_ssdv+0x9f0>)
 8002194:	4823      	ldr	r0, [pc, #140]	; (8002224 <encode_ssdv+0x9c4>)
 8002196:	f008 fa7b 	bl	800a690 <chprintf.constprop.26>
 800219a:	4929      	ldr	r1, [pc, #164]	; (8002240 <encode_ssdv+0x9e0>)
 800219c:	4821      	ldr	r0, [pc, #132]	; (8002224 <encode_ssdv+0x9c4>)
 800219e:	f008 fa77 	bl	800a690 <chprintf.constprop.26>
 80021a2:	481c      	ldr	r0, [pc, #112]	; (8002214 <encode_ssdv+0x9b4>)
 80021a4:	f007 f9ec 	bl	8009580 <chMtxUnlock>
 80021a8:	2138      	movs	r1, #56	; 0x38
 80021aa:	4828      	ldr	r0, [pc, #160]	; (800224c <encode_ssdv+0x9ec>)
 80021ac:	f00a fbe8 	bl	800c980 <log_error>

		i++;
	}

	TRACE_INFO("SSDV > %i packets", i);
}
 80021b0:	f60d 1d8c 	addw	sp, sp, #2444	; 0x98c
 80021b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		s->state = S_HUFF;
		
		return(SSDV_OK);
	
	case J_DHT:
		s->stbl_len += l;
 80021b8:	f8bb 22cc 	ldrh.w	r2, [fp, #716]	; 0x2cc
 80021bc:	441a      	add	r2, r3
 80021be:	f8ab 22cc 	strh.w	r2, [fp, #716]	; 0x2cc
		while(l > 0)
 80021c2:	2b00      	cmp	r3, #0
 80021c4:	f43f af06 	beq.w	8001fd4 <encode_ssdv+0x774>
		{
			int i, j;
			
			switch(d[0])
 80021c8:	7823      	ldrb	r3, [r4, #0]
 80021ca:	2b11      	cmp	r3, #17
 80021cc:	d80c      	bhi.n	80021e8 <encode_ssdv+0x988>
 80021ce:	e8df f003 	tbb	[pc, r3]
 80021d2:	1b1e      	.short	0x1b1e
 80021d4:	0b0b0b0b 	.word	0x0b0b0b0b
 80021d8:	0b0b0b0b 	.word	0x0b0b0b0b
 80021dc:	0b0b0b0b 	.word	0x0b0b0b0b
 80021e0:	09180b0b 	.word	0x09180b0b
			{
			case 0x00: s->sdht[0][0] = d; break;
			case 0x01: s->sdht[0][1] = d; break;
			case 0x10: s->sdht[1][0] = d; break;
			case 0x11: s->sdht[1][1] = d; break;
 80021e4:	f8cb 42c0 	str.w	r4, [fp, #704]	; 0x2c0
 80021e8:	4623      	mov	r3, r4
 80021ea:	f104 0010 	add.w	r0, r4, #16
			}
			
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
 80021ee:	2211      	movs	r2, #17
				j += d[i];
 80021f0:	f813 1f01 	ldrb.w	r1, [r3, #1]!
			case 0x10: s->sdht[1][0] = d; break;
			case 0x11: s->sdht[1][1] = d; break;
			}
			
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
 80021f4:	4283      	cmp	r3, r0
				j += d[i];
 80021f6:	440a      	add	r2, r1
			case 0x10: s->sdht[1][0] = d; break;
			case 0x11: s->sdht[1][1] = d; break;
			}
			
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
 80021f8:	d1fa      	bne.n	80021f0 <encode_ssdv+0x990>
		
		return(SSDV_OK);
	
	case J_DHT:
		s->stbl_len += l;
		while(l > 0)
 80021fa:	1aad      	subs	r5, r5, r2
			/* Skip to the next DHT table */
			for(j = 17, i = 1; i <= 16; i++)
				j += d[i];
			
			l -= j;
			d += j;
 80021fc:	4414      	add	r4, r2
		
		return(SSDV_OK);
	
	case J_DHT:
		s->stbl_len += l;
		while(l > 0)
 80021fe:	d1e3      	bne.n	80021c8 <encode_ssdv+0x968>
 8002200:	e6e8      	b.n	8001fd4 <encode_ssdv+0x774>
			
			switch(d[0])
			{
			case 0x00: s->sdht[0][0] = d; break;
			case 0x01: s->sdht[0][1] = d; break;
			case 0x10: s->sdht[1][0] = d; break;
 8002202:	f8cb 42bc 	str.w	r4, [fp, #700]	; 0x2bc
 8002206:	e7ef      	b.n	80021e8 <encode_ssdv+0x988>
			int i, j;
			
			switch(d[0])
			{
			case 0x00: s->sdht[0][0] = d; break;
			case 0x01: s->sdht[0][1] = d; break;
 8002208:	f8cb 42b8 	str.w	r4, [fp, #696]	; 0x2b8
 800220c:	e7ec      	b.n	80021e8 <encode_ssdv+0x988>
		{
			int i, j;
			
			switch(d[0])
			{
			case 0x00: s->sdht[0][0] = d; break;
 800220e:	f8cb 42b4 	str.w	r4, [fp, #692]	; 0x2b4
 8002212:	e7e9      	b.n	80021e8 <encode_ssdv+0x988>
 8002214:	2001b720 	.word	0x2001b720
 8002218:	d1b71759 	.word	0xd1b71759
 800221c:	0800ea50 	.word	0x0800ea50
 8002220:	10624dd3 	.word	0x10624dd3
 8002224:	2001ac28 	.word	0x2001ac28
 8002228:	0800f1dc 	.word	0x0800f1dc
 800222c:	0800ea64 	.word	0x0800ea64
 8002230:	0800eabb 	.word	0x0800eabb
 8002234:	0800ea7c 	.word	0x0800ea7c
 8002238:	0800f1e0 	.word	0x0800f1e0
 800223c:	0800eaf8 	.word	0x0800eaf8
 8002240:	0800eaa8 	.word	0x0800eaa8
 8002244:	0800ea5c 	.word	0x0800ea5c
 8002248:	0800eb3c 	.word	0x0800eb3c
 800224c:	0800ea74 	.word	0x0800ea74
 8002250:	0800edac 	.word	0x0800edac
	int i;
	
	switch(s->marker)
	{
	case J_SOF0:
		s->width  = (d[3] << 8) | d[4];
 8002254:	78e2      	ldrb	r2, [r4, #3]
 8002256:	7923      	ldrb	r3, [r4, #4]
		s->height = (d[1] << 8) | d[2];
		
		/* Display information about the image... */
		TRACE_INFO("SSDV > Precision: %i", d[0]);
 8002258:	48b7      	ldr	r0, [pc, #732]	; (8002538 <encode_ssdv+0xcd8>)
 800225a:	f8df 8318 	ldr.w	r8, [pc, #792]	; 8002574 <encode_ssdv+0xd14>
 800225e:	f8df 92e0 	ldr.w	r9, [pc, #736]	; 8002540 <encode_ssdv+0xce0>
	int i;
	
	switch(s->marker)
	{
	case J_SOF0:
		s->width  = (d[3] << 8) | d[4];
 8002262:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002266:	f8ab 3006 	strh.w	r3, [fp, #6]
		s->height = (d[1] << 8) | d[2];
 800226a:	7862      	ldrb	r2, [r4, #1]
 800226c:	78a3      	ldrb	r3, [r4, #2]
 800226e:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8002272:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002276:	f8ab 3008 	strh.w	r3, [fp, #8]
		
		/* Display information about the image... */
		TRACE_INFO("SSDV > Precision: %i", d[0]);
 800227a:	f009 ff91 	bl	800c1a0 <chMtxLock>
 800227e:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8002280:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002282:	49ae      	ldr	r1, [pc, #696]	; (800253c <encode_ssdv+0xcdc>)
 8002284:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8002288:	4640      	mov	r0, r8
 800228a:	fb07 f303 	mul.w	r3, r7, r3
 800228e:	fba0 0303 	umull	r0, r3, r0, r3
 8002292:	48ab      	ldr	r0, [pc, #684]	; (8002540 <encode_ssdv+0xce0>)
 8002294:	0b5b      	lsrs	r3, r3, #13
 8002296:	fba0 0e03 	umull	r0, lr, r0, r3
 800229a:	4640      	mov	r0, r8
 800229c:	fba0 0202 	umull	r0, r2, r0, r2
 80022a0:	ea4f 109e 	mov.w	r0, lr, lsr #6
 80022a4:	fb07 3310 	mls	r3, r7, r0, r3
 80022a8:	0b52      	lsrs	r2, r2, #13
 80022aa:	48a6      	ldr	r0, [pc, #664]	; (8002544 <encode_ssdv+0xce4>)
 80022ac:	f008 f9f0 	bl	800a690 <chprintf.constprop.26>
 80022b0:	4aa5      	ldr	r2, [pc, #660]	; (8002548 <encode_ssdv+0xce8>)
 80022b2:	49a6      	ldr	r1, [pc, #664]	; (800254c <encode_ssdv+0xcec>)
 80022b4:	48a3      	ldr	r0, [pc, #652]	; (8002544 <encode_ssdv+0xce4>)
 80022b6:	f008 f9eb 	bl	800a690 <chprintf.constprop.26>
 80022ba:	f240 238f 	movw	r3, #655	; 0x28f
 80022be:	4aa4      	ldr	r2, [pc, #656]	; (8002550 <encode_ssdv+0xcf0>)
 80022c0:	49a4      	ldr	r1, [pc, #656]	; (8002554 <encode_ssdv+0xcf4>)
 80022c2:	48a0      	ldr	r0, [pc, #640]	; (8002544 <encode_ssdv+0xce4>)
 80022c4:	f008 f9e4 	bl	800a690 <chprintf.constprop.26>
 80022c8:	49a3      	ldr	r1, [pc, #652]	; (8002558 <encode_ssdv+0xcf8>)
 80022ca:	489e      	ldr	r0, [pc, #632]	; (8002544 <encode_ssdv+0xce4>)
 80022cc:	f008 f9e0 	bl	800a690 <chprintf.constprop.26>
 80022d0:	7822      	ldrb	r2, [r4, #0]
 80022d2:	49a2      	ldr	r1, [pc, #648]	; (800255c <encode_ssdv+0xcfc>)
 80022d4:	489b      	ldr	r0, [pc, #620]	; (8002544 <encode_ssdv+0xce4>)
 80022d6:	f008 f9db 	bl	800a690 <chprintf.constprop.26>
 80022da:	49a1      	ldr	r1, [pc, #644]	; (8002560 <encode_ssdv+0xd00>)
 80022dc:	4899      	ldr	r0, [pc, #612]	; (8002544 <encode_ssdv+0xce4>)
 80022de:	f008 f9d7 	bl	800a690 <chprintf.constprop.26>
 80022e2:	4895      	ldr	r0, [pc, #596]	; (8002538 <encode_ssdv+0xcd8>)
 80022e4:	f007 f94c 	bl	8009580 <chMtxUnlock>
		TRACE_INFO("SSDV > Resolution: %ix%i", s->width, s->height);
 80022e8:	4893      	ldr	r0, [pc, #588]	; (8002538 <encode_ssdv+0xcd8>)
 80022ea:	f009 ff59 	bl	800c1a0 <chMtxLock>
 80022ee:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80022f0:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80022f2:	4992      	ldr	r1, [pc, #584]	; (800253c <encode_ssdv+0xcdc>)
 80022f4:	4640      	mov	r0, r8
 80022f6:	fb07 f303 	mul.w	r3, r7, r3
 80022fa:	fba0 0303 	umull	r0, r3, r0, r3
 80022fe:	4890      	ldr	r0, [pc, #576]	; (8002540 <encode_ssdv+0xce0>)
 8002300:	0b5b      	lsrs	r3, r3, #13
 8002302:	fba0 0e03 	umull	r0, lr, r0, r3
 8002306:	4640      	mov	r0, r8
 8002308:	fba0 0202 	umull	r0, r2, r0, r2
 800230c:	ea4f 109e 	mov.w	r0, lr, lsr #6
 8002310:	fb07 3310 	mls	r3, r7, r0, r3
 8002314:	0b52      	lsrs	r2, r2, #13
 8002316:	488b      	ldr	r0, [pc, #556]	; (8002544 <encode_ssdv+0xce4>)
 8002318:	f008 f9ba 	bl	800a690 <chprintf.constprop.26>
 800231c:	4a8a      	ldr	r2, [pc, #552]	; (8002548 <encode_ssdv+0xce8>)
 800231e:	498b      	ldr	r1, [pc, #556]	; (800254c <encode_ssdv+0xcec>)
 8002320:	4888      	ldr	r0, [pc, #544]	; (8002544 <encode_ssdv+0xce4>)
 8002322:	f008 f9b5 	bl	800a690 <chprintf.constprop.26>
 8002326:	f44f 7324 	mov.w	r3, #656	; 0x290
 800232a:	4a89      	ldr	r2, [pc, #548]	; (8002550 <encode_ssdv+0xcf0>)
 800232c:	4989      	ldr	r1, [pc, #548]	; (8002554 <encode_ssdv+0xcf4>)
 800232e:	4885      	ldr	r0, [pc, #532]	; (8002544 <encode_ssdv+0xce4>)
 8002330:	f008 f9ae 	bl	800a690 <chprintf.constprop.26>
 8002334:	4988      	ldr	r1, [pc, #544]	; (8002558 <encode_ssdv+0xcf8>)
 8002336:	4883      	ldr	r0, [pc, #524]	; (8002544 <encode_ssdv+0xce4>)
 8002338:	f008 f9aa 	bl	800a690 <chprintf.constprop.26>
 800233c:	f8bb 3008 	ldrh.w	r3, [fp, #8]
 8002340:	f8bb 2006 	ldrh.w	r2, [fp, #6]
 8002344:	4987      	ldr	r1, [pc, #540]	; (8002564 <encode_ssdv+0xd04>)
 8002346:	487f      	ldr	r0, [pc, #508]	; (8002544 <encode_ssdv+0xce4>)
 8002348:	f008 f9a2 	bl	800a690 <chprintf.constprop.26>
 800234c:	4984      	ldr	r1, [pc, #528]	; (8002560 <encode_ssdv+0xd00>)
 800234e:	487d      	ldr	r0, [pc, #500]	; (8002544 <encode_ssdv+0xce4>)
 8002350:	f008 f99e 	bl	800a690 <chprintf.constprop.26>
 8002354:	4878      	ldr	r0, [pc, #480]	; (8002538 <encode_ssdv+0xcd8>)
 8002356:	f007 f913 	bl	8009580 <chMtxUnlock>
		TRACE_INFO("SSDV > Components: %i", d[5]);
 800235a:	4877      	ldr	r0, [pc, #476]	; (8002538 <encode_ssdv+0xcd8>)
 800235c:	f009 ff20 	bl	800c1a0 <chMtxLock>
 8002360:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8002362:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002364:	4975      	ldr	r1, [pc, #468]	; (800253c <encode_ssdv+0xcdc>)
 8002366:	4640      	mov	r0, r8
 8002368:	fb07 f303 	mul.w	r3, r7, r3
 800236c:	fba0 0303 	umull	r0, r3, r0, r3
 8002370:	4873      	ldr	r0, [pc, #460]	; (8002540 <encode_ssdv+0xce0>)
 8002372:	0b5b      	lsrs	r3, r3, #13
 8002374:	fba0 0e03 	umull	r0, lr, r0, r3
 8002378:	4640      	mov	r0, r8
 800237a:	fba0 0202 	umull	r0, r2, r0, r2
 800237e:	ea4f 109e 	mov.w	r0, lr, lsr #6
 8002382:	fb07 3310 	mls	r3, r7, r0, r3
 8002386:	0b52      	lsrs	r2, r2, #13
 8002388:	486e      	ldr	r0, [pc, #440]	; (8002544 <encode_ssdv+0xce4>)
 800238a:	f008 f981 	bl	800a690 <chprintf.constprop.26>
 800238e:	4a6e      	ldr	r2, [pc, #440]	; (8002548 <encode_ssdv+0xce8>)
 8002390:	496e      	ldr	r1, [pc, #440]	; (800254c <encode_ssdv+0xcec>)
 8002392:	486c      	ldr	r0, [pc, #432]	; (8002544 <encode_ssdv+0xce4>)
 8002394:	f008 f97c 	bl	800a690 <chprintf.constprop.26>
 8002398:	f240 2391 	movw	r3, #657	; 0x291
 800239c:	4a6c      	ldr	r2, [pc, #432]	; (8002550 <encode_ssdv+0xcf0>)
 800239e:	496d      	ldr	r1, [pc, #436]	; (8002554 <encode_ssdv+0xcf4>)
 80023a0:	4868      	ldr	r0, [pc, #416]	; (8002544 <encode_ssdv+0xce4>)
 80023a2:	f008 f975 	bl	800a690 <chprintf.constprop.26>
 80023a6:	496c      	ldr	r1, [pc, #432]	; (8002558 <encode_ssdv+0xcf8>)
 80023a8:	4866      	ldr	r0, [pc, #408]	; (8002544 <encode_ssdv+0xce4>)
 80023aa:	f008 f971 	bl	800a690 <chprintf.constprop.26>
 80023ae:	7962      	ldrb	r2, [r4, #5]
 80023b0:	496d      	ldr	r1, [pc, #436]	; (8002568 <encode_ssdv+0xd08>)
 80023b2:	4864      	ldr	r0, [pc, #400]	; (8002544 <encode_ssdv+0xce4>)
 80023b4:	f008 f96c 	bl	800a690 <chprintf.constprop.26>
 80023b8:	4969      	ldr	r1, [pc, #420]	; (8002560 <encode_ssdv+0xd00>)
 80023ba:	4862      	ldr	r0, [pc, #392]	; (8002544 <encode_ssdv+0xce4>)
 80023bc:	f008 f968 	bl	800a690 <chprintf.constprop.26>
 80023c0:	485d      	ldr	r0, [pc, #372]	; (8002538 <encode_ssdv+0xcd8>)
 80023c2:	f007 f8dd 	bl	8009580 <chMtxUnlock>
		
		/* The image must have a precision of 8 */
		if(d[0] != 8)
 80023c6:	7823      	ldrb	r3, [r4, #0]
 80023c8:	2b08      	cmp	r3, #8
 80023ca:	f000 86d3 	beq.w	8003174 <encode_ssdv+0x1914>
		{
			TRACE_ERROR("SSDV > The image must have a precision of 8");
 80023ce:	485a      	ldr	r0, [pc, #360]	; (8002538 <encode_ssdv+0xcd8>)
 80023d0:	f009 fee6 	bl	800c1a0 <chMtxLock>
 80023d4:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80023d6:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80023d8:	4958      	ldr	r1, [pc, #352]	; (800253c <encode_ssdv+0xcdc>)
 80023da:	485a      	ldr	r0, [pc, #360]	; (8002544 <encode_ssdv+0xce4>)
 80023dc:	fb07 f303 	mul.w	r3, r7, r3
 80023e0:	fba8 4303 	umull	r4, r3, r8, r3
 80023e4:	0b5b      	lsrs	r3, r3, #13
 80023e6:	fba9 5403 	umull	r5, r4, r9, r3
 80023ea:	09a4      	lsrs	r4, r4, #6
 80023ec:	fba8 5202 	umull	r5, r2, r8, r2
 80023f0:	fb07 3314 	mls	r3, r7, r4, r3
 80023f4:	0b52      	lsrs	r2, r2, #13
 80023f6:	f008 f94b 	bl	800a690 <chprintf.constprop.26>
 80023fa:	4a5c      	ldr	r2, [pc, #368]	; (800256c <encode_ssdv+0xd0c>)
 80023fc:	4953      	ldr	r1, [pc, #332]	; (800254c <encode_ssdv+0xcec>)
 80023fe:	4851      	ldr	r0, [pc, #324]	; (8002544 <encode_ssdv+0xce4>)
 8002400:	f008 f946 	bl	800a690 <chprintf.constprop.26>
 8002404:	f240 2396 	movw	r3, #662	; 0x296
 8002408:	4a51      	ldr	r2, [pc, #324]	; (8002550 <encode_ssdv+0xcf0>)
 800240a:	4952      	ldr	r1, [pc, #328]	; (8002554 <encode_ssdv+0xcf4>)
 800240c:	484d      	ldr	r0, [pc, #308]	; (8002544 <encode_ssdv+0xce4>)
 800240e:	f008 f93f 	bl	800a690 <chprintf.constprop.26>
 8002412:	4951      	ldr	r1, [pc, #324]	; (8002558 <encode_ssdv+0xcf8>)
 8002414:	484b      	ldr	r0, [pc, #300]	; (8002544 <encode_ssdv+0xce4>)
 8002416:	f008 f93b 	bl	800a690 <chprintf.constprop.26>
 800241a:	4955      	ldr	r1, [pc, #340]	; (8002570 <encode_ssdv+0xd10>)
 800241c:	4849      	ldr	r0, [pc, #292]	; (8002544 <encode_ssdv+0xce4>)
 800241e:	f008 f937 	bl	800a690 <chprintf.constprop.26>
 8002422:	494f      	ldr	r1, [pc, #316]	; (8002560 <encode_ssdv+0xd00>)
 8002424:	4847      	ldr	r0, [pc, #284]	; (8002544 <encode_ssdv+0xce4>)
 8002426:	f008 f933 	bl	800a690 <chprintf.constprop.26>
 800242a:	4843      	ldr	r0, [pc, #268]	; (8002538 <encode_ssdv+0xcd8>)
 800242c:	f007 f8a8 	bl	8009580 <chMtxUnlock>
 8002430:	f240 2196 	movw	r1, #662	; 0x296
 8002434:	4846      	ldr	r0, [pc, #280]	; (8002550 <encode_ssdv+0xcf0>)
 8002436:	f00a faa3 	bl	800c980 <log_error>
 800243a:	e67c      	b.n	8002136 <encode_ssdv+0x8d6>
 800243c:	f89b 2049 	ldrb.w	r2, [fp, #73]	; 0x49
	return(SSDV_OK);
}

static char ssdv_process(ssdv_t *s)
{
	if(s->state == S_HUFF)
 8002440:	2a03      	cmp	r2, #3
 8002442:	f47f ab10 	bne.w	8001a66 <encode_ssdv+0x206>
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
 8002446:	f89b 4059 	ldrb.w	r4, [fp, #89]	; 0x59
 800244a:	f89b a056 	ldrb.w	sl, [fp, #86]	; 0x56
 800244e:	f89b e030 	ldrb.w	lr, [fp, #48]	; 0x30
		if(cw > s->worklen) return(SSDV_FEED_ME);
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
		{
			if(s->workbits >> (s->worklen - cw) == code)
 8002452:	f8db 802c 	ldr.w	r8, [fp, #44]	; 0x2c
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
 8002456:	1c22      	adds	r2, r4, #0
 8002458:	bf18      	it	ne
 800245a:	2201      	movne	r2, #1
 800245c:	0052      	lsls	r2, r2, #1
 800245e:	f1ba 0f00 	cmp.w	sl, #0
 8002462:	bf18      	it	ne
 8002464:	3201      	addne	r2, #1
 8002466:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
	return(callsign);
}

static inline char jpeg_dht_lookup(ssdv_t *s, uint8_t *symbol, uint8_t *width)
{
	uint16_t code = 0;
 800246a:	2300      	movs	r3, #0
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
 800246c:	f8d2 92b4 	ldr.w	r9, [r2, #692]	; 0x2b4
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 8002470:	2701      	movs	r7, #1
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
 8002472:	f109 0211 	add.w	r2, r9, #17
 8002476:	46cc      	mov	ip, r9
	
	for(cw = 1; cw <= 16; cw++)
	{
		/* Got enough bits? */
		if(cw > s->worklen) return(SSDV_FEED_ME);
 8002478:	4577      	cmp	r7, lr
 800247a:	f63f aaad 	bhi.w	80019d8 <encode_ssdv+0x178>
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
 800247e:	f81c 1f01 	ldrb.w	r1, [ip, #1]!
 8002482:	b1a1      	cbz	r1, 80024ae <encode_ssdv+0xc4e>
		{
			if(s->workbits >> (s->worklen - cw) == code)
 8002484:	ebcc 000e 	rsb	r0, ip, lr
 8002488:	4448      	add	r0, r9
 800248a:	fa28 f000 	lsr.w	r0, r8, r0
 800248e:	4283      	cmp	r3, r0
 8002490:	f000 811f 	beq.w	80026d2 <encode_ssdv+0xe72>
 8002494:	3901      	subs	r1, #1
 8002496:	b2c9      	uxtb	r1, r1
 8002498:	3101      	adds	r1, #1
 800249a:	4411      	add	r1, r2
 800249c:	e002      	b.n	80024a4 <encode_ssdv+0xc44>
 800249e:	4283      	cmp	r3, r0
 80024a0:	f000 8117 	beq.w	80026d2 <encode_ssdv+0xe72>
				/* Found a match */
				*symbol = *ss;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 80024a4:	3201      	adds	r2, #1
 80024a6:	3301      	adds	r3, #1
	{
		/* Got enough bits? */
		if(cw > s->worklen) return(SSDV_FEED_ME);
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
 80024a8:	428a      	cmp	r2, r1
				/* Found a match */
				*symbol = *ss;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 80024aa:	b29b      	uxth	r3, r3
	{
		/* Got enough bits? */
		if(cw > s->worklen) return(SSDV_FEED_ME);
		
		/* Compare against each code 'cw' bits wide */
		for(n = dht[cw]; n > 0; n--)
 80024ac:	d1f7      	bne.n	800249e <encode_ssdv+0xc3e>
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 80024ae:	3701      	adds	r7, #1
 80024b0:	b2ff      	uxtb	r7, r7
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 80024b2:	005b      	lsls	r3, r3, #1
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 80024b4:	2f11      	cmp	r7, #17
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 80024b6:	b29b      	uxth	r3, r3
	
	/* Select the appropriate huffman table */
	dht = SDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 80024b8:	d1de      	bne.n	8002478 <encode_ssdv+0xc18>
				return(SSDV_OK);
			}
			else if(r != SSDV_FEED_ME)
			{
				/* An error occured */
				TRACE_ERROR("SSDV > ssdv_process() failed: %i", r);
 80024ba:	481f      	ldr	r0, [pc, #124]	; (8002538 <encode_ssdv+0xcd8>)
 80024bc:	4e2d      	ldr	r6, [pc, #180]	; (8002574 <encode_ssdv+0xd14>)
 80024be:	f009 fe6f 	bl	800c1a0 <chMtxLock>
 80024c2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80024c6:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 80024ca:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80024cc:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80024ce:	4b1c      	ldr	r3, [pc, #112]	; (8002540 <encode_ssdv+0xce0>)
 80024d0:	491a      	ldr	r1, [pc, #104]	; (800253c <encode_ssdv+0xcdc>)
 80024d2:	481c      	ldr	r0, [pc, #112]	; (8002544 <encode_ssdv+0xce4>)
 80024d4:	fb05 f404 	mul.w	r4, r5, r4
 80024d8:	fba6 7404 	umull	r7, r4, r6, r4
 80024dc:	0b64      	lsrs	r4, r4, #13
 80024de:	fba3 7304 	umull	r7, r3, r3, r4
 80024e2:	fba6 6202 	umull	r6, r2, r6, r2
 80024e6:	099b      	lsrs	r3, r3, #6
 80024e8:	fb05 4313 	mls	r3, r5, r3, r4
 80024ec:	0b52      	lsrs	r2, r2, #13
 80024ee:	f008 f8cf 	bl	800a690 <chprintf.constprop.26>
 80024f2:	4a1e      	ldr	r2, [pc, #120]	; (800256c <encode_ssdv+0xd0c>)
 80024f4:	4915      	ldr	r1, [pc, #84]	; (800254c <encode_ssdv+0xcec>)
 80024f6:	4813      	ldr	r0, [pc, #76]	; (8002544 <encode_ssdv+0xce4>)
 80024f8:	f008 f8ca 	bl	800a690 <chprintf.constprop.26>
 80024fc:	f44f 737c 	mov.w	r3, #1008	; 0x3f0
 8002500:	4a13      	ldr	r2, [pc, #76]	; (8002550 <encode_ssdv+0xcf0>)
 8002502:	4914      	ldr	r1, [pc, #80]	; (8002554 <encode_ssdv+0xcf4>)
 8002504:	480f      	ldr	r0, [pc, #60]	; (8002544 <encode_ssdv+0xce4>)
 8002506:	f008 f8c3 	bl	800a690 <chprintf.constprop.26>
 800250a:	4913      	ldr	r1, [pc, #76]	; (8002558 <encode_ssdv+0xcf8>)
 800250c:	480d      	ldr	r0, [pc, #52]	; (8002544 <encode_ssdv+0xce4>)
 800250e:	f008 f8bf 	bl	800a690 <chprintf.constprop.26>
 8002512:	22ff      	movs	r2, #255	; 0xff
 8002514:	4918      	ldr	r1, [pc, #96]	; (8002578 <encode_ssdv+0xd18>)
 8002516:	480b      	ldr	r0, [pc, #44]	; (8002544 <encode_ssdv+0xce4>)
 8002518:	f008 f8ba 	bl	800a690 <chprintf.constprop.26>
 800251c:	4910      	ldr	r1, [pc, #64]	; (8002560 <encode_ssdv+0xd00>)
 800251e:	4809      	ldr	r0, [pc, #36]	; (8002544 <encode_ssdv+0xce4>)
 8002520:	f008 f8b6 	bl	800a690 <chprintf.constprop.26>
 8002524:	4804      	ldr	r0, [pc, #16]	; (8002538 <encode_ssdv+0xcd8>)
 8002526:	f007 f82b 	bl	8009580 <chMtxUnlock>
 800252a:	f44f 717c 	mov.w	r1, #1008	; 0x3f0
 800252e:	4808      	ldr	r0, [pc, #32]	; (8002550 <encode_ssdv+0xcf0>)
 8002530:	f00a fa26 	bl	800c980 <log_error>
 8002534:	e5ff      	b.n	8002136 <encode_ssdv+0x8d6>
 8002536:	bf00      	nop
 8002538:	2001b720 	.word	0x2001b720
 800253c:	0800ea50 	.word	0x0800ea50
 8002540:	10624dd3 	.word	0x10624dd3
 8002544:	2001ac28 	.word	0x2001ac28
 8002548:	0800f1dc 	.word	0x0800f1dc
 800254c:	0800ea64 	.word	0x0800ea64
 8002550:	0800eabb 	.word	0x0800eabb
 8002554:	0800ea7c 	.word	0x0800ea7c
 8002558:	0800f1e0 	.word	0x0800f1e0
 800255c:	0800eac4 	.word	0x0800eac4
 8002560:	0800eaa8 	.word	0x0800eaa8
 8002564:	0800eadc 	.word	0x0800eadc
 8002568:	0800eaf8 	.word	0x0800eaf8
 800256c:	0800ea5c 	.word	0x0800ea5c
 8002570:	0800eb10 	.word	0x0800eb10
 8002574:	d1b71759 	.word	0xd1b71759
 8002578:	0800ee50 	.word	0x0800ee50
	else if(s->state == S_INT)
	{
		int i;
		
		/* Not enough bits yet? */
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
 800257c:	f89b 2030 	ldrb.w	r2, [fp, #48]	; 0x30
 8002580:	f89b 3080 	ldrb.w	r3, [fp, #128]	; 0x80
 8002584:	429a      	cmp	r2, r3
 8002586:	f4ff aa27 	bcc.w	80019d8 <encode_ssdv+0x178>
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
 800258a:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
		
		if(s->acpart == 0) /* DC */
 800258e:	f89b 0059 	ldrb.w	r0, [fp, #89]	; 0x59
		
		/* Not enough bits yet? */
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
 8002592:	1ad2      	subs	r2, r2, r3
	return(SSDV_ERROR);
}

static inline int jpeg_int(int bits, int width)
{
	int b = (1 << width) - 1;
 8002594:	fa05 f303 	lsl.w	r3, r5, r3
		
		/* Not enough bits yet? */
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
 8002598:	fa21 f702 	lsr.w	r7, r1, r2
	return(SSDV_ERROR);
}

static inline int jpeg_int(int bits, int width)
{
	int b = (1 << width) - 1;
 800259c:	3b01      	subs	r3, #1
	if(bits <= b >> 1) bits = -(bits ^ b);
 800259e:	ebb7 0f63 	cmp.w	r7, r3, asr #1
 80025a2:	bfdc      	itt	le
 80025a4:	405f      	eorle	r7, r3
 80025a6:	427f      	negle	r7, r7
		if(s->worklen < s->needbits) return(SSDV_FEED_ME);
		
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
		
		if(s->acpart == 0) /* DC */
 80025a8:	2800      	cmp	r0, #0
 80025aa:	f040 80cc 	bne.w	8002746 <encode_ssdv+0xee6>
		{
			if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
 80025ae:	f8bb 3016 	ldrh.w	r3, [fp, #22]
 80025b2:	f8db 207c 	ldr.w	r2, [fp, #124]	; 0x7c
 80025b6:	429a      	cmp	r2, r3
 80025b8:	f000 8176 	beq.w	80028a8 <encode_ssdv+0x1048>
					s->dc[s->component] = i;
				}
			}
			else
			{
				if(s->mode == S_DECODING)
 80025bc:	f89b 3078 	ldrb.w	r3, [fp, #120]	; 0x78
 80025c0:	2b01      	cmp	r3, #1
				{
					s->dc[s->component] += UADJ(i);
 80025c2:	f89b 3056 	ldrb.w	r3, [fp, #86]	; 0x56
					s->dc[s->component] = i;
				}
			}
			else
			{
				if(s->mode == S_DECODING)
 80025c6:	f000 81c6 	beq.w	8002956 <encode_ssdv+0x10f6>
					ssdv_out_jpeg_int(s, 0, i);
				}
				else
				{
					/* Output relative DC value */
					s->dc[s->component] += UADJ(i);
 80025ca:	1c1a      	adds	r2, r3, #0
 80025cc:	bf18      	it	ne
 80025ce:	2201      	movne	r2, #1
 80025d0:	f102 01b0 	add.w	r1, r2, #176	; 0xb0
 80025d4:	eb0b 0181 	add.w	r1, fp, r1, lsl #2
 80025d8:	f502 72a0 	add.w	r2, r2, #320	; 0x140
 80025dc:	6848      	ldr	r0, [r1, #4]
 80025de:	f85b 4022 	ldr.w	r4, [fp, r2, lsl #2]
 80025e2:	7841      	ldrb	r1, [r0, #1]
 80025e4:	f894 c001 	ldrb.w	ip, [r4, #1]
 80025e8:	f103 0216 	add.w	r2, r3, #22
 80025ec:	eb0b 0e82 	add.w	lr, fp, r2, lsl #2
 80025f0:	458c      	cmp	ip, r1
 80025f2:	f8de e004 	ldr.w	lr, [lr, #4]
 80025f6:	bf18      	it	ne
 80025f8:	434f      	mulne	r7, r1
 80025fa:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
 80025fe:	4477      	add	r7, lr
 8002600:	6057      	str	r7, [r2, #4]
					
					/* Calculate closest adjusted DC value */
					i = AADJ(s->dc[s->component]);
 8002602:	7862      	ldrb	r2, [r4, #1]
 8002604:	7841      	ldrb	r1, [r0, #1]
 8002606:	4291      	cmp	r1, r2
 8002608:	d00d      	beq.n	8002626 <encode_ssdv+0xdc6>
#define BADJ(i) (SDQT == DDQT ? (i) : irdiv(i * SDQT, DDQT))

/* Integer-only division with rounding */
static int irdiv(int i, int div)
{
	i = i * 2 / div;
 800260a:	007f      	lsls	r7, r7, #1
 800260c:	fb97 f7f2 	sdiv	r7, r7, r2
	if(i & 1) i += (i > 0 ? 1 : -1);
 8002610:	07f9      	lsls	r1, r7, #31
 8002612:	d505      	bpl.n	8002620 <encode_ssdv+0xdc0>
 8002614:	2f00      	cmp	r7, #0
 8002616:	bfd4      	ite	le
 8002618:	f04f 32ff 	movle.w	r2, #4294967295
 800261c:	2201      	movgt	r2, #1
 800261e:	4417      	add	r7, r2
	return(i / 2);
 8002620:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 8002624:	107f      	asrs	r7, r7, #1
					/* Output relative DC value */
					s->dc[s->component] += UADJ(i);
					
					/* Calculate closest adjusted DC value */
					i = AADJ(s->dc[s->component]);
					ssdv_out_jpeg_int(s, 0, i - s->adc[s->component]);
 8002626:	331a      	adds	r3, #26
 8002628:	2100      	movs	r1, #0
 800262a:	f85b 2023 	ldr.w	r2, [fp, r3, lsl #2]
 800262e:	4658      	mov	r0, fp
 8002630:	1aba      	subs	r2, r7, r2
 8002632:	f00a fa8d 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
					s->adc[s->component] = i;
 8002636:	f89b 1056 	ldrb.w	r1, [fp, #86]	; 0x56
 800263a:	f89b 0059 	ldrb.w	r0, [fp, #89]	; 0x59
 800263e:	f89b 2030 	ldrb.w	r2, [fp, #48]	; 0x30
 8002642:	f89b 3080 	ldrb.w	r3, [fp, #128]	; 0x80
 8002646:	311a      	adds	r1, #26
 8002648:	1c44      	adds	r4, r0, #1
 800264a:	f84b 7021 	str.w	r7, [fp, r1, lsl #2]
 800264e:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
 8002652:	1ad2      	subs	r2, r2, r3
		
		/* Next bits are a huffman code */
		s->state = S_HUFF;
		
		/* Clear processed bits */
		s->worklen -= s->needbits;
 8002654:	b2d3      	uxtb	r3, r2
		s->workbits &= (1 << s->worklen) - 1;
 8002656:	fa05 f203 	lsl.w	r2, r5, r3
 800265a:	3a01      	subs	r2, #1
 800265c:	400a      	ands	r2, r1
				else s->accrle += s->acrle + 1;
			}
		}
		
		/* Next AC part to expect */
		s->acpart++;
 800265e:	b2e4      	uxtb	r4, r4
		
		/* Next bits are a huffman code */
		s->state = S_HUFF;
 8002660:	2103      	movs	r1, #3
		
		/* Clear processed bits */
		s->worklen -= s->needbits;
 8002662:	f88b 3030 	strb.w	r3, [fp, #48]	; 0x30
		s->workbits &= (1 << s->worklen) - 1;
 8002666:	f8cb 202c 	str.w	r2, [fp, #44]	; 0x2c
				else s->accrle += s->acrle + 1;
			}
		}
		
		/* Next AC part to expect */
		s->acpart++;
 800266a:	f88b 4059 	strb.w	r4, [fp, #89]	; 0x59
		
		/* Next bits are a huffman code */
		s->state = S_HUFF;
 800266e:	f88b 1049 	strb.w	r1, [fp, #73]	; 0x49
 8002672:	f7ff b9fd 	b.w	8001a70 <encode_ssdv+0x210>
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
			s->mcu_id++;
 8002676:	f8bb 3016 	ldrh.w	r3, [fp, #22]
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
 800267a:	f8bb 2018 	ldrh.w	r2, [fp, #24]
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
			s->mcu_id++;
 800267e:	3301      	adds	r3, #1
 8002680:	b29b      	uxth	r3, r3
	if(s->acpart >= 64)
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
 8002682:	2100      	movs	r1, #0
			s->mcu_id++;
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
 8002684:	429a      	cmp	r2, r3
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
			s->mcu_id++;
 8002686:	f8ab 3016 	strh.w	r3, [fp, #22]
	if(s->acpart >= 64)
	{
		/* Reached the end of this MCU part */
		if(++s->mcupart == s->ycparts + 2)
		{
			s->mcupart = 0;
 800268a:	f88b 1058 	strb.w	r1, [fp, #88]	; 0x58
			s->mcu_id++;
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
 800268e:	f240 80ac 	bls.w	80027ea <encode_ssdv+0xf8a>
				ssdv_outbits_sync(s);
				return(SSDV_EOI);
			}
			
			/* Set the packet MCU marker - encoder only */
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
 8002692:	f89b 2078 	ldrb.w	r2, [fp, #120]	; 0x78
 8002696:	2a00      	cmp	r2, #0
 8002698:	f040 80f2 	bne.w	8002880 <encode_ssdv+0x1020>
 800269c:	f8bb 201a 	ldrh.w	r2, [fp, #26]
 80026a0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80026a4:	429a      	cmp	r2, r3
 80026a6:	f000 81b0 	beq.w	8002a0a <encode_ssdv+0x11aa>
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
				s->workbits = s->worklen = 0;
			
			/* Test for a reset marker */
			if(s->dri > 0 && s->mcu_id > 0 && s->mcu_id % s->dri == 0)
 80026aa:	f8bb 3076 	ldrh.w	r3, [fp, #118]	; 0x76
 80026ae:	b153      	cbz	r3, 80026c6 <encode_ssdv+0xe66>
 80026b0:	f8bb 1016 	ldrh.w	r1, [fp, #22]
 80026b4:	b139      	cbz	r1, 80026c6 <encode_ssdv+0xe66>
 80026b6:	fbb1 f2f3 	udiv	r2, r1, r3
 80026ba:	fb03 1312 	mls	r3, r3, r2, r1
 80026be:	b29b      	uxth	r3, r3
 80026c0:	2b00      	cmp	r3, #0
 80026c2:	f43f ac88 	beq.w	8001fd6 <encode_ssdv+0x776>
 80026c6:	f89b 3058 	ldrb.w	r3, [fp, #88]	; 0x58
 80026ca:	f89b 2057 	ldrb.w	r2, [fp, #87]	; 0x57
 80026ce:	f7ff b9dd 	b.w	8001a8c <encode_ssdv+0x22c>
		for(n = dht[cw]; n > 0; n--)
		{
			if(s->workbits >> (s->worklen - cw) == code)
			{
				/* Found a match */
				*symbol = *ss;
 80026d2:	7812      	ldrb	r2, [r2, #0]
		
		/* Lookup the code, return if error or not enough bits yet */
		if((r = jpeg_dht_lookup(s, &symbol, &width)) != SSDV_OK)
			return(r);
		
		if(s->acpart == 0) /* DC */
 80026d4:	2c00      	cmp	r4, #0
 80026d6:	f040 80af 	bne.w	8002838 <encode_ssdv+0xfd8>
		{
			if(symbol == 0x00)
 80026da:	2a00      	cmp	r2, #0
 80026dc:	f040 80de 	bne.w	800289c <encode_ssdv+0x103c>
			{
				/* No change in DC from last block */
				if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
 80026e0:	f8bb 3016 	ldrh.w	r3, [fp, #22]
 80026e4:	f8db 207c 	ldr.w	r2, [fp, #124]	; 0x7c
 80026e8:	429a      	cmp	r2, r3
 80026ea:	f040 8152 	bne.w	8002992 <encode_ssdv+0x1132>
 80026ee:	f89b 3058 	ldrb.w	r3, [fp, #88]	; 0x58
 80026f2:	b123      	cbz	r3, 80026fe <encode_ssdv+0xe9e>
 80026f4:	f89b 2057 	ldrb.w	r2, [fp, #87]	; 0x57
 80026f8:	429a      	cmp	r2, r3
 80026fa:	f200 814a 	bhi.w	8002992 <encode_ssdv+0x1132>
				{
					if(s->mode == S_ENCODING) ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
 80026fe:	f89b 1078 	ldrb.w	r1, [fp, #120]	; 0x78
 8002702:	2900      	cmp	r1, #0
 8002704:	f040 81c6 	bne.w	8002a94 <encode_ssdv+0x1234>
 8002708:	f10a 0a1a 	add.w	sl, sl, #26
 800270c:	4658      	mov	r0, fp
 800270e:	f85b 202a 	ldr.w	r2, [fp, sl, lsl #2]
 8002712:	f00a fa1d 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
					}
				}
				else ssdv_out_jpeg_int(s, 0, 0);
				
				/* skip to the next AC part immediately */
				s->acpart++;
 8002716:	f89b 4059 	ldrb.w	r4, [fp, #89]	; 0x59
 800271a:	f89b e030 	ldrb.w	lr, [fp, #48]	; 0x30
 800271e:	f8db 802c 	ldr.w	r8, [fp, #44]	; 0x2c
 8002722:	3401      	adds	r4, #1
 8002724:	b2e4      	uxtb	r4, r4
 8002726:	f88b 4059 	strb.w	r4, [fp, #89]	; 0x59
				s->needbits = symbol & 0x0F;
			}
		}
		
		/* Clear processed bits */
		s->worklen -= width;
 800272a:	ebc7 070e 	rsb	r7, r7, lr
 800272e:	b2ff      	uxtb	r7, r7
		s->workbits &= (1 << s->worklen) - 1;
 8002730:	fa05 f307 	lsl.w	r3, r5, r7
 8002734:	3b01      	subs	r3, #1
 8002736:	ea03 0308 	and.w	r3, r3, r8
				s->needbits = symbol & 0x0F;
			}
		}
		
		/* Clear processed bits */
		s->worklen -= width;
 800273a:	f88b 7030 	strb.w	r7, [fp, #48]	; 0x30
		s->workbits &= (1 << s->worklen) - 1;
 800273e:	f8cb 302c 	str.w	r3, [fp, #44]	; 0x2c
 8002742:	f7ff b995 	b.w	8001a70 <encode_ssdv+0x210>
				}
			}
		}
		else /* AC */
		{
			if((i = BADJ(i)))
 8002746:	f89b 3056 	ldrb.w	r3, [fp, #86]	; 0x56
 800274a:	3300      	adds	r3, #0
 800274c:	bf18      	it	ne
 800274e:	2301      	movne	r3, #1
 8002750:	f103 04b0 	add.w	r4, r3, #176	; 0xb0
 8002754:	eb0b 0484 	add.w	r4, fp, r4, lsl #2
 8002758:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800275c:	f8d4 c004 	ldr.w	ip, [r4, #4]
 8002760:	f85b e023 	ldr.w	lr, [fp, r3, lsl #2]
 8002764:	1c44      	adds	r4, r0, #1
 8002766:	f81c 3004 	ldrb.w	r3, [ip, r4]
 800276a:	f81e e004 	ldrb.w	lr, [lr, r4]
 800276e:	4573      	cmp	r3, lr
 8002770:	d010      	beq.n	8002794 <encode_ssdv+0xf34>
#define BADJ(i) (SDQT == DDQT ? (i) : irdiv(i * SDQT, DDQT))

/* Integer-only division with rounding */
static int irdiv(int i, int div)
{
	i = i * 2 / div;
 8002772:	fb07 f303 	mul.w	r3, r7, r3
 8002776:	005b      	lsls	r3, r3, #1
 8002778:	fb93 f7fe 	sdiv	r7, r3, lr
	if(i & 1) i += (i > 0 ? 1 : -1);
 800277c:	f017 0f01 	tst.w	r7, #1
 8002780:	d005      	beq.n	800278e <encode_ssdv+0xf2e>
 8002782:	2f00      	cmp	r7, #0
 8002784:	bfd4      	ite	le
 8002786:	f04f 33ff 	movle.w	r3, #4294967295
 800278a:	2301      	movgt	r3, #1
 800278c:	441f      	add	r7, r3
	return(i / 2);
 800278e:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 8002792:	107f      	asrs	r7, r7, #1
				}
			}
		}
		else /* AC */
		{
			if((i = BADJ(i)))
 8002794:	2f00      	cmp	r7, #0
 8002796:	d067      	beq.n	8002868 <encode_ssdv+0x1008>
			{
				s->accrle += s->acrle;
 8002798:	f89b 1075 	ldrb.w	r1, [fp, #117]	; 0x75
 800279c:	f89b 3074 	ldrb.w	r3, [fp, #116]	; 0x74
 80027a0:	4419      	add	r1, r3
 80027a2:	b2c9      	uxtb	r1, r1
				while(s->accrle >= 16)
 80027a4:	290f      	cmp	r1, #15
		}
		else /* AC */
		{
			if((i = BADJ(i)))
			{
				s->accrle += s->acrle;
 80027a6:	f88b 1075 	strb.w	r1, [fp, #117]	; 0x75
				while(s->accrle >= 16)
 80027aa:	d90c      	bls.n	80027c6 <encode_ssdv+0xf66>
				{
					ssdv_out_jpeg_int(s, 15, 0);
 80027ac:	210f      	movs	r1, #15
 80027ae:	2200      	movs	r2, #0
 80027b0:	4658      	mov	r0, fp
 80027b2:	f00a f9cd 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
					s->accrle -= 16;
 80027b6:	f89b 1075 	ldrb.w	r1, [fp, #117]	; 0x75
 80027ba:	3910      	subs	r1, #16
 80027bc:	b2c9      	uxtb	r1, r1
		else /* AC */
		{
			if((i = BADJ(i)))
			{
				s->accrle += s->acrle;
				while(s->accrle >= 16)
 80027be:	290f      	cmp	r1, #15
				{
					ssdv_out_jpeg_int(s, 15, 0);
					s->accrle -= 16;
 80027c0:	f88b 1075 	strb.w	r1, [fp, #117]	; 0x75
		else /* AC */
		{
			if((i = BADJ(i)))
			{
				s->accrle += s->acrle;
				while(s->accrle >= 16)
 80027c4:	d8f2      	bhi.n	80027ac <encode_ssdv+0xf4c>
				{
					ssdv_out_jpeg_int(s, 15, 0);
					s->accrle -= 16;
				}
				ssdv_out_jpeg_int(s, s->accrle, i);
 80027c6:	463a      	mov	r2, r7
 80027c8:	4658      	mov	r0, fp
 80027ca:	f00a f9c1 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
 80027ce:	f89b 3080 	ldrb.w	r3, [fp, #128]	; 0x80
 80027d2:	f89b 2030 	ldrb.w	r2, [fp, #48]	; 0x30
 80027d6:	f89b 0059 	ldrb.w	r0, [fp, #89]	; 0x59
 80027da:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
 80027de:	1ad2      	subs	r2, r2, r3
				s->accrle = 0;
 80027e0:	2300      	movs	r3, #0
 80027e2:	1c44      	adds	r4, r0, #1
 80027e4:	f88b 3075 	strb.w	r3, [fp, #117]	; 0x75
 80027e8:	e734      	b.n	8002654 <encode_ssdv+0xdf4>
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
			{
				/* Flush any remaining bits */
				ssdv_outbits_sync(s);
 80027ea:	4658      	mov	r0, fp
 80027ec:	f00a f8b8 	bl	800c960 <ssdv_outbits_sync.lto_priv.143>
			while((r = ssdv_process(s)) == SSDV_OK);
			
			if(r == SSDV_BUFFER_FULL || r == SSDV_EOI)
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
 80027f0:	f89b 301c 	ldrb.w	r3, [fp, #28]
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 80027f4:	2bff      	cmp	r3, #255	; 0xff
			
			/* Test for the end of image */
			if(s->mcu_id >= s->mcu_count)
			{
				/* Flush any remaining bits */
				ssdv_outbits_sync(s);
 80027f6:	f04f 0404 	mov.w	r4, #4
			{
				uint16_t mcu_id     = s->packet_mcu_id;
				uint8_t i, mcu_offset = s->packet_mcu_offset;
				uint32_t x;
				
				if(mcu_offset != 0xFF && mcu_offset >= s->pkt_size_payload)
 80027fa:	f47f a95f 	bne.w	8001abc <encode_ssdv+0x25c>
			/* Process the new data until more needed, or an error occurs */
			while((r = ssdv_process(s)) == SSDV_OK);
			
			if(r == SSDV_BUFFER_FULL || r == SSDV_EOI)
			{
				uint16_t mcu_id     = s->packet_mcu_id;
 80027fe:	f8bb 101a 	ldrh.w	r1, [fp, #26]
					s->packet_mcu_offset -= s->pkt_size_payload;
				}
				else
				{
					/* Clear the MCU data for the next packet */
					s->packet_mcu_id = 0xFFFF;
 8002802:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002806:	ea4f 2e11 	mov.w	lr, r1, lsr #8
 800280a:	f8ab 201a 	strh.w	r2, [fp, #26]
 800280e:	b2c9      	uxtb	r1, r1
					s->packet_mcu_offset = 0xFF;
 8002810:	f88b 201c 	strb.w	r2, [fp, #28]
 8002814:	f7ff b95d 	b.w	8001ad2 <encode_ssdv+0x272>
			
			if(s->marker == J_TEM ||
			   (s->marker >= J_RST0 && s->marker <= J_EOI))
			{
				/* Marker without data */
				s->marker_len = 0;
 8002818:	2300      	movs	r3, #0
				r = ssdv_have_marker(s);
 800281a:	4658      	mov	r0, fp
			
			if(s->marker == J_TEM ||
			   (s->marker >= J_RST0 && s->marker <= J_EOI))
			{
				/* Marker without data */
				s->marker_len = 0;
 800281c:	f8ab 304c 	strh.w	r3, [fp, #76]	; 0x4c
				r = ssdv_have_marker(s);
 8002820:	f00a f8ee 	bl	800ca00 <ssdv_have_marker.lto_priv.141>
				if(r != SSDV_OK) return(r);
 8002824:	2800      	cmp	r0, #0
 8002826:	f43f a8d7 	beq.w	80019d8 <encode_ssdv+0x178>

	while(true)
	{
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
 800282a:	2801      	cmp	r0, #1
 800282c:	f43f ab06 	beq.w	8001e3c <encode_ssdv+0x5dc>
				break;
			}
			ssdv_enc_feed(&ssdv, b, r);
		}

		if(c == SSDV_EOI)
 8002830:	2804      	cmp	r0, #4
 8002832:	f43f ab1d 	beq.w	8001e70 <encode_ssdv+0x610>
 8002836:	e47f      	b.n	8002138 <encode_ssdv+0x8d8>
				s->needbits = symbol;
			}
		}
		else /* AC */
		{
			s->acrle = 0;
 8002838:	2300      	movs	r3, #0
 800283a:	f88b 3074 	strb.w	r3, [fp, #116]	; 0x74
			if(symbol == 0x00)
 800283e:	2a00      	cmp	r2, #0
 8002840:	f000 80ad 	beq.w	800299e <encode_ssdv+0x113e>
			{
				/* EOB -- all remaining AC parts are zero */
				ssdv_out_jpeg_int(s, 0, 0);
				s->acpart = 64;
			}
			else if(symbol == 0xF0)
 8002844:	2af0      	cmp	r2, #240	; 0xf0
 8002846:	f000 8115 	beq.w	8002a74 <encode_ssdv+0x1214>
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
				s->acrle = symbol >> 4;
 800284a:	0913      	lsrs	r3, r2, #4
				s->acpart += s->acrle;
 800284c:	441c      	add	r4, r3
 800284e:	b2e4      	uxtb	r4, r4
				s->needbits = symbol & 0x0F;
 8002850:	f002 020f 	and.w	r2, r2, #15
				s->acpart += 16;
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
 8002854:	2104      	movs	r1, #4
				s->acrle = symbol >> 4;
				s->acpart += s->acrle;
 8002856:	f88b 4059 	strb.w	r4, [fp, #89]	; 0x59
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
				s->acrle = symbol >> 4;
 800285a:	f88b 3074 	strb.w	r3, [fp, #116]	; 0x74
				s->acpart += s->acrle;
				s->needbits = symbol & 0x0F;
 800285e:	f88b 2080 	strb.w	r2, [fp, #128]	; 0x80
				s->acpart += 16;
			}
			else
			{
				/* Next bits are an integer value */
				s->state = S_INT;
 8002862:	f88b 1049 	strb.w	r1, [fp, #73]	; 0x49
 8002866:	e760      	b.n	800272a <encode_ssdv+0xeca>
				s->accrle = 0;
			}
			else
			{
				/* AC value got reduced to 0 in the DQT conversion */
				if(s->acpart >= 63)
 8002868:	283e      	cmp	r0, #62	; 0x3e
 800286a:	f200 80a6 	bhi.w	80029ba <encode_ssdv+0x115a>
				{
					ssdv_out_jpeg_int(s, 0, 0);
					s->accrle = 0;
				}
				else s->accrle += s->acrle + 1;
 800286e:	f89b 0075 	ldrb.w	r0, [fp, #117]	; 0x75
 8002872:	f89b 3074 	ldrb.w	r3, [fp, #116]	; 0x74
 8002876:	4403      	add	r3, r0
 8002878:	3301      	adds	r3, #1
 800287a:	f88b 3075 	strb.w	r3, [fp, #117]	; 0x75
 800287e:	e6e9      	b.n	8002654 <encode_ssdv+0xdf4>
				s->reset_mcu = s->mcu_id;
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 8002880:	2a01      	cmp	r2, #1
 8002882:	f47f af12 	bne.w	80026aa <encode_ssdv+0xe4a>
 8002886:	f8db 207c 	ldr.w	r2, [fp, #124]	; 0x7c
 800288a:	4293      	cmp	r3, r2
 800288c:	f47f af0d 	bne.w	80026aa <encode_ssdv+0xe4a>
				s->workbits = s->worklen = 0;
 8002890:	2300      	movs	r3, #0
 8002892:	f88b 3030 	strb.w	r3, [fp, #48]	; 0x30
 8002896:	f8cb 302c 	str.w	r3, [fp, #44]	; 0x2c
 800289a:	e706      	b.n	80026aa <encode_ssdv+0xe4a>
				s->acpart++;
			}
			else
			{
				/* DC value follows, 'symbol' bits wide */
				s->state = S_INT;
 800289c:	2304      	movs	r3, #4
				s->needbits = symbol;
 800289e:	f88b 2080 	strb.w	r2, [fp, #128]	; 0x80
				s->acpart++;
			}
			else
			{
				/* DC value follows, 'symbol' bits wide */
				s->state = S_INT;
 80028a2:	f88b 3049 	strb.w	r3, [fp, #73]	; 0x49
 80028a6:	e740      	b.n	800272a <encode_ssdv+0xeca>
		/* Decode the integer */
		i = jpeg_int(s->workbits >> (s->worklen - s->needbits), s->needbits);
		
		if(s->acpart == 0) /* DC */
		{
			if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
 80028a8:	f89b 3058 	ldrb.w	r3, [fp, #88]	; 0x58
 80028ac:	b123      	cbz	r3, 80028b8 <encode_ssdv+0x1058>
 80028ae:	f89b 2057 	ldrb.w	r2, [fp, #87]	; 0x57
 80028b2:	429a      	cmp	r2, r3
 80028b4:	f63f ae82 	bhi.w	80025bc <encode_ssdv+0xd5c>
			{
				if(s->mode == S_ENCODING)
 80028b8:	f89b 3078 	ldrb.w	r3, [fp, #120]	; 0x78
 80028bc:	2b00      	cmp	r3, #0
 80028be:	f040 80bf 	bne.w	8002a40 <encode_ssdv+0x11e0>
				{
					/* Output absolute DC value */
					s->dc[s->component] += UADJ(i);
 80028c2:	f89b 1056 	ldrb.w	r1, [fp, #86]	; 0x56
 80028c6:	1c0b      	adds	r3, r1, #0
 80028c8:	bf18      	it	ne
 80028ca:	2301      	movne	r3, #1
 80028cc:	f103 02b0 	add.w	r2, r3, #176	; 0xb0
 80028d0:	eb0b 0282 	add.w	r2, fp, r2, lsl #2
 80028d4:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 80028d8:	6854      	ldr	r4, [r2, #4]
 80028da:	f85b e023 	ldr.w	lr, [fp, r3, lsl #2]
 80028de:	7862      	ldrb	r2, [r4, #1]
 80028e0:	f89e c001 	ldrb.w	ip, [lr, #1]
 80028e4:	f101 0016 	add.w	r0, r1, #22
 80028e8:	eb0b 0380 	add.w	r3, fp, r0, lsl #2
 80028ec:	4594      	cmp	ip, r2
 80028ee:	685b      	ldr	r3, [r3, #4]
 80028f0:	bf18      	it	ne
 80028f2:	4357      	mulne	r7, r2
 80028f4:	eb0b 0080 	add.w	r0, fp, r0, lsl #2
 80028f8:	443b      	add	r3, r7
 80028fa:	6043      	str	r3, [r0, #4]
					s->adc[s->component] = AADJ(s->dc[s->component]);
 80028fc:	f89e 2001 	ldrb.w	r2, [lr, #1]
 8002900:	7860      	ldrb	r0, [r4, #1]
 8002902:	4290      	cmp	r0, r2
 8002904:	d00d      	beq.n	8002922 <encode_ssdv+0x10c2>
#define BADJ(i) (SDQT == DDQT ? (i) : irdiv(i * SDQT, DDQT))

/* Integer-only division with rounding */
static int irdiv(int i, int div)
{
	i = i * 2 / div;
 8002906:	005b      	lsls	r3, r3, #1
 8002908:	fb93 f3f2 	sdiv	r3, r3, r2
	if(i & 1) i += (i > 0 ? 1 : -1);
 800290c:	07d8      	lsls	r0, r3, #31
 800290e:	d505      	bpl.n	800291c <encode_ssdv+0x10bc>
 8002910:	2b00      	cmp	r3, #0
 8002912:	bfd4      	ite	le
 8002914:	f04f 32ff 	movle.w	r2, #4294967295
 8002918:	2201      	movgt	r2, #1
 800291a:	4413      	add	r3, r2
	return(i / 2);
 800291c:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 8002920:	105b      	asrs	r3, r3, #1
			{
				if(s->mode == S_ENCODING)
				{
					/* Output absolute DC value */
					s->dc[s->component] += UADJ(i);
					s->adc[s->component] = AADJ(s->dc[s->component]);
 8002922:	f101 001a 	add.w	r0, r1, #26
					ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
 8002926:	461a      	mov	r2, r3
			{
				if(s->mode == S_ENCODING)
				{
					/* Output absolute DC value */
					s->dc[s->component] += UADJ(i);
					s->adc[s->component] = AADJ(s->dc[s->component]);
 8002928:	f84b 3020 	str.w	r3, [fp, r0, lsl #2]
					ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
 800292c:	2100      	movs	r1, #0
 800292e:	4658      	mov	r0, fp
			else
			{
				if(s->mode == S_DECODING)
				{
					s->dc[s->component] += UADJ(i);
					ssdv_out_jpeg_int(s, 0, i);
 8002930:	f00a f90e 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
 8002934:	f89b 0059 	ldrb.w	r0, [fp, #89]	; 0x59
 8002938:	f89b 2030 	ldrb.w	r2, [fp, #48]	; 0x30
 800293c:	f89b 3080 	ldrb.w	r3, [fp, #128]	; 0x80
 8002940:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
 8002944:	1c44      	adds	r4, r0, #1
 8002946:	1ad2      	subs	r2, r2, r3
 8002948:	e684      	b.n	8002654 <encode_ssdv+0xdf4>

		while((c = ssdv_enc_get_packet(&ssdv)) == SSDV_FEED_ME)
		{
			b = &image[bi];
			uint8_t r = bi < image_len-128 ? 128 : image_len - bi;
			bi += r;
 800294a:	9b02      	ldr	r3, [sp, #8]
 800294c:	3380      	adds	r3, #128	; 0x80
 800294e:	9302      	str	r3, [sp, #8]
 8002950:	2380      	movs	r3, #128	; 0x80
 8002952:	f7ff ba84 	b.w	8001e5e <encode_ssdv+0x5fe>
			}
			else
			{
				if(s->mode == S_DECODING)
				{
					s->dc[s->component] += UADJ(i);
 8002956:	1c1a      	adds	r2, r3, #0
 8002958:	bf18      	it	ne
 800295a:	2201      	movne	r2, #1
 800295c:	f102 01b0 	add.w	r1, r2, #176	; 0xb0
 8002960:	eb0b 0181 	add.w	r1, fp, r1, lsl #2
 8002964:	f502 72a0 	add.w	r2, r2, #320	; 0x140
 8002968:	6848      	ldr	r0, [r1, #4]
 800296a:	f85b 1022 	ldr.w	r1, [fp, r2, lsl #2]
 800296e:	7842      	ldrb	r2, [r0, #1]
 8002970:	7849      	ldrb	r1, [r1, #1]
 8002972:	3316      	adds	r3, #22
 8002974:	eb0b 0083 	add.w	r0, fp, r3, lsl #2
 8002978:	4291      	cmp	r1, r2
 800297a:	6844      	ldr	r4, [r0, #4]
 800297c:	bf14      	ite	ne
 800297e:	437a      	mulne	r2, r7
 8002980:	463a      	moveq	r2, r7
 8002982:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8002986:	4414      	add	r4, r2
					ssdv_out_jpeg_int(s, 0, i);
 8002988:	2100      	movs	r1, #0
 800298a:	463a      	mov	r2, r7
 800298c:	4658      	mov	r0, fp
			}
			else
			{
				if(s->mode == S_DECODING)
				{
					s->dc[s->component] += UADJ(i);
 800298e:	605c      	str	r4, [r3, #4]
 8002990:	e7ce      	b.n	8002930 <encode_ssdv+0x10d0>
					{
						ssdv_out_jpeg_int(s, 0, 0 - s->dc[s->component]);
						s->dc[s->component] = 0;
					}
				}
				else ssdv_out_jpeg_int(s, 0, 0);
 8002992:	2200      	movs	r2, #0
 8002994:	4611      	mov	r1, r2
 8002996:	4658      	mov	r0, fp
 8002998:	f00a f8da 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
 800299c:	e6bb      	b.n	8002716 <encode_ssdv+0xeb6>
		{
			s->acrle = 0;
			if(symbol == 0x00)
			{
				/* EOB -- all remaining AC parts are zero */
				ssdv_out_jpeg_int(s, 0, 0);
 800299e:	4611      	mov	r1, r2
 80029a0:	4658      	mov	r0, fp
 80029a2:	f00a f8d5 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
				s->acpart = 64;
 80029a6:	f04f 0340 	mov.w	r3, #64	; 0x40
 80029aa:	f88b 3059 	strb.w	r3, [fp, #89]	; 0x59
 80029ae:	f89b e030 	ldrb.w	lr, [fp, #48]	; 0x30
 80029b2:	f8db 802c 	ldr.w	r8, [fp, #44]	; 0x2c
 80029b6:	2440      	movs	r4, #64	; 0x40
 80029b8:	e6b7      	b.n	800272a <encode_ssdv+0xeca>
			else
			{
				/* AC value got reduced to 0 in the DQT conversion */
				if(s->acpart >= 63)
				{
					ssdv_out_jpeg_int(s, 0, 0);
 80029ba:	463a      	mov	r2, r7
 80029bc:	4639      	mov	r1, r7
 80029be:	4658      	mov	r0, fp
 80029c0:	f00a f8c6 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
 80029c4:	f89b 0059 	ldrb.w	r0, [fp, #89]	; 0x59
 80029c8:	f89b 2030 	ldrb.w	r2, [fp, #48]	; 0x30
 80029cc:	f89b 3080 	ldrb.w	r3, [fp, #128]	; 0x80
					s->accrle = 0;
 80029d0:	f88b 7075 	strb.w	r7, [fp, #117]	; 0x75
 80029d4:	1c44      	adds	r4, r0, #1
 80029d6:	1ad2      	subs	r2, r2, r3
 80029d8:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
 80029dc:	e63a      	b.n	8002654 <encode_ssdv+0xdf4>
	
	/* Have we reached the end of the image? */
	if(s->state == S_EOI) return(SSDV_EOI);
	
	/* If the output buffer is empty, re-initialise */
	if(s->out_len == 0) ssdv_enc_set_buffer(s, s->out);
 80029de:	f8db 0034 	ldr.w	r0, [fp, #52]	; 0x34

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
	s->out_len = s->pkt_size_payload;
 80029e2:	f8bb 3002 	ldrh.w	r3, [fp, #2]
 80029e6:	f8cb 303c 	str.w	r3, [fp, #60]	; 0x3c
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 80029ea:	4621      	mov	r1, r4
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 80029ec:	f100 030f 	add.w	r3, r0, #15
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 80029f0:	f44f 7280 	mov.w	r2, #256	; 0x100
}

char ssdv_enc_set_buffer(ssdv_t *s, uint8_t *buffer)
{
	s->out     = buffer;
	s->outp    = buffer + SSDV_PKT_SIZE_HEADER;
 80029f4:	f8cb 3038 	str.w	r3, [fp, #56]	; 0x38
	s->out_len = s->pkt_size_payload;
	
	/* Zero the payload memory */
	memset(s->out, 0, SSDV_PKT_SIZE);
 80029f8:	f00b fe5a 	bl	800e6b0 <memset>
	
	/* Flush the output bits */
	ssdv_outbits(s, 0, 0);
 80029fc:	4622      	mov	r2, r4
 80029fe:	4621      	mov	r1, r4
 8002a00:	4658      	mov	r0, fp
 8002a02:	f009 ff5d 	bl	800c8c0 <ssdv_outbits.lto_priv.142>
 8002a06:	f7fe bfe7 	b.w	80019d8 <encode_ssdv+0x178>
			
			/* Set the packet MCU marker - encoder only */
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
			{
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
 8002a0a:	4658      	mov	r0, fp
 8002a0c:	f009 ffa8 	bl	800c960 <ssdv_outbits_sync.lto_priv.143>
				
				s->reset_mcu = s->mcu_id;
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
 8002a10:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
 8002a14:	f89b 3002 	ldrb.w	r3, [fp, #2]
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 8002a18:	f89b 1078 	ldrb.w	r1, [fp, #120]	; 0x78
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
				
				s->reset_mcu = s->mcu_id;
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
 8002a1c:	1a9b      	subs	r3, r3, r2
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 8002a1e:	2901      	cmp	r1, #1
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
			{
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
				
				s->reset_mcu = s->mcu_id;
 8002a20:	f8bb 2016 	ldrh.w	r2, [fp, #22]
				s->packet_mcu_id = s->mcu_id;
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
 8002a24:	f88b 301c 	strb.w	r3, [fp, #28]
			if(s->mode == S_ENCODING && s->packet_mcu_id == 0xFFFF)
			{
				/* The first MCU of each packet should be byte aligned */
				ssdv_outbits_sync(s);
				
				s->reset_mcu = s->mcu_id;
 8002a28:	f8cb 207c 	str.w	r2, [fp, #124]	; 0x7c
				s->packet_mcu_id = s->mcu_id;
 8002a2c:	f8ab 201a 	strh.w	r2, [fp, #26]
				s->packet_mcu_offset = s->pkt_size_payload - s->out_len;
			}
			
			if(s->mode == S_DECODING && s->mcu_id == s->reset_mcu)
 8002a30:	f47f ae3b 	bne.w	80026aa <encode_ssdv+0xe4a>
				s->workbits = s->worklen = 0;
 8002a34:	2300      	movs	r3, #0
 8002a36:	f88b 3030 	strb.w	r3, [fp, #48]	; 0x30
 8002a3a:	f8cb 302c 	str.w	r3, [fp, #44]	; 0x2c
 8002a3e:	e634      	b.n	80026aa <encode_ssdv+0xe4a>
					ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
				}
				else
				{
					/* Output relative DC value */
					ssdv_out_jpeg_int(s, 0, i - s->dc[s->component]);
 8002a40:	f89b 3056 	ldrb.w	r3, [fp, #86]	; 0x56
 8002a44:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8002a48:	2100      	movs	r1, #0
 8002a4a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8002a4c:	4658      	mov	r0, fp
 8002a4e:	1aba      	subs	r2, r7, r2
 8002a50:	f00a f87e 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
					s->dc[s->component] = i;
 8002a54:	f89b 1056 	ldrb.w	r1, [fp, #86]	; 0x56
 8002a58:	f89b 0059 	ldrb.w	r0, [fp, #89]	; 0x59
 8002a5c:	f89b 2030 	ldrb.w	r2, [fp, #48]	; 0x30
 8002a60:	f89b 3080 	ldrb.w	r3, [fp, #128]	; 0x80
 8002a64:	eb0b 0181 	add.w	r1, fp, r1, lsl #2
 8002a68:	1c44      	adds	r4, r0, #1
 8002a6a:	65cf      	str	r7, [r1, #92]	; 0x5c
 8002a6c:	1ad2      	subs	r2, r2, r3
 8002a6e:	f8db 102c 	ldr.w	r1, [fp, #44]	; 0x2c
 8002a72:	e5ef      	b.n	8002654 <encode_ssdv+0xdf4>
				s->acpart = 64;
			}
			else if(symbol == 0xF0)
			{
				/* The next 16 AC parts are zero */
				ssdv_out_jpeg_int(s, 15, 0);
 8002a74:	461a      	mov	r2, r3
 8002a76:	210f      	movs	r1, #15
 8002a78:	4658      	mov	r0, fp
 8002a7a:	f00a f869 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
				s->acpart += 16;
 8002a7e:	f89b 4059 	ldrb.w	r4, [fp, #89]	; 0x59
 8002a82:	f89b e030 	ldrb.w	lr, [fp, #48]	; 0x30
 8002a86:	f8db 802c 	ldr.w	r8, [fp, #44]	; 0x2c
 8002a8a:	3410      	adds	r4, #16
 8002a8c:	b2e4      	uxtb	r4, r4
 8002a8e:	f88b 4059 	strb.w	r4, [fp, #89]	; 0x59
 8002a92:	e64a      	b.n	800272a <encode_ssdv+0xeca>
				if(s->reset_mcu == s->mcu_id && (s->mcupart == 0 || s->mcupart >= s->ycparts))
				{
					if(s->mode == S_ENCODING) ssdv_out_jpeg_int(s, 0, s->adc[s->component]);
					else
					{
						ssdv_out_jpeg_int(s, 0, 0 - s->dc[s->component]);
 8002a94:	eb0b 0a8a 	add.w	sl, fp, sl, lsl #2
 8002a98:	2100      	movs	r1, #0
 8002a9a:	f8da 205c 	ldr.w	r2, [sl, #92]	; 0x5c
 8002a9e:	4658      	mov	r0, fp
 8002aa0:	4252      	negs	r2, r2
 8002aa2:	f00a f855 	bl	800cb50 <ssdv_out_jpeg_int.lto_priv.144>
						s->dc[s->component] = 0;
 8002aa6:	f89b 3056 	ldrb.w	r3, [fp, #86]	; 0x56
 8002aaa:	3316      	adds	r3, #22
 8002aac:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 8002ab0:	2200      	movs	r2, #0
 8002ab2:	605a      	str	r2, [r3, #4]
 8002ab4:	e62f      	b.n	8002716 <encode_ssdv+0xeb6>

			if(r <= 0)
			{
				TRACE_ERROR("SSDV > Premature end of file");
 8002ab6:	489f      	ldr	r0, [pc, #636]	; (8002d34 <encode_ssdv+0x14d4>)
 8002ab8:	4e9f      	ldr	r6, [pc, #636]	; (8002d38 <encode_ssdv+0x14d8>)
 8002aba:	f009 fb71 	bl	800c1a0 <chMtxLock>
 8002abe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002ac2:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8002ac6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002ac8:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8002aca:	4b9c      	ldr	r3, [pc, #624]	; (8002d3c <encode_ssdv+0x14dc>)
 8002acc:	499c      	ldr	r1, [pc, #624]	; (8002d40 <encode_ssdv+0x14e0>)
 8002ace:	489d      	ldr	r0, [pc, #628]	; (8002d44 <encode_ssdv+0x14e4>)
 8002ad0:	fb05 f404 	mul.w	r4, r5, r4
 8002ad4:	fba6 7404 	umull	r7, r4, r6, r4
 8002ad8:	0b64      	lsrs	r4, r4, #13
 8002ada:	fba3 7304 	umull	r7, r3, r3, r4
 8002ade:	fba6 6202 	umull	r6, r2, r6, r2
 8002ae2:	099b      	lsrs	r3, r3, #6
 8002ae4:	fb05 4313 	mls	r3, r5, r3, r4
 8002ae8:	0b52      	lsrs	r2, r2, #13
 8002aea:	f007 fdd1 	bl	800a690 <chprintf.constprop.26>
 8002aee:	4a96      	ldr	r2, [pc, #600]	; (8002d48 <encode_ssdv+0x14e8>)
 8002af0:	4996      	ldr	r1, [pc, #600]	; (8002d4c <encode_ssdv+0x14ec>)
 8002af2:	4894      	ldr	r0, [pc, #592]	; (8002d44 <encode_ssdv+0x14e4>)
 8002af4:	f007 fdcc 	bl	800a690 <chprintf.constprop.26>
 8002af8:	232d      	movs	r3, #45	; 0x2d
 8002afa:	4a95      	ldr	r2, [pc, #596]	; (8002d50 <encode_ssdv+0x14f0>)
 8002afc:	4995      	ldr	r1, [pc, #596]	; (8002d54 <encode_ssdv+0x14f4>)
 8002afe:	4891      	ldr	r0, [pc, #580]	; (8002d44 <encode_ssdv+0x14e4>)
 8002b00:	f007 fdc6 	bl	800a690 <chprintf.constprop.26>
 8002b04:	4994      	ldr	r1, [pc, #592]	; (8002d58 <encode_ssdv+0x14f8>)
 8002b06:	488f      	ldr	r0, [pc, #572]	; (8002d44 <encode_ssdv+0x14e4>)
 8002b08:	f007 fdc2 	bl	800a690 <chprintf.constprop.26>
 8002b0c:	4993      	ldr	r1, [pc, #588]	; (8002d5c <encode_ssdv+0x14fc>)
 8002b0e:	488d      	ldr	r0, [pc, #564]	; (8002d44 <encode_ssdv+0x14e4>)
 8002b10:	f007 fdbe 	bl	800a690 <chprintf.constprop.26>
 8002b14:	4992      	ldr	r1, [pc, #584]	; (8002d60 <encode_ssdv+0x1500>)
 8002b16:	488b      	ldr	r0, [pc, #556]	; (8002d44 <encode_ssdv+0x14e4>)
 8002b18:	f007 fdba 	bl	800a690 <chprintf.constprop.26>
 8002b1c:	4885      	ldr	r0, [pc, #532]	; (8002d34 <encode_ssdv+0x14d4>)
 8002b1e:	f006 fd2f 	bl	8009580 <chMtxUnlock>
 8002b22:	212d      	movs	r1, #45	; 0x2d
 8002b24:	488a      	ldr	r0, [pc, #552]	; (8002d50 <encode_ssdv+0x14f0>)
 8002b26:	f009 ff2b 	bl	800c980 <log_error>
 8002b2a:	2401      	movs	r4, #1
 8002b2c:	f7ff bb05 	b.w	800213a <encode_ssdv+0x8da>
		msg.power = config->power;

		switch(config->protocol) {
			case PROT_APRS_2GFSK:
			case PROT_APRS_AFSK:
				msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8002b30:	2a01      	cmp	r2, #1
 8002b32:	bf14      	ite	ne
 8002b34:	2302      	movne	r3, #2
 8002b36:	2304      	moveq	r3, #4
 8002b38:	461c      	mov	r4, r3
 8002b3a:	9309      	str	r3, [sp, #36]	; 0x24
				msg.afsk_config = &(config->afsk_config);
 8002b3c:	f100 0350 	add.w	r3, r0, #80	; 0x50
 8002b40:	f20d 104f 	addw	r0, sp, #335	; 0x14f
 8002b44:	f8c8 3214 	str.w	r3, [r8, #532]	; 0x214
				msg.gfsk_config = &(config->gfsk_config);
 8002b48:	f8c8 3218 	str.w	r3, [r8, #536]	; 0x218
		msg.power = config->power;

		switch(config->protocol) {
			case PROT_APRS_2GFSK:
			case PROT_APRS_AFSK:
				msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
 8002b4c:	f888 4209 	strb.w	r4, [r8, #521]	; 0x209
				msg.afsk_config = &(config->afsk_config);
				msg.gfsk_config = &(config->gfsk_config);
 8002b50:	4603      	mov	r3, r0
 8002b52:	f20d 214f 	addw	r1, sp, #591	; 0x24f

				// Deleting buffer
				for(uint16_t t=0; t<256; t++)
					pkt_base91[t] = 0;
 8002b56:	2200      	movs	r2, #0
 8002b58:	f803 2f01 	strb.w	r2, [r3, #1]!
				msg.mod = config->protocol == PROT_APRS_AFSK ? MOD_AFSK : MOD_2GFSK;
				msg.afsk_config = &(config->afsk_config);
				msg.gfsk_config = &(config->gfsk_config);

				// Deleting buffer
				for(uint16_t t=0; t<256; t++)
 8002b5c:	428b      	cmp	r3, r1
 8002b5e:	d1fb      	bne.n	8002b58 <encode_ssdv+0x12f8>
 8002b60:	f20d 225e 	addw	r2, sp, #606	; 0x25e
void base91_encode(const uint8_t *in, uint8_t *out, uint16_t input_length) {
	base91_t handle;

	uint32_t ototal = 0;
	for(uint32_t i=0; i<(uint32_t)BASE91LEN(input_length); i++)
		out[i] = 0;
 8002b64:	2300      	movs	r3, #0
 8002b66:	f800 3f01 	strb.w	r3, [r0, #1]!

void base91_encode(const uint8_t *in, uint8_t *out, uint16_t input_length) {
	base91_t handle;

	uint32_t ototal = 0;
	for(uint32_t i=0; i<(uint32_t)BASE91LEN(input_length); i++)
 8002b6a:	4282      	cmp	r2, r0
 8002b6c:	d1fb      	bne.n	8002b66 <encode_ssdv+0x1306>
 8002b6e:	2700      	movs	r7, #0
 8002b70:	2400      	movs	r4, #0
 8002b72:	2500      	movs	r5, #0
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8002b74:	46bc      	mov	ip, r7
 8002b76:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
 8002b7a:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 8002d6c <encode_ssdv+0x150c>
 8002b7e:	960a      	str	r6, [sp, #40]	; 0x28

void base91_encode(const uint8_t *in, uint8_t *out, uint16_t input_length) {
	base91_t handle;

	uint32_t ototal = 0;
	for(uint32_t i=0; i<(uint32_t)BASE91LEN(input_length); i++)
 8002b80:	f10d 0251 	add.w	r2, sp, #81	; 0x51
 8002b84:	f50d 7aa8 	add.w	sl, sp, #336	; 0x150
 8002b88:	f50d 7e96 	add.w	lr, sp, #300	; 0x12c
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8002b8c:	4627      	mov	r7, r4
 8002b8e:	46a8      	mov	r8, r5
 8002b90:	e02a      	b.n	8002be8 <encode_ssdv+0x1388>
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
				b->queue >>= 13;
 8002b92:	0b61      	lsrs	r1, r4, #13
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
 8002b94:	2b58      	cmp	r3, #88	; 0x58
				b->queue >>= 13;
 8002b96:	ea4f 3055 	mov.w	r0, r5, lsr #13
 8002b9a:	ea41 41c5 	orr.w	r1, r1, r5, lsl #19
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
 8002b9e:	f240 80bc 	bls.w	8002d1a <encode_ssdv+0x14ba>
				b->queue >>= 13;
				b->nbits -= 13;
 8002ba2:	3f05      	subs	r7, #5
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;

			if (val > 88) {
				b->queue >>= 13;
 8002ba4:	460c      	mov	r4, r1
 8002ba6:	4605      	mov	r5, r0
				b->nbits -= 13;
 8002ba8:	f148 38ff 	adc.w	r8, r8, #4294967295
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8002bac:	fba3 0109 	umull	r0, r1, r3, r9
 8002bb0:	1a5e      	subs	r6, r3, r1
 8002bb2:	9606      	str	r6, [sp, #24]
			ob[n++] = b91_table[val / 91];
 8002bb4:	fba9 6003 	umull	r6, r0, r9, r3
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8002bb8:	9e06      	ldr	r6, [sp, #24]
 8002bba:	eb01 0156 	add.w	r1, r1, r6, lsr #1
			ob[n++] = b91_table[val / 91];
 8002bbe:	1a1e      	subs	r6, r3, r0
 8002bc0:	eb00 0056 	add.w	r0, r0, r6, lsr #1
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8002bc4:	0989      	lsrs	r1, r1, #6
 8002bc6:	265b      	movs	r6, #91	; 0x5b
 8002bc8:	fb06 3111 	mls	r1, r6, r1, r3
			ob[n++] = b91_table[val / 91];
 8002bcc:	0980      	lsrs	r0, r0, #6
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8002bce:	4e65      	ldr	r6, [pc, #404]	; (8002d64 <encode_ssdv+0x1504>)
 8002bd0:	f10c 0301 	add.w	r3, ip, #1
 8002bd4:	5c71      	ldrb	r1, [r6, r1]
			ob[n++] = b91_table[val / 91];
 8002bd6:	5c30      	ldrb	r0, [r6, r0]
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
 8002bd8:	f80a 100c 	strb.w	r1, [sl, ip]
{
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
 8002bdc:	4572      	cmp	r2, lr
				val = b->queue & 16383;
				b->queue >>= 14;
				b->nbits -= 14;
			}
			ob[n++] = b91_table[val % 91];
			ob[n++] = b91_table[val / 91];
 8002bde:	f80a 0003 	strb.w	r0, [sl, r3]
 8002be2:	f10c 0c02 	add.w	ip, ip, #2
{
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
 8002be6:	d014      	beq.n	8002c12 <encode_ssdv+0x13b2>
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
 8002be8:	f117 0008 	adds.w	r0, r7, #8
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 8002bec:	f812 3b01 	ldrb.w	r3, [r2], #1
		b->nbits += 8;
 8002bf0:	f148 0100 	adc.w	r1, r8, #0
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 8002bf4:	40bb      	lsls	r3, r7
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
 8002bf6:	2900      	cmp	r1, #0
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 8002bf8:	ea44 0403 	orr.w	r4, r4, r3
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
 8002bfc:	bf08      	it	eq
 8002bfe:	280e      	cmpeq	r0, #14
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
 8002c00:	ea45 75e3 	orr.w	r5, r5, r3, asr #31
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
			uint32_t val = b->queue & 8191;
 8002c04:	f3c4 030c 	ubfx	r3, r4, #0, #13
	size_t n = 0;

	while (len--) {
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
 8002c08:	d2c3      	bcs.n	8002b92 <encode_ssdv+0x1332>
{
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
 8002c0a:	4572      	cmp	r2, lr
		b->queue |= *ib++ << b->nbits;
		b->nbits += 8;
		if (b->nbits > 13) {	/* enough bits in queue */
 8002c0c:	4607      	mov	r7, r0
 8002c0e:	4688      	mov	r8, r1
{
	const uint8_t *ib = i;
	uint8_t *ob = o;
	size_t n = 0;

	while (len--) {
 8002c10:	d1ea      	bne.n	8002be8 <encode_ssdv+0x1388>
 8002c12:	4642      	mov	r2, r8
 8002c14:	4639      	mov	r1, r7
	for(uint32_t i=0; i<(uint32_t)BASE91LEN(input_length); i++)
		out[i] = 0;

	basE91_init(&handle);
	ototal += basE91_encode(&handle, in, input_length, out);
	ototal += basE91_encode_end(&handle, out + ototal);
 8002c16:	eb0a 030c 	add.w	r3, sl, ip
 8002c1a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8002c1c:	930a      	str	r3, [sp, #40]	; 0x28
size_t basE91_encode_end(base91_t *b, void *o)
{
	uint8_t *ob = o;
	size_t n = 0;

	if (b->nbits) {
 8002c1e:	e9cd 1206 	strd	r1, r2, [sp, #24]
 8002c22:	4613      	mov	r3, r2
 8002c24:	460a      	mov	r2, r1
 8002c26:	4313      	orrs	r3, r2
 8002c28:	4667      	mov	r7, ip
 8002c2a:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8002c2e:	d01c      	beq.n	8002c6a <encode_ssdv+0x140a>
		ob[n++] = b91_table[b->queue % 91];
 8002c30:	225b      	movs	r2, #91	; 0x5b
 8002c32:	2300      	movs	r3, #0
 8002c34:	4620      	mov	r0, r4
 8002c36:	4629      	mov	r1, r5
 8002c38:	f7fe f9fe 	bl	8001038 <__aeabi_uldivmod>
 8002c3c:	f8df 9124 	ldr.w	r9, [pc, #292]	; 8002d64 <encode_ssdv+0x1504>
 8002c40:	f819 3002 	ldrb.w	r3, [r9, r2]
 8002c44:	f80a 3007 	strb.w	r3, [sl, r7]
		if (b->nbits > 7 || b->queue > 90)
 8002c48:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8002c4c:	2b00      	cmp	r3, #0
 8002c4e:	bf08      	it	eq
 8002c50:	2a08      	cmpeq	r2, #8
 8002c52:	f0c0 837f 	bcc.w	8003354 <encode_ssdv+0x1af4>
			ob[n++] = b91_table[b->queue / 91];
 8002c56:	225b      	movs	r2, #91	; 0x5b
 8002c58:	2300      	movs	r3, #0
 8002c5a:	4620      	mov	r0, r4
 8002c5c:	4629      	mov	r1, r5
 8002c5e:	f7fe f9eb 	bl	8001038 <__aeabi_uldivmod>
 8002c62:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8002c64:	f819 3000 	ldrb.w	r3, [r9, r0]
 8002c68:	7053      	strb	r3, [r2, #1]
					pkt_base91[t] = 0;

				base91_encode(&pkt[1], pkt_base91, sizeof(pkt)-37); // Sync byte, CRC and FEC of SSDV not transmitted
				msg.bin_len = aprs_encode_experimental('I', msg.msg, msg.mod, &config->aprs_config, pkt_base91, strlen((char*)pkt_base91));
 8002c6a:	4650      	mov	r0, sl
 8002c6c:	f7fe fd88 	bl	8001780 <strlen>
{
	uint8_t i, j;
	uint8_t tmp[8];
	packet->size = 0;
	packet->ones_in_a_row = 0;
	packet->crc = 0xffff;
 8002c70:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002c74:	f8ad 204c 	strh.w	r2, [sp, #76]	; 0x4c
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8002c78:	9a08      	ldr	r2, [sp, #32]
 * Transmit custom experimental packet
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
	ax25_t packet;
	packet.data = message;
 8002c7a:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44

void ax25_send_header(ax25_t *packet, const char *callsign, uint8_t ssid, const char *path, uint16_t preamble)
{
	uint8_t i, j;
	uint8_t tmp[8];
	packet->size = 0;
 8002c7e:	2300      	movs	r3, #0
 8002c80:	4604      	mov	r4, r0
 8002c82:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;
 8002c86:	9809      	ldr	r0, [sp, #36]	; 0x24
	packet->ones_in_a_row = 0;
 8002c88:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8002c8c:	4613      	mov	r3, r2
 8002c8e:	3358      	adds	r3, #88	; 0x58
 8002c90:	f892 9068 	ldrb.w	r9, [r2, #104]	; 0x68
 8002c94:	9309      	str	r3, [sp, #36]	; 0x24
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 8002c96:	f44f 7100 	mov.w	r1, #512	; 0x200
	packet.mod = mod;

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8002c9a:	f8b2 307c 	ldrh.w	r3, [r2, #124]	; 0x7c
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
	packet.mod = mod;
 8002c9e:	f88d 004e 	strb.w	r0, [sp, #78]	; 0x4e

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8002ca2:	326c      	adds	r2, #108	; 0x6c
	packet->crc = 0xffff;

	// Send preamble ("a bunch of 0s")
	if(packet->mod == MOD_2GFSK) {
 8002ca4:	2802      	cmp	r0, #2
 */
uint32_t aprs_encode_experimental(char packetType, uint8_t* message, mod_t mod, const aprs_config_t *config, uint8_t *data, size_t size)
{
	ax25_t packet;
	packet.data = message;
	packet.max_size = 512; // TODO: replace 512 with real size
 8002ca6:	f8ad 104a 	strh.w	r1, [sp, #74]	; 0x4a
	packet.mod = mod;

	// Encode APRS header
	ax25_send_header(&packet, config->callsign, config->ssid, config->path, config->preamble);
 8002caa:	9206      	str	r2, [sp, #24]
 8002cac:	f000 8347 	beq.w	800333e <encode_ssdv+0x1ade>
		preamble = preamble * 6 / 5;
	} else {
		preamble = preamble * 3 / 20;
 8002cb0:	4d2d      	ldr	r5, [pc, #180]	; (8002d68 <encode_ssdv+0x1508>)
 8002cb2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002cb6:	fb85 2503 	smull	r2, r5, r5, r3
 8002cba:	17db      	asrs	r3, r3, #31
 8002cbc:	ebc3 05e5 	rsb	r5, r3, r5, asr #3
 8002cc0:	b2ad      	uxth	r5, r5
	}
	for(i=0; i<preamble; i++)
 8002cc2:	2d00      	cmp	r5, #0
 8002cc4:	d054      	beq.n	8002d70 <encode_ssdv+0x1510>
 8002cc6:	2300      	movs	r3, #0
 8002cc8:	461f      	mov	r7, r3
 8002cca:	f44f 7e00 	mov.w	lr, #512	; 0x200
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 8002cce:	f04f 0c01 	mov.w	ip, #1
	if(packet->mod == MOD_2GFSK) {
		preamble = preamble * 6 / 5;
	} else {
		preamble = preamble * 3 / 20;
	}
	for(i=0; i<preamble; i++)
 8002cd2:	2108      	movs	r1, #8
 8002cd4:	e001      	b.n	8002cda <encode_ssdv+0x147a>
 8002cd6:	f8bd e04a 	ldrh.w	lr, [sp, #74]	; 0x4a
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 8002cda:	f003 0207 	and.w	r2, r3, #7
void ax25_send_sync(ax25_t *packet)
{
	unsigned char byte = 0x00;
	int i;
	for(i=0; i<8; i++, packet->size++) {
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 8002cde:	ebb3 0fce 	cmp.w	r3, lr, lsl #3
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 8002ce2:	ea4f 00d3 	mov.w	r0, r3, lsr #3
 8002ce6:	fa0c f202 	lsl.w	r2, ip, r2
void ax25_send_sync(ax25_t *packet)
{
	unsigned char byte = 0x00;
	int i;
	for(i=0; i<8; i++, packet->size++) {
		if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 8002cea:	da0d      	bge.n	8002d08 <encode_ssdv+0x14a8>
			return;
		if((byte >> i) & 1)
			packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
		else
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 8002cec:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8002cee:	f813 e000 	ldrb.w	lr, [r3, r0]
 8002cf2:	ea2e 0202 	bic.w	r2, lr, r2
 8002cf6:	541a      	strb	r2, [r3, r0]

void ax25_send_sync(ax25_t *packet)
{
	unsigned char byte = 0x00;
	int i;
	for(i=0; i<8; i++, packet->size++) {
 8002cf8:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 8002cfc:	3301      	adds	r3, #1
 8002cfe:	b29b      	uxth	r3, r3
 8002d00:	3901      	subs	r1, #1
 8002d02:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
 8002d06:	d1e6      	bne.n	8002cd6 <encode_ssdv+0x1476>
	if(packet->mod == MOD_2GFSK) {
		preamble = preamble * 6 / 5;
	} else {
		preamble = preamble * 3 / 20;
	}
	for(i=0; i<preamble; i++)
 8002d08:	3701      	adds	r7, #1
 8002d0a:	b2ff      	uxtb	r7, r7
 8002d0c:	42af      	cmp	r7, r5
 8002d0e:	d22f      	bcs.n	8002d70 <encode_ssdv+0x1510>
 8002d10:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 8002d14:	f8bd e04a 	ldrh.w	lr, [sp, #74]	; 0x4a
 8002d18:	e7db      	b.n	8002cd2 <encode_ssdv+0x1472>
			if (val > 88) {
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
 8002d1a:	0ba1      	lsrs	r1, r4, #14
 8002d1c:	ea41 4185 	orr.w	r1, r1, r5, lsl #18
				b->nbits -= 14;
 8002d20:	3f06      	subs	r7, #6
			if (val > 88) {
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
 8002d22:	ea4f 3095 	mov.w	r0, r5, lsr #14

			if (val > 88) {
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
 8002d26:	f3c4 030d 	ubfx	r3, r4, #0, #14
				b->queue >>= 14;
				b->nbits -= 14;
 8002d2a:	f148 38ff 	adc.w	r8, r8, #4294967295
			if (val > 88) {
				b->queue >>= 13;
				b->nbits -= 13;
			} else {	/* we can take 14 bits */
				val = b->queue & 16383;
				b->queue >>= 14;
 8002d2e:	460c      	mov	r4, r1
 8002d30:	4605      	mov	r5, r0
 8002d32:	e73b      	b.n	8002bac <encode_ssdv+0x134c>
 8002d34:	2001b720 	.word	0x2001b720
 8002d38:	d1b71759 	.word	0xd1b71759
 8002d3c:	10624dd3 	.word	0x10624dd3
 8002d40:	0800ea50 	.word	0x0800ea50
 8002d44:	2001ac28 	.word	0x2001ac28
 8002d48:	0800ea5c 	.word	0x0800ea5c
 8002d4c:	0800ea64 	.word	0x0800ea64
 8002d50:	0800ea74 	.word	0x0800ea74
 8002d54:	0800ea7c 	.word	0x0800ea7c
 8002d58:	0800f1e0 	.word	0x0800f1e0
 8002d5c:	0800ea88 	.word	0x0800ea88
 8002d60:	0800eaa8 	.word	0x0800eaa8
 8002d64:	0800ef74 	.word	0x0800ef74
 8002d68:	66666667 	.word	0x66666667
 8002d6c:	68168169 	.word	0x68168169
	}

	// Send flag
	for(uint8_t i=0; i<4; i++)
	{
		ax25_send_flag(packet);
 8002d70:	a810      	add	r0, sp, #64	; 0x40
 8002d72:	f009 fcf5 	bl	800c760 <ax25_send_flag>
 8002d76:	a810      	add	r0, sp, #64	; 0x40
 8002d78:	f009 fcf2 	bl	800c760 <ax25_send_flag>
 8002d7c:	a810      	add	r0, sp, #64	; 0x40
 8002d7e:	f009 fcef 	bl	800c760 <ax25_send_flag>
 8002d82:	a810      	add	r0, sp, #64	; 0x40
 8002d84:	f009 fcec 	bl	800c760 <ax25_send_flag>
	}

	ax25_send_path(packet, APRS_DEST_CALLSIGN, APRS_DEST_SSID, false);		// Destination callsign
 8002d88:	2300      	movs	r3, #0
 8002d8a:	461a      	mov	r2, r3
 8002d8c:	4981      	ldr	r1, [pc, #516]	; (8002f94 <encode_ssdv+0x1734>)
 8002d8e:	a810      	add	r0, sp, #64	; 0x40
 8002d90:	f009 fd66 	bl	800c860 <ax25_send_path>
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign
 8002d94:	9b08      	ldr	r3, [sp, #32]
 8002d96:	9909      	ldr	r1, [sp, #36]	; 0x24
 8002d98:	f893 306c 	ldrb.w	r3, [r3, #108]	; 0x6c
 8002d9c:	fab3 f383 	clz	r3, r3
 8002da0:	464a      	mov	r2, r9
 8002da2:	095b      	lsrs	r3, r3, #5
 8002da4:	a810      	add	r0, sp, #64	; 0x40
 8002da6:	2500      	movs	r5, #0
 8002da8:	f009 fd5a 	bl	800c860 <ax25_send_path>
		if(path[i] == ',' || path[i] == 0) { // Found block in path
			if(!j) // Block empty
				break;

			// Filter Path until '-'
			tmp[j] = 0;
 8002dac:	f10d 0930 	add.w	r9, sp, #48	; 0x30

	ax25_send_path(packet, APRS_DEST_CALLSIGN, APRS_DEST_SSID, false);		// Destination callsign
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign

	// Parse path
	for(i=0, j=0; (path[i-1] != 0 || i == 0) && path != NULL; i++) {
 8002db0:	462b      	mov	r3, r5
 8002db2:	9409      	str	r4, [sp, #36]	; 0x24
 8002db4:	9906      	ldr	r1, [sp, #24]
 8002db6:	b2ea      	uxtb	r2, r5
 8002db8:	4411      	add	r1, r2
 8002dba:	f811 1c01 	ldrb.w	r1, [r1, #-1]
 8002dbe:	2900      	cmp	r1, #0
 8002dc0:	d17f      	bne.n	8002ec2 <encode_ssdv+0x1662>
 8002dc2:	2a00      	cmp	r2, #0
 8002dc4:	d07d      	beq.n	8002ec2 <encode_ssdv+0x1662>
			tmp[j++] = path[i];
		}
	}

	// Control field: 3 = APRS-UI frame
	send_byte(packet, 0x03);
 8002dc6:	2103      	movs	r1, #3
 8002dc8:	a810      	add	r0, sp, #64	; 0x40
 8002dca:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8002dcc:	4f72      	ldr	r7, [pc, #456]	; (8002f98 <encode_ssdv+0x1738>)
 8002dce:	f009 fcf7 	bl	800c7c0 <send_byte.lto_priv.140>
 8002dd2:	257b      	movs	r5, #123	; 0x7b

	// Protocol ID: 0xf0 = no layer 3 data
	send_byte(packet, 0xf0);
 8002dd4:	21f0      	movs	r1, #240	; 0xf0
 8002dd6:	a810      	add	r0, sp, #64	; 0x40
 8002dd8:	f009 fcf2 	bl	800c7c0 <send_byte.lto_priv.140>
 8002ddc:	4629      	mov	r1, r5
	}
}

void ax25_send_byte(ax25_t *packet, char byte)
{
	send_byte(packet, byte);
 8002dde:	a810      	add	r0, sp, #64	; 0x40
 8002de0:	f009 fcee 	bl	800c7c0 <send_byte.lto_priv.140>
}

void ax25_send_string(ax25_t *packet, const char *string)
{
	int i;
	for(i=0; string[i]; i++) {
 8002de4:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 8002de8:	2900      	cmp	r1, #0
 8002dea:	d1f8      	bne.n	8002dde <encode_ssdv+0x157e>
 8002dec:	460d      	mov	r5, r1
	}
}

void ax25_send_byte(ax25_t *packet, char byte)
{
	send_byte(packet, byte);
 8002dee:	a810      	add	r0, sp, #64	; 0x40
 8002df0:	2149      	movs	r1, #73	; 0x49
 8002df2:	f009 fce5 	bl	800c7c0 <send_byte.lto_priv.140>
	ax25_send_string(&packet, "{{");
	ax25_send_byte(&packet, packetType);

	// Encode message
	for(uint16_t i=0; i<size; i++)
 8002df6:	b154      	cbz	r4, 8002e0e <encode_ssdv+0x15ae>
 8002df8:	462b      	mov	r3, r5
 8002dfa:	3501      	adds	r5, #1
 8002dfc:	f81a 1003 	ldrb.w	r1, [sl, r3]
 8002e00:	b2ad      	uxth	r5, r5
 8002e02:	a810      	add	r0, sp, #64	; 0x40
 8002e04:	f009 fcdc 	bl	800c7c0 <send_byte.lto_priv.140>
 8002e08:	42ac      	cmp	r4, r5
 8002e0a:	462b      	mov	r3, r5
 8002e0c:	d8f5      	bhi.n	8002dfa <encode_ssdv+0x159a>
}

void ax25_send_footer(ax25_t *packet)
{
	// Save the crc so that it can be treated it atomically
	uint16_t final_crc = packet->crc;
 8002e0e:	f8bd 404c 	ldrh.w	r4, [sp, #76]	; 0x4c

	// Send CRC
	send_byte(packet, ~(final_crc & 0xff));
 8002e12:	43e1      	mvns	r1, r4
 8002e14:	b2c9      	uxtb	r1, r1
	final_crc >>= 8;
 8002e16:	0a24      	lsrs	r4, r4, #8
{
	// Save the crc so that it can be treated it atomically
	uint16_t final_crc = packet->crc;

	// Send CRC
	send_byte(packet, ~(final_crc & 0xff));
 8002e18:	a810      	add	r0, sp, #64	; 0x40
 8002e1a:	f009 fcd1 	bl	800c7c0 <send_byte.lto_priv.140>
	final_crc >>= 8;
	send_byte(packet, ~(final_crc & 0xff));
 8002e1e:	43e1      	mvns	r1, r4
 8002e20:	b2c9      	uxtb	r1, r1
 8002e22:	a810      	add	r0, sp, #64	; 0x40
 8002e24:	f009 fccc 	bl	800c7c0 <send_byte.lto_priv.140>

	packet->crc = final_crc;

	// Signal the end of frame
	ax25_send_flag(packet);
 8002e28:	a810      	add	r0, sp, #64	; 0x40
	// Send CRC
	send_byte(packet, ~(final_crc & 0xff));
	final_crc >>= 8;
	send_byte(packet, ~(final_crc & 0xff));

	packet->crc = final_crc;
 8002e2a:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c

	// Signal the end of frame
	ax25_send_flag(packet);
 8002e2e:	f009 fc97 	bl	800c760 <ax25_send_flag>

/**
  * Scrambling for 2GFSK
  */
void scramble(ax25_t *packet) {
	if(packet->mod != MOD_2GFSK)
 8002e32:	f89d 304e 	ldrb.w	r3, [sp, #78]	; 0x4e
 8002e36:	2b02      	cmp	r3, #2
 8002e38:	f000 81d8 	beq.w	80031ec <encode_ssdv+0x198c>
 8002e3c:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
/**
  * NRZ-I tone encoding (0: bit change, 1: no bit change)
  */
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 8002e40:	b33b      	cbz	r3, 8002e92 <encode_ssdv+0x1632>
 8002e42:	f04f 0c00 	mov.w	ip, #0
 8002e46:	4661      	mov	r1, ip
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
			ctone = !ctone;
		if(ctone) {
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 8002e48:	2701      	movs	r7, #1
 8002e4a:	4666      	mov	r6, ip
 8002e4c:	e005      	b.n	8002e5a <encode_ssdv+0x15fa>
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
			ctone = !ctone;
		if(ctone) {
			AX25_WRITE_BIT(packet->data, i);
 8002e4e:	5528      	strb	r0, [r5, r4]
/**
  * NRZ-I tone encoding (0: bit change, 1: no bit change)
  */
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 8002e50:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 8002e54:	3101      	adds	r1, #1
 8002e56:	4299      	cmp	r1, r3
 8002e58:	d21a      	bcs.n	8002e90 <encode_ssdv+0x1630>
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
 8002e5a:	08cc      	lsrs	r4, r1, #3
 8002e5c:	9d11      	ldr	r5, [sp, #68]	; 0x44
 8002e5e:	5d2a      	ldrb	r2, [r5, r4]
 8002e60:	f001 0307 	and.w	r3, r1, #7
 8002e64:	fa42 fe03 	asr.w	lr, r2, r3
 8002e68:	f01e 0f01 	tst.w	lr, #1
			ctone = !ctone;
		if(ctone) {
			AX25_WRITE_BIT(packet->data, i);
 8002e6c:	fa07 f003 	lsl.w	r0, r7, r3
 8002e70:	bf08      	it	eq
 8002e72:	f086 0601 	eoreq.w	r6, r6, #1
 8002e76:	4310      	orrs	r0, r2
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 8002e78:	fa07 f303 	lsl.w	r3, r7, r3
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		if(((packet->data[i >> 3] >> (i & 0x7)) & 0x1) == 0)
			ctone = !ctone;
		if(ctone) {
 8002e7c:	2e00      	cmp	r6, #0
 8002e7e:	d1e6      	bne.n	8002e4e <encode_ssdv+0x15ee>
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 8002e80:	ea22 0303 	bic.w	r3, r2, r3
 8002e84:	552b      	strb	r3, [r5, r4]
/**
  * NRZ-I tone encoding (0: bit change, 1: no bit change)
  */
void nrzi_encode(ax25_t *packet) {
	uint8_t ctone = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 8002e86:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 8002e8a:	3101      	adds	r1, #1
 8002e8c:	4299      	cmp	r1, r3
 8002e8e:	d3e4      	bcc.n	8002e5a <encode_ssdv+0x15fa>
 8002e90:	461e      	mov	r6, r3

				transmitOnRadio(&msg);
 8002e92:	4640      	mov	r0, r8
				// Deleting buffer
				for(uint16_t t=0; t<256; t++)
					pkt_base91[t] = 0;

				base91_encode(&pkt[1], pkt_base91, sizeof(pkt)-37); // Sync byte, CRC and FEC of SSDV not transmitted
				msg.bin_len = aprs_encode_experimental('I', msg.msg, msg.mod, &config->aprs_config, pkt_base91, strlen((char*)pkt_base91));
 8002e94:	f8c8 6200 	str.w	r6, [r8, #512]	; 0x200

				transmitOnRadio(&msg);
 8002e98:	f00b f912 	bl	800e0c0 <transmitOnRadio>
			default:
				TRACE_ERROR("IMG  > Unsupported protocol selected for module IMAGE");
		}

		// Packet spacing (delay)
		if(config->packet_spacing)
 8002e9c:	9b08      	ldr	r3, [sp, #32]
 8002e9e:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8002ea0:	2800      	cmp	r0, #0
 8002ea2:	f43e af35 	beq.w	8001d10 <encode_ssdv+0x4b0>
			chThdSleepMilliseconds(config->packet_spacing);
 8002ea6:	f242 7310 	movw	r3, #10000	; 0x2710
 8002eaa:	fb03 f000 	mul.w	r0, r3, r0
 8002eae:	4b3b      	ldr	r3, [pc, #236]	; (8002f9c <encode_ssdv+0x173c>)
 8002eb0:	f200 30e7 	addw	r0, r0, #999	; 0x3e7
 8002eb4:	fba3 3000 	umull	r3, r0, r3, r0
 8002eb8:	0980      	lsrs	r0, r0, #6
 8002eba:	f009 fa41 	bl	800c340 <chThdSleep>
 8002ebe:	f7fe bf27 	b.w	8001d10 <encode_ssdv+0x4b0>
	ax25_send_path(packet, APRS_DEST_CALLSIGN, APRS_DEST_SSID, false);		// Destination callsign
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign

	// Parse path
	for(i=0, j=0; (path[i-1] != 0 || i == 0) && path != NULL; i++) {
		if(path[i] == ',' || path[i] == 0) { // Found block in path
 8002ec2:	9906      	ldr	r1, [sp, #24]
 8002ec4:	f811 c002 	ldrb.w	ip, [r1, r2]
 8002ec8:	f1bc 0f2c 	cmp.w	ip, #44	; 0x2c
 8002ecc:	d008      	beq.n	8002ee0 <encode_ssdv+0x1680>
 8002ece:	f1bc 0f00 	cmp.w	ip, #0
 8002ed2:	d005      	beq.n	8002ee0 <encode_ssdv+0x1680>
			if(s != 0)
				ax25_send_path(packet, p, s, path[i] == 0);
			j = 0;

		} else {
			tmp[j++] = path[i];
 8002ed4:	1c5a      	adds	r2, r3, #1
 8002ed6:	f809 c003 	strb.w	ip, [r9, r3]
 8002eda:	b2d3      	uxtb	r3, r2
 8002edc:	3501      	adds	r5, #1
 8002ede:	e769      	b.n	8002db4 <encode_ssdv+0x1554>
	ax25_send_path(packet, callsign, ssid, path[0] == 0 || path == NULL);	// Source callsign

	// Parse path
	for(i=0, j=0; (path[i-1] != 0 || i == 0) && path != NULL; i++) {
		if(path[i] == ',' || path[i] == 0) { // Found block in path
			if(!j) // Block empty
 8002ee0:	2b00      	cmp	r3, #0
 8002ee2:	f43f af70 	beq.w	8002dc6 <encode_ssdv+0x1566>
				break;

			// Filter Path until '-'
			tmp[j] = 0;
 8002ee6:	2200      	movs	r2, #0
 8002ee8:	f04f 0100 	mov.w	r1, #0
 8002eec:	f809 1003 	strb.w	r1, [r9, r3]
 8002ef0:	4610      	mov	r0, r2
 8002ef2:	f10d 072f 	add.w	r7, sp, #47	; 0x2f
 8002ef6:	f10d 0437 	add.w	r4, sp, #55	; 0x37
 8002efa:	e004      	b.n	8002f06 <encode_ssdv+0x16a6>
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
 8002efc:	b2d0      	uxtb	r0, r2
 8002efe:	4283      	cmp	r3, r0
				p[t] = tmp[t];
 8002f00:	f804 1f01 	strb.w	r1, [r4, #1]!

			// Filter Path until '-'
			tmp[j] = 0;
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
 8002f04:	d914      	bls.n	8002f30 <encode_ssdv+0x16d0>
 8002f06:	f817 1f01 	ldrb.w	r1, [r7, #1]!
 8002f0a:	292d      	cmp	r1, #45	; 0x2d
 8002f0c:	4696      	mov	lr, r2
 8002f0e:	f102 0201 	add.w	r2, r2, #1
 8002f12:	d1f3      	bne.n	8002efc <encode_ssdv+0x169c>
				p[t] = tmp[t];
			p[t] = 0;
 8002f14:	ab0e      	add	r3, sp, #56	; 0x38
 8002f16:	f04f 0200 	mov.w	r2, #0
 8002f1a:	f803 200e 	strb.w	r2, [r3, lr]

			// Filter TTL
			uint8_t s = ((tmp[t] == '-' ? tmp[++t] : tmp[--t])-48) & 0x7;
 8002f1e:	1c43      	adds	r3, r0, #1
 8002f20:	b2db      	uxtb	r3, r3
 8002f22:	f819 2003 	ldrb.w	r2, [r9, r3]
 8002f26:	f002 0207 	and.w	r2, r2, #7

			if(s != 0)
 8002f2a:	b972      	cbnz	r2, 8002f4a <encode_ssdv+0x16ea>
				ax25_send_path(packet, p, s, path[i] == 0);
			j = 0;
 8002f2c:	2300      	movs	r3, #0
 8002f2e:	e7d5      	b.n	8002edc <encode_ssdv+0x167c>
			for(t=0; t<j && tmp[t] != '-'; t++)
				p[t] = tmp[t];
			p[t] = 0;

			// Filter TTL
			uint8_t s = ((tmp[t] == '-' ? tmp[++t] : tmp[--t])-48) & 0x7;
 8002f30:	f819 3000 	ldrb.w	r3, [r9, r0]
			tmp[j] = 0;
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
				p[t] = tmp[t];
			p[t] = 0;
 8002f34:	aa0e      	add	r2, sp, #56	; 0x38
 8002f36:	f04f 0400 	mov.w	r4, #0

			// Filter TTL
			uint8_t s = ((tmp[t] == '-' ? tmp[++t] : tmp[--t])-48) & 0x7;
 8002f3a:	2b2d      	cmp	r3, #45	; 0x2d
			tmp[j] = 0;
			char p[8];
			uint8_t t;
			for(t=0; t<j && tmp[t] != '-'; t++)
				p[t] = tmp[t];
			p[t] = 0;
 8002f3c:	5414      	strb	r4, [r2, r0]

			// Filter TTL
			uint8_t s = ((tmp[t] == '-' ? tmp[++t] : tmp[--t])-48) & 0x7;
 8002f3e:	bf18      	it	ne
 8002f40:	f001 0207 	andne.w	r2, r1, #7
 8002f44:	d0eb      	beq.n	8002f1e <encode_ssdv+0x16be>

			if(s != 0)
 8002f46:	2a00      	cmp	r2, #0
 8002f48:	d0f0      	beq.n	8002f2c <encode_ssdv+0x16cc>
				ax25_send_path(packet, p, s, path[i] == 0);
 8002f4a:	fabc f38c 	clz	r3, ip
 8002f4e:	095b      	lsrs	r3, r3, #5
 8002f50:	a90e      	add	r1, sp, #56	; 0x38
 8002f52:	a810      	add	r0, sp, #64	; 0x40
 8002f54:	f009 fc84 	bl	800c860 <ax25_send_path>
 8002f58:	e7e8      	b.n	8002f2c <encode_ssdv+0x16cc>
				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
				msg.fsk_config = &(config->fsk_config);
 8002f5a:	9b08      	ldr	r3, [sp, #32]

				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
 8002f5c:	2001      	movs	r0, #1
				msg.fsk_config = &(config->fsk_config);
 8002f5e:	3350      	adds	r3, #80	; 0x50

				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
 8002f60:	f888 0209 	strb.w	r0, [r8, #521]	; 0x209
				msg.fsk_config = &(config->fsk_config);

				memcpy(msg.msg, pkt, sizeof(pkt));
 8002f64:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002f68:	a914      	add	r1, sp, #80	; 0x50
 8002f6a:	4640      	mov	r0, r8
				transmitOnRadio(&msg);
				break;

			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
				msg.fsk_config = &(config->fsk_config);
 8002f6c:	f8c8 3210 	str.w	r3, [r8, #528]	; 0x210

				memcpy(msg.msg, pkt, sizeof(pkt));
 8002f70:	f7fe f9ee 	bl	8001350 <memcpy>
				msg.bin_len = 8*sizeof(pkt);
 8002f74:	f44f 6300 	mov.w	r3, #2048	; 0x800

				transmitOnRadio(&msg);
 8002f78:	4640      	mov	r0, r8
			case PROT_SSDV_2FSK:
				msg.mod = MOD_2FSK;
				msg.fsk_config = &(config->fsk_config);

				memcpy(msg.msg, pkt, sizeof(pkt));
				msg.bin_len = 8*sizeof(pkt);
 8002f7a:	f8c8 3200 	str.w	r3, [r8, #512]	; 0x200

				transmitOnRadio(&msg);
 8002f7e:	f00b f89f 	bl	800e0c0 <transmitOnRadio>
 8002f82:	f7fe bec0 	b.w	8001d06 <encode_ssdv+0x4a6>

		case FREQ_STATIC: // Static frequency
			return config->hz;

		default:
			return 0;
 8002f86:	2300      	movs	r3, #0
 8002f88:	f7fe be71 	b.w	8001c6e <encode_ssdv+0x40e>
			if(!ret) // Use default frequency
				return config->hz;
			return ret;

		case FREQ_STATIC: // Static frequency
			return config->hz;
 8002f8c:	9b08      	ldr	r3, [sp, #32]
 8002f8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002f90:	f7fe be6d 	b.w	8001c6e <encode_ssdv+0x40e>
 8002f94:	0800edd4 	.word	0x0800edd4
 8002f98:	0800eddc 	.word	0x0800eddc
 8002f9c:	10624dd3 	.word	0x10624dd3
	
	case J_SOS:
		TRACE_INFO("SSDV > Components: %i", d[0]);
		
		/* The image must have 3 components (Y'Cb'Cr) */
		if(d[0] != 3)
 8002fa0:	2300      	movs	r3, #0
			return(SSDV_ERROR);
		}
		
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
 8002fa2:	005e      	lsls	r6, r3, #1
 8002fa4:	3601      	adds	r6, #1
			if(dh[0] != i + 1)
 8002fa6:	3301      	adds	r3, #1
 8002fa8:	5da5      	ldrb	r5, [r4, r6]
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > Component %i DHT: %02X", dh[0], dh[1]);
 8002faa:	48ad      	ldr	r0, [pc, #692]	; (8003260 <encode_ssdv+0x1a00>)
		}
		
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
			if(dh[0] != i + 1)
 8002fac:	429d      	cmp	r5, r3
			return(SSDV_ERROR);
		}
		
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
 8002fae:	eb04 0706 	add.w	r7, r4, r6
			if(dh[0] != i + 1)
 8002fb2:	f040 8255 	bne.w	8003460 <encode_ssdv+0x1c00>
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > Component %i DHT: %02X", dh[0], dh[1]);
 8002fb6:	f009 f8f3 	bl	800c1a0 <chMtxLock>
 8002fba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002fbe:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
 8002fc2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002fc4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8002fc6:	4ba7      	ldr	r3, [pc, #668]	; (8003264 <encode_ssdv+0x1a04>)
 8002fc8:	49a7      	ldr	r1, [pc, #668]	; (8003268 <encode_ssdv+0x1a08>)
 8002fca:	fb0e f000 	mul.w	r0, lr, r0
 8002fce:	fba3 3000 	umull	r3, r0, r3, r0
 8002fd2:	4ba6      	ldr	r3, [pc, #664]	; (800326c <encode_ssdv+0x1a0c>)
 8002fd4:	0b40      	lsrs	r0, r0, #13
 8002fd6:	fba3 3c00 	umull	r3, ip, r3, r0
 8002fda:	4ba2      	ldr	r3, [pc, #648]	; (8003264 <encode_ssdv+0x1a04>)
 8002fdc:	fba3 3202 	umull	r3, r2, r3, r2
 8002fe0:	ea4f 139c 	mov.w	r3, ip, lsr #6
 8002fe4:	fb0e 0313 	mls	r3, lr, r3, r0
 8002fe8:	0b52      	lsrs	r2, r2, #13
 8002fea:	48a1      	ldr	r0, [pc, #644]	; (8003270 <encode_ssdv+0x1a10>)
 8002fec:	f007 fb50 	bl	800a690 <chprintf.constprop.26>
 8002ff0:	4aa0      	ldr	r2, [pc, #640]	; (8003274 <encode_ssdv+0x1a14>)
 8002ff2:	49a1      	ldr	r1, [pc, #644]	; (8003278 <encode_ssdv+0x1a18>)
 8002ff4:	489e      	ldr	r0, [pc, #632]	; (8003270 <encode_ssdv+0x1a10>)
 8002ff6:	f007 fb4b 	bl	800a690 <chprintf.constprop.26>
 8002ffa:	f240 23f9 	movw	r3, #761	; 0x2f9
 8002ffe:	4a9f      	ldr	r2, [pc, #636]	; (800327c <encode_ssdv+0x1a1c>)
 8003000:	499f      	ldr	r1, [pc, #636]	; (8003280 <encode_ssdv+0x1a20>)
 8003002:	489b      	ldr	r0, [pc, #620]	; (8003270 <encode_ssdv+0x1a10>)
 8003004:	f007 fb44 	bl	800a690 <chprintf.constprop.26>
 8003008:	499e      	ldr	r1, [pc, #632]	; (8003284 <encode_ssdv+0x1a24>)
 800300a:	4899      	ldr	r0, [pc, #612]	; (8003270 <encode_ssdv+0x1a10>)
 800300c:	f007 fb40 	bl	800a690 <chprintf.constprop.26>
 8003010:	787b      	ldrb	r3, [r7, #1]
 8003012:	5da2      	ldrb	r2, [r4, r6]
 8003014:	499c      	ldr	r1, [pc, #624]	; (8003288 <encode_ssdv+0x1a28>)
 8003016:	4896      	ldr	r0, [pc, #600]	; (8003270 <encode_ssdv+0x1a10>)
 8003018:	f007 fb3a 	bl	800a690 <chprintf.constprop.26>
 800301c:	499b      	ldr	r1, [pc, #620]	; (800328c <encode_ssdv+0x1a2c>)
 800301e:	4894      	ldr	r0, [pc, #592]	; (8003270 <encode_ssdv+0x1a10>)
 8003020:	f007 fb36 	bl	800a690 <chprintf.constprop.26>
 8003024:	488e      	ldr	r0, [pc, #568]	; (8003260 <encode_ssdv+0x1a00>)
 8003026:	f006 faab 	bl	8009580 <chMtxUnlock>
		{
			TRACE_ERROR("SSDV > The image must have 3 components");
			return(SSDV_ERROR);
		}
		
		for(i = 0; i < 3; i++)
 800302a:	2d03      	cmp	r5, #3
 800302c:	462b      	mov	r3, r5
 800302e:	d1b8      	bne.n	8002fa2 <encode_ssdv+0x1742>
		
		/* Do I need to look at the last three bytes of the SOS data? */
		/* 00 3F 00 */
		
		/* Verify all of the DQT and DHT tables where loaded */
		if(!s->sdqt[0] || !s->sdqt[1])
 8003030:	f8db 22c4 	ldr.w	r2, [fp, #708]	; 0x2c4
 8003034:	2a00      	cmp	r2, #0
 8003036:	f000 8193 	beq.w	8003360 <encode_ssdv+0x1b00>
 800303a:	f8db 22c8 	ldr.w	r2, [fp, #712]	; 0x2c8
 800303e:	2a00      	cmp	r2, #0
 8003040:	f000 818e 	beq.w	8003360 <encode_ssdv+0x1b00>
		{
			TRACE_ERROR("SSDV > The image is missing one or more DQT tables");
			return(SSDV_ERROR);
		}
		
		if(!s->sdht[0][0] || !s->sdht[0][1] ||
 8003044:	f8db 22b4 	ldr.w	r2, [fp, #692]	; 0x2b4
 8003048:	b152      	cbz	r2, 8003060 <encode_ssdv+0x1800>
 800304a:	f8db 22b8 	ldr.w	r2, [fp, #696]	; 0x2b8
 800304e:	b13a      	cbz	r2, 8003060 <encode_ssdv+0x1800>
 8003050:	f8db 22bc 	ldr.w	r2, [fp, #700]	; 0x2bc
 8003054:	b122      	cbz	r2, 8003060 <encode_ssdv+0x1800>
		   !s->sdht[1][0] || !s->sdht[1][1])
 8003056:	f8db 22c0 	ldr.w	r2, [fp, #704]	; 0x2c0
 800305a:	2a00      	cmp	r2, #0
 800305c:	f47e afbb 	bne.w	8001fd6 <encode_ssdv+0x776>
		{
			TRACE_ERROR("SSDV > The image is missing one or more DHT tables");
 8003060:	487f      	ldr	r0, [pc, #508]	; (8003260 <encode_ssdv+0x1a00>)
 8003062:	4e80      	ldr	r6, [pc, #512]	; (8003264 <encode_ssdv+0x1a04>)
 8003064:	f009 f89c 	bl	800c1a0 <chMtxLock>
 8003068:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800306c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8003070:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003072:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8003074:	4b7d      	ldr	r3, [pc, #500]	; (800326c <encode_ssdv+0x1a0c>)
 8003076:	497c      	ldr	r1, [pc, #496]	; (8003268 <encode_ssdv+0x1a08>)
 8003078:	487d      	ldr	r0, [pc, #500]	; (8003270 <encode_ssdv+0x1a10>)
 800307a:	fb05 f404 	mul.w	r4, r5, r4
 800307e:	fba6 7404 	umull	r7, r4, r6, r4
 8003082:	0b64      	lsrs	r4, r4, #13
 8003084:	fba3 7304 	umull	r7, r3, r3, r4
 8003088:	fba6 6202 	umull	r6, r2, r6, r2
 800308c:	099b      	lsrs	r3, r3, #6
 800308e:	fb05 4313 	mls	r3, r5, r3, r4
 8003092:	0b52      	lsrs	r2, r2, #13
 8003094:	f007 fafc 	bl	800a690 <chprintf.constprop.26>
 8003098:	4a7d      	ldr	r2, [pc, #500]	; (8003290 <encode_ssdv+0x1a30>)
 800309a:	4977      	ldr	r1, [pc, #476]	; (8003278 <encode_ssdv+0x1a18>)
 800309c:	4874      	ldr	r0, [pc, #464]	; (8003270 <encode_ssdv+0x1a10>)
 800309e:	f007 faf7 	bl	800a690 <chprintf.constprop.26>
 80030a2:	f240 3309 	movw	r3, #777	; 0x309
 80030a6:	4a75      	ldr	r2, [pc, #468]	; (800327c <encode_ssdv+0x1a1c>)
 80030a8:	4975      	ldr	r1, [pc, #468]	; (8003280 <encode_ssdv+0x1a20>)
 80030aa:	4871      	ldr	r0, [pc, #452]	; (8003270 <encode_ssdv+0x1a10>)
 80030ac:	f007 faf0 	bl	800a690 <chprintf.constprop.26>
 80030b0:	4974      	ldr	r1, [pc, #464]	; (8003284 <encode_ssdv+0x1a24>)
 80030b2:	486f      	ldr	r0, [pc, #444]	; (8003270 <encode_ssdv+0x1a10>)
 80030b4:	f007 faec 	bl	800a690 <chprintf.constprop.26>
 80030b8:	4976      	ldr	r1, [pc, #472]	; (8003294 <encode_ssdv+0x1a34>)
 80030ba:	486d      	ldr	r0, [pc, #436]	; (8003270 <encode_ssdv+0x1a10>)
 80030bc:	f007 fae8 	bl	800a690 <chprintf.constprop.26>
 80030c0:	4972      	ldr	r1, [pc, #456]	; (800328c <encode_ssdv+0x1a2c>)
 80030c2:	486b      	ldr	r0, [pc, #428]	; (8003270 <encode_ssdv+0x1a10>)
 80030c4:	f007 fae4 	bl	800a690 <chprintf.constprop.26>
 80030c8:	4865      	ldr	r0, [pc, #404]	; (8003260 <encode_ssdv+0x1a00>)
 80030ca:	f006 fa59 	bl	8009580 <chMtxUnlock>
 80030ce:	f240 3109 	movw	r1, #777	; 0x309
 80030d2:	486a      	ldr	r0, [pc, #424]	; (800327c <encode_ssdv+0x1a1c>)
 80030d4:	f009 fc54 	bl	800c980 <log_error>
 80030d8:	f7ff b82d 	b.w	8002136 <encode_ssdv+0x8d6>
					encode_rs_8(&s->out[1], &s->out[i], 0);
				
				s->packet_id++;
				
				/* Have we reached the end of the image data? */
				if(r == SSDV_EOI) s->state = S_EOI;
 80030dc:	2305      	movs	r3, #5
 80030de:	f88b 3049 	strb.w	r3, [fp, #73]	; 0x49
 80030e2:	f7fe bdb4 	b.w	8001c4e <encode_ssdv+0x3ee>
				s->out[i++] = (x >> 8) & 0xFF;
				s->out[i++] = x & 0xFF;
				
				/* Generate the RS codes */
				if(s->type == SSDV_TYPE_NORMAL)
					encode_rs_8(&s->out[1], &s->out[i], 0);
 80030e6:	f8db 5034 	ldr.w	r5, [fp, #52]	; 0x34
 80030ea:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 800329c <encode_ssdv+0x1a3c>
 80030ee:	3705      	adds	r7, #5
 80030f0:	fa55 f787 	uxtab	r7, r5, r7
void encode_rs_8(uint8_t *data, uint8_t *parity, int pad)
{
	int i, j;
	uint8_t feedback;
	
	memset(parity, 0, NROOTS * sizeof(uint8_t));
 80030f4:	4638      	mov	r0, r7
 80030f6:	2220      	movs	r2, #32
 80030f8:	f00b fada 	bl	800e6b0 <memset>
 80030fc:	1c7b      	adds	r3, r7, #1
 80030fe:	46a9      	mov	r9, r5
 8003100:	f105 0adf 	add.w	sl, r5, #223	; 0xdf
 8003104:	9306      	str	r3, [sp, #24]
	
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
 8003106:	f819 2f01 	ldrb.w	r2, [r9, #1]!
 800310a:	783b      	ldrb	r3, [r7, #0]
 800310c:	4053      	eors	r3, r2
 800310e:	4a62      	ldr	r2, [pc, #392]	; (8003298 <encode_ssdv+0x1a38>)
 8003110:	5cd5      	ldrb	r5, [r2, r3]
		if(feedback != A0) /* feedback term is non-zero */
 8003112:	2dff      	cmp	r5, #255	; 0xff
 8003114:	d023      	beq.n	800315e <encode_ssdv+0x18fe>
 8003116:	f8df c190 	ldr.w	ip, [pc, #400]	; 80032a8 <encode_ssdv+0x1a48>
 800311a:	46be      	mov	lr, r7
 800311c:	4638      	mov	r0, r7
 800311e:	23f9      	movs	r3, #249	; 0xf9
 8003120:	2101      	movs	r1, #1
 8003122:	e001      	b.n	8003128 <encode_ssdv+0x18c8>
 8003124:	f81c 3d01 	ldrb.w	r3, [ip, #-1]!
		{
			for(j = 1; j < NROOTS; j++)
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
 8003128:	f81e 2f01 	ldrb.w	r2, [lr, #1]!
 800312c:	442b      	add	r3, r5
0x00,
};

static inline int mod255(int x)
{
	while(x >= 255)
 800312e:	2bfe      	cmp	r3, #254	; 0xfe
	{
		x -= 255;
 8003130:	bfc8      	it	gt
 8003132:	3bff      	subgt	r3, #255	; 0xff
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
		{
			for(j = 1; j < NROOTS; j++)
 8003134:	3101      	adds	r1, #1
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
 8003136:	f818 3003 	ldrb.w	r3, [r8, r3]
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
		{
			for(j = 1; j < NROOTS; j++)
 800313a:	2920      	cmp	r1, #32
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
 800313c:	ea83 0302 	eor.w	r3, r3, r2
 8003140:	f800 3f01 	strb.w	r3, [r0, #1]!
	for(i = 0; i < NN - NROOTS - pad; i++)
	{
		feedback = INDEX_OF[data[i] ^ parity[0]];
		if(feedback != A0) /* feedback term is non-zero */
		{
			for(j = 1; j < NROOTS; j++)
 8003144:	d1ee      	bne.n	8003124 <encode_ssdv+0x18c4>
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
		}
		
		/* Shift */
		memmove(&parity[0], &parity[1], sizeof(uint8_t) * (NROOTS - 1));
 8003146:	221f      	movs	r2, #31
 8003148:	9906      	ldr	r1, [sp, #24]
 800314a:	4638      	mov	r0, r7
 800314c:	f00b fa4c 	bl	800e5e8 <memmove>
		if(feedback != A0)
			parity[NROOTS - 1] = ALPHA_TO[mod255(feedback + GENPOLY[0])];
 8003150:	4b52      	ldr	r3, [pc, #328]	; (800329c <encode_ssdv+0x1a3c>)
 8003152:	5d5b      	ldrb	r3, [r3, r5]
 8003154:	77fb      	strb	r3, [r7, #31]
	int i, j;
	uint8_t feedback;
	
	memset(parity, 0, NROOTS * sizeof(uint8_t));
	
	for(i = 0; i < NN - NROOTS - pad; i++)
 8003156:	45d1      	cmp	r9, sl
 8003158:	d1d5      	bne.n	8003106 <encode_ssdv+0x18a6>
 800315a:	f7fe bd6f 	b.w	8001c3c <encode_ssdv+0x3dc>
			for(j = 1; j < NROOTS; j++)
				parity[j] ^= ALPHA_TO[mod255(feedback + GENPOLY[NROOTS - j])];
		}
		
		/* Shift */
		memmove(&parity[0], &parity[1], sizeof(uint8_t) * (NROOTS - 1));
 800315e:	221f      	movs	r2, #31
 8003160:	9906      	ldr	r1, [sp, #24]
 8003162:	4638      	mov	r0, r7
 8003164:	f00b fa40 	bl	800e5e8 <memmove>
		if(feedback != A0)
			parity[NROOTS - 1] = ALPHA_TO[mod255(feedback + GENPOLY[0])];
		else
			parity[NROOTS - 1] = 0;
 8003168:	2300      	movs	r3, #0
 800316a:	77fb      	strb	r3, [r7, #31]
 800316c:	e7f3      	b.n	8003156 <encode_ssdv+0x18f6>

	switch(config->type) {
		case FREQ_DYNAMIC: // Dynamic frequency determination
			fptr = config->method;
			uint32_t ret = (*fptr)();
			if(!ret) // Use default frequency
 800316e:	4603      	mov	r3, r0
 8003170:	f7fe bd7d 	b.w	8001c6e <encode_ssdv+0x40e>
			TRACE_ERROR("SSDV > The image must have a precision of 8");
			return(SSDV_ERROR);
		}
		
		/* The image must have 3 components (Y'Cb'Cr) */
		if(d[5] != 3)
 8003174:	7963      	ldrb	r3, [r4, #5]
 8003176:	2b03      	cmp	r3, #3
 8003178:	f000 8098 	beq.w	80032ac <encode_ssdv+0x1a4c>
		{
			TRACE_ERROR("SSDV > The image must have 3 components");
 800317c:	4838      	ldr	r0, [pc, #224]	; (8003260 <encode_ssdv+0x1a00>)
 800317e:	f009 f80f 	bl	800c1a0 <chMtxLock>
 8003182:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8003184:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8003186:	4938      	ldr	r1, [pc, #224]	; (8003268 <encode_ssdv+0x1a08>)
 8003188:	4839      	ldr	r0, [pc, #228]	; (8003270 <encode_ssdv+0x1a10>)
 800318a:	fb07 f303 	mul.w	r3, r7, r3
 800318e:	fba8 4303 	umull	r4, r3, r8, r3
 8003192:	0b5b      	lsrs	r3, r3, #13
 8003194:	fba9 5403 	umull	r5, r4, r9, r3
 8003198:	09a4      	lsrs	r4, r4, #6
 800319a:	fba8 5202 	umull	r5, r2, r8, r2
 800319e:	fb07 3314 	mls	r3, r7, r4, r3
 80031a2:	0b52      	lsrs	r2, r2, #13
 80031a4:	f007 fa74 	bl	800a690 <chprintf.constprop.26>
 80031a8:	4a39      	ldr	r2, [pc, #228]	; (8003290 <encode_ssdv+0x1a30>)
 80031aa:	4933      	ldr	r1, [pc, #204]	; (8003278 <encode_ssdv+0x1a18>)
 80031ac:	4830      	ldr	r0, [pc, #192]	; (8003270 <encode_ssdv+0x1a10>)
 80031ae:	f007 fa6f 	bl	800a690 <chprintf.constprop.26>
 80031b2:	f240 239d 	movw	r3, #669	; 0x29d
 80031b6:	4a31      	ldr	r2, [pc, #196]	; (800327c <encode_ssdv+0x1a1c>)
 80031b8:	4931      	ldr	r1, [pc, #196]	; (8003280 <encode_ssdv+0x1a20>)
 80031ba:	482d      	ldr	r0, [pc, #180]	; (8003270 <encode_ssdv+0x1a10>)
 80031bc:	f007 fa68 	bl	800a690 <chprintf.constprop.26>
 80031c0:	4930      	ldr	r1, [pc, #192]	; (8003284 <encode_ssdv+0x1a24>)
 80031c2:	482b      	ldr	r0, [pc, #172]	; (8003270 <encode_ssdv+0x1a10>)
 80031c4:	f007 fa64 	bl	800a690 <chprintf.constprop.26>
 80031c8:	4935      	ldr	r1, [pc, #212]	; (80032a0 <encode_ssdv+0x1a40>)
 80031ca:	4829      	ldr	r0, [pc, #164]	; (8003270 <encode_ssdv+0x1a10>)
 80031cc:	f007 fa60 	bl	800a690 <chprintf.constprop.26>
 80031d0:	492e      	ldr	r1, [pc, #184]	; (800328c <encode_ssdv+0x1a2c>)
 80031d2:	4827      	ldr	r0, [pc, #156]	; (8003270 <encode_ssdv+0x1a10>)
 80031d4:	f007 fa5c 	bl	800a690 <chprintf.constprop.26>
 80031d8:	4821      	ldr	r0, [pc, #132]	; (8003260 <encode_ssdv+0x1a00>)
 80031da:	f006 f9d1 	bl	8009580 <chMtxUnlock>
 80031de:	f240 219d 	movw	r1, #669	; 0x29d
 80031e2:	4826      	ldr	r0, [pc, #152]	; (800327c <encode_ssdv+0x1a1c>)
 80031e4:	f009 fbcc 	bl	800c980 <log_error>
 80031e8:	f7fe bfa5 	b.w	8002136 <encode_ssdv+0x8d6>
void scramble(ax25_t *packet) {
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
 80031ec:	4f2d      	ldr	r7, [pc, #180]	; (80032a4 <encode_ssdv+0x1a44>)
	for(uint32_t i=0; i<packet->size; i++) {
 80031ee:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
void scramble(ax25_t *packet) {
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
 80031f2:	2000      	movs	r0, #0
 80031f4:	6038      	str	r0, [r7, #0]
	for(uint32_t i=0; i<packet->size; i++) {
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	f43f ae4b 	beq.w	8002e92 <encode_ssdv+0x1632>
 80031fc:	4604      	mov	r4, r0
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 80031fe:	f04f 0e01 	mov.w	lr, #1
 8003202:	e006      	b.n	8003212 <encode_ssdv+0x19b2>
	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
			AX25_WRITE_BIT(packet->data, i);
 8003204:	f80c 9005 	strb.w	r9, [ip, r5]
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 8003208:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 800320c:	3401      	adds	r4, #1
 800320e:	429c      	cmp	r4, r3
 8003210:	d223      	bcs.n	800325a <encode_ssdv+0x19fa>
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
 8003212:	08e5      	lsrs	r5, r4, #3
 8003214:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
 8003218:	f81c 2005 	ldrb.w	r2, [ip, r5]
 800321c:	f004 0107 	and.w	r1, r4, #7
		packet->crc = packet->crc >> 1;
}

uint32_t lfsr;
uint8_t scramble_bit(uint8_t _in) {
	uint8_t x = (_in ^ (lfsr >> 16) ^ (lfsr >> 11)) & 1;
 8003220:	ea4f 29d0 	mov.w	r9, r0, lsr #11
 8003224:	ea89 4910 	eor.w	r9, r9, r0, lsr #16
 8003228:	fa42 f301 	asr.w	r3, r2, r1
 800322c:	ea89 0303 	eor.w	r3, r9, r3
 8003230:	f003 0301 	and.w	r3, r3, #1
	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
			AX25_WRITE_BIT(packet->data, i);
 8003234:	fa0e f901 	lsl.w	r9, lr, r1
 8003238:	ea49 0902 	orr.w	r9, r9, r2
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 800323c:	fa0e f101 	lsl.w	r1, lr, r1
}

uint32_t lfsr;
uint8_t scramble_bit(uint8_t _in) {
	uint8_t x = (_in ^ (lfsr >> 16) ^ (lfsr >> 11)) & 1;
	lfsr = (lfsr << 1) | (x & 1);
 8003240:	ea43 0040 	orr.w	r0, r3, r0, lsl #1

	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
		uint8_t bit = scramble_bit((packet->data[i >> 3] >> (i & 0x7)) & 0x1);
		if(bit) {
 8003244:	2b00      	cmp	r3, #0
 8003246:	d1dd      	bne.n	8003204 <encode_ssdv+0x19a4>
			AX25_WRITE_BIT(packet->data, i);
		} else {
			AX25_CLEAR_BIT(packet->data, i);
 8003248:	ea22 0201 	bic.w	r2, r2, r1
 800324c:	f80c 2005 	strb.w	r2, [ip, r5]
	if(packet->mod != MOD_2GFSK)
		return; // Scrambling not necessary

	// Scramble
	lfsr = 0;
	for(uint32_t i=0; i<packet->size; i++) {
 8003250:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 8003254:	3401      	adds	r4, #1
 8003256:	429c      	cmp	r4, r3
 8003258:	d3db      	bcc.n	8003212 <encode_ssdv+0x19b2>
 800325a:	6038      	str	r0, [r7, #0]
 800325c:	e5f0      	b.n	8002e40 <encode_ssdv+0x15e0>
 800325e:	bf00      	nop
 8003260:	2001b720 	.word	0x2001b720
 8003264:	d1b71759 	.word	0xd1b71759
 8003268:	0800ea50 	.word	0x0800ea50
 800326c:	10624dd3 	.word	0x10624dd3
 8003270:	2001ac28 	.word	0x2001ac28
 8003274:	0800f1dc 	.word	0x0800f1dc
 8003278:	0800ea64 	.word	0x0800ea64
 800327c:	0800eabb 	.word	0x0800eabb
 8003280:	0800ea7c 	.word	0x0800ea7c
 8003284:	0800f1e0 	.word	0x0800f1e0
 8003288:	0800ed00 	.word	0x0800ed00
 800328c:	0800eaa8 	.word	0x0800eaa8
 8003290:	0800ea5c 	.word	0x0800ea5c
 8003294:	0800ed54 	.word	0x0800ed54
 8003298:	0800ee74 	.word	0x0800ee74
 800329c:	0800efd0 	.word	0x0800efd0
 80032a0:	0800eb3c 	.word	0x0800eb3c
 80032a4:	20000808 	.word	0x20000808
 80032a8:	0800ea4b 	.word	0x0800ea4b
			return(SSDV_ERROR);
		}
		
		/* Maximum image is 4080x4080 */
		if(s->width > 4080 || s->height > 4080)
 80032ac:	f8bb 2006 	ldrh.w	r2, [fp, #6]
 80032b0:	f5b2 6f7f 	cmp.w	r2, #4080	; 0xff0
 80032b4:	d805      	bhi.n	80032c2 <encode_ssdv+0x1a62>
 80032b6:	f8bb 3008 	ldrh.w	r3, [fp, #8]
 80032ba:	f5b3 6f7f 	cmp.w	r3, #4080	; 0xff0
 80032be:	f240 8093 	bls.w	80033e8 <encode_ssdv+0x1b88>
		{
			TRACE_ERROR("SSDV > The image is too big. Maximum resolution is 4080x4080");
 80032c2:	48b8      	ldr	r0, [pc, #736]	; (80035a4 <encode_ssdv+0x1d44>)
 80032c4:	4eb8      	ldr	r6, [pc, #736]	; (80035a8 <encode_ssdv+0x1d48>)
 80032c6:	f008 ff6b 	bl	800c1a0 <chMtxLock>
 80032ca:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80032ce:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 80032d2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80032d4:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 80032d6:	4bb5      	ldr	r3, [pc, #724]	; (80035ac <encode_ssdv+0x1d4c>)
 80032d8:	49b5      	ldr	r1, [pc, #724]	; (80035b0 <encode_ssdv+0x1d50>)
 80032da:	48b6      	ldr	r0, [pc, #728]	; (80035b4 <encode_ssdv+0x1d54>)
 80032dc:	fb05 f404 	mul.w	r4, r5, r4
 80032e0:	fba6 7404 	umull	r7, r4, r6, r4
 80032e4:	0b64      	lsrs	r4, r4, #13
 80032e6:	fba3 7304 	umull	r7, r3, r3, r4
 80032ea:	fba6 6202 	umull	r6, r2, r6, r2
 80032ee:	099b      	lsrs	r3, r3, #6
 80032f0:	fb05 4313 	mls	r3, r5, r3, r4
 80032f4:	0b52      	lsrs	r2, r2, #13
 80032f6:	f007 f9cb 	bl	800a690 <chprintf.constprop.26>
 80032fa:	4aaf      	ldr	r2, [pc, #700]	; (80035b8 <encode_ssdv+0x1d58>)
 80032fc:	49af      	ldr	r1, [pc, #700]	; (80035bc <encode_ssdv+0x1d5c>)
 80032fe:	48ad      	ldr	r0, [pc, #692]	; (80035b4 <encode_ssdv+0x1d54>)
 8003300:	f007 f9c6 	bl	800a690 <chprintf.constprop.26>
 8003304:	f44f 7329 	mov.w	r3, #676	; 0x2a4
 8003308:	4aad      	ldr	r2, [pc, #692]	; (80035c0 <encode_ssdv+0x1d60>)
 800330a:	49ae      	ldr	r1, [pc, #696]	; (80035c4 <encode_ssdv+0x1d64>)
 800330c:	48a9      	ldr	r0, [pc, #676]	; (80035b4 <encode_ssdv+0x1d54>)
 800330e:	f007 f9bf 	bl	800a690 <chprintf.constprop.26>
 8003312:	49ad      	ldr	r1, [pc, #692]	; (80035c8 <encode_ssdv+0x1d68>)
 8003314:	48a7      	ldr	r0, [pc, #668]	; (80035b4 <encode_ssdv+0x1d54>)
 8003316:	f007 f9bb 	bl	800a690 <chprintf.constprop.26>
 800331a:	49ac      	ldr	r1, [pc, #688]	; (80035cc <encode_ssdv+0x1d6c>)
 800331c:	48a5      	ldr	r0, [pc, #660]	; (80035b4 <encode_ssdv+0x1d54>)
 800331e:	f007 f9b7 	bl	800a690 <chprintf.constprop.26>
 8003322:	49ab      	ldr	r1, [pc, #684]	; (80035d0 <encode_ssdv+0x1d70>)
 8003324:	48a3      	ldr	r0, [pc, #652]	; (80035b4 <encode_ssdv+0x1d54>)
 8003326:	f007 f9b3 	bl	800a690 <chprintf.constprop.26>
 800332a:	489e      	ldr	r0, [pc, #632]	; (80035a4 <encode_ssdv+0x1d44>)
 800332c:	f006 f928 	bl	8009580 <chMtxUnlock>
 8003330:	f44f 7129 	mov.w	r1, #676	; 0x2a4
 8003334:	48a2      	ldr	r0, [pc, #648]	; (80035c0 <encode_ssdv+0x1d60>)
 8003336:	f009 fb23 	bl	800c980 <log_error>
 800333a:	f7fe befc 	b.w	8002136 <encode_ssdv+0x8d6>
	packet->ones_in_a_row = 0;
	packet->crc = 0xffff;

	// Send preamble ("a bunch of 0s")
	if(packet->mod == MOD_2GFSK) {
		preamble = preamble * 6 / 5;
 800333e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8003342:	4da4      	ldr	r5, [pc, #656]	; (80035d4 <encode_ssdv+0x1d74>)
 8003344:	005b      	lsls	r3, r3, #1
 8003346:	fb85 2503 	smull	r2, r5, r5, r3
 800334a:	17db      	asrs	r3, r3, #31
 800334c:	ebc3 0565 	rsb	r5, r3, r5, asr #1
 8003350:	b2ad      	uxth	r5, r5
 8003352:	e4b6      	b.n	8002cc2 <encode_ssdv+0x1462>
	uint8_t *ob = o;
	size_t n = 0;

	if (b->nbits) {
		ob[n++] = b91_table[b->queue % 91];
		if (b->nbits > 7 || b->queue > 90)
 8003354:	2d00      	cmp	r5, #0
 8003356:	bf08      	it	eq
 8003358:	2c5b      	cmpeq	r4, #91	; 0x5b
 800335a:	f4bf ac7c 	bcs.w	8002c56 <encode_ssdv+0x13f6>
 800335e:	e484      	b.n	8002c6a <encode_ssdv+0x140a>
		/* 00 3F 00 */
		
		/* Verify all of the DQT and DHT tables where loaded */
		if(!s->sdqt[0] || !s->sdqt[1])
		{
			TRACE_ERROR("SSDV > The image is missing one or more DQT tables");
 8003360:	4890      	ldr	r0, [pc, #576]	; (80035a4 <encode_ssdv+0x1d44>)
 8003362:	4e91      	ldr	r6, [pc, #580]	; (80035a8 <encode_ssdv+0x1d48>)
 8003364:	f008 ff1c 	bl	800c1a0 <chMtxLock>
 8003368:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800336c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8003370:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003372:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8003374:	4b8d      	ldr	r3, [pc, #564]	; (80035ac <encode_ssdv+0x1d4c>)
 8003376:	498e      	ldr	r1, [pc, #568]	; (80035b0 <encode_ssdv+0x1d50>)
 8003378:	488e      	ldr	r0, [pc, #568]	; (80035b4 <encode_ssdv+0x1d54>)
 800337a:	fb05 f404 	mul.w	r4, r5, r4
 800337e:	fba6 7404 	umull	r7, r4, r6, r4
 8003382:	0b64      	lsrs	r4, r4, #13
 8003384:	fba3 7304 	umull	r7, r3, r3, r4
 8003388:	fba6 6202 	umull	r6, r2, r6, r2
 800338c:	099b      	lsrs	r3, r3, #6
 800338e:	fb05 4313 	mls	r3, r5, r3, r4
 8003392:	0b52      	lsrs	r2, r2, #13
 8003394:	f007 f97c 	bl	800a690 <chprintf.constprop.26>
 8003398:	4a87      	ldr	r2, [pc, #540]	; (80035b8 <encode_ssdv+0x1d58>)
 800339a:	4988      	ldr	r1, [pc, #544]	; (80035bc <encode_ssdv+0x1d5c>)
 800339c:	4885      	ldr	r0, [pc, #532]	; (80035b4 <encode_ssdv+0x1d54>)
 800339e:	f007 f977 	bl	800a690 <chprintf.constprop.26>
 80033a2:	f240 3302 	movw	r3, #770	; 0x302
 80033a6:	4a86      	ldr	r2, [pc, #536]	; (80035c0 <encode_ssdv+0x1d60>)
 80033a8:	4986      	ldr	r1, [pc, #536]	; (80035c4 <encode_ssdv+0x1d64>)
 80033aa:	4882      	ldr	r0, [pc, #520]	; (80035b4 <encode_ssdv+0x1d54>)
 80033ac:	f007 f970 	bl	800a690 <chprintf.constprop.26>
 80033b0:	4985      	ldr	r1, [pc, #532]	; (80035c8 <encode_ssdv+0x1d68>)
 80033b2:	4880      	ldr	r0, [pc, #512]	; (80035b4 <encode_ssdv+0x1d54>)
 80033b4:	f007 f96c 	bl	800a690 <chprintf.constprop.26>
 80033b8:	4987      	ldr	r1, [pc, #540]	; (80035d8 <encode_ssdv+0x1d78>)
 80033ba:	487e      	ldr	r0, [pc, #504]	; (80035b4 <encode_ssdv+0x1d54>)
 80033bc:	f007 f968 	bl	800a690 <chprintf.constprop.26>
 80033c0:	4983      	ldr	r1, [pc, #524]	; (80035d0 <encode_ssdv+0x1d70>)
 80033c2:	487c      	ldr	r0, [pc, #496]	; (80035b4 <encode_ssdv+0x1d54>)
 80033c4:	f007 f964 	bl	800a690 <chprintf.constprop.26>
 80033c8:	4876      	ldr	r0, [pc, #472]	; (80035a4 <encode_ssdv+0x1d44>)
 80033ca:	f006 f8d9 	bl	8009580 <chMtxUnlock>
 80033ce:	f240 3102 	movw	r1, #770	; 0x302
 80033d2:	487b      	ldr	r0, [pc, #492]	; (80035c0 <encode_ssdv+0x1d60>)
 80033d4:	f009 fad4 	bl	800c980 <log_error>
 80033d8:	f7fe bead 	b.w	8002136 <encode_ssdv+0x8d6>
static uint32_t crc32(void *data, size_t length)
{
	uint32_t crc, x;
	uint8_t i, *d;
	
	for(d = data, crc = 0xFFFFFFFF; length; length--)
 80033dc:	4628      	mov	r0, r5
 80033de:	46ae      	mov	lr, r5
 80033e0:	4629      	mov	r1, r5
 80033e2:	46ac      	mov	ip, r5
 80033e4:	f7fe bc10 	b.w	8001c08 <encode_ssdv+0x3a8>
			TRACE_ERROR("SSDV > The image is too big. Maximum resolution is 4080x4080");
			return(SSDV_ERROR);
		}
		
		/* The image dimensions must be a multiple of 16 */
		if((s->width & 0x0F) || (s->height & 0x0F))
 80033e8:	4313      	orrs	r3, r2
 80033ea:	f013 030f 	ands.w	r3, r3, #15
 80033ee:	d074      	beq.n	80034da <encode_ssdv+0x1c7a>
		{
			TRACE_ERROR("SSDV > The image dimensions must be a multiple of 16");
 80033f0:	486c      	ldr	r0, [pc, #432]	; (80035a4 <encode_ssdv+0x1d44>)
 80033f2:	f008 fed5 	bl	800c1a0 <chMtxLock>
 80033f6:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80033f8:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80033fa:	496d      	ldr	r1, [pc, #436]	; (80035b0 <encode_ssdv+0x1d50>)
 80033fc:	486d      	ldr	r0, [pc, #436]	; (80035b4 <encode_ssdv+0x1d54>)
 80033fe:	fb07 f303 	mul.w	r3, r7, r3
 8003402:	fba8 4303 	umull	r4, r3, r8, r3
 8003406:	0b5b      	lsrs	r3, r3, #13
 8003408:	fba9 5403 	umull	r5, r4, r9, r3
 800340c:	09a4      	lsrs	r4, r4, #6
 800340e:	fba8 5202 	umull	r5, r2, r8, r2
 8003412:	fb07 3314 	mls	r3, r7, r4, r3
 8003416:	0b52      	lsrs	r2, r2, #13
 8003418:	f007 f93a 	bl	800a690 <chprintf.constprop.26>
 800341c:	4a66      	ldr	r2, [pc, #408]	; (80035b8 <encode_ssdv+0x1d58>)
 800341e:	4967      	ldr	r1, [pc, #412]	; (80035bc <encode_ssdv+0x1d5c>)
 8003420:	4864      	ldr	r0, [pc, #400]	; (80035b4 <encode_ssdv+0x1d54>)
 8003422:	f007 f935 	bl	800a690 <chprintf.constprop.26>
 8003426:	f240 23ab 	movw	r3, #683	; 0x2ab
 800342a:	4a65      	ldr	r2, [pc, #404]	; (80035c0 <encode_ssdv+0x1d60>)
 800342c:	4965      	ldr	r1, [pc, #404]	; (80035c4 <encode_ssdv+0x1d64>)
 800342e:	4861      	ldr	r0, [pc, #388]	; (80035b4 <encode_ssdv+0x1d54>)
 8003430:	f007 f92e 	bl	800a690 <chprintf.constprop.26>
 8003434:	4964      	ldr	r1, [pc, #400]	; (80035c8 <encode_ssdv+0x1d68>)
 8003436:	485f      	ldr	r0, [pc, #380]	; (80035b4 <encode_ssdv+0x1d54>)
 8003438:	f007 f92a 	bl	800a690 <chprintf.constprop.26>
 800343c:	4967      	ldr	r1, [pc, #412]	; (80035dc <encode_ssdv+0x1d7c>)
 800343e:	485d      	ldr	r0, [pc, #372]	; (80035b4 <encode_ssdv+0x1d54>)
 8003440:	f007 f926 	bl	800a690 <chprintf.constprop.26>
 8003444:	4962      	ldr	r1, [pc, #392]	; (80035d0 <encode_ssdv+0x1d70>)
 8003446:	485b      	ldr	r0, [pc, #364]	; (80035b4 <encode_ssdv+0x1d54>)
 8003448:	f007 f922 	bl	800a690 <chprintf.constprop.26>
 800344c:	4855      	ldr	r0, [pc, #340]	; (80035a4 <encode_ssdv+0x1d44>)
 800344e:	f006 f897 	bl	8009580 <chMtxUnlock>
 8003452:	f240 21ab 	movw	r1, #683	; 0x2ab
 8003456:	485a      	ldr	r0, [pc, #360]	; (80035c0 <encode_ssdv+0x1d60>)
 8003458:	f009 fa92 	bl	800c980 <log_error>
 800345c:	f7fe be6b 	b.w	8002136 <encode_ssdv+0x8d6>
		for(i = 0; i < 3; i++)
		{
			uint8_t *dh = &d[i * 2 + 1];
			if(dh[0] != i + 1)
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
 8003460:	f008 fe9e 	bl	800c1a0 <chMtxLock>
 8003464:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003468:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800346c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800346e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8003470:	4e4d      	ldr	r6, [pc, #308]	; (80035a8 <encode_ssdv+0x1d48>)
 8003472:	4b4e      	ldr	r3, [pc, #312]	; (80035ac <encode_ssdv+0x1d4c>)
 8003474:	494e      	ldr	r1, [pc, #312]	; (80035b0 <encode_ssdv+0x1d50>)
 8003476:	484f      	ldr	r0, [pc, #316]	; (80035b4 <encode_ssdv+0x1d54>)
 8003478:	fb05 f404 	mul.w	r4, r5, r4
 800347c:	fba6 7404 	umull	r7, r4, r6, r4
 8003480:	0b64      	lsrs	r4, r4, #13
 8003482:	fba3 7304 	umull	r7, r3, r3, r4
 8003486:	fba6 6202 	umull	r6, r2, r6, r2
 800348a:	099b      	lsrs	r3, r3, #6
 800348c:	fb05 4313 	mls	r3, r5, r3, r4
 8003490:	0b52      	lsrs	r2, r2, #13
 8003492:	f007 f8fd 	bl	800a690 <chprintf.constprop.26>
 8003496:	4a48      	ldr	r2, [pc, #288]	; (80035b8 <encode_ssdv+0x1d58>)
 8003498:	4948      	ldr	r1, [pc, #288]	; (80035bc <encode_ssdv+0x1d5c>)
 800349a:	4846      	ldr	r0, [pc, #280]	; (80035b4 <encode_ssdv+0x1d54>)
 800349c:	f007 f8f8 	bl	800a690 <chprintf.constprop.26>
 80034a0:	f240 23f5 	movw	r3, #757	; 0x2f5
 80034a4:	4a46      	ldr	r2, [pc, #280]	; (80035c0 <encode_ssdv+0x1d60>)
 80034a6:	4947      	ldr	r1, [pc, #284]	; (80035c4 <encode_ssdv+0x1d64>)
 80034a8:	4842      	ldr	r0, [pc, #264]	; (80035b4 <encode_ssdv+0x1d54>)
 80034aa:	f007 f8f1 	bl	800a690 <chprintf.constprop.26>
 80034ae:	4946      	ldr	r1, [pc, #280]	; (80035c8 <encode_ssdv+0x1d68>)
 80034b0:	4840      	ldr	r0, [pc, #256]	; (80035b4 <encode_ssdv+0x1d54>)
 80034b2:	f007 f8ed 	bl	800a690 <chprintf.constprop.26>
 80034b6:	494a      	ldr	r1, [pc, #296]	; (80035e0 <encode_ssdv+0x1d80>)
 80034b8:	483e      	ldr	r0, [pc, #248]	; (80035b4 <encode_ssdv+0x1d54>)
 80034ba:	f007 f8e9 	bl	800a690 <chprintf.constprop.26>
 80034be:	4944      	ldr	r1, [pc, #272]	; (80035d0 <encode_ssdv+0x1d70>)
 80034c0:	483c      	ldr	r0, [pc, #240]	; (80035b4 <encode_ssdv+0x1d54>)
 80034c2:	f007 f8e5 	bl	800a690 <chprintf.constprop.26>
 80034c6:	4837      	ldr	r0, [pc, #220]	; (80035a4 <encode_ssdv+0x1d44>)
 80034c8:	f006 f85a 	bl	8009580 <chMtxUnlock>
 80034cc:	f240 21f5 	movw	r1, #757	; 0x2f5
 80034d0:	483b      	ldr	r0, [pc, #236]	; (80035c0 <encode_ssdv+0x1d60>)
 80034d2:	f009 fa55 	bl	800c980 <log_error>
 80034d6:	f7fe be2e 	b.w	8002136 <encode_ssdv+0x8d6>
		
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
 80034da:	eb03 0743 	add.w	r7, r3, r3, lsl #1
 80034de:	3706      	adds	r7, #6
			if(dq[0] != i + 1)
 80034e0:	3301      	adds	r3, #1
 80034e2:	5de6      	ldrb	r6, [r4, r7]
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
 80034e4:	482f      	ldr	r0, [pc, #188]	; (80035a4 <encode_ssdv+0x1d44>)
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
			if(dq[0] != i + 1)
 80034e6:	429e      	cmp	r6, r3
 80034e8:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
 80034ec:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
		
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
 80034f0:	eb04 0807 	add.w	r8, r4, r7
			if(dq[0] != i + 1)
 80034f4:	d17a      	bne.n	80035ec <encode_ssdv+0x1d8c>
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
				return(SSDV_ERROR);
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
 80034f6:	f008 fe53 	bl	800c1a0 <chMtxLock>
 80034fa:	f8d9 c024 	ldr.w	ip, [r9, #36]	; 0x24
 80034fe:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8003502:	4a29      	ldr	r2, [pc, #164]	; (80035a8 <encode_ssdv+0x1d48>)
 8003504:	492a      	ldr	r1, [pc, #168]	; (80035b0 <encode_ssdv+0x1d50>)
 8003506:	482b      	ldr	r0, [pc, #172]	; (80035b4 <encode_ssdv+0x1d54>)
 8003508:	fb0a f303 	mul.w	r3, sl, r3
 800350c:	fba2 2303 	umull	r2, r3, r2, r3
 8003510:	4a26      	ldr	r2, [pc, #152]	; (80035ac <encode_ssdv+0x1d4c>)
 8003512:	0b5b      	lsrs	r3, r3, #13
 8003514:	fba2 2e03 	umull	r2, lr, r2, r3
 8003518:	4a23      	ldr	r2, [pc, #140]	; (80035a8 <encode_ssdv+0x1d48>)
 800351a:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800351e:	fba2 c20c 	umull	ip, r2, r2, ip
 8003522:	fb0a 331e 	mls	r3, sl, lr, r3
 8003526:	0b52      	lsrs	r2, r2, #13
 8003528:	f007 f8b2 	bl	800a690 <chprintf.constprop.26>
 800352c:	4a2d      	ldr	r2, [pc, #180]	; (80035e4 <encode_ssdv+0x1d84>)
 800352e:	4923      	ldr	r1, [pc, #140]	; (80035bc <encode_ssdv+0x1d5c>)
 8003530:	4820      	ldr	r0, [pc, #128]	; (80035b4 <encode_ssdv+0x1d54>)
 8003532:	f007 f8ad 	bl	800a690 <chprintf.constprop.26>
 8003536:	f240 23ba 	movw	r3, #698	; 0x2ba
 800353a:	4a21      	ldr	r2, [pc, #132]	; (80035c0 <encode_ssdv+0x1d60>)
 800353c:	4921      	ldr	r1, [pc, #132]	; (80035c4 <encode_ssdv+0x1d64>)
 800353e:	481d      	ldr	r0, [pc, #116]	; (80035b4 <encode_ssdv+0x1d54>)
 8003540:	f007 f8a6 	bl	800a690 <chprintf.constprop.26>
 8003544:	4920      	ldr	r1, [pc, #128]	; (80035c8 <encode_ssdv+0x1d68>)
 8003546:	481b      	ldr	r0, [pc, #108]	; (80035b4 <encode_ssdv+0x1d54>)
 8003548:	f007 f8a2 	bl	800a690 <chprintf.constprop.26>
 800354c:	f898 0001 	ldrb.w	r0, [r8, #1]
 8003550:	f898 3002 	ldrb.w	r3, [r8, #2]
 8003554:	5de2      	ldrb	r2, [r4, r7]
 8003556:	4924      	ldr	r1, [pc, #144]	; (80035e8 <encode_ssdv+0x1d88>)
 8003558:	ea4f 1e10 	mov.w	lr, r0, lsr #4
 800355c:	f000 000f 	and.w	r0, r0, #15
 8003560:	e88d 4001 	stmia.w	sp, {r0, lr}
 8003564:	4813      	ldr	r0, [pc, #76]	; (80035b4 <encode_ssdv+0x1d54>)
 8003566:	f007 f893 	bl	800a690 <chprintf.constprop.26>
 800356a:	4919      	ldr	r1, [pc, #100]	; (80035d0 <encode_ssdv+0x1d70>)
 800356c:	4811      	ldr	r0, [pc, #68]	; (80035b4 <encode_ssdv+0x1d54>)
 800356e:	f007 f88f 	bl	800a690 <chprintf.constprop.26>
 8003572:	480c      	ldr	r0, [pc, #48]	; (80035a4 <encode_ssdv+0x1d44>)
 8003574:	f006 f804 	bl	8009580 <chMtxUnlock>
			
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
 8003578:	5de3      	ldrb	r3, [r4, r7]
 800357a:	2b01      	cmp	r3, #1
			{
				switch(dq[1])
 800357c:	f898 3001 	ldrb.w	r3, [r8, #1]
			}
			
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
			
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
 8003580:	f000 80af 	beq.w	80036e2 <encode_ssdv+0x1e82>
				default:
					TRACE_ERROR("SSDV > Component 1 sampling factor is not supported");
					return(SSDV_ERROR);
				}
			}
			else if(dq[0] != 1 && dq[1] != 0x11)
 8003584:	2b11      	cmp	r3, #17
 8003586:	d16d      	bne.n	8003664 <encode_ssdv+0x1e04>
			return(SSDV_ERROR);
		}
		
		/* TODO: Read in the quantisation table ID for each component */
		// 01 22 00 02 11 01 03 11 01
		for(i = 0; i < 3; i++)
 8003588:	2e03      	cmp	r6, #3
 800358a:	4633      	mov	r3, r6
 800358c:	d1a5      	bne.n	80034da <encode_ssdv+0x1c7a>
				return(SSDV_ERROR);
			}
		}
		
		/* Calculate number of MCU blocks in this image */
		switch(s->mcu_mode)
 800358e:	f89b 3014 	ldrb.w	r3, [fp, #20]
 8003592:	2b03      	cmp	r3, #3
 8003594:	f200 80bc 	bhi.w	8003710 <encode_ssdv+0x1eb0>
 8003598:	e8df f013 	tbh	[pc, r3, lsl #1]
 800359c:	01c20197 	.word	0x01c20197
 80035a0:	00b2018e 	.word	0x00b2018e
 80035a4:	2001b720 	.word	0x2001b720
 80035a8:	d1b71759 	.word	0xd1b71759
 80035ac:	10624dd3 	.word	0x10624dd3
 80035b0:	0800ea50 	.word	0x0800ea50
 80035b4:	2001ac28 	.word	0x2001ac28
 80035b8:	0800ea5c 	.word	0x0800ea5c
 80035bc:	0800ea64 	.word	0x0800ea64
 80035c0:	0800eabb 	.word	0x0800eabb
 80035c4:	0800ea7c 	.word	0x0800ea7c
 80035c8:	0800f1e0 	.word	0x0800f1e0
 80035cc:	0800eb64 	.word	0x0800eb64
 80035d0:	0800eaa8 	.word	0x0800eaa8
 80035d4:	66666667 	.word	0x66666667
 80035d8:	0800ed20 	.word	0x0800ed20
 80035dc:	0800eba4 	.word	0x0800eba4
 80035e0:	0800ebdc 	.word	0x0800ebdc
 80035e4:	0800f1dc 	.word	0x0800f1dc
 80035e8:	0800ec14 	.word	0x0800ec14
		for(i = 0; i < 3; i++)
		{
			uint8_t *dq = &d[i * 3 + 6];
			if(dq[0] != i + 1)
			{
				TRACE_ERROR("SSDV > Components are not in order in the SOF0 header");
 80035ec:	f008 fdd8 	bl	800c1a0 <chMtxLock>
 80035f0:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 80035f4:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
 80035f8:	4eb8      	ldr	r6, [pc, #736]	; (80038dc <encode_ssdv+0x207c>)
 80035fa:	4bb9      	ldr	r3, [pc, #740]	; (80038e0 <encode_ssdv+0x2080>)
 80035fc:	49b9      	ldr	r1, [pc, #740]	; (80038e4 <encode_ssdv+0x2084>)
 80035fe:	48ba      	ldr	r0, [pc, #744]	; (80038e8 <encode_ssdv+0x2088>)
 8003600:	4655      	mov	r5, sl
 8003602:	fb05 f404 	mul.w	r4, r5, r4
 8003606:	fba6 7404 	umull	r7, r4, r6, r4
 800360a:	0b64      	lsrs	r4, r4, #13
 800360c:	fba3 7304 	umull	r7, r3, r3, r4
 8003610:	fba6 6202 	umull	r6, r2, r6, r2
 8003614:	099b      	lsrs	r3, r3, #6
 8003616:	fb0a 4313 	mls	r3, sl, r3, r4
 800361a:	0b52      	lsrs	r2, r2, #13
 800361c:	f007 f838 	bl	800a690 <chprintf.constprop.26>
 8003620:	4ab2      	ldr	r2, [pc, #712]	; (80038ec <encode_ssdv+0x208c>)
 8003622:	49b3      	ldr	r1, [pc, #716]	; (80038f0 <encode_ssdv+0x2090>)
 8003624:	48b0      	ldr	r0, [pc, #704]	; (80038e8 <encode_ssdv+0x2088>)
 8003626:	f007 f833 	bl	800a690 <chprintf.constprop.26>
 800362a:	f240 23b6 	movw	r3, #694	; 0x2b6
 800362e:	4ab1      	ldr	r2, [pc, #708]	; (80038f4 <encode_ssdv+0x2094>)
 8003630:	49b1      	ldr	r1, [pc, #708]	; (80038f8 <encode_ssdv+0x2098>)
 8003632:	48ad      	ldr	r0, [pc, #692]	; (80038e8 <encode_ssdv+0x2088>)
 8003634:	f007 f82c 	bl	800a690 <chprintf.constprop.26>
 8003638:	49b0      	ldr	r1, [pc, #704]	; (80038fc <encode_ssdv+0x209c>)
 800363a:	48ab      	ldr	r0, [pc, #684]	; (80038e8 <encode_ssdv+0x2088>)
 800363c:	f007 f828 	bl	800a690 <chprintf.constprop.26>
 8003640:	49af      	ldr	r1, [pc, #700]	; (8003900 <encode_ssdv+0x20a0>)
 8003642:	48a9      	ldr	r0, [pc, #676]	; (80038e8 <encode_ssdv+0x2088>)
 8003644:	f007 f824 	bl	800a690 <chprintf.constprop.26>
 8003648:	49ae      	ldr	r1, [pc, #696]	; (8003904 <encode_ssdv+0x20a4>)
 800364a:	48a7      	ldr	r0, [pc, #668]	; (80038e8 <encode_ssdv+0x2088>)
 800364c:	f007 f820 	bl	800a690 <chprintf.constprop.26>
 8003650:	48ad      	ldr	r0, [pc, #692]	; (8003908 <encode_ssdv+0x20a8>)
 8003652:	f005 ff95 	bl	8009580 <chMtxUnlock>
 8003656:	f240 21b6 	movw	r1, #694	; 0x2b6
 800365a:	48a6      	ldr	r0, [pc, #664]	; (80038f4 <encode_ssdv+0x2094>)
 800365c:	f009 f990 	bl	800c980 <log_error>
 8003660:	f7fe bd69 	b.w	8002136 <encode_ssdv+0x8d6>
					return(SSDV_ERROR);
				}
			}
			else if(dq[0] != 1 && dq[1] != 0x11)
			{
				TRACE_ERROR("SSDV > Component %i sampling factor must be 1x1", dq[0]);
 8003664:	48a8      	ldr	r0, [pc, #672]	; (8003908 <encode_ssdv+0x20a8>)
 8003666:	4c9d      	ldr	r4, [pc, #628]	; (80038dc <encode_ssdv+0x207c>)
 8003668:	f008 fd9a 	bl	800c1a0 <chMtxLock>
 800366c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8003670:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8003674:	499b      	ldr	r1, [pc, #620]	; (80038e4 <encode_ssdv+0x2084>)
 8003676:	489c      	ldr	r0, [pc, #624]	; (80038e8 <encode_ssdv+0x2088>)
 8003678:	fb0a f303 	mul.w	r3, sl, r3
 800367c:	fba4 4303 	umull	r4, r3, r4, r3
 8003680:	4c97      	ldr	r4, [pc, #604]	; (80038e0 <encode_ssdv+0x2080>)
 8003682:	0b5b      	lsrs	r3, r3, #13
 8003684:	fba4 5403 	umull	r5, r4, r4, r3
 8003688:	4d94      	ldr	r5, [pc, #592]	; (80038dc <encode_ssdv+0x207c>)
 800368a:	09a4      	lsrs	r4, r4, #6
 800368c:	fba5 5202 	umull	r5, r2, r5, r2
 8003690:	fb0a 3314 	mls	r3, sl, r4, r3
 8003694:	0b52      	lsrs	r2, r2, #13
 8003696:	f006 fffb 	bl	800a690 <chprintf.constprop.26>
 800369a:	4a94      	ldr	r2, [pc, #592]	; (80038ec <encode_ssdv+0x208c>)
 800369c:	4994      	ldr	r1, [pc, #592]	; (80038f0 <encode_ssdv+0x2090>)
 800369e:	4892      	ldr	r0, [pc, #584]	; (80038e8 <encode_ssdv+0x2088>)
 80036a0:	f006 fff6 	bl	800a690 <chprintf.constprop.26>
 80036a4:	f44f 7333 	mov.w	r3, #716	; 0x2cc
 80036a8:	4a92      	ldr	r2, [pc, #584]	; (80038f4 <encode_ssdv+0x2094>)
 80036aa:	4993      	ldr	r1, [pc, #588]	; (80038f8 <encode_ssdv+0x2098>)
 80036ac:	488e      	ldr	r0, [pc, #568]	; (80038e8 <encode_ssdv+0x2088>)
 80036ae:	f006 ffef 	bl	800a690 <chprintf.constprop.26>
 80036b2:	4992      	ldr	r1, [pc, #584]	; (80038fc <encode_ssdv+0x209c>)
 80036b4:	488c      	ldr	r0, [pc, #560]	; (80038e8 <encode_ssdv+0x2088>)
 80036b6:	f006 ffeb 	bl	800a690 <chprintf.constprop.26>
 80036ba:	f898 2000 	ldrb.w	r2, [r8]
 80036be:	4993      	ldr	r1, [pc, #588]	; (800390c <encode_ssdv+0x20ac>)
 80036c0:	4889      	ldr	r0, [pc, #548]	; (80038e8 <encode_ssdv+0x2088>)
 80036c2:	f006 ffe5 	bl	800a690 <chprintf.constprop.26>
 80036c6:	498f      	ldr	r1, [pc, #572]	; (8003904 <encode_ssdv+0x20a4>)
 80036c8:	4887      	ldr	r0, [pc, #540]	; (80038e8 <encode_ssdv+0x2088>)
 80036ca:	f006 ffe1 	bl	800a690 <chprintf.constprop.26>
 80036ce:	488e      	ldr	r0, [pc, #568]	; (8003908 <encode_ssdv+0x20a8>)
 80036d0:	f005 ff56 	bl	8009580 <chMtxUnlock>
 80036d4:	f44f 7133 	mov.w	r1, #716	; 0x2cc
 80036d8:	4886      	ldr	r0, [pc, #536]	; (80038f4 <encode_ssdv+0x2094>)
 80036da:	f009 f951 	bl	800c980 <log_error>
 80036de:	f7fe bd2a 	b.w	8002136 <encode_ssdv+0x8d6>
			TRACE_INFO("SSDV > DQT table for component %i: %02X, Sampling factor: %ix%i", dq[0], dq[2], dq[1] & 0x0F, dq[1] >> 4);
			
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
			{
				switch(dq[1])
 80036e2:	3b11      	subs	r3, #17
 80036e4:	2b11      	cmp	r3, #17
 80036e6:	f200 80a9 	bhi.w	800383c <encode_ssdv+0x1fdc>
 80036ea:	e8df f003 	tbb	[pc, r3]
 80036ee:	99a0      	.short	0x99a0
 80036f0:	a7a7a7a7 	.word	0xa7a7a7a7
 80036f4:	a7a7a7a7 	.word	0xa7a7a7a7
 80036f8:	a7a7a7a7 	.word	0xa7a7a7a7
 80036fc:	5493a7a7 	.word	0x5493a7a7
		switch(s->mcu_mode)
		{
		case 0: l = (s->width >> 4) * (s->height >> 4); break;
		case 1: l = (s->width >> 4) * (s->height >> 3); break;
		case 2: l = (s->width >> 3) * (s->height >> 4); break;
		case 3: l = (s->width >> 3) * (s->height >> 3); break;
 8003700:	f8bb 3006 	ldrh.w	r3, [fp, #6]
 8003704:	f8bb 5008 	ldrh.w	r5, [fp, #8]
 8003708:	08db      	lsrs	r3, r3, #3
 800370a:	08ed      	lsrs	r5, r5, #3
 800370c:	fb05 f503 	mul.w	r5, r5, r3
 8003710:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
		}
		
		TRACE_INFO("SSDV > MCU blocks: %i", (int) l);
 8003714:	487c      	ldr	r0, [pc, #496]	; (8003908 <encode_ssdv+0x20a8>)
 8003716:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 80038dc <encode_ssdv+0x207c>
 800371a:	f008 fd41 	bl	800c1a0 <chMtxLock>
 800371e:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8003720:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8003722:	4970      	ldr	r1, [pc, #448]	; (80038e4 <encode_ssdv+0x2084>)
 8003724:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8003728:	4640      	mov	r0, r8
 800372a:	fb07 f303 	mul.w	r3, r7, r3
 800372e:	fba0 0303 	umull	r0, r3, r0, r3
 8003732:	486b      	ldr	r0, [pc, #428]	; (80038e0 <encode_ssdv+0x2080>)
 8003734:	0b5b      	lsrs	r3, r3, #13
 8003736:	fba0 4003 	umull	r4, r0, r0, r3
 800373a:	4644      	mov	r4, r8
 800373c:	fba4 4202 	umull	r4, r2, r4, r2
 8003740:	0980      	lsrs	r0, r0, #6
 8003742:	fb07 3310 	mls	r3, r7, r0, r3
 8003746:	0b52      	lsrs	r2, r2, #13
 8003748:	4867      	ldr	r0, [pc, #412]	; (80038e8 <encode_ssdv+0x2088>)
 800374a:	4c65      	ldr	r4, [pc, #404]	; (80038e0 <encode_ssdv+0x2080>)
 800374c:	f006 ffa0 	bl	800a690 <chprintf.constprop.26>
 8003750:	4a6f      	ldr	r2, [pc, #444]	; (8003910 <encode_ssdv+0x20b0>)
 8003752:	4967      	ldr	r1, [pc, #412]	; (80038f0 <encode_ssdv+0x2090>)
 8003754:	4864      	ldr	r0, [pc, #400]	; (80038e8 <encode_ssdv+0x2088>)
 8003756:	f006 ff9b 	bl	800a690 <chprintf.constprop.26>
 800375a:	f240 23da 	movw	r3, #730	; 0x2da
 800375e:	4a65      	ldr	r2, [pc, #404]	; (80038f4 <encode_ssdv+0x2094>)
 8003760:	4965      	ldr	r1, [pc, #404]	; (80038f8 <encode_ssdv+0x2098>)
 8003762:	4861      	ldr	r0, [pc, #388]	; (80038e8 <encode_ssdv+0x2088>)
 8003764:	f006 ff94 	bl	800a690 <chprintf.constprop.26>
 8003768:	4964      	ldr	r1, [pc, #400]	; (80038fc <encode_ssdv+0x209c>)
 800376a:	485f      	ldr	r0, [pc, #380]	; (80038e8 <encode_ssdv+0x2088>)
 800376c:	f006 ff90 	bl	800a690 <chprintf.constprop.26>
 8003770:	462a      	mov	r2, r5
 8003772:	4968      	ldr	r1, [pc, #416]	; (8003914 <encode_ssdv+0x20b4>)
 8003774:	485c      	ldr	r0, [pc, #368]	; (80038e8 <encode_ssdv+0x2088>)
 8003776:	f006 ff8b 	bl	800a690 <chprintf.constprop.26>
 800377a:	4962      	ldr	r1, [pc, #392]	; (8003904 <encode_ssdv+0x20a4>)
 800377c:	485a      	ldr	r0, [pc, #360]	; (80038e8 <encode_ssdv+0x2088>)
 800377e:	f006 ff87 	bl	800a690 <chprintf.constprop.26>
 8003782:	4861      	ldr	r0, [pc, #388]	; (8003908 <encode_ssdv+0x20a8>)
 8003784:	f005 fefc 	bl	8009580 <chMtxUnlock>
		
		if(l > 0xFFFF)
 8003788:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800378c:	d20a      	bcs.n	80037a4 <encode_ssdv+0x1f44>
		{
			TRACE_ERROR("SSDV > Maximum number of MCU blocks is 65535");
			return(SSDV_ERROR);
		}
		
		s->mcu_count = l;
 800378e:	f8ab 5018 	strh.w	r5, [fp, #24]
 8003792:	f7fe bc1f 	b.w	8001fd4 <encode_ssdv+0x774>
			/* The first (Y) component must have a factor of 2x2,2x1,1x2 or 1x1 */
			if(dq[0] == 1)
			{
				switch(dq[1])
				{
				case 0x22: s->mcu_mode = 0; s->ycparts = 4; break;
 8003796:	2200      	movs	r2, #0
 8003798:	2304      	movs	r3, #4
 800379a:	f88b 2014 	strb.w	r2, [fp, #20]
 800379e:	f88b 3057 	strb.w	r3, [fp, #87]	; 0x57
 80037a2:	e6f1      	b.n	8003588 <encode_ssdv+0x1d28>
		
		TRACE_INFO("SSDV > MCU blocks: %i", (int) l);
		
		if(l > 0xFFFF)
		{
			TRACE_ERROR("SSDV > Maximum number of MCU blocks is 65535");
 80037a4:	4858      	ldr	r0, [pc, #352]	; (8003908 <encode_ssdv+0x20a8>)
 80037a6:	f008 fcfb 	bl	800c1a0 <chMtxLock>
 80037aa:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80037ac:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80037ae:	494d      	ldr	r1, [pc, #308]	; (80038e4 <encode_ssdv+0x2084>)
 80037b0:	484d      	ldr	r0, [pc, #308]	; (80038e8 <encode_ssdv+0x2088>)
 80037b2:	fb07 f303 	mul.w	r3, r7, r3
 80037b6:	fba8 5303 	umull	r5, r3, r8, r3
 80037ba:	0b5b      	lsrs	r3, r3, #13
 80037bc:	fba4 5403 	umull	r5, r4, r4, r3
 80037c0:	09a4      	lsrs	r4, r4, #6
 80037c2:	fba8 5202 	umull	r5, r2, r8, r2
 80037c6:	fb07 3314 	mls	r3, r7, r4, r3
 80037ca:	0b52      	lsrs	r2, r2, #13
 80037cc:	f006 ff60 	bl	800a690 <chprintf.constprop.26>
 80037d0:	4a46      	ldr	r2, [pc, #280]	; (80038ec <encode_ssdv+0x208c>)
 80037d2:	4947      	ldr	r1, [pc, #284]	; (80038f0 <encode_ssdv+0x2090>)
 80037d4:	4844      	ldr	r0, [pc, #272]	; (80038e8 <encode_ssdv+0x2088>)
 80037d6:	f006 ff5b 	bl	800a690 <chprintf.constprop.26>
 80037da:	f240 23de 	movw	r3, #734	; 0x2de
 80037de:	4a45      	ldr	r2, [pc, #276]	; (80038f4 <encode_ssdv+0x2094>)
 80037e0:	4945      	ldr	r1, [pc, #276]	; (80038f8 <encode_ssdv+0x2098>)
 80037e2:	4841      	ldr	r0, [pc, #260]	; (80038e8 <encode_ssdv+0x2088>)
 80037e4:	f006 ff54 	bl	800a690 <chprintf.constprop.26>
 80037e8:	4944      	ldr	r1, [pc, #272]	; (80038fc <encode_ssdv+0x209c>)
 80037ea:	483f      	ldr	r0, [pc, #252]	; (80038e8 <encode_ssdv+0x2088>)
 80037ec:	f006 ff50 	bl	800a690 <chprintf.constprop.26>
 80037f0:	4949      	ldr	r1, [pc, #292]	; (8003918 <encode_ssdv+0x20b8>)
 80037f2:	483d      	ldr	r0, [pc, #244]	; (80038e8 <encode_ssdv+0x2088>)
 80037f4:	f006 ff4c 	bl	800a690 <chprintf.constprop.26>
 80037f8:	4942      	ldr	r1, [pc, #264]	; (8003904 <encode_ssdv+0x20a4>)
 80037fa:	483b      	ldr	r0, [pc, #236]	; (80038e8 <encode_ssdv+0x2088>)
 80037fc:	f006 ff48 	bl	800a690 <chprintf.constprop.26>
 8003800:	4841      	ldr	r0, [pc, #260]	; (8003908 <encode_ssdv+0x20a8>)
 8003802:	f005 febd 	bl	8009580 <chMtxUnlock>
 8003806:	f240 21de 	movw	r1, #734	; 0x2de
 800380a:	483a      	ldr	r0, [pc, #232]	; (80038f4 <encode_ssdv+0x2094>)
 800380c:	f009 f8b8 	bl	800c980 <log_error>
 8003810:	f7fe bc91 	b.w	8002136 <encode_ssdv+0x8d6>
			{
				switch(dq[1])
				{
				case 0x22: s->mcu_mode = 0; s->ycparts = 4; break;
				case 0x12: s->mcu_mode = 1; s->ycparts = 2; break;
				case 0x21: s->mcu_mode = 2; s->ycparts = 2; break;
 8003814:	2302      	movs	r3, #2
 8003816:	f88b 3014 	strb.w	r3, [fp, #20]
 800381a:	f88b 3057 	strb.w	r3, [fp, #87]	; 0x57
 800381e:	e6b3      	b.n	8003588 <encode_ssdv+0x1d28>
			if(dq[0] == 1)
			{
				switch(dq[1])
				{
				case 0x22: s->mcu_mode = 0; s->ycparts = 4; break;
				case 0x12: s->mcu_mode = 1; s->ycparts = 2; break;
 8003820:	2201      	movs	r2, #1
 8003822:	2302      	movs	r3, #2
 8003824:	f88b 2014 	strb.w	r2, [fp, #20]
 8003828:	f88b 3057 	strb.w	r3, [fp, #87]	; 0x57
 800382c:	e6ac      	b.n	8003588 <encode_ssdv+0x1d28>
				case 0x21: s->mcu_mode = 2; s->ycparts = 2; break;
				case 0x11: s->mcu_mode = 3; s->ycparts = 1; break;
 800382e:	2203      	movs	r2, #3
 8003830:	2301      	movs	r3, #1
 8003832:	f88b 2014 	strb.w	r2, [fp, #20]
 8003836:	f88b 3057 	strb.w	r3, [fp, #87]	; 0x57
 800383a:	e6a5      	b.n	8003588 <encode_ssdv+0x1d28>
				default:
					TRACE_ERROR("SSDV > Component 1 sampling factor is not supported");
 800383c:	4832      	ldr	r0, [pc, #200]	; (8003908 <encode_ssdv+0x20a8>)
 800383e:	4e27      	ldr	r6, [pc, #156]	; (80038dc <encode_ssdv+0x207c>)
 8003840:	f008 fcae 	bl	800c1a0 <chMtxLock>
 8003844:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003848:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800384c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800384e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8003850:	4b23      	ldr	r3, [pc, #140]	; (80038e0 <encode_ssdv+0x2080>)
 8003852:	4924      	ldr	r1, [pc, #144]	; (80038e4 <encode_ssdv+0x2084>)
 8003854:	4824      	ldr	r0, [pc, #144]	; (80038e8 <encode_ssdv+0x2088>)
 8003856:	fb05 f404 	mul.w	r4, r5, r4
 800385a:	fba6 7404 	umull	r7, r4, r6, r4
 800385e:	0b64      	lsrs	r4, r4, #13
 8003860:	fba3 7304 	umull	r7, r3, r3, r4
 8003864:	fba6 6202 	umull	r6, r2, r6, r2
 8003868:	099b      	lsrs	r3, r3, #6
 800386a:	fb05 4313 	mls	r3, r5, r3, r4
 800386e:	0b52      	lsrs	r2, r2, #13
 8003870:	f006 ff0e 	bl	800a690 <chprintf.constprop.26>
 8003874:	4a1d      	ldr	r2, [pc, #116]	; (80038ec <encode_ssdv+0x208c>)
 8003876:	491e      	ldr	r1, [pc, #120]	; (80038f0 <encode_ssdv+0x2090>)
 8003878:	481b      	ldr	r0, [pc, #108]	; (80038e8 <encode_ssdv+0x2088>)
 800387a:	f006 ff09 	bl	800a690 <chprintf.constprop.26>
 800387e:	f240 23c6 	movw	r3, #710	; 0x2c6
 8003882:	4a1c      	ldr	r2, [pc, #112]	; (80038f4 <encode_ssdv+0x2094>)
 8003884:	491c      	ldr	r1, [pc, #112]	; (80038f8 <encode_ssdv+0x2098>)
 8003886:	4818      	ldr	r0, [pc, #96]	; (80038e8 <encode_ssdv+0x2088>)
 8003888:	f006 ff02 	bl	800a690 <chprintf.constprop.26>
 800388c:	491b      	ldr	r1, [pc, #108]	; (80038fc <encode_ssdv+0x209c>)
 800388e:	4816      	ldr	r0, [pc, #88]	; (80038e8 <encode_ssdv+0x2088>)
 8003890:	f006 fefe 	bl	800a690 <chprintf.constprop.26>
 8003894:	4921      	ldr	r1, [pc, #132]	; (800391c <encode_ssdv+0x20bc>)
 8003896:	4814      	ldr	r0, [pc, #80]	; (80038e8 <encode_ssdv+0x2088>)
 8003898:	f006 fefa 	bl	800a690 <chprintf.constprop.26>
 800389c:	4919      	ldr	r1, [pc, #100]	; (8003904 <encode_ssdv+0x20a4>)
 800389e:	4812      	ldr	r0, [pc, #72]	; (80038e8 <encode_ssdv+0x2088>)
 80038a0:	f006 fef6 	bl	800a690 <chprintf.constprop.26>
 80038a4:	4818      	ldr	r0, [pc, #96]	; (8003908 <encode_ssdv+0x20a8>)
 80038a6:	f005 fe6b 	bl	8009580 <chMtxUnlock>
 80038aa:	f240 21c6 	movw	r1, #710	; 0x2c6
 80038ae:	4811      	ldr	r0, [pc, #68]	; (80038f4 <encode_ssdv+0x2094>)
 80038b0:	f009 f866 	bl	800c980 <log_error>
 80038b4:	f7fe bc3f 	b.w	8002136 <encode_ssdv+0x8d6>
		/* Calculate number of MCU blocks in this image */
		switch(s->mcu_mode)
		{
		case 0: l = (s->width >> 4) * (s->height >> 4); break;
		case 1: l = (s->width >> 4) * (s->height >> 3); break;
		case 2: l = (s->width >> 3) * (s->height >> 4); break;
 80038b8:	f8bb 3006 	ldrh.w	r3, [fp, #6]
 80038bc:	f8bb 5008 	ldrh.w	r5, [fp, #8]
 80038c0:	08db      	lsrs	r3, r3, #3
 80038c2:	092d      	lsrs	r5, r5, #4
 80038c4:	fb05 f503 	mul.w	r5, r5, r3
 80038c8:	e722      	b.n	8003710 <encode_ssdv+0x1eb0>
		}
		
		/* Calculate number of MCU blocks in this image */
		switch(s->mcu_mode)
		{
		case 0: l = (s->width >> 4) * (s->height >> 4); break;
 80038ca:	f8bb 3006 	ldrh.w	r3, [fp, #6]
 80038ce:	f8bb 5008 	ldrh.w	r5, [fp, #8]
 80038d2:	091b      	lsrs	r3, r3, #4
 80038d4:	092d      	lsrs	r5, r5, #4
 80038d6:	fb05 f503 	mul.w	r5, r5, r3
 80038da:	e719      	b.n	8003710 <encode_ssdv+0x1eb0>
 80038dc:	d1b71759 	.word	0xd1b71759
 80038e0:	10624dd3 	.word	0x10624dd3
 80038e4:	0800ea50 	.word	0x0800ea50
 80038e8:	2001ac28 	.word	0x2001ac28
 80038ec:	0800ea5c 	.word	0x0800ea5c
 80038f0:	0800ea64 	.word	0x0800ea64
 80038f4:	0800eabb 	.word	0x0800eabb
 80038f8:	0800ea7c 	.word	0x0800ea7c
 80038fc:	0800f1e0 	.word	0x0800f1e0
 8003900:	0800ebdc 	.word	0x0800ebdc
 8003904:	0800eaa8 	.word	0x0800eaa8
 8003908:	2001b720 	.word	0x2001b720
 800390c:	0800ec88 	.word	0x0800ec88
 8003910:	0800f1dc 	.word	0x0800f1dc
 8003914:	0800ecb8 	.word	0x0800ecb8
 8003918:	0800ecd0 	.word	0x0800ecd0
 800391c:	0800ec54 	.word	0x0800ec54
		case 1: l = (s->width >> 4) * (s->height >> 3); break;
 8003920:	f8bb 3006 	ldrh.w	r3, [fp, #6]
 8003924:	f8bb 5008 	ldrh.w	r5, [fp, #8]
 8003928:	091b      	lsrs	r3, r3, #4
 800392a:	08ed      	lsrs	r5, r5, #3
 800392c:	fb05 f503 	mul.w	r5, r5, r3
 8003930:	e6ee      	b.n	8003710 <encode_ssdv+0x1eb0>
 8003932:	bf00      	nop
	...

08003940 <moduleTRACKING>:
}

/**
  * Tracking Module (Thread)
  */
THD_FUNCTION(moduleTRACKING, arg) {
 8003940:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	(void)arg;

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");
 8003944:	48b8      	ldr	r0, [pc, #736]	; (8003c28 <moduleTRACKING+0x2e8>)
 8003946:	4cb9      	ldr	r4, [pc, #740]	; (8003c2c <moduleTRACKING+0x2ec>)
}

/**
  * Tracking Module (Thread)
  */
THD_FUNCTION(moduleTRACKING, arg) {
 8003948:	b0dd      	sub	sp, #372	; 0x174
	(void)arg;

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");
 800394a:	f008 fc29 	bl	800c1a0 <chMtxLock>
 800394e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003952:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8003956:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003958:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800395a:	4bb5      	ldr	r3, [pc, #724]	; (8003c30 <moduleTRACKING+0x2f0>)
 800395c:	fb00 f101 	mul.w	r1, r0, r1
 8003960:	fba4 5101 	umull	r5, r1, r4, r1
 8003964:	0b49      	lsrs	r1, r1, #13
 8003966:	fba3 5301 	umull	r5, r3, r3, r1
 800396a:	fba4 4202 	umull	r4, r2, r4, r2
 800396e:	099b      	lsrs	r3, r3, #6
 8003970:	fb00 1313 	mls	r3, r0, r3, r1
 8003974:	0b52      	lsrs	r2, r2, #13
 8003976:	49af      	ldr	r1, [pc, #700]	; (8003c34 <moduleTRACKING+0x2f4>)
 8003978:	48af      	ldr	r0, [pc, #700]	; (8003c38 <moduleTRACKING+0x2f8>)
 800397a:	f006 fe89 	bl	800a690 <chprintf.constprop.26>
 800397e:	4aaf      	ldr	r2, [pc, #700]	; (8003c3c <moduleTRACKING+0x2fc>)
 8003980:	49af      	ldr	r1, [pc, #700]	; (8003c40 <moduleTRACKING+0x300>)
 8003982:	48ad      	ldr	r0, [pc, #692]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003984:	f006 fe84 	bl	800a690 <chprintf.constprop.26>
 8003988:	234c      	movs	r3, #76	; 0x4c
 800398a:	4aae      	ldr	r2, [pc, #696]	; (8003c44 <moduleTRACKING+0x304>)
 800398c:	49ae      	ldr	r1, [pc, #696]	; (8003c48 <moduleTRACKING+0x308>)
 800398e:	48aa      	ldr	r0, [pc, #680]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003990:	f006 fe7e 	bl	800a690 <chprintf.constprop.26>
 8003994:	49ad      	ldr	r1, [pc, #692]	; (8003c4c <moduleTRACKING+0x30c>)
 8003996:	48a8      	ldr	r0, [pc, #672]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003998:	f006 fe7a 	bl	800a690 <chprintf.constprop.26>
 800399c:	49ac      	ldr	r1, [pc, #688]	; (8003c50 <moduleTRACKING+0x310>)
 800399e:	48a6      	ldr	r0, [pc, #664]	; (8003c38 <moduleTRACKING+0x2f8>)
 80039a0:	f006 fe76 	bl	800a690 <chprintf.constprop.26>
 80039a4:	49ab      	ldr	r1, [pc, #684]	; (8003c54 <moduleTRACKING+0x314>)
 80039a6:	48a4      	ldr	r0, [pc, #656]	; (8003c38 <moduleTRACKING+0x2f8>)
 80039a8:	f006 fe72 	bl	800a690 <chprintf.constprop.26>
 80039ac:	489e      	ldr	r0, [pc, #632]	; (8003c28 <moduleTRACKING+0x2e8>)
 80039ae:	f005 fde7 	bl	8009580 <chMtxUnlock>

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];
 80039b2:	4aa9      	ldr	r2, [pc, #676]	; (8003c58 <moduleTRACKING+0x318>)
 80039b4:	49a9      	ldr	r1, [pc, #676]	; (8003c5c <moduleTRACKING+0x31c>)

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 80039b6:	4baa      	ldr	r3, [pc, #680]	; (8003c60 <moduleTRACKING+0x320>)

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];
 80039b8:	6011      	str	r1, [r2, #0]
	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
	{
		logTrackPoint_t pt;
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
 80039ba:	681a      	ldr	r2, [r3, #0]
 80039bc:	3201      	adds	r2, #1

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 80039be:	f103 0310 	add.w	r3, r3, #16
	{
		logTrackPoint_t pt;
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
 80039c2:	d008      	beq.n	80039d6 <moduleTRACKING+0x96>
			break;
		logEntryCounter++;
 80039c4:	4aa7      	ldr	r2, [pc, #668]	; (8003c64 <moduleTRACKING+0x324>)
 80039c6:	49a7      	ldr	r1, [pc, #668]	; (8003c64 <moduleTRACKING+0x324>)
 80039c8:	6812      	ldr	r2, [r2, #0]

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 80039ca:	f1b3 6f01 	cmp.w	r3, #135266304	; 0x8100000
	{
		logTrackPoint_t pt;
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
			break;
		logEntryCounter++;
 80039ce:	f102 0201 	add.w	r2, r2, #1
 80039d2:	600a      	str	r2, [r1, #0]

	uint32_t id = 1;
	lastTrackPoint = &trackPoints[0];

	// Find next free log entry
	for(uint32_t address = LOG_FLASH_ADDR; address < LOG_FLASH_ADDR+LOG_FLASH_SIZE; address += sizeof(logTrackPoint_t))
 80039d4:	d1f1      	bne.n	80039ba <moduleTRACKING+0x7a>
 80039d6:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
			break;
		logEntryCounter++;
	}
	TRACE_WARN("TRAC > Next log entry ID=%d", logEntryCounter);
 80039da:	4893      	ldr	r0, [pc, #588]	; (8003c28 <moduleTRACKING+0x2e8>)
 80039dc:	4e93      	ldr	r6, [pc, #588]	; (8003c2c <moduleTRACKING+0x2ec>)
 80039de:	4c94      	ldr	r4, [pc, #592]	; (8003c30 <moduleTRACKING+0x2f0>)
	// Initial fill by PAC1720 and BME280 and RTC

	// Time
	ptime_t rtc;
	getTime(&rtc);
	lastTrackPoint->time.year = rtc.year;
 80039e0:	f8df 8274 	ldr.w	r8, [pc, #628]	; 8003c58 <moduleTRACKING+0x318>
		flashRead(address, (char*)&pt, sizeof(logTrackPoint_t));
		if(pt.time == 0xFFFFFFFF)
			break;
		logEntryCounter++;
	}
	TRACE_WARN("TRAC > Next log entry ID=%d", logEntryCounter);
 80039e4:	f008 fbdc 	bl	800c1a0 <chMtxLock>
 80039e8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80039ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80039ec:	4991      	ldr	r1, [pc, #580]	; (8003c34 <moduleTRACKING+0x2f4>)
 80039ee:	4892      	ldr	r0, [pc, #584]	; (8003c38 <moduleTRACKING+0x2f8>)
 80039f0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 80039f4:	fb05 f303 	mul.w	r3, r5, r3
 80039f8:	fba6 e303 	umull	lr, r3, r6, r3
 80039fc:	0b5b      	lsrs	r3, r3, #13
 80039fe:	fba4 ce03 	umull	ip, lr, r4, r3
 8003a02:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8003a06:	fba6 c202 	umull	ip, r2, r6, r2
 8003a0a:	fb05 331e 	mls	r3, r5, lr, r3
 8003a0e:	0b52      	lsrs	r2, r2, #13
 8003a10:	f006 fe3e 	bl	800a690 <chprintf.constprop.26>
 8003a14:	4a94      	ldr	r2, [pc, #592]	; (8003c68 <moduleTRACKING+0x328>)
 8003a16:	498a      	ldr	r1, [pc, #552]	; (8003c40 <moduleTRACKING+0x300>)
 8003a18:	4887      	ldr	r0, [pc, #540]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003a1a:	f006 fe39 	bl	800a690 <chprintf.constprop.26>
 8003a1e:	235a      	movs	r3, #90	; 0x5a
 8003a20:	4a88      	ldr	r2, [pc, #544]	; (8003c44 <moduleTRACKING+0x304>)
 8003a22:	4989      	ldr	r1, [pc, #548]	; (8003c48 <moduleTRACKING+0x308>)
 8003a24:	4884      	ldr	r0, [pc, #528]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003a26:	f006 fe33 	bl	800a690 <chprintf.constprop.26>
 8003a2a:	4988      	ldr	r1, [pc, #544]	; (8003c4c <moduleTRACKING+0x30c>)
 8003a2c:	4882      	ldr	r0, [pc, #520]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003a2e:	f006 fe2f 	bl	800a690 <chprintf.constprop.26>
 8003a32:	4b8c      	ldr	r3, [pc, #560]	; (8003c64 <moduleTRACKING+0x324>)
 8003a34:	498d      	ldr	r1, [pc, #564]	; (8003c6c <moduleTRACKING+0x32c>)
 8003a36:	681a      	ldr	r2, [r3, #0]
 8003a38:	487f      	ldr	r0, [pc, #508]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003a3a:	f006 fe29 	bl	800a690 <chprintf.constprop.26>
 8003a3e:	4985      	ldr	r1, [pc, #532]	; (8003c54 <moduleTRACKING+0x314>)
 8003a40:	487d      	ldr	r0, [pc, #500]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003a42:	f006 fe25 	bl	800a690 <chprintf.constprop.26>
 8003a46:	4878      	ldr	r0, [pc, #480]	; (8003c28 <moduleTRACKING+0x2e8>)
 8003a48:	f005 fd9a 	bl	8009580 <chMtxUnlock>

	// Initial fill by PAC1720 and BME280 and RTC

	// Time
	ptime_t rtc;
	getTime(&rtc);
 8003a4c:	a837      	add	r0, sp, #220	; 0xdc
 8003a4e:	f008 fd6f 	bl	800c530 <getTime>
    return TRUE;
}

int flashRead(flashaddr_t address, char* buffer, size_t size)
{
    memcpy(buffer, (char*)address, size);
 8003a52:	4b84      	ldr	r3, [pc, #528]	; (8003c64 <moduleTRACKING+0x324>)
	lastTrackPoint->time.year = rtc.year;
 8003a54:	f8d8 2000 	ldr.w	r2, [r8]
 8003a58:	681b      	ldr	r3, [r3, #0]
 8003a5a:	f8bd 00dc 	ldrh.w	r0, [sp, #220]	; 0xdc
	lastTrackPoint->time.month = rtc.month;
 8003a5e:	f89d 10de 	ldrb.w	r1, [sp, #222]	; 0xde
	// Initial fill by PAC1720 and BME280 and RTC

	// Time
	ptime_t rtc;
	getTime(&rtc);
	lastTrackPoint->time.year = rtc.year;
 8003a62:	8090      	strh	r0, [r2, #4]
 8003a64:	3b01      	subs	r3, #1
 8003a66:	f3c3 030d 	ubfx	r3, r3, #0, #14
	lastTrackPoint->time.month = rtc.month;
 8003a6a:	7191      	strb	r1, [r2, #6]
 8003a6c:	f503 0300 	add.w	r3, r3, #8388608	; 0x800000
	lastTrackPoint->time.day = rtc.day;
 8003a70:	f89d 10df 	ldrb.w	r1, [sp, #223]	; 0xdf
 8003a74:	71d1      	strb	r1, [r2, #7]
	lastTrackPoint->time.hour = rtc.hour;
 8003a76:	f89d e0e0 	ldrb.w	lr, [sp, #224]	; 0xe0
	lastTrackPoint->time.minute = rtc.minute;
 8003a7a:	f89d 00e1 	ldrb.w	r0, [sp, #225]	; 0xe1
	lastTrackPoint->time.second = rtc.second;
 8003a7e:	f89d 10e2 	ldrb.w	r1, [sp, #226]	; 0xe2
	ptime_t rtc;
	getTime(&rtc);
	lastTrackPoint->time.year = rtc.year;
	lastTrackPoint->time.month = rtc.month;
	lastTrackPoint->time.day = rtc.day;
	lastTrackPoint->time.hour = rtc.hour;
 8003a82:	f882 e008 	strb.w	lr, [r2, #8]
 8003a86:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
 8003a8a:	011b      	lsls	r3, r3, #4
	lastTrackPoint->time.minute = rtc.minute;
 8003a8c:	7250      	strb	r0, [r2, #9]
	lastTrackPoint->time.second = rtc.second;
 8003a8e:	7291      	strb	r1, [r2, #10]
 8003a90:	e893 4002 	ldmia.w	r3, {r1, lr}
 8003a94:	6898      	ldr	r0, [r3, #8]
 8003a96:	68db      	ldr	r3, [r3, #12]

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
	lastTrackPoint->gps_lon = lastLogPoint.gps_lon;
	lastTrackPoint->gps_alt = lastLogPoint.gps_alt;
 8003a98:	6193      	str	r3, [r2, #24]
	logTrackPoint_t lastLogPoint;
	uint32_t address = LOG_FLASH_ADDR + ((logEntryCounter-1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t))) * sizeof(logTrackPoint_t);
	flashRead(address, (char*)&lastLogPoint, sizeof(logTrackPoint_t));

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
 8003a9a:	2300      	movs	r3, #0
 8003a9c:	7393      	strb	r3, [r2, #14]
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
	lastTrackPoint->gps_lon = lastLogPoint.gps_lon;
	lastTrackPoint->gps_alt = lastLogPoint.gps_alt;
	lastTrackPoint->gps_sats = 0;
 8003a9e:	7713      	strb	r3, [r2, #28]
	lastTrackPoint->gps_ttff = 0;
 8003aa0:	7753      	strb	r3, [r2, #29]

	// Debug last stored GPS position
	if(lastLogPoint.time != 0xFFFFFFFF) {
 8003aa2:	3101      	adds	r1, #1
		TRACE_INFO(
 8003aa4:	4b72      	ldr	r3, [pc, #456]	; (8003c70 <moduleTRACKING+0x330>)
	flashRead(address, (char*)&lastLogPoint, sizeof(logTrackPoint_t));

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
	lastTrackPoint->gps_lon = lastLogPoint.gps_lon;
 8003aa6:	6150      	str	r0, [r2, #20]
	uint32_t address = LOG_FLASH_ADDR + ((logEntryCounter-1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t))) * sizeof(logTrackPoint_t);
	flashRead(address, (char*)&lastLogPoint, sizeof(logTrackPoint_t));

	// Last GPS fix
	lastTrackPoint->gps_lock = 0;
	lastTrackPoint->gps_lat = lastLogPoint.gps_lat;
 8003aa8:	f8c2 e010 	str.w	lr, [r2, #16]
	lastTrackPoint->gps_sats = 0;
	lastTrackPoint->gps_ttff = 0;

	// Debug last stored GPS position
	if(lastLogPoint.time != 0xFFFFFFFF) {
		TRACE_INFO(
 8003aac:	485e      	ldr	r0, [pc, #376]	; (8003c28 <moduleTRACKING+0x2e8>)
 8003aae:	9330      	str	r3, [sp, #192]	; 0xc0
	lastTrackPoint->gps_alt = lastLogPoint.gps_alt;
	lastTrackPoint->gps_sats = 0;
	lastTrackPoint->gps_ttff = 0;

	// Debug last stored GPS position
	if(lastLogPoint.time != 0xFFFFFFFF) {
 8003ab0:	f001 868c 	beq.w	80057cc <moduleTRACKING+0x1e8c>
		TRACE_INFO(
 8003ab4:	f008 fb74 	bl	800c1a0 <chMtxLock>
 8003ab8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003aba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003abc:	495d      	ldr	r1, [pc, #372]	; (8003c34 <moduleTRACKING+0x2f4>)
 8003abe:	4f6c      	ldr	r7, [pc, #432]	; (8003c70 <moduleTRACKING+0x330>)
 8003ac0:	fb05 f303 	mul.w	r3, r5, r3
 8003ac4:	fba6 0303 	umull	r0, r3, r6, r3
 8003ac8:	0b5b      	lsrs	r3, r3, #13
 8003aca:	fba4 4003 	umull	r4, r0, r4, r3
 8003ace:	0980      	lsrs	r0, r0, #6
 8003ad0:	fba6 4202 	umull	r4, r2, r6, r2
 8003ad4:	fb05 3310 	mls	r3, r5, r0, r3
 8003ad8:	0b52      	lsrs	r2, r2, #13
 8003ada:	4857      	ldr	r0, [pc, #348]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003adc:	f006 fdd8 	bl	800a690 <chprintf.constprop.26>
 8003ae0:	4a56      	ldr	r2, [pc, #344]	; (8003c3c <moduleTRACKING+0x2fc>)
 8003ae2:	4957      	ldr	r1, [pc, #348]	; (8003c40 <moduleTRACKING+0x300>)
 8003ae4:	4854      	ldr	r0, [pc, #336]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003ae6:	f006 fdd3 	bl	800a690 <chprintf.constprop.26>
 8003aea:	2380      	movs	r3, #128	; 0x80
 8003aec:	4a55      	ldr	r2, [pc, #340]	; (8003c44 <moduleTRACKING+0x304>)
 8003aee:	4956      	ldr	r1, [pc, #344]	; (8003c48 <moduleTRACKING+0x308>)
 8003af0:	4851      	ldr	r0, [pc, #324]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003af2:	f006 fdcd 	bl	800a690 <chprintf.constprop.26>
 8003af6:	4955      	ldr	r1, [pc, #340]	; (8003c4c <moduleTRACKING+0x30c>)
 8003af8:	484f      	ldr	r0, [pc, #316]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003afa:	f006 fdc9 	bl	800a690 <chprintf.constprop.26>
 8003afe:	f8d8 2000 	ldr.w	r2, [r8]
 8003b02:	495c      	ldr	r1, [pc, #368]	; (8003c74 <moduleTRACKING+0x334>)
 8003b04:	6914      	ldr	r4, [r2, #16]
 8003b06:	6953      	ldr	r3, [r2, #20]
 8003b08:	6992      	ldr	r2, [r2, #24]
 8003b0a:	9205      	str	r2, [sp, #20]
 8003b0c:	2c00      	cmp	r4, #0
 8003b0e:	bfd4      	ite	le
 8003b10:	f04f 30ff 	movle.w	r0, #4294967295
 8003b14:	2001      	movgt	r0, #1
 8003b16:	fb04 f000 	mul.w	r0, r4, r0
 8003b1a:	fb81 5600 	smull	r5, r6, r1, r0
 8003b1e:	2b00      	cmp	r3, #0
 8003b20:	ea4f 75e0 	mov.w	r5, r0, asr #31
 8003b24:	ebc5 55a6 	rsb	r5, r5, r6, asr #22
 8003b28:	bfd8      	it	le
 8003b2a:	f04f 32ff 	movle.w	r2, #4294967295
 8003b2e:	4e52      	ldr	r6, [pc, #328]	; (8003c78 <moduleTRACKING+0x338>)
 8003b30:	9704      	str	r7, [sp, #16]
 8003b32:	bfc8      	it	gt
 8003b34:	2201      	movgt	r2, #1
 8003b36:	fb03 f202 	mul.w	r2, r3, r2
 8003b3a:	fb06 0515 	mls	r5, r6, r5, r0
 8003b3e:	fb81 0702 	smull	r0, r7, r1, r2
 8003b42:	17d0      	asrs	r0, r2, #31
 8003b44:	ebc0 50a7 	rsb	r0, r0, r7, asr #22
 8003b48:	fb06 2010 	mls	r0, r6, r0, r2
 8003b4c:	fb81 6203 	smull	r6, r2, r1, r3
 8003b50:	17db      	asrs	r3, r3, #31
 8003b52:	ebc3 52a2 	rsb	r2, r3, r2, asr #22
 8003b56:	fb81 6104 	smull	r6, r1, r1, r4
 8003b5a:	17e3      	asrs	r3, r4, #31
 8003b5c:	9202      	str	r2, [sp, #8]
 8003b5e:	4a44      	ldr	r2, [pc, #272]	; (8003c70 <moduleTRACKING+0x330>)
 8003b60:	9003      	str	r0, [sp, #12]
 8003b62:	ebc3 53a1 	rsb	r3, r3, r1, asr #22
 8003b66:	9500      	str	r5, [sp, #0]
 8003b68:	9201      	str	r2, [sp, #4]
 8003b6a:	4944      	ldr	r1, [pc, #272]	; (8003c7c <moduleTRACKING+0x33c>)
 8003b6c:	4832      	ldr	r0, [pc, #200]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003b6e:	f006 fd8f 	bl	800a690 <chprintf.constprop.26>
			TRACE_TAB, lastTrackPoint->gps_lat/10000000, (lastTrackPoint->gps_lat > 0 ? 1:-1)*lastTrackPoint->gps_lat%10000000,
			TRACE_TAB, lastTrackPoint->gps_lon/10000000, (lastTrackPoint->gps_lon > 0 ? 1:-1)*lastTrackPoint->gps_lon%10000000,
			TRACE_TAB, lastTrackPoint->gps_alt
		);
	} else {
		TRACE_INFO("TRAC > No GPS position in memory");
 8003b72:	4938      	ldr	r1, [pc, #224]	; (8003c54 <moduleTRACKING+0x314>)
 8003b74:	4830      	ldr	r0, [pc, #192]	; (8003c38 <moduleTRACKING+0x2f8>)
 8003b76:	f006 fd8b 	bl	800a690 <chprintf.constprop.26>
 8003b7a:	482b      	ldr	r0, [pc, #172]	; (8003c28 <moduleTRACKING+0x2e8>)
 8003b7c:	f005 fd00 	bl	8009580 <chMtxUnlock>
	}

	// Voltage/Current
	lastTrackPoint->adc_vsol = getSolarVoltageMV();
 8003b80:	4b35      	ldr	r3, [pc, #212]	; (8003c58 <moduleTRACKING+0x318>)
 8003b82:	461c      	mov	r4, r3
 8003b84:	681d      	ldr	r5, [r3, #0]
 8003b86:	f009 f9a3 	bl	800ced0 <getSolarVoltageMV>
 8003b8a:	83e8      	strh	r0, [r5, #30]
	lastTrackPoint->adc_vbat = getBatteryVoltageMV();
 8003b8c:	6825      	ldr	r5, [r4, #0]
 8003b8e:	f009 f9b7 	bl	800cf00 <getBatteryVoltageMV>
 8003b92:	8428      	strh	r0, [r5, #32]
	lastTrackPoint->adc_vusb = getUSBVoltageMV();
 8003b94:	6826      	ldr	r6, [r4, #0]
	return samples[0] * vcc_ref * DIVIDER_VSOL / 4096;
}

uint16_t getUSBVoltageMV(void)
{
	doConversion();
 8003b96:	f009 f8a3 	bl	800cce0 <doConversion>
 8003b9a:	4b39      	ldr	r3, [pc, #228]	; (8003c80 <moduleTRACKING+0x340>)
	lastTrackPoint->adc_psol = pac1720_getPsol();
 8003b9c:	6825      	ldr	r5, [r4, #0]
	}

	// Voltage/Current
	lastTrackPoint->adc_vsol = getSolarVoltageMV();
	lastTrackPoint->adc_vbat = getBatteryVoltageMV();
	lastTrackPoint->adc_vusb = getUSBVoltageMV();
 8003b9e:	885a      	ldrh	r2, [r3, #2]
 8003ba0:	4b38      	ldr	r3, [pc, #224]	; (8003c84 <moduleTRACKING+0x344>)
 8003ba2:	881b      	ldrh	r3, [r3, #0]
 8003ba4:	fb03 f202 	mul.w	r2, r3, r2
 8003ba8:	23c8      	movs	r3, #200	; 0xc8
 8003baa:	fb03 f302 	mul.w	r3, r3, r2
 8003bae:	149b      	asrs	r3, r3, #18
 8003bb0:	8473      	strh	r3, [r6, #34]	; 0x22
	lastTrackPoint->adc_psol = pac1720_getPsol();
 8003bb2:	f004 fb85 	bl	80082c0 <pac1720_getPsol>
 8003bb6:	84e8      	strh	r0, [r5, #38]	; 0x26
	lastTrackPoint->adc_pbat = pac1720_getPbat();
 8003bb8:	6825      	ldr	r5, [r4, #0]
 8003bba:	f004 fba9 	bl	8008310 <pac1720_getPbat>
#include <math.h>

bool BME280_isAvailable(uint8_t address)
{
	uint8_t val;
	if(I2C_read8(address, BME280_REGISTER_CHIPID, &val))
 8003bbe:	aa4f      	add	r2, sp, #316	; 0x13c
 8003bc0:	84a8      	strh	r0, [r5, #36]	; 0x24
 8003bc2:	21d0      	movs	r1, #208	; 0xd0
 8003bc4:	2077      	movs	r0, #119	; 0x77
 8003bc6:	f008 fd5b 	bl	800c680 <I2C_read8>
 8003bca:	2800      	cmp	r0, #0
 8003bcc:	f001 85bc 	beq.w	8005748 <moduleTRACKING+0x1e08>
		return val == 0x60;
 8003bd0:	f89d 313c 	ldrb.w	r3, [sp, #316]	; 0x13c

	bme280_t bme280;

	// Atmosphere condition
	if(BME280_isAvailable(BME280_ADDRESS_INT)) {
 8003bd4:	2b60      	cmp	r3, #96	; 0x60
 8003bd6:	f041 85b7 	bne.w	8005748 <moduleTRACKING+0x1e08>
		BME280_Init(&bme280, BME280_ADDRESS_INT);
 8003bda:	a844      	add	r0, sp, #272	; 0x110
 8003bdc:	f009 fb10 	bl	800d200 <BME280_Init.constprop.17>
		lastTrackPoint->air_press = BME280_getPressure(&bme280, 256);
 8003be0:	a844      	add	r0, sp, #272	; 0x110
 8003be2:	6825      	ldr	r5, [r4, #0]
 8003be4:	f009 f9cc 	bl	800cf80 <BME280_getPressure.constprop.19>
 8003be8:	62a8      	str	r0, [r5, #40]	; 0x28
		lastTrackPoint->air_hum = BME280_getHumidity(&bme280);
 8003bea:	a844      	add	r0, sp, #272	; 0x110
 8003bec:	6825      	ldr	r5, [r4, #0]
 8003bee:	f004 fbdf 	bl	80083b0 <BME280_getHumidity>
 8003bf2:	85a8      	strh	r0, [r5, #44]	; 0x2c
		lastTrackPoint->air_temp = BME280_getTemperature(&bme280);
 8003bf4:	a844      	add	r0, sp, #272	; 0x110
 8003bf6:	6824      	ldr	r4, [r4, #0]
 8003bf8:	f004 fc32 	bl	8008460 <BME280_getTemperature>
 8003bfc:	85e0      	strh	r0, [r4, #46]	; 0x2e
 8003bfe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c02:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003c04:	9322      	str	r3, [sp, #136]	; 0x88
	(void)arg;

	// Print initialization message
	TRACE_INFO("TRAC > Startup module TRACKING MANAGER");

	uint32_t id = 1;
 8003c06:	2301      	movs	r3, #1
 8003c08:	932d      	str	r3, [sp, #180]	; 0xb4
 8003c0a:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8003c0e:	4806      	ldr	r0, [pc, #24]	; (8003c28 <moduleTRACKING+0x2e8>)
 8003c10:	4f06      	ldr	r7, [pc, #24]	; (8003c2c <moduleTRACKING+0x2ec>)
 8003c12:	4c07      	ldr	r4, [pc, #28]	; (8003c30 <moduleTRACKING+0x2f0>)
}

bool GPS_Init(void) {
	// Initialize pins
	TRACE_INFO("GPS  > Init pins");
	palSetPadMode(PORT(GPS_RESET), PIN(GPS_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// GPS reset
 8003c14:	f8df 9070 	ldr.w	r9, [pc, #112]	; 8003c88 <moduleTRACKING+0x348>
	palSetPadMode(PORT(GPS_EN), PIN(GPS_EN), PAL_MODE_OUTPUT_PUSHPULL);			// GPS off
 8003c18:	f8df a070 	ldr.w	sl, [pc, #112]	; 8003c8c <moduleTRACKING+0x34c>
 8003c1c:	f008 fac0 	bl	800c1a0 <chMtxLock>
 8003c20:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003c22:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003c24:	e034      	b.n	8003c90 <moduleTRACKING+0x350>
 8003c26:	bf00      	nop
 8003c28:	2001b720 	.word	0x2001b720
 8003c2c:	d1b71759 	.word	0xd1b71759
 8003c30:	10624dd3 	.word	0x10624dd3
 8003c34:	0800ea50 	.word	0x0800ea50
 8003c38:	2001ac28 	.word	0x2001ac28
 8003c3c:	0800f1dc 	.word	0x0800f1dc
 8003c40:	0800ea64 	.word	0x0800ea64
 8003c44:	0800f15c 	.word	0x0800f15c
 8003c48:	0800ea7c 	.word	0x0800ea7c
 8003c4c:	0800f1e0 	.word	0x0800f1e0
 8003c50:	0800f168 	.word	0x0800f168
 8003c54:	0800eaa8 	.word	0x0800eaa8
 8003c58:	2001b730 	.word	0x2001b730
 8003c5c:	20000810 	.word	0x20000810
 8003c60:	080c0000 	.word	0x080c0000
 8003c64:	2000080c 	.word	0x2000080c
 8003c68:	0800f190 	.word	0x0800f190
 8003c6c:	0800f198 	.word	0x0800f198
 8003c70:	0800f1b4 	.word	0x0800f1b4
 8003c74:	6b5fca6b 	.word	0x6b5fca6b
 8003c78:	00989680 	.word	0x00989680
 8003c7c:	0800f1e4 	.word	0x0800f1e4
 8003c80:	2001b690 	.word	0x2001b690
 8003c84:	20000800 	.word	0x20000800
 8003c88:	40020c00 	.word	0x40020c00
 8003c8c:	40021400 	.word	0x40021400
 8003c90:	49c0      	ldr	r1, [pc, #768]	; (8003f94 <moduleTRACKING+0x654>)
 8003c92:	48c1      	ldr	r0, [pc, #772]	; (8003f98 <moduleTRACKING+0x658>)
 8003c94:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8003c98:	fb06 f303 	mul.w	r3, r6, r3
 8003c9c:	fba7 e303 	umull	lr, r3, r7, r3
 8003ca0:	0b5b      	lsrs	r3, r3, #13
 8003ca2:	fba4 ce03 	umull	ip, lr, r4, r3
 8003ca6:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8003caa:	fba7 c202 	umull	ip, r2, r7, r2
 8003cae:	fb06 331e 	mls	r3, r6, lr, r3
 8003cb2:	0b52      	lsrs	r2, r2, #13
 8003cb4:	f006 fcec 	bl	800a690 <chprintf.constprop.26>
 8003cb8:	4ab8      	ldr	r2, [pc, #736]	; (8003f9c <moduleTRACKING+0x65c>)
 8003cba:	49b9      	ldr	r1, [pc, #740]	; (8003fa0 <moduleTRACKING+0x660>)
 8003cbc:	48b6      	ldr	r0, [pc, #728]	; (8003f98 <moduleTRACKING+0x658>)
 8003cbe:	f006 fce7 	bl	800a690 <chprintf.constprop.26>
 8003cc2:	239e      	movs	r3, #158	; 0x9e
 8003cc4:	4ab7      	ldr	r2, [pc, #732]	; (8003fa4 <moduleTRACKING+0x664>)
 8003cc6:	49b8      	ldr	r1, [pc, #736]	; (8003fa8 <moduleTRACKING+0x668>)
 8003cc8:	48b3      	ldr	r0, [pc, #716]	; (8003f98 <moduleTRACKING+0x658>)
 8003cca:	f006 fce1 	bl	800a690 <chprintf.constprop.26>
 8003cce:	49b7      	ldr	r1, [pc, #732]	; (8003fac <moduleTRACKING+0x66c>)
 8003cd0:	48b1      	ldr	r0, [pc, #708]	; (8003f98 <moduleTRACKING+0x658>)
 8003cd2:	f006 fcdd 	bl	800a690 <chprintf.constprop.26>
 8003cd6:	49b6      	ldr	r1, [pc, #728]	; (8003fb0 <moduleTRACKING+0x670>)
 8003cd8:	48af      	ldr	r0, [pc, #700]	; (8003f98 <moduleTRACKING+0x658>)
 8003cda:	f006 fcd9 	bl	800a690 <chprintf.constprop.26>
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003cde:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8003ce0:	49b4      	ldr	r1, [pc, #720]	; (8003fb4 <moduleTRACKING+0x674>)
 8003ce2:	48ad      	ldr	r0, [pc, #692]	; (8003f98 <moduleTRACKING+0x658>)
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003ce4:	f003 0201 	and.w	r2, r3, #1
 8003ce8:	922b      	str	r2, [sp, #172]	; 0xac
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8003cea:	f006 fcd1 	bl	800a690 <chprintf.constprop.26>
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003cee:	9b2b      	ldr	r3, [sp, #172]	; 0xac
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8003cf0:	48b1      	ldr	r0, [pc, #708]	; (8003fb8 <moduleTRACKING+0x678>)
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003cf2:	005a      	lsls	r2, r3, #1
 8003cf4:	922c      	str	r2, [sp, #176]	; 0xb0
	}

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
 8003cf6:	f005 fc43 	bl	8009580 <chMtxUnlock>
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003cfa:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8003cfc:	9a2c      	ldr	r2, [sp, #176]	; 0xb0

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer
 8003cfe:	49af      	ldr	r1, [pc, #700]	; (8003fbc <moduleTRACKING+0x67c>)

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003d00:	441a      	add	r2, r3
 8003d02:	6a6b      	ldr	r3, [r5, #36]	; 0x24

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer
 8003d04:	600b      	str	r3, [r1, #0]

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8003d06:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003d08:	49ad      	ldr	r1, [pc, #692]	; (8003fc0 <moduleTRACKING+0x680>)
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8003d0a:	3b01      	subs	r3, #1

		// Search for GPS satellites
		gpsFix_t gpsFix = {{0,0,0,0,0,0,0},0,0,0,0,0};
 8003d0c:	f04f 0800 	mov.w	r8, #0
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003d10:	eb01 1202 	add.w	r2, r1, r2, lsl #4
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8003d14:	f003 0301 	and.w	r3, r3, #1
	while(true)
	{
		TRACE_INFO("TRAC > Do module TRACKING MANAGER cycle");
		watchdog_tracking = chVTGetSystemTimeX(); // Update watchdog timer

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
 8003d18:	9232      	str	r2, [sp, #200]	; 0xc8
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point
 8003d1a:	9331      	str	r3, [sp, #196]	; 0xc4

		// Search for GPS satellites
		gpsFix_t gpsFix = {{0,0,0,0,0,0,0},0,0,0,0,0};
 8003d1c:	f8cd 80f8 	str.w	r8, [sp, #248]	; 0xf8
 8003d20:	f8cd 80fc 	str.w	r8, [sp, #252]	; 0xfc
 8003d24:	f8cd 8100 	str.w	r8, [sp, #256]	; 0x100
 8003d28:	f8cd 8104 	str.w	r8, [sp, #260]	; 0x104
 8003d2c:	f8cd 8108 	str.w	r8, [sp, #264]	; 0x108
 8003d30:	f8cd 810c 	str.w	r8, [sp, #268]	; 0x10c

		// Switch on GPS is enough power is available
		uint16_t batt = getBatteryVoltageMV();
 8003d34:	f009 f8e4 	bl	800cf00 <getBatteryVoltageMV>
	return gps_receive_ack(0x06, 0x11, 1000);
}

bool GPS_Init(void) {
	// Initialize pins
	TRACE_INFO("GPS  > Init pins");
 8003d38:	489f      	ldr	r0, [pc, #636]	; (8003fb8 <moduleTRACKING+0x678>)
 8003d3a:	f008 fa31 	bl	800c1a0 <chMtxLock>
 8003d3e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003d40:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003d42:	4994      	ldr	r1, [pc, #592]	; (8003f94 <moduleTRACKING+0x654>)
 8003d44:	4894      	ldr	r0, [pc, #592]	; (8003f98 <moduleTRACKING+0x658>)
 8003d46:	fb06 f303 	mul.w	r3, r6, r3
 8003d4a:	fba7 e303 	umull	lr, r3, r7, r3
 8003d4e:	0b5b      	lsrs	r3, r3, #13
 8003d50:	fba4 ce03 	umull	ip, lr, r4, r3
 8003d54:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8003d58:	fba7 c202 	umull	ip, r2, r7, r2
 8003d5c:	fb06 331e 	mls	r3, r6, lr, r3
 8003d60:	0b52      	lsrs	r2, r2, #13
 8003d62:	f006 fc95 	bl	800a690 <chprintf.constprop.26>
 8003d66:	4a8d      	ldr	r2, [pc, #564]	; (8003f9c <moduleTRACKING+0x65c>)
 8003d68:	498d      	ldr	r1, [pc, #564]	; (8003fa0 <moduleTRACKING+0x660>)
 8003d6a:	488b      	ldr	r0, [pc, #556]	; (8003f98 <moduleTRACKING+0x658>)
 8003d6c:	f006 fc90 	bl	800a690 <chprintf.constprop.26>
 8003d70:	f44f 739f 	mov.w	r3, #318	; 0x13e
 8003d74:	4a93      	ldr	r2, [pc, #588]	; (8003fc4 <moduleTRACKING+0x684>)
 8003d76:	498c      	ldr	r1, [pc, #560]	; (8003fa8 <moduleTRACKING+0x668>)
 8003d78:	4887      	ldr	r0, [pc, #540]	; (8003f98 <moduleTRACKING+0x658>)
 8003d7a:	f006 fc89 	bl	800a690 <chprintf.constprop.26>
 8003d7e:	498b      	ldr	r1, [pc, #556]	; (8003fac <moduleTRACKING+0x66c>)
 8003d80:	4885      	ldr	r0, [pc, #532]	; (8003f98 <moduleTRACKING+0x658>)
 8003d82:	f006 fc85 	bl	800a690 <chprintf.constprop.26>
 8003d86:	4990      	ldr	r1, [pc, #576]	; (8003fc8 <moduleTRACKING+0x688>)
 8003d88:	4883      	ldr	r0, [pc, #524]	; (8003f98 <moduleTRACKING+0x658>)
 8003d8a:	f006 fc81 	bl	800a690 <chprintf.constprop.26>
 8003d8e:	4989      	ldr	r1, [pc, #548]	; (8003fb4 <moduleTRACKING+0x674>)
 8003d90:	4881      	ldr	r0, [pc, #516]	; (8003f98 <moduleTRACKING+0x658>)
 8003d92:	f006 fc7d 	bl	800a690 <chprintf.constprop.26>
 8003d96:	4888      	ldr	r0, [pc, #544]	; (8003fb8 <moduleTRACKING+0x678>)
 8003d98:	f005 fbf2 	bl	8009580 <chMtxUnlock>
	palSetPadMode(PORT(GPS_RESET), PIN(GPS_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// GPS reset
 8003d9c:	4648      	mov	r0, r9
 8003d9e:	2201      	movs	r2, #1
 8003da0:	2180      	movs	r1, #128	; 0x80
 8003da2:	f006 f9c5 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_EN), PIN(GPS_EN), PAL_MODE_OUTPUT_PUSHPULL);			// GPS off
 8003da6:	4650      	mov	r0, sl
 8003da8:	2201      	movs	r2, #1
 8003daa:	2108      	movs	r1, #8
 8003dac:	f006 f9c0 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_TIMEPULSE), PIN(GPS_TIMEPULSE), PAL_MODE_INPUT);		// GPS timepulse
 8003db0:	4642      	mov	r2, r8
 8003db2:	2110      	movs	r1, #16
 8003db4:	4885      	ldr	r0, [pc, #532]	; (8003fcc <moduleTRACKING+0x68c>)
 8003db6:	f006 f9bb 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_RXD), PIN(GPS_RXD), PAL_MODE_ALTERNATE(8));			// UART RXD
 8003dba:	4648      	mov	r0, r9
 8003dbc:	f240 4202 	movw	r2, #1026	; 0x402
 8003dc0:	2104      	movs	r1, #4
 8003dc2:	f006 f9b5 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_TXD), PIN(GPS_TXD), PAL_MODE_ALTERNATE(8));			// UART TXD
 8003dc6:	f240 4202 	movw	r2, #1026	; 0x402
 8003dca:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8003dce:	4880      	ldr	r0, [pc, #512]	; (8003fd0 <moduleTRACKING+0x690>)
 8003dd0:	f006 f9ae 	bl	800a130 <_pal_lld_setgroupmode>

	// Init UART
	TRACE_INFO("GPS  > Init GPS UART");
 8003dd4:	4878      	ldr	r0, [pc, #480]	; (8003fb8 <moduleTRACKING+0x678>)
 8003dd6:	f008 f9e3 	bl	800c1a0 <chMtxLock>
 8003dda:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003ddc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003dde:	496d      	ldr	r1, [pc, #436]	; (8003f94 <moduleTRACKING+0x654>)
 8003de0:	486d      	ldr	r0, [pc, #436]	; (8003f98 <moduleTRACKING+0x658>)
 8003de2:	fb06 f303 	mul.w	r3, r6, r3
 8003de6:	fba7 e303 	umull	lr, r3, r7, r3
 8003dea:	0b5b      	lsrs	r3, r3, #13
 8003dec:	fba4 ce03 	umull	ip, lr, r4, r3
 8003df0:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8003df4:	fba7 c202 	umull	ip, r2, r7, r2
 8003df8:	fb06 331e 	mls	r3, r6, lr, r3
 8003dfc:	0b52      	lsrs	r2, r2, #13
 8003dfe:	f006 fc47 	bl	800a690 <chprintf.constprop.26>
 8003e02:	4a66      	ldr	r2, [pc, #408]	; (8003f9c <moduleTRACKING+0x65c>)
 8003e04:	4966      	ldr	r1, [pc, #408]	; (8003fa0 <moduleTRACKING+0x660>)
 8003e06:	4864      	ldr	r0, [pc, #400]	; (8003f98 <moduleTRACKING+0x658>)
 8003e08:	f006 fc42 	bl	800a690 <chprintf.constprop.26>
 8003e0c:	f44f 73a3 	mov.w	r3, #326	; 0x146
 8003e10:	4a6c      	ldr	r2, [pc, #432]	; (8003fc4 <moduleTRACKING+0x684>)
 8003e12:	4965      	ldr	r1, [pc, #404]	; (8003fa8 <moduleTRACKING+0x668>)
 8003e14:	4860      	ldr	r0, [pc, #384]	; (8003f98 <moduleTRACKING+0x658>)
 8003e16:	f006 fc3b 	bl	800a690 <chprintf.constprop.26>
 8003e1a:	4964      	ldr	r1, [pc, #400]	; (8003fac <moduleTRACKING+0x66c>)
 8003e1c:	485e      	ldr	r0, [pc, #376]	; (8003f98 <moduleTRACKING+0x658>)
 8003e1e:	f006 fc37 	bl	800a690 <chprintf.constprop.26>
 8003e22:	496c      	ldr	r1, [pc, #432]	; (8003fd4 <moduleTRACKING+0x694>)
 8003e24:	485c      	ldr	r0, [pc, #368]	; (8003f98 <moduleTRACKING+0x658>)
 8003e26:	f006 fc33 	bl	800a690 <chprintf.constprop.26>
 8003e2a:	4962      	ldr	r1, [pc, #392]	; (8003fb4 <moduleTRACKING+0x674>)
 8003e2c:	485a      	ldr	r0, [pc, #360]	; (8003f98 <moduleTRACKING+0x658>)
 8003e2e:	f006 fc2f 	bl	800a690 <chprintf.constprop.26>
 8003e32:	4861      	ldr	r0, [pc, #388]	; (8003fb8 <moduleTRACKING+0x678>)
 8003e34:	f005 fba4 	bl	8009580 <chMtxUnlock>
	sdStart(&SD5, &gps_config);
 8003e38:	4967      	ldr	r1, [pc, #412]	; (8003fd8 <moduleTRACKING+0x698>)
 8003e3a:	4868      	ldr	r0, [pc, #416]	; (8003fdc <moduleTRACKING+0x69c>)
 8003e3c:	f005 f8f0 	bl	8009020 <sdStart>

	// Switch MOSFET
	TRACE_INFO("GPS  > Switch on");
 8003e40:	485d      	ldr	r0, [pc, #372]	; (8003fb8 <moduleTRACKING+0x678>)
 8003e42:	f008 f9ad 	bl	800c1a0 <chMtxLock>
 8003e46:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003e48:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003e4a:	4952      	ldr	r1, [pc, #328]	; (8003f94 <moduleTRACKING+0x654>)
 8003e4c:	4852      	ldr	r0, [pc, #328]	; (8003f98 <moduleTRACKING+0x658>)
 8003e4e:	fb06 f303 	mul.w	r3, r6, r3
 8003e52:	fba7 e303 	umull	lr, r3, r7, r3
 8003e56:	0b5b      	lsrs	r3, r3, #13
 8003e58:	fba4 ce03 	umull	ip, lr, r4, r3
 8003e5c:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8003e60:	fba7 c202 	umull	ip, r2, r7, r2
 8003e64:	fb06 331e 	mls	r3, r6, lr, r3
 8003e68:	0b52      	lsrs	r2, r2, #13
 8003e6a:	f006 fc11 	bl	800a690 <chprintf.constprop.26>
 8003e6e:	4a4b      	ldr	r2, [pc, #300]	; (8003f9c <moduleTRACKING+0x65c>)
 8003e70:	494b      	ldr	r1, [pc, #300]	; (8003fa0 <moduleTRACKING+0x660>)
 8003e72:	4849      	ldr	r0, [pc, #292]	; (8003f98 <moduleTRACKING+0x658>)
 8003e74:	f006 fc0c 	bl	800a690 <chprintf.constprop.26>
 8003e78:	f44f 73a5 	mov.w	r3, #330	; 0x14a
 8003e7c:	4a51      	ldr	r2, [pc, #324]	; (8003fc4 <moduleTRACKING+0x684>)
 8003e7e:	494a      	ldr	r1, [pc, #296]	; (8003fa8 <moduleTRACKING+0x668>)
 8003e80:	4845      	ldr	r0, [pc, #276]	; (8003f98 <moduleTRACKING+0x658>)
 8003e82:	f006 fc05 	bl	800a690 <chprintf.constprop.26>
 8003e86:	4949      	ldr	r1, [pc, #292]	; (8003fac <moduleTRACKING+0x66c>)
 8003e88:	4843      	ldr	r0, [pc, #268]	; (8003f98 <moduleTRACKING+0x658>)
 8003e8a:	f006 fc01 	bl	800a690 <chprintf.constprop.26>
 8003e8e:	4954      	ldr	r1, [pc, #336]	; (8003fe0 <moduleTRACKING+0x6a0>)
 8003e90:	4841      	ldr	r0, [pc, #260]	; (8003f98 <moduleTRACKING+0x658>)
 8003e92:	f006 fbfd 	bl	800a690 <chprintf.constprop.26>
 8003e96:	4947      	ldr	r1, [pc, #284]	; (8003fb4 <moduleTRACKING+0x674>)
 8003e98:	483f      	ldr	r0, [pc, #252]	; (8003f98 <moduleTRACKING+0x658>)
 8003e9a:	f006 fbf9 	bl	800a690 <chprintf.constprop.26>
 8003e9e:	4846      	ldr	r0, [pc, #280]	; (8003fb8 <moduleTRACKING+0x678>)
 8003ea0:	f005 fb6e 	bl	8009580 <chMtxUnlock>
	palSetPad(PORT(GPS_RESET), PIN(GPS_RESET));	// Pull up GPS reset
 8003ea4:	2280      	movs	r2, #128	; 0x80
	palSetPad(PORT(GPS_EN), PIN(GPS_EN));		// Switch on GPS
 8003ea6:	2308      	movs	r3, #8
	TRACE_INFO("GPS  > Init GPS UART");
	sdStart(&SD5, &gps_config);

	// Switch MOSFET
	TRACE_INFO("GPS  > Switch on");
	palSetPad(PORT(GPS_RESET), PIN(GPS_RESET));	// Pull up GPS reset
 8003ea8:	f8a9 2018 	strh.w	r2, [r9, #24]
	palSetPad(PORT(GPS_EN), PIN(GPS_EN));		// Switch on GPS
	
	// Wait for GPS startup
	chThdSleepMilliseconds(3000);
 8003eac:	f247 5030 	movw	r0, #30000	; 0x7530
	sdStart(&SD5, &gps_config);

	// Switch MOSFET
	TRACE_INFO("GPS  > Switch on");
	palSetPad(PORT(GPS_RESET), PIN(GPS_RESET));	// Pull up GPS reset
	palSetPad(PORT(GPS_EN), PIN(GPS_EN));		// Switch on GPS
 8003eb0:	f8aa 3018 	strh.w	r3, [sl, #24]
	
	// Wait for GPS startup
	chThdSleepMilliseconds(3000);
 8003eb4:	f008 fa44 	bl	800c340 <chThdSleep>

	uint8_t status = 1;

	// Configure GPS
	TRACE_INFO("GPS  > Initialize GPS");
 8003eb8:	483f      	ldr	r0, [pc, #252]	; (8003fb8 <moduleTRACKING+0x678>)
 8003eba:	f008 f971 	bl	800c1a0 <chMtxLock>
 8003ebe:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003ec0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003ec2:	4934      	ldr	r1, [pc, #208]	; (8003f94 <moduleTRACKING+0x654>)
 8003ec4:	4834      	ldr	r0, [pc, #208]	; (8003f98 <moduleTRACKING+0x658>)
 8003ec6:	fb06 f303 	mul.w	r3, r6, r3
 8003eca:	fba7 e303 	umull	lr, r3, r7, r3
 8003ece:	0b5b      	lsrs	r3, r3, #13
 8003ed0:	fba4 ce03 	umull	ip, lr, r4, r3
 8003ed4:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8003ed8:	fba7 c202 	umull	ip, r2, r7, r2
 8003edc:	fb06 331e 	mls	r3, r6, lr, r3
 8003ee0:	0b52      	lsrs	r2, r2, #13
 8003ee2:	f006 fbd5 	bl	800a690 <chprintf.constprop.26>
 8003ee6:	4a2d      	ldr	r2, [pc, #180]	; (8003f9c <moduleTRACKING+0x65c>)
 8003ee8:	492d      	ldr	r1, [pc, #180]	; (8003fa0 <moduleTRACKING+0x660>)
 8003eea:	482b      	ldr	r0, [pc, #172]	; (8003f98 <moduleTRACKING+0x658>)
 8003eec:	f006 fbd0 	bl	800a690 <chprintf.constprop.26>
 8003ef0:	f44f 73aa 	mov.w	r3, #340	; 0x154
 8003ef4:	4a33      	ldr	r2, [pc, #204]	; (8003fc4 <moduleTRACKING+0x684>)
 8003ef6:	492c      	ldr	r1, [pc, #176]	; (8003fa8 <moduleTRACKING+0x668>)
 8003ef8:	4827      	ldr	r0, [pc, #156]	; (8003f98 <moduleTRACKING+0x658>)
 8003efa:	f006 fbc9 	bl	800a690 <chprintf.constprop.26>
 8003efe:	492b      	ldr	r1, [pc, #172]	; (8003fac <moduleTRACKING+0x66c>)
 8003f00:	4825      	ldr	r0, [pc, #148]	; (8003f98 <moduleTRACKING+0x658>)
 8003f02:	f006 fbc5 	bl	800a690 <chprintf.constprop.26>
 8003f06:	4937      	ldr	r1, [pc, #220]	; (8003fe4 <moduleTRACKING+0x6a4>)
 8003f08:	4823      	ldr	r0, [pc, #140]	; (8003f98 <moduleTRACKING+0x658>)
 8003f0a:	f006 fbc1 	bl	800a690 <chprintf.constprop.26>
 8003f0e:	4929      	ldr	r1, [pc, #164]	; (8003fb4 <moduleTRACKING+0x674>)
 8003f10:	4821      	ldr	r0, [pc, #132]	; (8003f98 <moduleTRACKING+0x658>)
 8003f12:	f006 fbbd 	bl	800a690 <chprintf.constprop.26>
 8003f16:	4828      	ldr	r0, [pc, #160]	; (8003fb8 <moduleTRACKING+0x678>)
 8003f18:	f005 fb32 	bl	8009580 <chMtxUnlock>
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_disable_nmea_output(void) {
	uint8_t nonmea[] = {
 8003f1c:	4b32      	ldr	r3, [pc, #200]	; (8003fe8 <moduleTRACKING+0x6a8>)
 8003f1e:	6818      	ldr	r0, [r3, #0]
 8003f20:	6859      	ldr	r1, [r3, #4]
 8003f22:	689a      	ldr	r2, [r3, #8]
 8003f24:	68db      	ldr	r3, [r3, #12]
 8003f26:	f50d 7e9e 	add.w	lr, sp, #316	; 0x13c
 8003f2a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 8003f2e:	4b2e      	ldr	r3, [pc, #184]	; (8003fe8 <moduleTRACKING+0x6a8>)
 8003f30:	6918      	ldr	r0, [r3, #16]
 8003f32:	6959      	ldr	r1, [r3, #20]
 8003f34:	699a      	ldr	r2, [r3, #24]
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 8003f36:	f04f 33ff 	mov.w	r3, #4294967295
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_disable_nmea_output(void) {
	uint8_t nonmea[] = {
 8003f3a:	e8ae 0007 	stmia.w	lr!, {r0, r1, r2}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 8003f3e:	221c      	movs	r2, #28
 8003f40:	a94f      	add	r1, sp, #316	; 0x13c
 8003f42:	482a      	ldr	r0, [pc, #168]	; (8003fec <moduleTRACKING+0x6ac>)
 8003f44:	f005 f8f4 	bl	8009130 <oqWriteTimeout>
		0x00, 0x00,							// reserved
		0xaa, 0x79							// checksum
	};

	gps_transmit_string(nonmea, sizeof(nonmea));
	return gps_receive_ack(0x06, 0x00, 1000);
 8003f48:	4640      	mov	r0, r8
 8003f4a:	f009 f9f1 	bl	800d330 <gps_receive_ack.constprop.14>

	uint8_t status = 1;

	// Configure GPS
	TRACE_INFO("GPS  > Initialize GPS");
	if(gps_disable_nmea_output()) {
 8003f4e:	2800      	cmp	r0, #0
 8003f50:	f001 80a1 	beq.w	8005096 <moduleTRACKING+0x1756>
		TRACE_INFO("GPS  > Disable NMEA output OK");
 8003f54:	4818      	ldr	r0, [pc, #96]	; (8003fb8 <moduleTRACKING+0x678>)
 8003f56:	f008 f923 	bl	800c1a0 <chMtxLock>
 8003f5a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003f5c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003f5e:	490d      	ldr	r1, [pc, #52]	; (8003f94 <moduleTRACKING+0x654>)
 8003f60:	fb06 f303 	mul.w	r3, r6, r3
 8003f64:	fba7 0303 	umull	r0, r3, r7, r3
 8003f68:	0b5b      	lsrs	r3, r3, #13
 8003f6a:	fba4 4003 	umull	r4, r0, r4, r3
 8003f6e:	0980      	lsrs	r0, r0, #6
 8003f70:	fba7 4202 	umull	r4, r2, r7, r2
 8003f74:	fb06 3310 	mls	r3, r6, r0, r3
 8003f78:	0b52      	lsrs	r2, r2, #13
 8003f7a:	4807      	ldr	r0, [pc, #28]	; (8003f98 <moduleTRACKING+0x658>)
 8003f7c:	f006 fb88 	bl	800a690 <chprintf.constprop.26>
 8003f80:	4a06      	ldr	r2, [pc, #24]	; (8003f9c <moduleTRACKING+0x65c>)
 8003f82:	4907      	ldr	r1, [pc, #28]	; (8003fa0 <moduleTRACKING+0x660>)
 8003f84:	4804      	ldr	r0, [pc, #16]	; (8003f98 <moduleTRACKING+0x658>)
 8003f86:	f006 fb83 	bl	800a690 <chprintf.constprop.26>
 8003f8a:	f44f 73ab 	mov.w	r3, #342	; 0x156
 8003f8e:	4a0d      	ldr	r2, [pc, #52]	; (8003fc4 <moduleTRACKING+0x684>)
 8003f90:	4905      	ldr	r1, [pc, #20]	; (8003fa8 <moduleTRACKING+0x668>)
 8003f92:	e02d      	b.n	8003ff0 <moduleTRACKING+0x6b0>
 8003f94:	0800ea50 	.word	0x0800ea50
 8003f98:	2001ac28 	.word	0x2001ac28
 8003f9c:	0800f1dc 	.word	0x0800f1dc
 8003fa0:	0800ea64 	.word	0x0800ea64
 8003fa4:	0800f15c 	.word	0x0800f15c
 8003fa8:	0800ea7c 	.word	0x0800ea7c
 8003fac:	0800f1e0 	.word	0x0800f1e0
 8003fb0:	0800f2a4 	.word	0x0800f2a4
 8003fb4:	0800eaa8 	.word	0x0800eaa8
 8003fb8:	2001b720 	.word	0x2001b720
 8003fbc:	2001aa2c 	.word	0x2001aa2c
 8003fc0:	20000810 	.word	0x20000810
 8003fc4:	0800f2d4 	.word	0x0800f2d4
 8003fc8:	0800f2dc 	.word	0x0800f2dc
 8003fcc:	40020400 	.word	0x40020400
 8003fd0:	40020800 	.word	0x40020800
 8003fd4:	0800f2f0 	.word	0x0800f2f0
 8003fd8:	0800f110 	.word	0x0800f110
 8003fdc:	2001b6a4 	.word	0x2001b6a4
 8003fe0:	0800f308 	.word	0x0800f308
 8003fe4:	0800f31c 	.word	0x0800f31c
 8003fe8:	0800e74c 	.word	0x0800e74c
 8003fec:	2001b6d4 	.word	0x2001b6d4
 8003ff0:	489c      	ldr	r0, [pc, #624]	; (8004264 <moduleTRACKING+0x924>)
 8003ff2:	f006 fb4d 	bl	800a690 <chprintf.constprop.26>
 8003ff6:	499c      	ldr	r1, [pc, #624]	; (8004268 <moduleTRACKING+0x928>)
 8003ff8:	489a      	ldr	r0, [pc, #616]	; (8004264 <moduleTRACKING+0x924>)
 8003ffa:	f006 fb49 	bl	800a690 <chprintf.constprop.26>
 8003ffe:	499b      	ldr	r1, [pc, #620]	; (800426c <moduleTRACKING+0x92c>)
 8004000:	4898      	ldr	r0, [pc, #608]	; (8004264 <moduleTRACKING+0x924>)
 8004002:	f006 fb45 	bl	800a690 <chprintf.constprop.26>
 8004006:	499a      	ldr	r1, [pc, #616]	; (8004270 <moduleTRACKING+0x930>)
 8004008:	4896      	ldr	r0, [pc, #600]	; (8004264 <moduleTRACKING+0x924>)
 800400a:	f006 fb41 	bl	800a690 <chprintf.constprop.26>
 800400e:	4899      	ldr	r0, [pc, #612]	; (8004274 <moduleTRACKING+0x934>)
 8004010:	f005 fab6 	bl	8009580 <chMtxUnlock>
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_set_airborne_model(void) {
	uint8_t model6[] = {
 8004014:	4c98      	ldr	r4, [pc, #608]	; (8004278 <moduleTRACKING+0x938>)
 8004016:	ad4f      	add	r5, sp, #316	; 0x13c
 8004018:	f104 0720 	add.w	r7, r4, #32
 800401c:	6820      	ldr	r0, [r4, #0]
 800401e:	6861      	ldr	r1, [r4, #4]
 8004020:	68a2      	ldr	r2, [r4, #8]
 8004022:	68e3      	ldr	r3, [r4, #12]
 8004024:	462e      	mov	r6, r5
 8004026:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8004028:	3410      	adds	r4, #16
 800402a:	42bc      	cmp	r4, r7
 800402c:	4635      	mov	r5, r6
 800402e:	d1f5      	bne.n	800401c <moduleTRACKING+0x6dc>
 8004030:	6820      	ldr	r0, [r4, #0]
 8004032:	6861      	ldr	r1, [r4, #4]
 8004034:	68a2      	ldr	r2, [r4, #8]
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 8004036:	f04f 33ff 	mov.w	r3, #4294967295
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_set_airborne_model(void) {
	uint8_t model6[] = {
 800403a:	c507      	stmia	r5!, {r0, r1, r2}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 800403c:	222c      	movs	r2, #44	; 0x2c
 800403e:	a94f      	add	r1, sp, #316	; 0x13c
 8004040:	488e      	ldr	r0, [pc, #568]	; (800427c <moduleTRACKING+0x93c>)
 8004042:	f005 f875 	bl	8009130 <oqWriteTimeout>
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 	// reserved
		0x1a, 0x28								// checksum
	};

	gps_transmit_string(model6, sizeof(model6));
	return gps_receive_ack(0x06, 0x24, 1000);
 8004046:	2024      	movs	r0, #36	; 0x24
 8004048:	f009 f972 	bl	800d330 <gps_receive_ack.constprop.14>
	} else {
		TRACE_ERROR("GPS  > Disable NMEA output FAILED");
		status = 0;
	}

	if(gps_set_airborne_model()) {
 800404c:	2800      	cmp	r0, #0
 800404e:	f000 87e4 	beq.w	800501a <moduleTRACKING+0x16da>
		TRACE_INFO("GPS  > Set airborne model OK");
 8004052:	4888      	ldr	r0, [pc, #544]	; (8004274 <moduleTRACKING+0x934>)
 8004054:	4c8a      	ldr	r4, [pc, #552]	; (8004280 <moduleTRACKING+0x940>)
 8004056:	f008 f8a3 	bl	800c1a0 <chMtxLock>
 800405a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800405e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004062:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004064:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8004066:	4b87      	ldr	r3, [pc, #540]	; (8004284 <moduleTRACKING+0x944>)
 8004068:	fb00 f101 	mul.w	r1, r0, r1
 800406c:	fba4 5101 	umull	r5, r1, r4, r1
 8004070:	0b49      	lsrs	r1, r1, #13
 8004072:	fba3 5301 	umull	r5, r3, r3, r1
 8004076:	fba4 4202 	umull	r4, r2, r4, r2
 800407a:	099b      	lsrs	r3, r3, #6
 800407c:	fb00 1313 	mls	r3, r0, r3, r1
 8004080:	0b52      	lsrs	r2, r2, #13
 8004082:	4981      	ldr	r1, [pc, #516]	; (8004288 <moduleTRACKING+0x948>)
 8004084:	4877      	ldr	r0, [pc, #476]	; (8004264 <moduleTRACKING+0x924>)
 8004086:	f006 fb03 	bl	800a690 <chprintf.constprop.26>
 800408a:	4a80      	ldr	r2, [pc, #512]	; (800428c <moduleTRACKING+0x94c>)
 800408c:	4980      	ldr	r1, [pc, #512]	; (8004290 <moduleTRACKING+0x950>)
 800408e:	4875      	ldr	r0, [pc, #468]	; (8004264 <moduleTRACKING+0x924>)
 8004090:	f006 fafe 	bl	800a690 <chprintf.constprop.26>
 8004094:	f240 135d 	movw	r3, #349	; 0x15d
 8004098:	4a7e      	ldr	r2, [pc, #504]	; (8004294 <moduleTRACKING+0x954>)
 800409a:	497f      	ldr	r1, [pc, #508]	; (8004298 <moduleTRACKING+0x958>)
 800409c:	4871      	ldr	r0, [pc, #452]	; (8004264 <moduleTRACKING+0x924>)
 800409e:	f006 faf7 	bl	800a690 <chprintf.constprop.26>
 80040a2:	4971      	ldr	r1, [pc, #452]	; (8004268 <moduleTRACKING+0x928>)
 80040a4:	486f      	ldr	r0, [pc, #444]	; (8004264 <moduleTRACKING+0x924>)
 80040a6:	f006 faf3 	bl	800a690 <chprintf.constprop.26>
 80040aa:	497c      	ldr	r1, [pc, #496]	; (800429c <moduleTRACKING+0x95c>)
 80040ac:	486d      	ldr	r0, [pc, #436]	; (8004264 <moduleTRACKING+0x924>)
 80040ae:	f006 faef 	bl	800a690 <chprintf.constprop.26>
 80040b2:	496f      	ldr	r1, [pc, #444]	; (8004270 <moduleTRACKING+0x930>)
 80040b4:	486b      	ldr	r0, [pc, #428]	; (8004264 <moduleTRACKING+0x924>)
 80040b6:	f006 faeb 	bl	800a690 <chprintf.constprop.26>
 80040ba:	486e      	ldr	r0, [pc, #440]	; (8004274 <moduleTRACKING+0x934>)
 80040bc:	f005 fa60 	bl	8009580 <chMtxUnlock>
 *
 * returns if ACKed by GPS
 *
 */
uint8_t gps_set_power_save(void) {
	uint8_t powersave[] = {
 80040c0:	4c77      	ldr	r4, [pc, #476]	; (80042a0 <moduleTRACKING+0x960>)
 80040c2:	ae4f      	add	r6, sp, #316	; 0x13c
 80040c4:	f104 0730 	add.w	r7, r4, #48	; 0x30
 80040c8:	6820      	ldr	r0, [r4, #0]
 80040ca:	6861      	ldr	r1, [r4, #4]
 80040cc:	68a2      	ldr	r2, [r4, #8]
 80040ce:	68e3      	ldr	r3, [r4, #12]
 80040d0:	4635      	mov	r5, r6
 80040d2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80040d4:	3410      	adds	r4, #16
 80040d6:	42bc      	cmp	r4, r7
 80040d8:	462e      	mov	r6, r5
 80040da:	d1f5      	bne.n	80040c8 <moduleTRACKING+0x788>
 80040dc:	6820      	ldr	r0, [r4, #0]
 80040de:	6028      	str	r0, [r5, #0]
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 80040e0:	f04f 33ff 	mov.w	r3, #4294967295
 80040e4:	2234      	movs	r2, #52	; 0x34
 80040e6:	a94f      	add	r1, sp, #316	; 0x13c
 80040e8:	4864      	ldr	r0, [pc, #400]	; (800427c <moduleTRACKING+0x93c>)
 80040ea:	f005 f821 	bl	8009130 <oqWriteTimeout>
		0x00, 0x00, 0x00, 0x00,				// reserved 11
		0xef, 0x29
	};

	gps_transmit_string(powersave, sizeof(powersave));
	return gps_receive_ack(0x06, 0x3B, 1000);
 80040ee:	203b      	movs	r0, #59	; 0x3b
 80040f0:	f009 f91e 	bl	800d330 <gps_receive_ack.constprop.14>
		TRACE_INFO("GPS  > Set airborne model OK");
	} else {
		TRACE_ERROR("GPS  > Set airborne model FAILED");
		status = 0;
	}
	if(gps_set_power_save()) {
 80040f4:	2800      	cmp	r0, #0
 80040f6:	f000 8705 	beq.w	8004f04 <moduleTRACKING+0x15c4>
		TRACE_INFO("GPS  > Configure power save OK");
 80040fa:	485e      	ldr	r0, [pc, #376]	; (8004274 <moduleTRACKING+0x934>)
 80040fc:	4c60      	ldr	r4, [pc, #384]	; (8004280 <moduleTRACKING+0x940>)
 80040fe:	f008 f84f 	bl	800c1a0 <chMtxLock>
 8004102:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004106:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800410a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800410c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800410e:	4b5d      	ldr	r3, [pc, #372]	; (8004284 <moduleTRACKING+0x944>)
 8004110:	fb00 f101 	mul.w	r1, r0, r1
 8004114:	fba4 5101 	umull	r5, r1, r4, r1
 8004118:	0b49      	lsrs	r1, r1, #13
 800411a:	fba3 5301 	umull	r5, r3, r3, r1
 800411e:	fba4 4202 	umull	r4, r2, r4, r2
 8004122:	099b      	lsrs	r3, r3, #6
 8004124:	fb00 1313 	mls	r3, r0, r3, r1
 8004128:	0b52      	lsrs	r2, r2, #13
 800412a:	4957      	ldr	r1, [pc, #348]	; (8004288 <moduleTRACKING+0x948>)
 800412c:	484d      	ldr	r0, [pc, #308]	; (8004264 <moduleTRACKING+0x924>)
 800412e:	f006 faaf 	bl	800a690 <chprintf.constprop.26>
 8004132:	4a56      	ldr	r2, [pc, #344]	; (800428c <moduleTRACKING+0x94c>)
 8004134:	4956      	ldr	r1, [pc, #344]	; (8004290 <moduleTRACKING+0x950>)
 8004136:	484b      	ldr	r0, [pc, #300]	; (8004264 <moduleTRACKING+0x924>)
 8004138:	f006 faaa 	bl	800a690 <chprintf.constprop.26>
 800413c:	f240 1363 	movw	r3, #355	; 0x163
 8004140:	4a54      	ldr	r2, [pc, #336]	; (8004294 <moduleTRACKING+0x954>)
 8004142:	4955      	ldr	r1, [pc, #340]	; (8004298 <moduleTRACKING+0x958>)
 8004144:	4847      	ldr	r0, [pc, #284]	; (8004264 <moduleTRACKING+0x924>)
 8004146:	f006 faa3 	bl	800a690 <chprintf.constprop.26>
 800414a:	4947      	ldr	r1, [pc, #284]	; (8004268 <moduleTRACKING+0x928>)
 800414c:	4845      	ldr	r0, [pc, #276]	; (8004264 <moduleTRACKING+0x924>)
 800414e:	f006 fa9f 	bl	800a690 <chprintf.constprop.26>
 8004152:	4954      	ldr	r1, [pc, #336]	; (80042a4 <moduleTRACKING+0x964>)
 8004154:	4843      	ldr	r0, [pc, #268]	; (8004264 <moduleTRACKING+0x924>)
 8004156:	f006 fa9b 	bl	800a690 <chprintf.constprop.26>
 800415a:	4945      	ldr	r1, [pc, #276]	; (8004270 <moduleTRACKING+0x930>)
 800415c:	4841      	ldr	r0, [pc, #260]	; (8004264 <moduleTRACKING+0x924>)
 800415e:	f006 fa97 	bl	800a690 <chprintf.constprop.26>
 8004162:	4844      	ldr	r0, [pc, #272]	; (8004274 <moduleTRACKING+0x934>)
 8004164:	f005 fa0c 	bl	8009580 <chMtxUnlock>
 * gps_power_save
 *
 * enables or disables the power save mode (which was configured before)
 */
uint8_t gps_power_save(int on) {
	uint8_t recvmgmt[] = {
 8004168:	4b4f      	ldr	r3, [pc, #316]	; (80042a8 <moduleTRACKING+0x968>)
 800416a:	6818      	ldr	r0, [r3, #0]
 800416c:	6859      	ldr	r1, [r3, #4]
 800416e:	ab4f      	add	r3, sp, #316	; 0x13c
 8004170:	c303      	stmia	r3!, {r0, r1}
		0xB5, 0x62, 0x06, 0x11, 2, 0,	// UBX-CFG-RXM
		0x08, 0x01,						// reserved, enable power save mode
		0x22, 0x92
	};
	if (!on) {
		recvmgmt[7] = 0x00;		// continuous mode
 8004172:	2100      	movs	r1, #0
		recvmgmt[8] = 0x21;		// new checksum
 8004174:	2021      	movs	r0, #33	; 0x21
		0xB5, 0x62, 0x06, 0x11, 2, 0,	// UBX-CFG-RXM
		0x08, 0x01,						// reserved, enable power save mode
		0x22, 0x92
	};
	if (!on) {
		recvmgmt[7] = 0x00;		// continuous mode
 8004176:	f88d 1143 	strb.w	r1, [sp, #323]	; 0x143
		recvmgmt[8] = 0x21;		// new checksum
 800417a:	f88d 0144 	strb.w	r0, [sp, #324]	; 0x144
		recvmgmt[9] = 0x91;
 800417e:	2491      	movs	r4, #145	; 0x91
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 8004180:	f04f 33ff 	mov.w	r3, #4294967295
 8004184:	220a      	movs	r2, #10
 8004186:	a94f      	add	r1, sp, #316	; 0x13c
 8004188:	483c      	ldr	r0, [pc, #240]	; (800427c <moduleTRACKING+0x93c>)
		0x22, 0x92
	};
	if (!on) {
		recvmgmt[7] = 0x00;		// continuous mode
		recvmgmt[8] = 0x21;		// new checksum
		recvmgmt[9] = 0x91;
 800418a:	f88d 4145 	strb.w	r4, [sp, #325]	; 0x145
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 800418e:	f004 ffcf 	bl	8009130 <oqWriteTimeout>
		recvmgmt[8] = 0x21;		// new checksum
		recvmgmt[9] = 0x91;
	}

	gps_transmit_string(recvmgmt, sizeof(recvmgmt));
	return gps_receive_ack(0x06, 0x11, 1000);
 8004192:	2011      	movs	r0, #17
 8004194:	f009 f8cc 	bl	800d330 <gps_receive_ack.constprop.14>
		TRACE_INFO("GPS  > Configure power save OK");
	} else {
		TRACE_ERROR("GPS  > Configure power save FAILED");
		status = 0;
	}
	if(gps_power_save(0)) {
 8004198:	2800      	cmp	r0, #0
 800419a:	f040 87b4 	bne.w	8005106 <moduleTRACKING+0x17c6>
		TRACE_INFO("GPS  > Disable power save OK");
	} else {
		TRACE_ERROR("GPS  > Disable power save FAILED");
 800419e:	4835      	ldr	r0, [pc, #212]	; (8004274 <moduleTRACKING+0x934>)
 80041a0:	4c37      	ldr	r4, [pc, #220]	; (8004280 <moduleTRACKING+0x940>)
 80041a2:	f007 fffd 	bl	800c1a0 <chMtxLock>
 80041a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80041aa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80041ae:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80041b0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80041b2:	4b34      	ldr	r3, [pc, #208]	; (8004284 <moduleTRACKING+0x944>)
 80041b4:	fb00 f101 	mul.w	r1, r0, r1
 80041b8:	fba4 5101 	umull	r5, r1, r4, r1
 80041bc:	0b49      	lsrs	r1, r1, #13
 80041be:	fba3 5301 	umull	r5, r3, r3, r1
 80041c2:	fba4 4202 	umull	r4, r2, r4, r2
 80041c6:	099b      	lsrs	r3, r3, #6
 80041c8:	fb00 1313 	mls	r3, r0, r3, r1
 80041cc:	0b52      	lsrs	r2, r2, #13
 80041ce:	492e      	ldr	r1, [pc, #184]	; (8004288 <moduleTRACKING+0x948>)
 80041d0:	4824      	ldr	r0, [pc, #144]	; (8004264 <moduleTRACKING+0x924>)
 80041d2:	f006 fa5d 	bl	800a690 <chprintf.constprop.26>
 80041d6:	4a35      	ldr	r2, [pc, #212]	; (80042ac <moduleTRACKING+0x96c>)
 80041d8:	492d      	ldr	r1, [pc, #180]	; (8004290 <moduleTRACKING+0x950>)
 80041da:	4822      	ldr	r0, [pc, #136]	; (8004264 <moduleTRACKING+0x924>)
 80041dc:	f006 fa58 	bl	800a690 <chprintf.constprop.26>
 80041e0:	f240 136b 	movw	r3, #363	; 0x16b
 80041e4:	4a2b      	ldr	r2, [pc, #172]	; (8004294 <moduleTRACKING+0x954>)
 80041e6:	492c      	ldr	r1, [pc, #176]	; (8004298 <moduleTRACKING+0x958>)
 80041e8:	481e      	ldr	r0, [pc, #120]	; (8004264 <moduleTRACKING+0x924>)
 80041ea:	f006 fa51 	bl	800a690 <chprintf.constprop.26>
 80041ee:	491e      	ldr	r1, [pc, #120]	; (8004268 <moduleTRACKING+0x928>)
 80041f0:	481c      	ldr	r0, [pc, #112]	; (8004264 <moduleTRACKING+0x924>)
 80041f2:	f006 fa4d 	bl	800a690 <chprintf.constprop.26>
 80041f6:	492e      	ldr	r1, [pc, #184]	; (80042b0 <moduleTRACKING+0x970>)
 80041f8:	481a      	ldr	r0, [pc, #104]	; (8004264 <moduleTRACKING+0x924>)
 80041fa:	f006 fa49 	bl	800a690 <chprintf.constprop.26>
 80041fe:	491c      	ldr	r1, [pc, #112]	; (8004270 <moduleTRACKING+0x930>)
 8004200:	4818      	ldr	r0, [pc, #96]	; (8004264 <moduleTRACKING+0x924>)
 8004202:	f006 fa45 	bl	800a690 <chprintf.constprop.26>
 8004206:	481b      	ldr	r0, [pc, #108]	; (8004274 <moduleTRACKING+0x934>)
 8004208:	f005 f9ba 	bl	8009580 <chMtxUnlock>
 800420c:	f240 116b 	movw	r1, #363	; 0x16b
 8004210:	4820      	ldr	r0, [pc, #128]	; (8004294 <moduleTRACKING+0x954>)
 8004212:	f008 fbb5 	bl	800c980 <log_error>

		trackPoint_t* tp = &trackPoints[id % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Current track point
		trackPoint_t* ltp = &trackPoints[(id-1) % (sizeof(trackPoints) / sizeof(trackPoint_t))]; // Last track point

		// Search for GPS satellites
		gpsFix_t gpsFix = {{0,0,0,0,0,0,0},0,0,0,0,0};
 8004216:	2300      	movs	r3, #0
 8004218:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
	// Transmit request
	uint8_t pvt[] = {0xB5, 0x62, 0x01, 0x07, 0x00, 0x00, 0x08, 0x19};
	gps_transmit_string(pvt, sizeof(pvt));

	if(!gps_receive_payload(0x01, 0x07, response, 5000)) { // Receive request
		TRACE_INFO("GPS  > PVT Polling FAILED");
 800421c:	f8df b060 	ldr.w	fp, [pc, #96]	; 8004280 <moduleTRACKING+0x940>
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
				state = PAYLOAD;
				break;
			case PAYLOAD:
				payload[payload_cnt] = rx_byte;
 8004220:	4d24      	ldr	r5, [pc, #144]	; (80042b4 <moduleTRACKING+0x974>)
 8004222:	932a      	str	r3, [sp, #168]	; 0xa8
 8004224:	9320      	str	r3, [sp, #128]	; 0x80
 8004226:	9321      	str	r3, [sp, #132]	; 0x84
 8004228:	9323      	str	r3, [sp, #140]	; 0x8c
 800422a:	461f      	mov	r7, r3
 800422c:	9328      	str	r3, [sp, #160]	; 0xa0
 800422e:	9325      	str	r3, [sp, #148]	; 0x94
 8004230:	9324      	str	r3, [sp, #144]	; 0x90
 8004232:	9326      	str	r3, [sp, #152]	; 0x98
 8004234:	9327      	str	r3, [sp, #156]	; 0x9c
 8004236:	9329      	str	r3, [sp, #164]	; 0xa4
 8004238:	46a2      	mov	sl, r4
			// Switch on GPS
			GPS_Init();

			// Search for lock as long enough power is available
			do {
				batt = getBatteryVoltageMV();
 800423a:	f008 fe61 	bl	800cf00 <getBatteryVoltageMV>
 */
bool gps_get_fix(gpsFix_t *fix) {
	static uint8_t response[92];

	// Transmit request
	uint8_t pvt[] = {0xB5, 0x62, 0x01, 0x07, 0x00, 0x00, 0x08, 0x19};
 800423e:	4b1e      	ldr	r3, [pc, #120]	; (80042b8 <moduleTRACKING+0x978>)
 8004240:	6818      	ldr	r0, [r3, #0]
 8004242:	6859      	ldr	r1, [r3, #4]
 8004244:	ab4f      	add	r3, sp, #316	; 0x13c
 8004246:	c303      	stmia	r3!, {r0, r1}
 *
 * transmits a command to the GPS
 */
void gps_transmit_string(uint8_t *cmd, uint8_t length)
{
	sdWrite(&SD5, cmd, length);
 8004248:	2208      	movs	r2, #8
 800424a:	f04f 33ff 	mov.w	r3, #4294967295
 800424e:	a94f      	add	r1, sp, #316	; 0x13c
 8004250:	480a      	ldr	r0, [pc, #40]	; (800427c <moduleTRACKING+0x93c>)
 8004252:	f004 ff6d 	bl	8009130 <oqWriteTimeout>
 8004256:	6a66      	ldr	r6, [r4, #36]	; 0x24
	uint8_t rx_byte;
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
 8004258:	f506 4643 	add.w	r6, r6, #49920	; 0xc300
 800425c:	3650      	adds	r6, #80	; 0x50
 * returns the length of the payload
 *
 */
uint16_t gps_receive_payload(uint8_t class_id, uint8_t msg_id, unsigned char *payload, uint16_t timeout) {
	uint8_t rx_byte;
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
 800425e:	f04f 0800 	mov.w	r8, #0
 8004262:	e039      	b.n	80042d8 <moduleTRACKING+0x998>
 8004264:	2001ac28 	.word	0x2001ac28
 8004268:	0800f1e0 	.word	0x0800f1e0
 800426c:	0800f334 	.word	0x0800f334
 8004270:	0800eaa8 	.word	0x0800eaa8
 8004274:	2001b720 	.word	0x2001b720
 8004278:	0800e768 	.word	0x0800e768
 800427c:	2001b6d4 	.word	0x2001b6d4
 8004280:	d1b71759 	.word	0xd1b71759
 8004284:	10624dd3 	.word	0x10624dd3
 8004288:	0800ea50 	.word	0x0800ea50
 800428c:	0800f1dc 	.word	0x0800f1dc
 8004290:	0800ea64 	.word	0x0800ea64
 8004294:	0800f2d4 	.word	0x0800f2d4
 8004298:	0800ea7c 	.word	0x0800ea7c
 800429c:	0800f378 	.word	0x0800f378
 80042a0:	0800e794 	.word	0x0800e794
 80042a4:	0800f3bc 	.word	0x0800f3bc
 80042a8:	0800e7c8 	.word	0x0800e7c8
 80042ac:	0800ea5c 	.word	0x0800ea5c
 80042b0:	0800f420 	.word	0x0800f420
 80042b4:	20000874 	.word	0x20000874
 80042b8:	0800e7d4 	.word	0x0800e7d4
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 80042bc:	429e      	cmp	r6, r3
 80042be:	d328      	bcc.n	8004312 <moduleTRACKING+0x9d2>
 80042c0:	6a61      	ldr	r1, [r4, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 80042c2:	48b6      	ldr	r0, [pc, #728]	; (800459c <moduleTRACKING+0xc5c>)
 80042c4:	1a71      	subs	r1, r6, r1
 80042c6:	f005 f8c3 	bl	8009450 <iqGetTimeout>
 80042ca:	b2c0      	uxtb	r0, r0

		// Process one byte
		switch (state) {
			case UBX_A:
				if (rx_byte == 0xB5)	state = UBX_B;
				else 			state = UBX_A;
 80042cc:	f1a0 08b5 	sub.w	r8, r0, #181	; 0xb5
 80042d0:	fab8 f888 	clz	r8, r8
 80042d4:	ea4f 1858 	mov.w	r8, r8, lsr #5
 80042d8:	6a63      	ldr	r3, [r4, #36]	; 0x24
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 80042da:	429e      	cmp	r6, r3
 80042dc:	d319      	bcc.n	8004312 <moduleTRACKING+0x9d2>
 80042de:	6a61      	ldr	r1, [r4, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 80042e0:	48ae      	ldr	r0, [pc, #696]	; (800459c <moduleTRACKING+0xc5c>)
 80042e2:	1a71      	subs	r1, r6, r1
 80042e4:	f005 f8b4 	bl	8009450 <iqGetTimeout>
 80042e8:	b2c0      	uxtb	r0, r0

		// Process one byte
		switch (state) {
 80042ea:	f1b8 0f00 	cmp.w	r8, #0
 80042ee:	d0ed      	beq.n	80042cc <moduleTRACKING+0x98c>
			case UBX_A:
				if (rx_byte == 0xB5)	state = UBX_B;
				else 			state = UBX_A;
				break;
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
 80042f0:	2862      	cmp	r0, #98	; 0x62
 80042f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80042f4:	d1e2      	bne.n	80042bc <moduleTRACKING+0x97c>
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 80042f6:	429e      	cmp	r6, r3
 80042f8:	d30b      	bcc.n	8004312 <moduleTRACKING+0x9d2>
 80042fa:	6a61      	ldr	r1, [r4, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 80042fc:	48a7      	ldr	r0, [pc, #668]	; (800459c <moduleTRACKING+0xc5c>)
 80042fe:	1a71      	subs	r1, r6, r1
 8004300:	f005 f8a6 	bl	8009450 <iqGetTimeout>
			case UBX_B:
				if (rx_byte == 0x62)	state = CLASSID;
				else			state = UBX_A;
				break;
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
 8004304:	b2c0      	uxtb	r0, r0
 8004306:	2801      	cmp	r0, #1
 8004308:	f000 8259 	beq.w	80047be <moduleTRACKING+0xe7e>
 800430c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800430e:	429e      	cmp	r6, r3
 8004310:	d2d6      	bcs.n	80042c0 <moduleTRACKING+0x980>
	// Transmit request
	uint8_t pvt[] = {0xB5, 0x62, 0x01, 0x07, 0x00, 0x00, 0x08, 0x19};
	gps_transmit_string(pvt, sizeof(pvt));

	if(!gps_receive_payload(0x01, 0x07, response, 5000)) { // Receive request
		TRACE_INFO("GPS  > PVT Polling FAILED");
 8004312:	48a3      	ldr	r0, [pc, #652]	; (80045a0 <moduleTRACKING+0xc60>)
 8004314:	f007 ff44 	bl	800c1a0 <chMtxLock>
 8004318:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800431a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800431c:	49a1      	ldr	r1, [pc, #644]	; (80045a4 <moduleTRACKING+0xc64>)
 800431e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8004322:	fb06 f000 	mul.w	r0, r6, r0
 8004326:	fbab 3000 	umull	r3, r0, fp, r0
 800432a:	4b9f      	ldr	r3, [pc, #636]	; (80045a8 <moduleTRACKING+0xc68>)
 800432c:	0b40      	lsrs	r0, r0, #13
 800432e:	fba3 e300 	umull	lr, r3, r3, r0
 8004332:	fbab e202 	umull	lr, r2, fp, r2
 8004336:	099b      	lsrs	r3, r3, #6
 8004338:	fb06 0313 	mls	r3, r6, r3, r0
 800433c:	0b52      	lsrs	r2, r2, #13
 800433e:	489b      	ldr	r0, [pc, #620]	; (80045ac <moduleTRACKING+0xc6c>)
 8004340:	f006 f9a6 	bl	800a690 <chprintf.constprop.26>
 8004344:	4a9a      	ldr	r2, [pc, #616]	; (80045b0 <moduleTRACKING+0xc70>)
 8004346:	499b      	ldr	r1, [pc, #620]	; (80045b4 <moduleTRACKING+0xc74>)
 8004348:	4898      	ldr	r0, [pc, #608]	; (80045ac <moduleTRACKING+0xc6c>)
 800434a:	f006 f9a1 	bl	800a690 <chprintf.constprop.26>
 800434e:	23a3      	movs	r3, #163	; 0xa3
 8004350:	4a99      	ldr	r2, [pc, #612]	; (80045b8 <moduleTRACKING+0xc78>)
 8004352:	499a      	ldr	r1, [pc, #616]	; (80045bc <moduleTRACKING+0xc7c>)
 8004354:	4895      	ldr	r0, [pc, #596]	; (80045ac <moduleTRACKING+0xc6c>)
 8004356:	f006 f99b 	bl	800a690 <chprintf.constprop.26>
 800435a:	4999      	ldr	r1, [pc, #612]	; (80045c0 <moduleTRACKING+0xc80>)
 800435c:	4893      	ldr	r0, [pc, #588]	; (80045ac <moduleTRACKING+0xc6c>)
 800435e:	f006 f997 	bl	800a690 <chprintf.constprop.26>
 8004362:	4998      	ldr	r1, [pc, #608]	; (80045c4 <moduleTRACKING+0xc84>)
 8004364:	4891      	ldr	r0, [pc, #580]	; (80045ac <moduleTRACKING+0xc6c>)
 8004366:	f006 f993 	bl	800a690 <chprintf.constprop.26>
 800436a:	4997      	ldr	r1, [pc, #604]	; (80045c8 <moduleTRACKING+0xc88>)
 800436c:	488f      	ldr	r0, [pc, #572]	; (80045ac <moduleTRACKING+0xc6c>)
 800436e:	f006 f98f 	bl	800a690 <chprintf.constprop.26>
 8004372:	488b      	ldr	r0, [pc, #556]	; (80045a0 <moduleTRACKING+0xc60>)
 8004374:	f005 f904 	bl	8009580 <chMtxUnlock>
				gps_get_fix(&gpsFix);
			} while(!isGPSLocked(&gpsFix) && batt >= GPS_OFF_VBAT && chVTGetSystemTimeX() <= time + S2ST(TRACK_CYCLE_TIME-5)); // Do as long no GPS lock and within timeout, timeout=cycle-1sec (-1sec in order to keep synchronization)
 8004378:	2f03      	cmp	r7, #3
 800437a:	f000 8310 	beq.w	800499e <moduleTRACKING+0x105e>
 800437e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8004380:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8004382:	f503 138c 	add.w	r3, r3, #1146880	; 0x118000
 8004386:	f503 6343 	add.w	r3, r3, #3120	; 0xc30
 800438a:	429a      	cmp	r2, r3
 800438c:	f67f af55 	bls.w	800423a <moduleTRACKING+0x8fa>

			if(batt < GPS_OFF_VBAT) // Switch off GPS at low batt
				GPS_Deinit();
		}

		if(isGPSLocked(&gpsFix)) { // GPS locked
 8004390:	2f03      	cmp	r7, #3
 8004392:	f000 85f5 	beq.w	8004f80 <moduleTRACKING+0x1640>
			tp->gps_sats = gpsFix.num_svs;

		} else { // GPS lost (keep GPS switched on)

			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");
 8004396:	4882      	ldr	r0, [pc, #520]	; (80045a0 <moduleTRACKING+0xc60>)
 8004398:	4c8c      	ldr	r4, [pc, #560]	; (80045cc <moduleTRACKING+0xc8c>)
 800439a:	f007 ff01 	bl	800c1a0 <chMtxLock>
 800439e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80043a2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80043a6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80043a8:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80043aa:	4b7f      	ldr	r3, [pc, #508]	; (80045a8 <moduleTRACKING+0xc68>)
 80043ac:	fb00 f101 	mul.w	r1, r0, r1
 80043b0:	fba4 5101 	umull	r5, r1, r4, r1
 80043b4:	0b49      	lsrs	r1, r1, #13
 80043b6:	fba3 5301 	umull	r5, r3, r3, r1
 80043ba:	fba4 4202 	umull	r4, r2, r4, r2
 80043be:	099b      	lsrs	r3, r3, #6
 80043c0:	fb00 1313 	mls	r3, r0, r3, r1
 80043c4:	0b52      	lsrs	r2, r2, #13
 80043c6:	4977      	ldr	r1, [pc, #476]	; (80045a4 <moduleTRACKING+0xc64>)
 80043c8:	4878      	ldr	r0, [pc, #480]	; (80045ac <moduleTRACKING+0xc6c>)
 80043ca:	f006 f961 	bl	800a690 <chprintf.constprop.26>
 80043ce:	4a80      	ldr	r2, [pc, #512]	; (80045d0 <moduleTRACKING+0xc90>)
 80043d0:	4978      	ldr	r1, [pc, #480]	; (80045b4 <moduleTRACKING+0xc74>)
 80043d2:	4876      	ldr	r0, [pc, #472]	; (80045ac <moduleTRACKING+0xc6c>)
 80043d4:	f006 f95c 	bl	800a690 <chprintf.constprop.26>
 80043d8:	23d7      	movs	r3, #215	; 0xd7
 80043da:	4a7e      	ldr	r2, [pc, #504]	; (80045d4 <moduleTRACKING+0xc94>)
 80043dc:	4977      	ldr	r1, [pc, #476]	; (80045bc <moduleTRACKING+0xc7c>)
 80043de:	4873      	ldr	r0, [pc, #460]	; (80045ac <moduleTRACKING+0xc6c>)
 80043e0:	f006 f956 	bl	800a690 <chprintf.constprop.26>
 80043e4:	4976      	ldr	r1, [pc, #472]	; (80045c0 <moduleTRACKING+0xc80>)
 80043e6:	4871      	ldr	r0, [pc, #452]	; (80045ac <moduleTRACKING+0xc6c>)
 80043e8:	f006 f952 	bl	800a690 <chprintf.constprop.26>
 80043ec:	497a      	ldr	r1, [pc, #488]	; (80045d8 <moduleTRACKING+0xc98>)
 80043ee:	486f      	ldr	r0, [pc, #444]	; (80045ac <moduleTRACKING+0xc6c>)
 80043f0:	f006 f94e 	bl	800a690 <chprintf.constprop.26>
 80043f4:	4974      	ldr	r1, [pc, #464]	; (80045c8 <moduleTRACKING+0xc88>)
 80043f6:	486d      	ldr	r0, [pc, #436]	; (80045ac <moduleTRACKING+0xc6c>)
 80043f8:	f006 f94a 	bl	800a690 <chprintf.constprop.26>
 80043fc:	4868      	ldr	r0, [pc, #416]	; (80045a0 <moduleTRACKING+0xc60>)
 80043fe:	f005 f8bf 	bl	8009580 <chMtxUnlock>

			// Take time from internal RTC
			getTime(&rtc);
 8004402:	a837      	add	r0, sp, #220	; 0xdc
 8004404:	f008 f894 	bl	800c530 <getTime>
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 8004408:	9b31      	ldr	r3, [sp, #196]	; 0xc4
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 800440a:	992b      	ldr	r1, [sp, #172]	; 0xac
 800440c:	f8bd 50dc 	ldrh.w	r5, [sp, #220]	; 0xdc
			tp->time.month = rtc.month;
 8004410:	f89d 40de 	ldrb.w	r4, [sp, #222]	; 0xde
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 8004414:	005a      	lsls	r2, r3, #1
 8004416:	441a      	add	r2, r3
 8004418:	4b70      	ldr	r3, [pc, #448]	; (80045dc <moduleTRACKING+0xc9c>)
 800441a:	eb03 1202 	add.w	r2, r3, r2, lsl #4
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 800441e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 8004420:	6910      	ldr	r0, [r2, #16]
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 8004422:	440b      	add	r3, r1
 8004424:	496d      	ldr	r1, [pc, #436]	; (80045dc <moduleTRACKING+0xc9c>)
 8004426:	eb01 1303 	add.w	r3, r1, r3, lsl #4
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
 800442a:	f89d 10df 	ldrb.w	r1, [sp, #223]	; 0xdf
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
 800442e:	6118      	str	r0, [r3, #16]
			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
 8004430:	f89d 00e0 	ldrb.w	r0, [sp, #224]	; 0xe0
			// Debug
			TRACE_WARN("TRAC > GPS sampling finished GPS LOSS");

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
 8004434:	809d      	strh	r5, [r3, #4]
			tp->time.month = rtc.month;
 8004436:	719c      	strb	r4, [r3, #6]
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
 8004438:	f89d 50e1 	ldrb.w	r5, [sp, #225]	; 0xe1
			tp->time.second = rtc.second;
 800443c:	f89d 40e2 	ldrb.w	r4, [sp, #226]	; 0xe2

			// Take time from internal RTC
			getTime(&rtc);
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
 8004440:	71d9      	strb	r1, [r3, #7]
			tp->time.hour = rtc.hour;
 8004442:	7218      	strb	r0, [r3, #8]
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
			tp->gps_lon = ltp->gps_lon;
 8004444:	6951      	ldr	r1, [r2, #20]
			tp->gps_alt = ltp->gps_alt;
 8004446:	6992      	ldr	r2, [r2, #24]
			getTime(&rtc);
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
 8004448:	725d      	strb	r5, [r3, #9]
			tp->gps_lat = ltp->gps_lat;
			tp->gps_lon = ltp->gps_lon;
			tp->gps_alt = ltp->gps_alt;

			// Mark gpsloss
			tp->gps_lock = false;
 800444a:	2000      	movs	r0, #0
			tp->time.year = rtc.year;
			tp->time.month = rtc.month;
			tp->time.day = rtc.day;
			tp->time.hour = rtc.hour;
			tp->time.minute = rtc.minute;
			tp->time.second = rtc.second;
 800444c:	729c      	strb	r4, [r3, #10]

			// Take GPS fix from old lock
			tp->gps_lat = ltp->gps_lat;
			tp->gps_lon = ltp->gps_lon;
 800444e:	6159      	str	r1, [r3, #20]
			tp->gps_alt = ltp->gps_alt;
 8004450:	619a      	str	r2, [r3, #24]

			// Mark gpsloss
			tp->gps_lock = false;
 8004452:	7398      	strb	r0, [r3, #14]
			tp->gps_sats = 0;
 8004454:	7718      	strb	r0, [r3, #28]

		}

		tp->id = id; // Serial ID
 8004456:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8004458:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 800445a:	992d      	ldr	r1, [sp, #180]	; 0xb4
	}
}

int16_t pac1720_getAvgPsol(void) {
	// Return current value if time interval too short
	if(!pac1720_psol_counter)
 800445c:	4d60      	ldr	r5, [pc, #384]	; (80045e0 <moduleTRACKING+0xca0>)
 800445e:	189c      	adds	r4, r3, r2
 8004460:	0124      	lsls	r4, r4, #4
 8004462:	4a5e      	ldr	r2, [pc, #376]	; (80045dc <moduleTRACKING+0xc9c>)
 8004464:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004468:	5111      	str	r1, [r2, r4]
 800446a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
		tp->gps_ttff = ST2S(chVTGetSystemTimeX() - time); // Time to first fix
 800446c:	4957      	ldr	r1, [pc, #348]	; (80045cc <moduleTRACKING+0xc8c>)
 800446e:	f502 531c 	add.w	r3, r2, #9984	; 0x2700
 8004472:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8004474:	330f      	adds	r3, #15
 8004476:	1a9b      	subs	r3, r3, r2
			tp->gps_lock = false;
			tp->gps_sats = 0;

		}

		tp->id = id; // Serial ID
 8004478:	4a58      	ldr	r2, [pc, #352]	; (80045dc <moduleTRACKING+0xc9c>)
 800447a:	4414      	add	r4, r2
		tp->gps_ttff = ST2S(chVTGetSystemTimeX() - time); // Time to first fix
 800447c:	fba1 2303 	umull	r2, r3, r1, r3
 8004480:	0b5b      	lsrs	r3, r3, #13
 8004482:	7763      	strb	r3, [r4, #29]

		// Power management
		tp->adc_vsol = getSolarVoltageMV();
 8004484:	f008 fd24 	bl	800ced0 <getSolarVoltageMV>
 8004488:	83e0      	strh	r0, [r4, #30]
		tp->adc_vbat = getBatteryVoltageMV();
 800448a:	f008 fd39 	bl	800cf00 <getBatteryVoltageMV>
 800448e:	8420      	strh	r0, [r4, #32]
 8004490:	f008 fc26 	bl	800cce0 <doConversion>
		tp->adc_vusb = getUSBVoltageMV();
 8004494:	4b53      	ldr	r3, [pc, #332]	; (80045e4 <moduleTRACKING+0xca4>)
 8004496:	6829      	ldr	r1, [r5, #0]
 8004498:	885a      	ldrh	r2, [r3, #2]
 800449a:	4b53      	ldr	r3, [pc, #332]	; (80045e8 <moduleTRACKING+0xca8>)
 800449c:	881b      	ldrh	r3, [r3, #0]
 800449e:	fb03 f202 	mul.w	r2, r3, r2
 80044a2:	23c8      	movs	r3, #200	; 0xc8
 80044a4:	fb03 f302 	mul.w	r3, r3, r2
 80044a8:	149b      	asrs	r3, r3, #18
 80044aa:	8463      	strh	r3, [r4, #34]	; 0x22
 80044ac:	b911      	cbnz	r1, 80044b4 <moduleTRACKING+0xb74>
		pac1720_getPsol();
 80044ae:	f003 ff07 	bl	80082c0 <pac1720_getPsol>
 80044b2:	6829      	ldr	r1, [r5, #0]

	// Calculate average power
	int16_t ret = pac1720_psol / pac1720_psol_counter;
 80044b4:	4b4d      	ldr	r3, [pc, #308]	; (80045ec <moduleTRACKING+0xcac>)
		tp->adc_psol = pac1720_getAvgPsol();
 80044b6:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 80044b8:	681b      	ldr	r3, [r3, #0]
 80044ba:	fb93 f1f1 	sdiv	r1, r3, r1
 80044be:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
	return ret;
}

int16_t pac1720_getAvgPbat(void) {
	// Return current value if time interval too short
	if(!pac1720_pbat_counter)
 80044c0:	4c4b      	ldr	r4, [pc, #300]	; (80045f0 <moduleTRACKING+0xcb0>)
 80044c2:	4413      	add	r3, r2
 80044c4:	4a45      	ldr	r2, [pc, #276]	; (80045dc <moduleTRACKING+0xc9c>)
 80044c6:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 80044ca:	4a49      	ldr	r2, [pc, #292]	; (80045f0 <moduleTRACKING+0xcb0>)
 80044cc:	84d9      	strh	r1, [r3, #38]	; 0x26

	// Calculate average power
	int16_t ret = pac1720_psol / pac1720_psol_counter;

	// Reset current measurement
	pac1720_psol = 0;
 80044ce:	4947      	ldr	r1, [pc, #284]	; (80045ec <moduleTRACKING+0xcac>)
	return ret;
}

int16_t pac1720_getAvgPbat(void) {
	// Return current value if time interval too short
	if(!pac1720_pbat_counter)
 80044d0:	6812      	ldr	r2, [r2, #0]

	// Calculate average power
	int16_t ret = pac1720_psol / pac1720_psol_counter;

	// Reset current measurement
	pac1720_psol = 0;
 80044d2:	2300      	movs	r3, #0
 80044d4:	600b      	str	r3, [r1, #0]
	pac1720_psol_counter = 0;
 80044d6:	4942      	ldr	r1, [pc, #264]	; (80045e0 <moduleTRACKING+0xca0>)
 80044d8:	600b      	str	r3, [r1, #0]
	return ret;
}

int16_t pac1720_getAvgPbat(void) {
	// Return current value if time interval too short
	if(!pac1720_pbat_counter)
 80044da:	b912      	cbnz	r2, 80044e2 <moduleTRACKING+0xba2>
		pac1720_getPbat();
 80044dc:	f003 ff18 	bl	8008310 <pac1720_getPbat>
 80044e0:	6822      	ldr	r2, [r4, #0]

	// Calculate average power
	int16_t ret = pac1720_pbat / pac1720_pbat_counter;
 80044e2:	4b44      	ldr	r3, [pc, #272]	; (80045f4 <moduleTRACKING+0xcb4>)
		tp->adc_pbat = pac1720_getAvgPbat();
 80044e4:	992b      	ldr	r1, [sp, #172]	; 0xac
 80044e6:	681b      	ldr	r3, [r3, #0]
 80044e8:	fb93 f3f2 	sdiv	r3, r3, r2
 80044ec:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
 80044ee:	1854      	adds	r4, r2, r1
 80044f0:	4a3a      	ldr	r2, [pc, #232]	; (80045dc <moduleTRACKING+0xc9c>)
 80044f2:	eb02 1404 	add.w	r4, r2, r4, lsl #4

	// Reset current measurement
	pac1720_pbat = 0;
 80044f6:	2500      	movs	r5, #0
 80044f8:	84a3      	strh	r3, [r4, #36]	; 0x24
 80044fa:	4b3e      	ldr	r3, [pc, #248]	; (80045f4 <moduleTRACKING+0xcb4>)
 80044fc:	601d      	str	r5, [r3, #0]
	pac1720_pbat_counter = 0;
 80044fe:	4b3c      	ldr	r3, [pc, #240]	; (80045f0 <moduleTRACKING+0xcb0>)
#include <math.h>

bool BME280_isAvailable(uint8_t address)
{
	uint8_t val;
	if(I2C_read8(address, BME280_REGISTER_CHIPID, &val))
 8004500:	aa4f      	add	r2, sp, #316	; 0x13c
 8004502:	21d0      	movs	r1, #208	; 0xd0
 8004504:	2077      	movs	r0, #119	; 0x77
 8004506:	601d      	str	r5, [r3, #0]
 8004508:	f008 f8ba 	bl	800c680 <I2C_read8>
 800450c:	2800      	cmp	r0, #0
 800450e:	f000 853c 	beq.w	8004f8a <moduleTRACKING+0x164a>
		return val == 0x60;
 8004512:	f89d 313c 	ldrb.w	r3, [sp, #316]	; 0x13c

		bme280_t bme280;

		// Atmosphere condition
		if(BME280_isAvailable(BME280_ADDRESS_INT)) {
 8004516:	2b60      	cmp	r3, #96	; 0x60
 8004518:	f040 8537 	bne.w	8004f8a <moduleTRACKING+0x164a>
			BME280_Init(&bme280, BME280_ADDRESS_INT);
 800451c:	a84f      	add	r0, sp, #316	; 0x13c
 800451e:	f008 fe6f 	bl	800d200 <BME280_Init.constprop.17>
			tp->air_press = BME280_getPressure(&bme280, 256);
 8004522:	a84f      	add	r0, sp, #316	; 0x13c
 8004524:	f008 fd2c 	bl	800cf80 <BME280_getPressure.constprop.19>
 8004528:	62a0      	str	r0, [r4, #40]	; 0x28
			tp->air_hum = BME280_getHumidity(&bme280);
 800452a:	a84f      	add	r0, sp, #316	; 0x13c
 800452c:	f003 ff40 	bl	80083b0 <BME280_getHumidity>
 8004530:	85a0      	strh	r0, [r4, #44]	; 0x2c
			tp->air_temp = BME280_getTemperature(&bme280);
 8004532:	a84f      	add	r0, sp, #316	; 0x13c
 8004534:	f003 ff94 	bl	8008460 <BME280_getTemperature>
 8004538:	85e0      	strh	r0, [r4, #46]	; 0x2e
 800453a:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
			tp->air_hum = 0;
			tp->air_temp = 0;
		}

		// Trace data
		TRACE_INFO(	"TRAC > New tracking point available (ID=%d)\r\n"
 800453e:	4818      	ldr	r0, [pc, #96]	; (80045a0 <moduleTRACKING+0xc60>)
 8004540:	4c22      	ldr	r4, [pc, #136]	; (80045cc <moduleTRACKING+0xc8c>)
 8004542:	4e19      	ldr	r6, [pc, #100]	; (80045a8 <moduleTRACKING+0xc68>)
 8004544:	f007 fe2c 	bl	800c1a0 <chMtxLock>
 8004548:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800454c:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8004550:	4914      	ldr	r1, [pc, #80]	; (80045a4 <moduleTRACKING+0xc64>)
 8004552:	4816      	ldr	r0, [pc, #88]	; (80045ac <moduleTRACKING+0xc6c>)
 8004554:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8004558:	fb05 f303 	mul.w	r3, r5, r3
 800455c:	fba4 e303 	umull	lr, r3, r4, r3
 8004560:	0b5b      	lsrs	r3, r3, #13
 8004562:	fba6 ce03 	umull	ip, lr, r6, r3
 8004566:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800456a:	fba4 4202 	umull	r4, r2, r4, r2
 800456e:	fb05 331e 	mls	r3, r5, lr, r3
 8004572:	0b52      	lsrs	r2, r2, #13
 8004574:	f006 f88c 	bl	800a690 <chprintf.constprop.26>
 8004578:	4a0d      	ldr	r2, [pc, #52]	; (80045b0 <moduleTRACKING+0xc70>)
 800457a:	490e      	ldr	r1, [pc, #56]	; (80045b4 <moduleTRACKING+0xc74>)
 800457c:	480b      	ldr	r0, [pc, #44]	; (80045ac <moduleTRACKING+0xc6c>)
 800457e:	f006 f887 	bl	800a690 <chprintf.constprop.26>
 8004582:	f240 1313 	movw	r3, #275	; 0x113
 8004586:	4a13      	ldr	r2, [pc, #76]	; (80045d4 <moduleTRACKING+0xc94>)
 8004588:	490c      	ldr	r1, [pc, #48]	; (80045bc <moduleTRACKING+0xc7c>)
 800458a:	4808      	ldr	r0, [pc, #32]	; (80045ac <moduleTRACKING+0xc6c>)
 800458c:	f006 f880 	bl	800a690 <chprintf.constprop.26>
 8004590:	490b      	ldr	r1, [pc, #44]	; (80045c0 <moduleTRACKING+0xc80>)
 8004592:	4806      	ldr	r0, [pc, #24]	; (80045ac <moduleTRACKING+0xc6c>)
 8004594:	f006 f87c 	bl	800a690 <chprintf.constprop.26>
 8004598:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 800459a:	e02d      	b.n	80045f8 <moduleTRACKING+0xcb8>
 800459c:	2001b6b0 	.word	0x2001b6b0
 80045a0:	2001b720 	.word	0x2001b720
 80045a4:	0800ea50 	.word	0x0800ea50
 80045a8:	10624dd3 	.word	0x10624dd3
 80045ac:	2001ac28 	.word	0x2001ac28
 80045b0:	0800f1dc 	.word	0x0800f1dc
 80045b4:	0800ea64 	.word	0x0800ea64
 80045b8:	0800f2d4 	.word	0x0800f2d4
 80045bc:	0800ea7c 	.word	0x0800ea7c
 80045c0:	0800f1e0 	.word	0x0800f1e0
 80045c4:	0800f444 	.word	0x0800f444
 80045c8:	0800eaa8 	.word	0x0800eaa8
 80045cc:	d1b71759 	.word	0xd1b71759
 80045d0:	0800f190 	.word	0x0800f190
 80045d4:	0800f15c 	.word	0x0800f15c
 80045d8:	0800f5cc 	.word	0x0800f5cc
 80045dc:	20000810 	.word	0x20000810
 80045e0:	2001aa68 	.word	0x2001aa68
 80045e4:	2001b690 	.word	0x2001b690
 80045e8:	20000800 	.word	0x20000800
 80045ec:	2001aa6c 	.word	0x2001aa6c
 80045f0:	2001aa60 	.word	0x2001aa60
 80045f4:	2001aa64 	.word	0x2001aa64
 80045f8:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 80045fa:	f8df e260 	ldr.w	lr, [pc, #608]	; 800485c <moduleTRACKING+0xf1c>
 80045fe:	189a      	adds	r2, r3, r2
 8004600:	4b8b      	ldr	r3, [pc, #556]	; (8004830 <moduleTRACKING+0xef0>)
 8004602:	0112      	lsls	r2, r2, #4
 8004604:	189c      	adds	r4, r3, r2
 8004606:	589b      	ldr	r3, [r3, r2]
 8004608:	f9b4 002e 	ldrsh.w	r0, [r4, #46]	; 0x2e
 800460c:	9020      	str	r0, [sp, #128]	; 0x80
 800460e:	9830      	ldr	r0, [sp, #192]	; 0xc0
 8004610:	f8b4 902c 	ldrh.w	r9, [r4, #44]	; 0x2c
 8004614:	f8b4 a020 	ldrh.w	sl, [r4, #32]
 8004618:	9324      	str	r3, [sp, #144]	; 0x90
 800461a:	9018      	str	r0, [sp, #96]	; 0x60
 800461c:	4b85      	ldr	r3, [pc, #532]	; (8004834 <moduleTRACKING+0xef4>)
 800461e:	6921      	ldr	r1, [r4, #16]
 8004620:	f8b4 b01e 	ldrh.w	fp, [r4, #30]
 8004624:	fba3 c209 	umull	ip, r2, r3, r9
 8004628:	6963      	ldr	r3, [r4, #20]
 800462a:	2900      	cmp	r1, #0
 800462c:	bfd4      	ite	le
 800462e:	f04f 31ff 	movle.w	r1, #4294967295
 8004632:	2101      	movgt	r1, #1
 8004634:	2b00      	cmp	r3, #0
 8004636:	8c63      	ldrh	r3, [r4, #34]	; 0x22
 8004638:	900f      	str	r0, [sp, #60]	; 0x3c
 800463a:	9321      	str	r3, [sp, #132]	; 0x84
 800463c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800463e:	9820      	ldr	r0, [sp, #128]	; 0x80
 8004640:	469c      	mov	ip, r3
 8004642:	4b7c      	ldr	r3, [pc, #496]	; (8004834 <moduleTRACKING+0xef4>)
 8004644:	ea4f 02d2 	mov.w	r2, r2, lsr #3
 8004648:	fba3 c30c 	umull	ip, r3, r3, ip
 800464c:	fb8e ce00 	smull	ip, lr, lr, r0
 8004650:	6920      	ldr	r0, [r4, #16]
 8004652:	921d      	str	r2, [sp, #116]	; 0x74
 8004654:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004658:	eba9 0242 	sub.w	r2, r9, r2, lsl #1
 800465c:	b292      	uxth	r2, r2
 800465e:	921e      	str	r2, [sp, #120]	; 0x78
 8004660:	fba6 920a 	umull	r9, r2, r6, sl
 8004664:	ea4f 1992 	mov.w	r9, r2, lsr #6
 8004668:	fb05 aa19 	mls	sl, r5, r9, sl
 800466c:	fb00 f101 	mul.w	r1, r0, r1
 8004670:	fa1f f28a 	uxth.w	r2, sl
 8004674:	9820      	ldr	r0, [sp, #128]	; 0x80
 8004676:	9211      	str	r2, [sp, #68]	; 0x44
 8004678:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 800467c:	9319      	str	r3, [sp, #100]	; 0x64
 800467e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8004680:	ea4f 7ce0 	mov.w	ip, r0, asr #31
 8004684:	9821      	ldr	r0, [sp, #132]	; 0x84
 8004686:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800468a:	eba2 0243 	sub.w	r2, r2, r3, lsl #1
 800468e:	fba6 a30b 	umull	sl, r3, r6, fp
 8004692:	4682      	mov	sl, r0
 8004694:	fba6 a60a 	umull	sl, r6, r6, sl
 8004698:	ea4f 1696 	mov.w	r6, r6, lsr #6
 800469c:	ea4f 1a93 	mov.w	sl, r3, lsr #6
 80046a0:	fb05 bb1a 	mls	fp, r5, sl, fp
 80046a4:	4603      	mov	r3, r0
 80046a6:	fb05 0516 	mls	r5, r5, r6, r0
 80046aa:	6960      	ldr	r0, [r4, #20]
 80046ac:	921a      	str	r2, [sp, #104]	; 0x68
 80046ae:	bfd4      	ite	le
 80046b0:	f04f 33ff 	movle.w	r3, #4294967295
 80046b4:	2301      	movgt	r3, #1
 80046b6:	fb00 f303 	mul.w	r3, r0, r3
 80046ba:	9820      	ldr	r0, [sp, #128]	; 0x80
 80046bc:	ebcc 1c6e 	rsb	ip, ip, lr, asr #5
 80046c0:	2264      	movs	r2, #100	; 0x64
 80046c2:	f8df e19c 	ldr.w	lr, [pc, #412]	; 8004860 <moduleTRACKING+0xf20>
 80046c6:	fb02 021c 	mls	r2, r2, ip, r0
 80046ca:	b2ad      	uxth	r5, r5
 80046cc:	fa0f f08c 	sxth.w	r0, ip
 80046d0:	b212      	sxth	r2, r2
 80046d2:	9515      	str	r5, [sp, #84]	; 0x54
 80046d4:	921c      	str	r2, [sp, #112]	; 0x70
 80046d6:	901b      	str	r0, [sp, #108]	; 0x6c
 80046d8:	fb8e 5201 	smull	r5, r2, lr, r1
 80046dc:	17c8      	asrs	r0, r1, #31
 80046de:	4d56      	ldr	r5, [pc, #344]	; (8004838 <moduleTRACKING+0xef8>)
 80046e0:	ebc0 52a2 	rsb	r2, r0, r2, asr #22
 80046e4:	fb05 1212 	mls	r2, r5, r2, r1
 80046e8:	f9b4 1026 	ldrsh.w	r1, [r4, #38]	; 0x26
 80046ec:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
 80046f0:	f9b4 0024 	ldrsh.w	r0, [r4, #36]	; 0x24
 80046f4:	9016      	str	r0, [sp, #88]	; 0x58
 80046f6:	fa1f fb8b 	uxth.w	fp, fp
 80046fa:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
 80046fe:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
 8004702:	9614      	str	r6, [sp, #80]	; 0x50
 8004704:	9117      	str	r1, [sp, #92]	; 0x5c
 8004706:	79e1      	ldrb	r1, [r4, #7]
 8004708:	7f60      	ldrb	r0, [r4, #29]
 800470a:	f8b4 b004 	ldrh.w	fp, [r4, #4]
 800470e:	f894 a006 	ldrb.w	sl, [r4, #6]
 8004712:	7a66      	ldrb	r6, [r4, #9]
 8004714:	fb8e 9c03 	smull	r9, ip, lr, r3
 8004718:	f894 9008 	ldrb.w	r9, [r4, #8]
 800471c:	9208      	str	r2, [sp, #32]
 800471e:	17da      	asrs	r2, r3, #31
 8004720:	900e      	str	r0, [sp, #56]	; 0x38
 8004722:	ebc2 52ac 	rsb	r2, r2, ip, asr #22
 8004726:	6960      	ldr	r0, [r4, #20]
 8004728:	fb05 3512 	mls	r5, r5, r2, r3
 800472c:	6923      	ldr	r3, [r4, #16]
 800472e:	6922      	ldr	r2, [r4, #16]
 8004730:	fb8e c303 	smull	ip, r3, lr, r3
 8004734:	4684      	mov	ip, r0
 8004736:	fb8e ce0c 	smull	ip, lr, lr, ip
 800473a:	17d2      	asrs	r2, r2, #31
 800473c:	17c0      	asrs	r0, r0, #31
 800473e:	ebc2 5ca3 	rsb	ip, r2, r3, asr #22
 8004742:	ebc0 50ae 	rsb	r0, r0, lr, asr #22
 8004746:	7f23      	ldrb	r3, [r4, #28]
 8004748:	9105      	str	r1, [sp, #20]
 800474a:	9102      	str	r1, [sp, #8]
 800474c:	9930      	ldr	r1, [sp, #192]	; 0xc0
 800474e:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8004750:	f8cd c01c 	str.w	ip, [sp, #28]
 8004754:	910c      	str	r1, [sp, #48]	; 0x30
 8004756:	9106      	str	r1, [sp, #24]
 8004758:	950a      	str	r5, [sp, #40]	; 0x28
 800475a:	9604      	str	r6, [sp, #16]
 800475c:	f8cd 900c 	str.w	r9, [sp, #12]
 8004760:	f8cd a004 	str.w	sl, [sp, #4]
 8004764:	f8cd b000 	str.w	fp, [sp]
 8004768:	9009      	str	r0, [sp, #36]	; 0x24
 800476a:	930d      	str	r3, [sp, #52]	; 0x34
 800476c:	69a3      	ldr	r3, [r4, #24]
 800476e:	930b      	str	r3, [sp, #44]	; 0x2c
 8004770:	4932      	ldr	r1, [pc, #200]	; (800483c <moduleTRACKING+0xefc>)
 8004772:	4b33      	ldr	r3, [pc, #204]	; (8004840 <moduleTRACKING+0xf00>)
 8004774:	4833      	ldr	r0, [pc, #204]	; (8004844 <moduleTRACKING+0xf04>)
 8004776:	f005 ff8b 	bl	800a690 <chprintf.constprop.26>
 800477a:	4933      	ldr	r1, [pc, #204]	; (8004848 <moduleTRACKING+0xf08>)
 800477c:	4831      	ldr	r0, [pc, #196]	; (8004844 <moduleTRACKING+0xf04>)
 800477e:	f005 ff87 	bl	800a690 <chprintf.constprop.26>
 8004782:	4832      	ldr	r0, [pc, #200]	; (800484c <moduleTRACKING+0xf0c>)
 8004784:	f004 fefc 	bl	8009580 <chMtxUnlock>
					TRACE_TAB, tp->adc_vbat/1000, (tp->adc_vbat%1000), tp->adc_vsol/1000, (tp->adc_vsol%1000), tp->adc_vusb/1000, (tp->adc_vusb%1000), tp->adc_pbat, tp->adc_psol,
					TRACE_TAB, tp->air_press/10, tp->air_press%10, tp->air_temp/100, tp->air_temp%100, tp->air_hum/10, tp->air_hum%10
		);

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
 8004788:	4b31      	ldr	r3, [pc, #196]	; (8004850 <moduleTRACKING+0xf10>)
 800478a:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800478e:	681b      	ldr	r3, [r3, #0]
 8004790:	429a      	cmp	r2, r3
			tp->air_hum = 0;
			tp->air_temp = 0;
		}

		// Trace data
		TRACE_INFO(	"TRAC > New tracking point available (ID=%d)\r\n"
 8004792:	f104 0504 	add.w	r5, r4, #4
					TRACE_TAB, tp->adc_vbat/1000, (tp->adc_vbat%1000), tp->adc_vsol/1000, (tp->adc_vsol%1000), tp->adc_vusb/1000, (tp->adc_vusb%1000), tp->adc_pbat, tp->adc_psol,
					TRACE_TAB, tp->air_press/10, tp->air_press%10, tp->air_temp/100, tp->air_temp%100, tp->air_hum/10, tp->air_hum%10
		);

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
 8004796:	d302      	bcc.n	800479e <moduleTRACKING+0xe5e>
 8004798:	2f03      	cmp	r7, #3
 800479a:	f000 84ed 	beq.w	8005178 <moduleTRACKING+0x1838>
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
 800479e:	4b2d      	ldr	r3, [pc, #180]	; (8004854 <moduleTRACKING+0xf14>)
		id++;

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 80047a0:	9822      	ldr	r0, [sp, #136]	; 0x88
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
 80047a2:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 80047a4:	601a      	str	r2, [r3, #0]
		id++;
 80047a6:	9b2d      	ldr	r3, [sp, #180]	; 0xb4

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 80047a8:	f500 1192 	add.w	r1, r0, #1196032	; 0x124000
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
		id++;
 80047ac:	3301      	adds	r3, #1

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 80047ae:	f501 6178 	add.w	r1, r1, #3968	; 0xf80
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
		}

		// Switch last recent track point
		lastTrackPoint = tp;
		id++;
 80047b2:	932d      	str	r3, [sp, #180]	; 0xb4

		time = chThdSleepUntilWindowed(time, time + S2ST(TRACK_CYCLE_TIME)); // Wait until time + cycletime
 80047b4:	f007 fd8c 	bl	800c2d0 <chThdSleepUntilWindowed>
 80047b8:	9022      	str	r0, [sp, #136]	; 0x88
 80047ba:	f7ff ba26 	b.w	8003c0a <moduleTRACKING+0x2ca>
 80047be:	6a63      	ldr	r3, [r4, #36]	; 0x24
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 80047c0:	429e      	cmp	r6, r3
 80047c2:	f4ff ada6 	bcc.w	8004312 <moduleTRACKING+0x9d2>
 80047c6:	6a61      	ldr	r1, [r4, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 80047c8:	4823      	ldr	r0, [pc, #140]	; (8004858 <moduleTRACKING+0xf18>)
 80047ca:	1a71      	subs	r1, r6, r1
 80047cc:	f004 fe40 	bl	8009450 <iqGetTimeout>
			case CLASSID:
				if (rx_byte == class_id)state = MSGID;
				else			state = UBX_A;
				break;
			case MSGID:
				if (rx_byte == msg_id)	state = LEN_A;
 80047d0:	b2c0      	uxtb	r0, r0
 80047d2:	2807      	cmp	r0, #7
 80047d4:	f47f ad9a 	bne.w	800430c <moduleTRACKING+0x9cc>
 80047d8:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 80047dc:	429e      	cmp	r6, r3
 80047de:	f4ff ad98 	bcc.w	8004312 <moduleTRACKING+0x9d2>
 80047e2:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 80047e6:	481c      	ldr	r0, [pc, #112]	; (8004858 <moduleTRACKING+0xf18>)
 80047e8:	1a71      	subs	r1, r6, r1
 80047ea:	f004 fe31 	bl	8009450 <iqGetTimeout>
 80047ee:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 80047f2:	42b3      	cmp	r3, r6

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 80047f4:	fa5f f880 	uxtb.w	r8, r0
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 80047f8:	f63f ad8b 	bhi.w	8004312 <moduleTRACKING+0x9d2>
 80047fc:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 8004800:	4815      	ldr	r0, [pc, #84]	; (8004858 <moduleTRACKING+0xf18>)
 8004802:	1a71      	subs	r1, r6, r1
 8004804:	f004 fe24 	bl	8009450 <iqGetTimeout>
 8004808:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
			case LEN_A:
				payload_len = rx_byte;
				state = LEN_B;
				break;
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
 800480c:	0200      	lsls	r0, r0, #8
 800480e:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 8004812:	429e      	cmp	r6, r3
			case LEN_A:
				payload_len = rx_byte;
				state = LEN_B;
				break;
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
 8004814:	ea40 0808 	orr.w	r8, r0, r8
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 8004818:	f4ff ad7b 	bcc.w	8004312 <moduleTRACKING+0x9d2>
 800481c:	6a61      	ldr	r1, [r4, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 800481e:	480e      	ldr	r0, [pc, #56]	; (8004858 <moduleTRACKING+0xf18>)
 8004820:	1a71      	subs	r1, r6, r1
 8004822:	f004 fe15 	bl	8009450 <iqGetTimeout>
 8004826:	f04f 0900 	mov.w	r9, #0
 800482a:	b2c2      	uxtb	r2, r0
 800482c:	e023      	b.n	8004876 <moduleTRACKING+0xf36>
 800482e:	bf00      	nop
 8004830:	20000810 	.word	0x20000810
 8004834:	cccccccd 	.word	0xcccccccd
 8004838:	00989680 	.word	0x00989680
 800483c:	0800f5f4 	.word	0x0800f5f4
 8004840:	0800f1b4 	.word	0x0800f1b4
 8004844:	2001ac28 	.word	0x2001ac28
 8004848:	0800eaa8 	.word	0x0800eaa8
 800484c:	2001b720 	.word	0x2001b720
 8004850:	20000870 	.word	0x20000870
 8004854:	2001b730 	.word	0x2001b730
 8004858:	2001b6b0 	.word	0x2001b6b0
 800485c:	51eb851f 	.word	0x51eb851f
 8004860:	6b5fca6b 	.word	0x6b5fca6b
 8004864:	6a63      	ldr	r3, [r4, #36]	; 0x24
	enum {UBX_A, UBX_B, CLASSID, MSGID, LEN_A, LEN_B, PAYLOAD} state = UBX_A;
	uint16_t payload_cnt = 0;
	uint16_t payload_len = 0;

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 8004866:	42b3      	cmp	r3, r6
 8004868:	f63f ad53 	bhi.w	8004312 <moduleTRACKING+0x9d2>
 800486c:	6a61      	ldr	r1, [r4, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 800486e:	1a71      	subs	r1, r6, r1
 8004870:	f004 fdee 	bl	8009450 <iqGetTimeout>
 8004874:	b2c2      	uxtb	r2, r0
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
				state = PAYLOAD;
				break;
			case PAYLOAD:
				payload[payload_cnt] = rx_byte;
 8004876:	4bbd      	ldr	r3, [pc, #756]	; (8004b6c <moduleTRACKING+0x122c>)

	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 8004878:	48bd      	ldr	r0, [pc, #756]	; (8004b70 <moduleTRACKING+0x1230>)
			case LEN_B:
				payload_len |= ((uint16_t)rx_byte << 8);
				state = PAYLOAD;
				break;
			case PAYLOAD:
				payload[payload_cnt] = rx_byte;
 800487a:	f803 2009 	strb.w	r2, [r3, r9]
				payload_cnt++;
 800487e:	f109 0901 	add.w	r9, r9, #1
 8004882:	fa1f f989 	uxth.w	r9, r9
				if (payload_cnt == payload_len)
 8004886:	45c8      	cmp	r8, r9
 8004888:	d1ec      	bne.n	8004864 <moduleTRACKING+0xf24>

	// Transmit request
	uint8_t pvt[] = {0xB5, 0x62, 0x01, 0x07, 0x00, 0x00, 0x08, 0x19};
	gps_transmit_string(pvt, sizeof(pvt));

	if(!gps_receive_payload(0x01, 0x07, response, 5000)) { // Receive request
 800488a:	f1b8 0f00 	cmp.w	r8, #0
 800488e:	f43f ad40 	beq.w	8004312 <moduleTRACKING+0x9d2>
		TRACE_INFO("GPS  > PVT Polling FAILED");
		return false;
	}

	TRACE_INFO("GPS  > PVT Polling OK");
 8004892:	48b8      	ldr	r0, [pc, #736]	; (8004b74 <moduleTRACKING+0x1234>)
 8004894:	f007 fc84 	bl	800c1a0 <chMtxLock>
 8004898:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800489a:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800489c:	49b6      	ldr	r1, [pc, #728]	; (8004b78 <moduleTRACKING+0x1238>)
 800489e:	48b7      	ldr	r0, [pc, #732]	; (8004b7c <moduleTRACKING+0x123c>)
 80048a0:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 80048a4:	fb07 f606 	mul.w	r6, r7, r6
 80048a8:	fbab 3606 	umull	r3, r6, fp, r6
 80048ac:	4bb4      	ldr	r3, [pc, #720]	; (8004b80 <moduleTRACKING+0x1240>)
 80048ae:	0b76      	lsrs	r6, r6, #13
 80048b0:	fba3 e306 	umull	lr, r3, r3, r6
 80048b4:	fbab e202 	umull	lr, r2, fp, r2
 80048b8:	099b      	lsrs	r3, r3, #6
 80048ba:	fb07 6313 	mls	r3, r7, r3, r6
 80048be:	0b52      	lsrs	r2, r2, #13
 80048c0:	f005 fee6 	bl	800a690 <chprintf.constprop.26>
 80048c4:	4aaf      	ldr	r2, [pc, #700]	; (8004b84 <moduleTRACKING+0x1244>)
 80048c6:	49b0      	ldr	r1, [pc, #704]	; (8004b88 <moduleTRACKING+0x1248>)
 80048c8:	48ac      	ldr	r0, [pc, #688]	; (8004b7c <moduleTRACKING+0x123c>)
 80048ca:	f005 fee1 	bl	800a690 <chprintf.constprop.26>
 80048ce:	23a7      	movs	r3, #167	; 0xa7
 80048d0:	4aae      	ldr	r2, [pc, #696]	; (8004b8c <moduleTRACKING+0x124c>)
 80048d2:	49af      	ldr	r1, [pc, #700]	; (8004b90 <moduleTRACKING+0x1250>)
 80048d4:	48a9      	ldr	r0, [pc, #676]	; (8004b7c <moduleTRACKING+0x123c>)
 80048d6:	f005 fedb 	bl	800a690 <chprintf.constprop.26>
 80048da:	49ae      	ldr	r1, [pc, #696]	; (8004b94 <moduleTRACKING+0x1254>)
 80048dc:	48a7      	ldr	r0, [pc, #668]	; (8004b7c <moduleTRACKING+0x123c>)
 80048de:	f005 fed7 	bl	800a690 <chprintf.constprop.26>
 80048e2:	49ad      	ldr	r1, [pc, #692]	; (8004b98 <moduleTRACKING+0x1258>)
 80048e4:	48a5      	ldr	r0, [pc, #660]	; (8004b7c <moduleTRACKING+0x123c>)
 80048e6:	f005 fed3 	bl	800a690 <chprintf.constprop.26>
 80048ea:	49ac      	ldr	r1, [pc, #688]	; (8004b9c <moduleTRACKING+0x125c>)
 80048ec:	48a3      	ldr	r0, [pc, #652]	; (8004b7c <moduleTRACKING+0x123c>)
 80048ee:	f005 fecf 	bl	800a690 <chprintf.constprop.26>
 80048f2:	48a0      	ldr	r0, [pc, #640]	; (8004b74 <moduleTRACKING+0x1234>)
 80048f4:	f004 fe44 	bl	8009580 <chMtxUnlock>
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 80048f8:	f895 0026 	ldrb.w	r0, [r5, #38]	; 0x26
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];

	fix->lat = (int32_t) (
 80048fc:	7fa9      	ldrb	r1, [r5, #30]
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 80048fe:	f895 9025 	ldrb.w	r9, [r5, #37]	; 0x25
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];

	fix->lat = (int32_t) (
 8004902:	f895 c01d 	ldrb.w	ip, [r5, #29]
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 8004906:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
	fix->time.second = response[10];

	fix->lat = (int32_t) (
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 800490a:	7e2e      	ldrb	r6, [r5, #24]
 800490c:	7eaa      	ldrb	r2, [r5, #26]
 800490e:	9621      	str	r6, [sp, #132]	; 0x84
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];

	fix->lat = (int32_t) (
 8004910:	0409      	lsls	r1, r1, #16
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 8004912:	0400      	lsls	r0, r0, #16
 8004914:	f895 8027 	ldrb.w	r8, [r5, #39]	; 0x27
	fix->time.second = response[10];

	fix->lat = (int32_t) (
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 8004918:	f895 e019 	ldrb.w	lr, [r5, #25]
	TRACE_INFO("GPS  > PVT Polling OK");

	fix->num_svs = response[23];
	fix->type = response[20];

	fix->time.year = response[4] + (response[5] << 8);
 800491c:	796e      	ldrb	r6, [r5, #5]
 800491e:	9620      	str	r6, [sp, #128]	; 0x80
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 8004920:	eb00 2009 	add.w	r0, r0, r9, lsl #8
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];

	fix->lat = (int32_t) (
 8004924:	eb01 2c0c 	add.w	ip, r1, ip, lsl #8
		return false;
	}

	TRACE_INFO("GPS  > PVT Polling OK");

	fix->num_svs = response[23];
 8004928:	7de9      	ldrb	r1, [r5, #23]
 800492a:	9123      	str	r1, [sp, #140]	; 0x8c
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 800492c:	4418      	add	r0, r3
	fix->time.second = response[10];

	fix->lat = (int32_t) (
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 800492e:	9921      	ldr	r1, [sp, #132]	; 0x84
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 8004930:	4b93      	ldr	r3, [pc, #588]	; (8004b80 <moduleTRACKING+0x1240>)
	TRACE_INFO("GPS  > PVT Polling OK");

	fix->num_svs = response[23];
	fix->type = response[20];

	fix->time.year = response[4] + (response[5] << 8);
 8004932:	792e      	ldrb	r6, [r5, #4]
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];

	fix->lat = (int32_t) (
 8004934:	7f2f      	ldrb	r7, [r5, #28]
 8004936:	f895 901f 	ldrb.w	r9, [r5, #31]
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 800493a:	0412      	lsls	r2, r2, #16
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 800493c:	eb00 6808 	add.w	r8, r0, r8, lsl #24
	fix->time.second = response[10];

	fix->lat = (int32_t) (
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 8004940:	eb02 220e 	add.w	r2, r2, lr, lsl #8
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 8004944:	fb83 3008 	smull	r3, r0, r3, r8
	fix->time.second = response[10];

	fix->lat = (int32_t) (
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 8004948:	440a      	add	r2, r1
 800494a:	7eeb      	ldrb	r3, [r5, #27]
	TRACE_INFO("GPS  > PVT Polling OK");

	fix->num_svs = response[23];
	fix->type = response[20];

	fix->time.year = response[4] + (response[5] << 8);
 800494c:	9920      	ldr	r1, [sp, #128]	; 0x80
	fix->time.second = response[10];

	fix->lat = (int32_t) (
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 800494e:	eb02 6303 	add.w	r3, r2, r3, lsl #24
	TRACE_INFO("GPS  > PVT Polling OK");

	fix->num_svs = response[23];
	fix->type = response[20];

	fix->time.year = response[4] + (response[5] << 8);
 8004952:	eb06 2601 	add.w	r6, r6, r1, lsl #8
	fix->time.second = response[10];

	fix->lat = (int32_t) (
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
 8004956:	9320      	str	r3, [sp, #128]	; 0x80
	TRACE_INFO("GPS  > PVT Polling OK");

	fix->num_svs = response[23];
	fix->type = response[20];

	fix->time.year = response[4] + (response[5] << 8);
 8004958:	b2b3      	uxth	r3, r6
 800495a:	9329      	str	r3, [sp, #164]	; 0xa4
	fix->time.month = response[6];
 800495c:	79ab      	ldrb	r3, [r5, #6]
 800495e:	9327      	str	r3, [sp, #156]	; 0x9c
	fix->time.day = response[7];
 8004960:	79eb      	ldrb	r3, [r5, #7]
 8004962:	9326      	str	r3, [sp, #152]	; 0x98
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];

	fix->lat = (int32_t) (
 8004964:	44bc      	add	ip, r7
	fix->type = response[20];

	fix->time.year = response[4] + (response[5] << 8);
	fix->time.month = response[6];
	fix->time.day = response[7];
	fix->time.hour = response[8];
 8004966:	7a2b      	ldrb	r3, [r5, #8]
 8004968:	9324      	str	r3, [sp, #144]	; 0x90
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 800496a:	ea4f 78e8 	mov.w	r8, r8, asr #31

	fix->time.year = response[4] + (response[5] << 8);
	fix->time.month = response[6];
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
 800496e:	7a6b      	ldrb	r3, [r5, #9]
	}

	TRACE_INFO("GPS  > PVT Polling OK");

	fix->num_svs = response[23];
	fix->type = response[20];
 8004970:	7d2f      	ldrb	r7, [r5, #20]

	fix->time.year = response[4] + (response[5] << 8);
	fix->time.month = response[6];
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
 8004972:	9325      	str	r3, [sp, #148]	; 0x94
			(uint32_t)(response[28]) + ((uint32_t)(response[29]) << 8) + ((uint32_t)(response[30]) << 16) + ((uint32_t)(response[31]) << 24)
			);
	fix->lon = (int32_t) (
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
 8004974:	ebc8 18a0 	rsb	r8, r8, r0, asr #6
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];

	fix->lat = (int32_t) (
 8004978:	eb0c 6109 	add.w	r1, ip, r9, lsl #24
 800497c:	9121      	str	r1, [sp, #132]	; 0x84
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
			((uint32_t)(response[36]) + ((uint32_t)(response[37]) << 8) + ((uint32_t)(response[38]) << 16) + ((uint32_t)(response[39]) << 24))
			) / 1000);
	if (alt_tmp <= 0) {
 800497e:	f1b8 0f00 	cmp.w	r8, #0
	fix->time.year = response[4] + (response[5] << 8);
	fix->time.month = response[6];
	fix->time.day = response[7];
	fix->time.hour = response[8];
	fix->time.minute = response[9];
	fix->time.second = response[10];
 8004982:	7aab      	ldrb	r3, [r5, #10]
 8004984:	9328      	str	r3, [sp, #160]	; 0xa0
			(uint32_t)(response[24]) + ((uint32_t)(response[25]) << 8) + ((uint32_t)(response[26]) << 16) + ((uint32_t)(response[27]) << 24)
			);
	int32_t alt_tmp = (((int32_t) 
			((uint32_t)(response[36]) + ((uint32_t)(response[37]) << 8) + ((uint32_t)(response[38]) << 16) + ((uint32_t)(response[39]) << 24))
			) / 1000);
	if (alt_tmp <= 0) {
 8004986:	f340 828b 	ble.w	8004ea0 <moduleTRACKING+0x1560>
 800498a:	f24c 3050 	movw	r0, #50000	; 0xc350
 800498e:	4580      	cmp	r8, r0
 8004990:	4643      	mov	r3, r8
 8004992:	bfa8      	it	ge
 8004994:	4603      	movge	r3, r0

			// Search for lock as long enough power is available
			do {
				batt = getBatteryVoltageMV();
				gps_get_fix(&gpsFix);
			} while(!isGPSLocked(&gpsFix) && batt >= GPS_OFF_VBAT && chVTGetSystemTimeX() <= time + S2ST(TRACK_CYCLE_TIME-5)); // Do as long no GPS lock and within timeout, timeout=cycle-1sec (-1sec in order to keep synchronization)
 8004996:	2f03      	cmp	r7, #3
 8004998:	932a      	str	r3, [sp, #168]	; 0xa8
 800499a:	f47f acf0 	bne.w	800437e <moduleTRACKING+0xa3e>
 800499e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80049a0:	2b04      	cmp	r3, #4
 80049a2:	f67f acec 	bls.w	800437e <moduleTRACKING+0xa3e>
 80049a6:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
}

void GPS_Deinit(void)
{
	// Switch MOSFET
	TRACE_INFO("GPS  > Switch off");
 80049aa:	4872      	ldr	r0, [pc, #456]	; (8004b74 <moduleTRACKING+0x1234>)
 80049ac:	4e7c      	ldr	r6, [pc, #496]	; (8004ba0 <moduleTRACKING+0x1260>)
 80049ae:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 8004b80 <moduleTRACKING+0x1240>
 80049b2:	f007 fbf5 	bl	800c1a0 <chMtxLock>
 80049b6:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80049b8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80049ba:	496f      	ldr	r1, [pc, #444]	; (8004b78 <moduleTRACKING+0x1238>)
 80049bc:	486f      	ldr	r0, [pc, #444]	; (8004b7c <moduleTRACKING+0x123c>)
 80049be:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 80049c2:	fb04 f303 	mul.w	r3, r4, r3
 80049c6:	fba6 7303 	umull	r7, r3, r6, r3
 80049ca:	0b5b      	lsrs	r3, r3, #13
 80049cc:	fbaa 7e03 	umull	r7, lr, sl, r3
 80049d0:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 80049d4:	fba6 7202 	umull	r7, r2, r6, r2
 80049d8:	fb04 331e 	mls	r3, r4, lr, r3
 80049dc:	0b52      	lsrs	r2, r2, #13
 80049de:	f005 fe57 	bl	800a690 <chprintf.constprop.26>
 80049e2:	4a68      	ldr	r2, [pc, #416]	; (8004b84 <moduleTRACKING+0x1244>)
 80049e4:	4968      	ldr	r1, [pc, #416]	; (8004b88 <moduleTRACKING+0x1248>)
 80049e6:	4865      	ldr	r0, [pc, #404]	; (8004b7c <moduleTRACKING+0x123c>)
 80049e8:	f005 fe52 	bl	800a690 <chprintf.constprop.26>
 80049ec:	f240 1375 	movw	r3, #373	; 0x175
 80049f0:	4a66      	ldr	r2, [pc, #408]	; (8004b8c <moduleTRACKING+0x124c>)
 80049f2:	4967      	ldr	r1, [pc, #412]	; (8004b90 <moduleTRACKING+0x1250>)
 80049f4:	4861      	ldr	r0, [pc, #388]	; (8004b7c <moduleTRACKING+0x123c>)
 80049f6:	f005 fe4b 	bl	800a690 <chprintf.constprop.26>
 80049fa:	4966      	ldr	r1, [pc, #408]	; (8004b94 <moduleTRACKING+0x1254>)
 80049fc:	485f      	ldr	r0, [pc, #380]	; (8004b7c <moduleTRACKING+0x123c>)
 80049fe:	f005 fe47 	bl	800a690 <chprintf.constprop.26>
 8004a02:	4968      	ldr	r1, [pc, #416]	; (8004ba4 <moduleTRACKING+0x1264>)
 8004a04:	485d      	ldr	r0, [pc, #372]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a06:	f005 fe43 	bl	800a690 <chprintf.constprop.26>
 8004a0a:	4964      	ldr	r1, [pc, #400]	; (8004b9c <moduleTRACKING+0x125c>)
 8004a0c:	485b      	ldr	r0, [pc, #364]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a0e:	f005 fe3f 	bl	800a690 <chprintf.constprop.26>
 8004a12:	4858      	ldr	r0, [pc, #352]	; (8004b74 <moduleTRACKING+0x1234>)
 8004a14:	f004 fdb4 	bl	8009580 <chMtxUnlock>
	palClearPad(PORT(GPS_EN), PIN(GPS_EN));
 8004a18:	4b63      	ldr	r3, [pc, #396]	; (8004ba8 <moduleTRACKING+0x1268>)

	// Deinit pins
	palSetPadMode(PORT(GPS_RESET), PIN(GPS_RESET), PAL_MODE_INPUT);	// GPS reset
 8004a1a:	4864      	ldr	r0, [pc, #400]	; (8004bac <moduleTRACKING+0x126c>)

void GPS_Deinit(void)
{
	// Switch MOSFET
	TRACE_INFO("GPS  > Switch off");
	palClearPad(PORT(GPS_EN), PIN(GPS_EN));
 8004a1c:	2208      	movs	r2, #8
 8004a1e:	835a      	strh	r2, [r3, #26]

	// Deinit pins
	palSetPadMode(PORT(GPS_RESET), PIN(GPS_RESET), PAL_MODE_INPUT);	// GPS reset
 8004a20:	2180      	movs	r1, #128	; 0x80
 8004a22:	2200      	movs	r2, #0
 8004a24:	f005 fb84 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_RXD), PIN(GPS_RXD), PAL_MODE_INPUT);		// UART RXD
 8004a28:	2200      	movs	r2, #0
 8004a2a:	2104      	movs	r1, #4
 8004a2c:	485f      	ldr	r0, [pc, #380]	; (8004bac <moduleTRACKING+0x126c>)
 8004a2e:	f005 fb7f 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(GPS_TXD), PIN(GPS_TXD), PAL_MODE_INPUT);		// UART TXD
 8004a32:	2200      	movs	r2, #0
 8004a34:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004a38:	485d      	ldr	r0, [pc, #372]	; (8004bb0 <moduleTRACKING+0x1270>)
 8004a3a:	f005 fb79 	bl	800a130 <_pal_lld_setgroupmode>

			// Switch off GPS
			GPS_Deinit();

			// Debug
			TRACE_INFO("TRAC > GPS sampling finished GPS LOCK");
 8004a3e:	484d      	ldr	r0, [pc, #308]	; (8004b74 <moduleTRACKING+0x1234>)
 8004a40:	f007 fbae 	bl	800c1a0 <chMtxLock>
 8004a44:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8004a46:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004a48:	494b      	ldr	r1, [pc, #300]	; (8004b78 <moduleTRACKING+0x1238>)
 8004a4a:	484c      	ldr	r0, [pc, #304]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a4c:	fb04 f303 	mul.w	r3, r4, r3
 8004a50:	fba6 7303 	umull	r7, r3, r6, r3
 8004a54:	0b5b      	lsrs	r3, r3, #13
 8004a56:	fbaa 7e03 	umull	r7, lr, sl, r3
 8004a5a:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8004a5e:	fba6 7202 	umull	r7, r2, r6, r2
 8004a62:	fb04 331e 	mls	r3, r4, lr, r3
 8004a66:	0b52      	lsrs	r2, r2, #13
 8004a68:	f005 fe12 	bl	800a690 <chprintf.constprop.26>
 8004a6c:	4a45      	ldr	r2, [pc, #276]	; (8004b84 <moduleTRACKING+0x1244>)
 8004a6e:	4946      	ldr	r1, [pc, #280]	; (8004b88 <moduleTRACKING+0x1248>)
 8004a70:	4842      	ldr	r0, [pc, #264]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a72:	f005 fe0d 	bl	800a690 <chprintf.constprop.26>
 8004a76:	23be      	movs	r3, #190	; 0xbe
 8004a78:	4a4e      	ldr	r2, [pc, #312]	; (8004bb4 <moduleTRACKING+0x1274>)
 8004a7a:	4945      	ldr	r1, [pc, #276]	; (8004b90 <moduleTRACKING+0x1250>)
 8004a7c:	483f      	ldr	r0, [pc, #252]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a7e:	f005 fe07 	bl	800a690 <chprintf.constprop.26>
 8004a82:	4944      	ldr	r1, [pc, #272]	; (8004b94 <moduleTRACKING+0x1254>)
 8004a84:	483d      	ldr	r0, [pc, #244]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a86:	f005 fe03 	bl	800a690 <chprintf.constprop.26>
 8004a8a:	494b      	ldr	r1, [pc, #300]	; (8004bb8 <moduleTRACKING+0x1278>)
 8004a8c:	483b      	ldr	r0, [pc, #236]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a8e:	f005 fdff 	bl	800a690 <chprintf.constprop.26>
 8004a92:	4942      	ldr	r1, [pc, #264]	; (8004b9c <moduleTRACKING+0x125c>)
 8004a94:	4839      	ldr	r0, [pc, #228]	; (8004b7c <moduleTRACKING+0x123c>)
 8004a96:	f005 fdfb 	bl	800a690 <chprintf.constprop.26>
 8004a9a:	4836      	ldr	r0, [pc, #216]	; (8004b74 <moduleTRACKING+0x1234>)
 8004a9c:	f004 fd70 	bl	8009580 <chMtxUnlock>
			TRACE_GPSFIX(&gpsFix);
 8004aa0:	4834      	ldr	r0, [pc, #208]	; (8004b74 <moduleTRACKING+0x1234>)
 8004aa2:	f007 fb7d 	bl	800c1a0 <chMtxLock>
 8004aa6:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8004aa8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004aaa:	4933      	ldr	r1, [pc, #204]	; (8004b78 <moduleTRACKING+0x1238>)
 8004aac:	4833      	ldr	r0, [pc, #204]	; (8004b7c <moduleTRACKING+0x123c>)
 8004aae:	fb04 f303 	mul.w	r3, r4, r3
 8004ab2:	fba6 7303 	umull	r7, r3, r6, r3
 8004ab6:	0b5b      	lsrs	r3, r3, #13
 8004ab8:	fbaa 7e03 	umull	r7, lr, sl, r3
 8004abc:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8004ac0:	fba6 7202 	umull	r7, r2, r6, r2
 8004ac4:	fb04 331e 	mls	r3, r4, lr, r3
 8004ac8:	0b52      	lsrs	r2, r2, #13
 8004aca:	f005 fde1 	bl	800a690 <chprintf.constprop.26>
 8004ace:	4a2d      	ldr	r2, [pc, #180]	; (8004b84 <moduleTRACKING+0x1244>)
 8004ad0:	492d      	ldr	r1, [pc, #180]	; (8004b88 <moduleTRACKING+0x1248>)
 8004ad2:	482a      	ldr	r0, [pc, #168]	; (8004b7c <moduleTRACKING+0x123c>)
 8004ad4:	f005 fddc 	bl	800a690 <chprintf.constprop.26>
 8004ad8:	23bf      	movs	r3, #191	; 0xbf
 8004ada:	4a36      	ldr	r2, [pc, #216]	; (8004bb4 <moduleTRACKING+0x1274>)
 8004adc:	492c      	ldr	r1, [pc, #176]	; (8004b90 <moduleTRACKING+0x1250>)
 8004ade:	4827      	ldr	r0, [pc, #156]	; (8004b7c <moduleTRACKING+0x123c>)
 8004ae0:	f005 fdd6 	bl	800a690 <chprintf.constprop.26>
 8004ae4:	492b      	ldr	r1, [pc, #172]	; (8004b94 <moduleTRACKING+0x1254>)
 8004ae6:	4825      	ldr	r0, [pc, #148]	; (8004b7c <moduleTRACKING+0x123c>)
 8004ae8:	f005 fdd2 	bl	800a690 <chprintf.constprop.26>
 8004aec:	9f21      	ldr	r7, [sp, #132]	; 0x84
 8004aee:	9920      	ldr	r1, [sp, #128]	; 0x80
 8004af0:	982a      	ldr	r0, [sp, #168]	; 0xa8
 8004af2:	4b32      	ldr	r3, [pc, #200]	; (8004bbc <moduleTRACKING+0x127c>)
 8004af4:	900e      	str	r0, [sp, #56]	; 0x38
 8004af6:	2f00      	cmp	r7, #0
 8004af8:	bfd4      	ite	le
 8004afa:	f04f 3cff 	movle.w	ip, #4294967295
 8004afe:	f04f 0c01 	movgt.w	ip, #1
 8004b02:	2900      	cmp	r1, #0
 8004b04:	bfd4      	ite	le
 8004b06:	f04f 30ff 	movle.w	r0, #4294967295
 8004b0a:	2001      	movgt	r0, #1
 8004b0c:	fb07 fc0c 	mul.w	ip, r7, ip
 8004b10:	fb01 f000 	mul.w	r0, r1, r0
 8004b14:	f8df e0a8 	ldr.w	lr, [pc, #168]	; 8004bc0 <moduleTRACKING+0x1280>
 8004b18:	f8dd 90a4 	ldr.w	r9, [sp, #164]	; 0xa4
 8004b1c:	fb83 810c 	smull	r8, r1, r3, ip
 8004b20:	ea4f 72ec 	mov.w	r2, ip, asr #31
 8004b24:	ebc2 51a1 	rsb	r1, r2, r1, asr #22
 8004b28:	fb0e c111 	mls	r1, lr, r1, ip
 8004b2c:	fb83 8200 	smull	r8, r2, r3, r0
 8004b30:	ea4f 7ce0 	mov.w	ip, r0, asr #31
 8004b34:	ebcc 52a2 	rsb	r2, ip, r2, asr #22
 8004b38:	fb0e 0012 	mls	r0, lr, r2, r0
 8004b3c:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8004b3e:	9109      	str	r1, [sp, #36]	; 0x24
 8004b40:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 8004b44:	fb83 7c07 	smull	r7, ip, r3, r7
 8004b48:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8004b4a:	9f20      	ldr	r7, [sp, #128]	; 0x80
 8004b4c:	900c      	str	r0, [sp, #48]	; 0x30
 8004b4e:	fb83 7307 	smull	r7, r3, r3, r7
 8004b52:	17d2      	asrs	r2, r2, #31
 8004b54:	ebc2 53a3 	rsb	r3, r2, r3, asr #22
 8004b58:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8004b5a:	920d      	str	r2, [sp, #52]	; 0x34
 8004b5c:	920a      	str	r2, [sp, #40]	; 0x28
 8004b5e:	9207      	str	r2, [sp, #28]
 8004b60:	9205      	str	r2, [sp, #20]
 8004b62:	9a25      	ldr	r2, [sp, #148]	; 0x94
 8004b64:	9203      	str	r2, [sp, #12]
 8004b66:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8004b68:	e02c      	b.n	8004bc4 <moduleTRACKING+0x1284>
 8004b6a:	bf00      	nop
 8004b6c:	20000874 	.word	0x20000874
 8004b70:	2001b6b0 	.word	0x2001b6b0
 8004b74:	2001b720 	.word	0x2001b720
 8004b78:	0800ea50 	.word	0x0800ea50
 8004b7c:	2001ac28 	.word	0x2001ac28
 8004b80:	10624dd3 	.word	0x10624dd3
 8004b84:	0800f1dc 	.word	0x0800f1dc
 8004b88:	0800ea64 	.word	0x0800ea64
 8004b8c:	0800f2d4 	.word	0x0800f2d4
 8004b90:	0800ea7c 	.word	0x0800ea7c
 8004b94:	0800f1e0 	.word	0x0800f1e0
 8004b98:	0800f460 	.word	0x0800f460
 8004b9c:	0800eaa8 	.word	0x0800eaa8
 8004ba0:	d1b71759 	.word	0xd1b71759
 8004ba4:	0800f478 	.word	0x0800f478
 8004ba8:	40021400 	.word	0x40021400
 8004bac:	40020c00 	.word	0x40020c00
 8004bb0:	40020800 	.word	0x40020800
 8004bb4:	0800f15c 	.word	0x0800f15c
 8004bb8:	0800f48c 	.word	0x0800f48c
 8004bbc:	6b5fca6b 	.word	0x6b5fca6b
 8004bc0:	00989680 	.word	0x00989680
 8004bc4:	9202      	str	r2, [sp, #8]
 8004bc6:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8004bc8:	9f23      	ldr	r7, [sp, #140]	; 0x8c
 8004bca:	9201      	str	r2, [sp, #4]
 8004bcc:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 8004bce:	9706      	str	r7, [sp, #24]
 8004bd0:	ebce 5cac 	rsb	ip, lr, ip, asr #22
 8004bd4:	9f28      	ldr	r7, [sp, #160]	; 0xa0
 8004bd6:	9200      	str	r2, [sp, #0]
 8004bd8:	930b      	str	r3, [sp, #44]	; 0x2c
 8004bda:	4ab3      	ldr	r2, [pc, #716]	; (8004ea8 <moduleTRACKING+0x1568>)
 8004bdc:	49b3      	ldr	r1, [pc, #716]	; (8004eac <moduleTRACKING+0x156c>)
 8004bde:	48b4      	ldr	r0, [pc, #720]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004be0:	f8cd c020 	str.w	ip, [sp, #32]
 8004be4:	464b      	mov	r3, r9
 8004be6:	9704      	str	r7, [sp, #16]
 8004be8:	f005 fd52 	bl	800a690 <chprintf.constprop.26>
 8004bec:	49b1      	ldr	r1, [pc, #708]	; (8004eb4 <moduleTRACKING+0x1574>)
 8004bee:	48b0      	ldr	r0, [pc, #704]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004bf0:	f005 fd4e 	bl	800a690 <chprintf.constprop.26>
 8004bf4:	48b0      	ldr	r0, [pc, #704]	; (8004eb8 <moduleTRACKING+0x1578>)
 8004bf6:	f004 fcc3 	bl	8009580 <chMtxUnlock>
void setTime(ptime_t date) {
	RTCDateTime timespec;
	timespec.year = date.year - 2000;
	timespec.month = date.month;
	timespec.day = date.day;
	timespec.millisecond = date.hour * 3600000 + date.minute * 60000 + date.second * 1000 + date.millisecond;
 8004bfa:	9925      	ldr	r1, [sp, #148]	; 0x94
 8004bfc:	4baf      	ldr	r3, [pc, #700]	; (8004ebc <moduleTRACKING+0x157c>)
 8004bfe:	f8bd 8100 	ldrh.w	r8, [sp, #256]	; 0x100

	TRACE_INFO("GPS  > Calibrate RTC");
 8004c02:	48ad      	ldr	r0, [pc, #692]	; (8004eb8 <moduleTRACKING+0x1578>)
void setTime(ptime_t date) {
	RTCDateTime timespec;
	timespec.year = date.year - 2000;
	timespec.month = date.month;
	timespec.day = date.day;
	timespec.millisecond = date.hour * 3600000 + date.minute * 60000 + date.second * 1000 + date.millisecond;
 8004c04:	f64e 2260 	movw	r2, #60000	; 0xea60
 8004c08:	fb02 f201 	mul.w	r2, r2, r1
 8004c0c:	9924      	ldr	r1, [sp, #144]	; 0x90
 8004c0e:	fb03 2301 	mla	r3, r3, r1, r2
 8004c12:	fb04 3307 	mla	r3, r4, r7, r3
 8004c16:	4498      	add	r8, r3

	TRACE_INFO("GPS  > Calibrate RTC");
 8004c18:	f007 fac2 	bl	800c1a0 <chMtxLock>
 8004c1c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8004c1e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004c20:	49a7      	ldr	r1, [pc, #668]	; (8004ec0 <moduleTRACKING+0x1580>)
 8004c22:	48a3      	ldr	r0, [pc, #652]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004c24:	fb04 f303 	mul.w	r3, r4, r3
 8004c28:	fba6 7303 	umull	r7, r3, r6, r3
 8004c2c:	0b5b      	lsrs	r3, r3, #13
 8004c2e:	fbaa 7e03 	umull	r7, lr, sl, r3
 8004c32:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8004c36:	fba6 7202 	umull	r7, r2, r6, r2
 8004c3a:	fb04 331e 	mls	r3, r4, lr, r3
 8004c3e:	0b52      	lsrs	r2, r2, #13
 8004c40:	f005 fd26 	bl	800a690 <chprintf.constprop.26>
 8004c44:	4a9f      	ldr	r2, [pc, #636]	; (8004ec4 <moduleTRACKING+0x1584>)
 8004c46:	49a0      	ldr	r1, [pc, #640]	; (8004ec8 <moduleTRACKING+0x1588>)
 8004c48:	4899      	ldr	r0, [pc, #612]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004c4a:	f005 fd21 	bl	800a690 <chprintf.constprop.26>
 8004c4e:	2363      	movs	r3, #99	; 0x63
 8004c50:	4a9e      	ldr	r2, [pc, #632]	; (8004ecc <moduleTRACKING+0x158c>)
 8004c52:	499f      	ldr	r1, [pc, #636]	; (8004ed0 <moduleTRACKING+0x1590>)
 8004c54:	4896      	ldr	r0, [pc, #600]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004c56:	f005 fd1b 	bl	800a690 <chprintf.constprop.26>
 8004c5a:	499e      	ldr	r1, [pc, #632]	; (8004ed4 <moduleTRACKING+0x1594>)
 8004c5c:	4894      	ldr	r0, [pc, #592]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004c5e:	f005 fd17 	bl	800a690 <chprintf.constprop.26>
 8004c62:	499d      	ldr	r1, [pc, #628]	; (8004ed8 <moduleTRACKING+0x1598>)
 8004c64:	4892      	ldr	r0, [pc, #584]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004c66:	f005 fd13 	bl	800a690 <chprintf.constprop.26>
 8004c6a:	4992      	ldr	r1, [pc, #584]	; (8004eb4 <moduleTRACKING+0x1574>)
 8004c6c:	4890      	ldr	r0, [pc, #576]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004c6e:	f005 fd0f 	bl	800a690 <chprintf.constprop.26>
 8004c72:	4891      	ldr	r0, [pc, #580]	; (8004eb8 <moduleTRACKING+0x1578>)
 8004c74:	f004 fc84 	bl	8009580 <chMtxUnlock>
	PRINT_TIME("RTC");
 8004c78:	a84f      	add	r0, sp, #316	; 0x13c
 8004c7a:	f007 fc59 	bl	800c530 <getTime>
 8004c7e:	488e      	ldr	r0, [pc, #568]	; (8004eb8 <moduleTRACKING+0x1578>)
 8004c80:	f007 fa8e 	bl	800c1a0 <chMtxLock>
 8004c84:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8004c86:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004c88:	498d      	ldr	r1, [pc, #564]	; (8004ec0 <moduleTRACKING+0x1580>)
 8004c8a:	4889      	ldr	r0, [pc, #548]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004c8c:	fb04 f303 	mul.w	r3, r4, r3
 8004c90:	fba6 5303 	umull	r5, r3, r6, r3
 8004c94:	0b5b      	lsrs	r3, r3, #13
 8004c96:	fbaa 7503 	umull	r7, r5, sl, r3
 8004c9a:	fba6 6202 	umull	r6, r2, r6, r2
 8004c9e:	09ad      	lsrs	r5, r5, #6
 8004ca0:	fb04 3315 	mls	r3, r4, r5, r3
 8004ca4:	0b52      	lsrs	r2, r2, #13
 8004ca6:	f005 fcf3 	bl	800a690 <chprintf.constprop.26>
 8004caa:	4a86      	ldr	r2, [pc, #536]	; (8004ec4 <moduleTRACKING+0x1584>)
 8004cac:	4986      	ldr	r1, [pc, #536]	; (8004ec8 <moduleTRACKING+0x1588>)
 8004cae:	4880      	ldr	r0, [pc, #512]	; (8004eb0 <moduleTRACKING+0x1570>)
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004cb0:	4f8a      	ldr	r7, [pc, #552]	; (8004edc <moduleTRACKING+0x159c>)
 8004cb2:	f005 fced 	bl	800a690 <chprintf.constprop.26>
 8004cb6:	2364      	movs	r3, #100	; 0x64
 8004cb8:	4a84      	ldr	r2, [pc, #528]	; (8004ecc <moduleTRACKING+0x158c>)
 8004cba:	4985      	ldr	r1, [pc, #532]	; (8004ed0 <moduleTRACKING+0x1590>)
 8004cbc:	487c      	ldr	r0, [pc, #496]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004cbe:	f005 fce7 	bl	800a690 <chprintf.constprop.26>
 8004cc2:	4984      	ldr	r1, [pc, #528]	; (8004ed4 <moduleTRACKING+0x1594>)
 8004cc4:	487a      	ldr	r0, [pc, #488]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004cc6:	f005 fce3 	bl	800a690 <chprintf.constprop.26>
 8004cca:	f8bd 6144 	ldrh.w	r6, [sp, #324]	; 0x144
 8004cce:	f89d 5142 	ldrb.w	r5, [sp, #322]	; 0x142
 8004cd2:	f89d 4141 	ldrb.w	r4, [sp, #321]	; 0x141
 8004cd6:	f89d 0140 	ldrb.w	r0, [sp, #320]	; 0x140
 8004cda:	f89d 113f 	ldrb.w	r1, [sp, #319]	; 0x13f
 8004cde:	f89d 213e 	ldrb.w	r2, [sp, #318]	; 0x13e
 8004ce2:	f8bd 313c 	ldrh.w	r3, [sp, #316]	; 0x13c
 8004ce6:	9605      	str	r6, [sp, #20]
 8004ce8:	9504      	str	r5, [sp, #16]
 8004cea:	9403      	str	r4, [sp, #12]
 8004cec:	9002      	str	r0, [sp, #8]
 8004cee:	9101      	str	r1, [sp, #4]
 8004cf0:	9200      	str	r2, [sp, #0]
 8004cf2:	497b      	ldr	r1, [pc, #492]	; (8004ee0 <moduleTRACKING+0x15a0>)
 8004cf4:	4a7b      	ldr	r2, [pc, #492]	; (8004ee4 <moduleTRACKING+0x15a4>)
 8004cf6:	486e      	ldr	r0, [pc, #440]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004cf8:	4e7b      	ldr	r6, [pc, #492]	; (8004ee8 <moduleTRACKING+0x15a8>)
 8004cfa:	4c7c      	ldr	r4, [pc, #496]	; (8004eec <moduleTRACKING+0x15ac>)
 8004cfc:	4d7c      	ldr	r5, [pc, #496]	; (8004ef0 <moduleTRACKING+0x15b0>)
 8004cfe:	f005 fcc7 	bl	800a690 <chprintf.constprop.26>
 8004d02:	496c      	ldr	r1, [pc, #432]	; (8004eb4 <moduleTRACKING+0x1574>)
 8004d04:	486a      	ldr	r0, [pc, #424]	; (8004eb0 <moduleTRACKING+0x1570>)
 8004d06:	f005 fcc3 	bl	800a690 <chprintf.constprop.26>
 8004d0a:	486b      	ldr	r0, [pc, #428]	; (8004eb8 <moduleTRACKING+0x1578>)
 8004d0c:	f004 fc38 	bl	8009580 <chMtxUnlock>
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
 8004d10:	9a26      	ldr	r2, [sp, #152]	; 0x98
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d12:	4878      	ldr	r0, [pc, #480]	; (8004ef4 <moduleTRACKING+0x15b4>)
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004d14:	f89d e13d 	ldrb.w	lr, [sp, #317]	; 0x13d
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
  uint32_t n, tr = 0;

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 8004d18:	f028 4378 	bic.w	r3, r8, #4160749568	; 0xf8000000
 8004d1c:	fb8a 1303 	smull	r1, r3, sl, r3
 8004d20:	099b      	lsrs	r3, r3, #6
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);

  /* Days conversion.*/
  n = timespec->day;
 8004d22:	f002 081f 	and.w	r8, r2, #31
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
 8004d26:	9a27      	ldr	r2, [sp, #156]	; 0x9c
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d28:	fba6 c103 	umull	ip, r1, r6, r3
 8004d2c:	fba0 c003 	umull	ip, r0, r0, r3
 8004d30:	08c9      	lsrs	r1, r1, #3
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);

  /* Months conversion.*/
  n = timespec->month;
 8004d32:	f002 020f 	and.w	r2, r2, #15
 8004d36:	9233      	str	r2, [sp, #204]	; 0xcc
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d38:	fba7 c201 	umull	ip, r2, r7, r1
 8004d3c:	ea4f 1c50 	mov.w	ip, r0, lsr #5
 8004d40:	fba4 0403 	umull	r0, r4, r4, r3
 8004d44:	fba5 5003 	umull	r5, r0, r5, r3
 8004d48:	09a5      	lsrs	r5, r4, #6
 8004d4a:	9531      	str	r5, [sp, #196]	; 0xc4
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004d4c:	fba6 a508 	umull	sl, r5, r6, r8
 8004d50:	ea4f 0bd5 	mov.w	fp, r5, lsr #3
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d54:	0892      	lsrs	r2, r2, #2
 8004d56:	9d31      	ldr	r5, [sp, #196]	; 0xc4
 8004d58:	4c67      	ldr	r4, [pc, #412]	; (8004ef8 <moduleTRACKING+0x15b8>)
 8004d5a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8004d5e:	fba7 a705 	umull	sl, r7, r7, r5
 8004d62:	eba1 0242 	sub.w	r2, r1, r2, lsl #1
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004d66:	9d33      	ldr	r5, [sp, #204]	; 0xcc
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d68:	9734      	str	r7, [sp, #208]	; 0xd0
 8004d6a:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8004d6e:	fba4 a403 	umull	sl, r4, r4, r3
 8004d72:	eba3 0141 	sub.w	r1, r3, r1, lsl #1
 8004d76:	0bc0      	lsrs	r0, r0, #15
 8004d78:	ea41 5000 	orr.w	r0, r1, r0, lsl #20
 8004d7c:	0ae7      	lsrs	r7, r4, #11
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004d7e:	fba6 a405 	umull	sl, r4, r6, r5
 8004d82:	08e4      	lsrs	r4, r4, #3
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d84:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
 8004d88:	9233      	str	r2, [sp, #204]	; 0xcc
 8004d8a:	fba6 020c 	umull	r0, r2, r6, ip
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004d8e:	00a0      	lsls	r0, r4, #2
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8004d90:	464b      	mov	r3, r9
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004d92:	4420      	add	r0, r4
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d94:	08d2      	lsrs	r2, r2, #3
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8004d96:	3330      	adds	r3, #48	; 0x30
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004d98:	9934      	ldr	r1, [sp, #208]	; 0xd0
 8004d9a:	9735      	str	r7, [sp, #212]	; 0xd4
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004d9c:	eba5 0040 	sub.w	r0, r5, r0, lsl #1
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004da0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004da4:	9d33      	ldr	r5, [sp, #204]	; 0xcc
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
  uint32_t n, dr = 0;

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8004da6:	b2df      	uxtb	r7, r3
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004da8:	ebac 0242 	sub.w	r2, ip, r2, lsl #1
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004dac:	eb0b 038b 	add.w	r3, fp, fp, lsl #2
 8004db0:	eba8 0343 	sub.w	r3, r8, r3, lsl #1
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004db4:	0889      	lsrs	r1, r1, #2
 8004db6:	ea45 2802 	orr.w	r8, r5, r2, lsl #8
 8004dba:	9d31      	ldr	r5, [sp, #196]	; 0xc4
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004dbc:	ea4f 125e 	mov.w	r2, lr, lsr #5
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004dc0:	eb01 0141 	add.w	r1, r1, r1, lsl #1
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004dc4:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
 8004dc8:	fba6 c207 	umull	ip, r2, r6, r7
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004dcc:	eba5 0c41 	sub.w	ip, r5, r1, lsl #1
 8004dd0:	9d35      	ldr	r5, [sp, #212]	; 0xd4
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004dd2:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8004dd6:	08d2      	lsrs	r2, r2, #3
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004dd8:	462b      	mov	r3, r5
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004dda:	ea40 3404 	orr.w	r4, r0, r4, lsl #12
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004dde:	fba6 3103 	umull	r3, r1, r6, r3
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004de2:	fba6 0302 	umull	r0, r3, r6, r2
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004de6:	08c9      	lsrs	r1, r1, #3
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004de8:	eb02 0082 	add.w	r0, r2, r2, lsl #2
 8004dec:	08db      	lsrs	r3, r3, #3
 8004dee:	ea44 140b 	orr.w	r4, r4, fp, lsl #4
 8004df2:	eba7 0040 	sub.w	r0, r7, r0, lsl #1
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004df6:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004dfa:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004dfe:	eba5 0141 	sub.w	r1, r5, r1, lsl #1
 8004e02:	ea48 360c 	orr.w	r6, r8, ip, lsl #12
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004e06:	eba2 0343 	sub.w	r3, r2, r3, lsl #1
 8004e0a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
  n /= 6;

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
  n /= 10;
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8004e0e:	ea46 4601 	orr.w	r6, r6, r1, lsl #16
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
  n /= 10;
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8004e12:	ea44 5503 	orr.w	r5, r4, r3, lsl #20
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8004e16:	f3ef 8411 	mrs	r4, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8004e1a:	b91c      	cbnz	r4, 8004e24 <moduleTRACKING+0x14e4>
 8004e1c:	f007 fae8 	bl	800c3f0 <chSysGetStatusAndLockX.part.1.lto_priv.137>
 8004e20:	f89d e13d 	ldrb.w	lr, [sp, #317]	; 0x13d
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 8004e24:	4b35      	ldr	r3, [pc, #212]	; (8004efc <moduleTRACKING+0x15bc>)
 8004e26:	681b      	ldr	r3, [r3, #0]
 8004e28:	68da      	ldr	r2, [r3, #12]
 8004e2a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8004e2e:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 8004e30:	68da      	ldr	r2, [r3, #12]
 8004e32:	0657      	lsls	r7, r2, #25
 8004e34:	d5fc      	bpl.n	8004e30 <moduleTRACKING+0x14f0>
  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();

  /* Writing the registers.*/
  rtc_enter_init();
  rtcp->rtc->TR  = tr;
 8004e36:	601e      	str	r6, [r3, #0]
  rtcp->rtc->DR  = dr;
 8004e38:	605d      	str	r5, [r3, #4]
  rtcp->rtc->CR |= timespec->dstflag << RTC_CR_BKP_OFFSET;
 8004e3a:	689a      	ldr	r2, [r3, #8]
 8004e3c:	f3ce 1e00 	ubfx	lr, lr, #4, #1
 8004e40:	ea42 428e 	orr.w	r2, r2, lr, lsl #18
 8004e44:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8004e46:	68da      	ldr	r2, [r3, #12]
 8004e48:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8004e4c:	60da      	str	r2, [r3, #12]
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 8004e4e:	b90c      	cbnz	r4, 8004e54 <moduleTRACKING+0x1514>
 8004e50:	f007 fae6 	bl	800c420 <chSysRestoreStatusX.part.2.lto_priv.138>

			// Calibrate RTC
			setTime(gpsFix.time);

			// Take time from GPS
			tp->time.year = gpsFix.time.year;
 8004e54:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8004e56:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8004e58:	f8bd 10a4 	ldrh.w	r1, [sp, #164]	; 0xa4
 8004e5c:	4413      	add	r3, r2
 8004e5e:	4a28      	ldr	r2, [pc, #160]	; (8004f00 <moduleTRACKING+0x15c0>)
 8004e60:	eb02 1303 	add.w	r3, r2, r3, lsl #4
			// Set new GPS fix
			tp->gps_lat = gpsFix.lat;
			tp->gps_lon = gpsFix.lon;
			tp->gps_alt = gpsFix.alt;

			tp->gps_lock = isGPSLocked(&gpsFix);
 8004e64:	2201      	movs	r2, #1

			// Calibrate RTC
			setTime(gpsFix.time);

			// Take time from GPS
			tp->time.year = gpsFix.time.year;
 8004e66:	8099      	strh	r1, [r3, #4]
			tp->time.month = gpsFix.time.month;
 8004e68:	f89d 109c 	ldrb.w	r1, [sp, #156]	; 0x9c
 8004e6c:	7199      	strb	r1, [r3, #6]
			tp->time.day = gpsFix.time.day;
 8004e6e:	f89d 1098 	ldrb.w	r1, [sp, #152]	; 0x98
 8004e72:	71d9      	strb	r1, [r3, #7]
			tp->time.hour = gpsFix.time.hour;
 8004e74:	f89d 1090 	ldrb.w	r1, [sp, #144]	; 0x90
 8004e78:	7219      	strb	r1, [r3, #8]
			tp->time.minute = gpsFix.time.minute;
 8004e7a:	f89d 1094 	ldrb.w	r1, [sp, #148]	; 0x94
 8004e7e:	7259      	strb	r1, [r3, #9]
			tp->time.second = gpsFix.time.second;
 8004e80:	f89d 10a0 	ldrb.w	r1, [sp, #160]	; 0xa0
 8004e84:	7299      	strb	r1, [r3, #10]

			// Set new GPS fix
			tp->gps_lat = gpsFix.lat;
 8004e86:	9921      	ldr	r1, [sp, #132]	; 0x84
 8004e88:	6119      	str	r1, [r3, #16]
			tp->gps_lon = gpsFix.lon;
 8004e8a:	9920      	ldr	r1, [sp, #128]	; 0x80
 8004e8c:	6159      	str	r1, [r3, #20]
			tp->gps_alt = gpsFix.alt;
 8004e8e:	992a      	ldr	r1, [sp, #168]	; 0xa8
 8004e90:	6199      	str	r1, [r3, #24]

			tp->gps_lock = isGPSLocked(&gpsFix);
			tp->gps_sats = gpsFix.num_svs;
 8004e92:	f89d 108c 	ldrb.w	r1, [sp, #140]	; 0x8c
 8004e96:	7719      	strb	r1, [r3, #28]
			// Set new GPS fix
			tp->gps_lat = gpsFix.lat;
			tp->gps_lon = gpsFix.lon;
			tp->gps_alt = gpsFix.alt;

			tp->gps_lock = isGPSLocked(&gpsFix);
 8004e98:	739a      	strb	r2, [r3, #14]
			tp->gps_sats = gpsFix.num_svs;
 8004e9a:	2703      	movs	r7, #3
 8004e9c:	f7ff badb 	b.w	8004456 <moduleTRACKING+0xb16>
			);
	int32_t alt_tmp = (((int32_t) 
			((uint32_t)(response[36]) + ((uint32_t)(response[37]) << 8) + ((uint32_t)(response[38]) << 16) + ((uint32_t)(response[39]) << 24))
			) / 1000);
	if (alt_tmp <= 0) {
		fix->alt = 1;
 8004ea0:	2301      	movs	r3, #1
 8004ea2:	932a      	str	r3, [sp, #168]	; 0xa8
 8004ea4:	f7ff ba68 	b.w	8004378 <moduleTRACKING+0xa38>
 8004ea8:	0800f1b4 	.word	0x0800f1b4
 8004eac:	0800f4b4 	.word	0x0800f4b4
 8004eb0:	2001ac28 	.word	0x2001ac28
 8004eb4:	0800eaa8 	.word	0x0800eaa8
 8004eb8:	2001b720 	.word	0x2001b720
 8004ebc:	0036ee80 	.word	0x0036ee80
 8004ec0:	0800ea50 	.word	0x0800ea50
 8004ec4:	0800f1dc 	.word	0x0800f1dc
 8004ec8:	0800ea64 	.word	0x0800ea64
 8004ecc:	0800f570 	.word	0x0800f570
 8004ed0:	0800ea7c 	.word	0x0800ea7c
 8004ed4:	0800f1e0 	.word	0x0800f1e0
 8004ed8:	0800f578 	.word	0x0800f578
 8004edc:	aaaaaaab 	.word	0xaaaaaaab
 8004ee0:	0800f594 	.word	0x0800f594
 8004ee4:	0800f590 	.word	0x0800f590
 8004ee8:	cccccccd 	.word	0xcccccccd
 8004eec:	1b4e81b5 	.word	0x1b4e81b5
 8004ef0:	e90452d5 	.word	0xe90452d5
 8004ef4:	88888889 	.word	0x88888889
 8004ef8:	91a2b3c5 	.word	0x91a2b3c5
 8004efc:	2001997c 	.word	0x2001997c
 8004f00:	20000810 	.word	0x20000810
		status = 0;
	}
	if(gps_set_power_save()) {
		TRACE_INFO("GPS  > Configure power save OK");
	} else {
		TRACE_ERROR("GPS  > Configure power save FAILED");
 8004f04:	48ba      	ldr	r0, [pc, #744]	; (80051f0 <moduleTRACKING+0x18b0>)
 8004f06:	4cbb      	ldr	r4, [pc, #748]	; (80051f4 <moduleTRACKING+0x18b4>)
 8004f08:	f007 f94a 	bl	800c1a0 <chMtxLock>
 8004f0c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004f10:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004f14:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004f16:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8004f18:	4bb7      	ldr	r3, [pc, #732]	; (80051f8 <moduleTRACKING+0x18b8>)
 8004f1a:	fb00 f101 	mul.w	r1, r0, r1
 8004f1e:	fba4 5101 	umull	r5, r1, r4, r1
 8004f22:	0b49      	lsrs	r1, r1, #13
 8004f24:	fba3 5301 	umull	r5, r3, r3, r1
 8004f28:	fba4 4202 	umull	r4, r2, r4, r2
 8004f2c:	099b      	lsrs	r3, r3, #6
 8004f2e:	fb00 1313 	mls	r3, r0, r3, r1
 8004f32:	0b52      	lsrs	r2, r2, #13
 8004f34:	49b1      	ldr	r1, [pc, #708]	; (80051fc <moduleTRACKING+0x18bc>)
 8004f36:	48b2      	ldr	r0, [pc, #712]	; (8005200 <moduleTRACKING+0x18c0>)
 8004f38:	f005 fbaa 	bl	800a690 <chprintf.constprop.26>
 8004f3c:	4ab1      	ldr	r2, [pc, #708]	; (8005204 <moduleTRACKING+0x18c4>)
 8004f3e:	49b2      	ldr	r1, [pc, #712]	; (8005208 <moduleTRACKING+0x18c8>)
 8004f40:	48af      	ldr	r0, [pc, #700]	; (8005200 <moduleTRACKING+0x18c0>)
 8004f42:	f005 fba5 	bl	800a690 <chprintf.constprop.26>
 8004f46:	f240 1365 	movw	r3, #357	; 0x165
 8004f4a:	4ab0      	ldr	r2, [pc, #704]	; (800520c <moduleTRACKING+0x18cc>)
 8004f4c:	49b0      	ldr	r1, [pc, #704]	; (8005210 <moduleTRACKING+0x18d0>)
 8004f4e:	48ac      	ldr	r0, [pc, #688]	; (8005200 <moduleTRACKING+0x18c0>)
 8004f50:	f005 fb9e 	bl	800a690 <chprintf.constprop.26>
 8004f54:	49af      	ldr	r1, [pc, #700]	; (8005214 <moduleTRACKING+0x18d4>)
 8004f56:	48aa      	ldr	r0, [pc, #680]	; (8005200 <moduleTRACKING+0x18c0>)
 8004f58:	f005 fb9a 	bl	800a690 <chprintf.constprop.26>
 8004f5c:	49ae      	ldr	r1, [pc, #696]	; (8005218 <moduleTRACKING+0x18d8>)
 8004f5e:	48a8      	ldr	r0, [pc, #672]	; (8005200 <moduleTRACKING+0x18c0>)
 8004f60:	f005 fb96 	bl	800a690 <chprintf.constprop.26>
 8004f64:	49ad      	ldr	r1, [pc, #692]	; (800521c <moduleTRACKING+0x18dc>)
 8004f66:	48a6      	ldr	r0, [pc, #664]	; (8005200 <moduleTRACKING+0x18c0>)
 8004f68:	f005 fb92 	bl	800a690 <chprintf.constprop.26>
 8004f6c:	48a0      	ldr	r0, [pc, #640]	; (80051f0 <moduleTRACKING+0x18b0>)
 8004f6e:	f004 fb07 	bl	8009580 <chMtxUnlock>
 8004f72:	f240 1165 	movw	r1, #357	; 0x165
 8004f76:	48a5      	ldr	r0, [pc, #660]	; (800520c <moduleTRACKING+0x18cc>)
 8004f78:	f007 fd02 	bl	800c980 <log_error>
 8004f7c:	f7ff b8f4 	b.w	8004168 <moduleTRACKING+0x828>

			if(batt < GPS_OFF_VBAT) // Switch off GPS at low batt
				GPS_Deinit();
		}

		if(isGPSLocked(&gpsFix)) { // GPS locked
 8004f80:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8004f82:	2b04      	cmp	r3, #4
 8004f84:	f67f aa07 	bls.w	8004396 <moduleTRACKING+0xa56>
 8004f88:	e50d      	b.n	80049a6 <moduleTRACKING+0x1066>
			BME280_Init(&bme280, BME280_ADDRESS_INT);
			tp->air_press = BME280_getPressure(&bme280, 256);
			tp->air_hum = BME280_getHumidity(&bme280);
			tp->air_temp = BME280_getTemperature(&bme280);
		} else { // No internal BME280 found
			TRACE_ERROR("TRAC > Internal BME280 not available");
 8004f8a:	4899      	ldr	r0, [pc, #612]	; (80051f0 <moduleTRACKING+0x18b0>)
 8004f8c:	4c99      	ldr	r4, [pc, #612]	; (80051f4 <moduleTRACKING+0x18b4>)
 8004f8e:	f007 f907 	bl	800c1a0 <chMtxLock>
 8004f92:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8004f96:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8004f9a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004f9c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8004f9e:	4b96      	ldr	r3, [pc, #600]	; (80051f8 <moduleTRACKING+0x18b8>)
 8004fa0:	fb00 f101 	mul.w	r1, r0, r1
 8004fa4:	fba4 5101 	umull	r5, r1, r4, r1
 8004fa8:	0b49      	lsrs	r1, r1, #13
 8004faa:	fba3 5301 	umull	r5, r3, r3, r1
 8004fae:	fba4 4202 	umull	r4, r2, r4, r2
 8004fb2:	099b      	lsrs	r3, r3, #6
 8004fb4:	fb00 1313 	mls	r3, r0, r3, r1
 8004fb8:	0b52      	lsrs	r2, r2, #13
 8004fba:	4990      	ldr	r1, [pc, #576]	; (80051fc <moduleTRACKING+0x18bc>)
 8004fbc:	4890      	ldr	r0, [pc, #576]	; (8005200 <moduleTRACKING+0x18c0>)
 8004fbe:	f005 fb67 	bl	800a690 <chprintf.constprop.26>
 8004fc2:	4a90      	ldr	r2, [pc, #576]	; (8005204 <moduleTRACKING+0x18c4>)
 8004fc4:	4990      	ldr	r1, [pc, #576]	; (8005208 <moduleTRACKING+0x18c8>)
 8004fc6:	488e      	ldr	r0, [pc, #568]	; (8005200 <moduleTRACKING+0x18c0>)
 8004fc8:	f005 fb62 	bl	800a690 <chprintf.constprop.26>
 8004fcc:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004fd0:	4a93      	ldr	r2, [pc, #588]	; (8005220 <moduleTRACKING+0x18e0>)
 8004fd2:	498f      	ldr	r1, [pc, #572]	; (8005210 <moduleTRACKING+0x18d0>)
 8004fd4:	488a      	ldr	r0, [pc, #552]	; (8005200 <moduleTRACKING+0x18c0>)
 8004fd6:	f005 fb5b 	bl	800a690 <chprintf.constprop.26>
 8004fda:	498e      	ldr	r1, [pc, #568]	; (8005214 <moduleTRACKING+0x18d4>)
 8004fdc:	4888      	ldr	r0, [pc, #544]	; (8005200 <moduleTRACKING+0x18c0>)
 8004fde:	f005 fb57 	bl	800a690 <chprintf.constprop.26>
 8004fe2:	4990      	ldr	r1, [pc, #576]	; (8005224 <moduleTRACKING+0x18e4>)
 8004fe4:	4886      	ldr	r0, [pc, #536]	; (8005200 <moduleTRACKING+0x18c0>)
 8004fe6:	f005 fb53 	bl	800a690 <chprintf.constprop.26>
 8004fea:	498c      	ldr	r1, [pc, #560]	; (800521c <moduleTRACKING+0x18dc>)
 8004fec:	4884      	ldr	r0, [pc, #528]	; (8005200 <moduleTRACKING+0x18c0>)
 8004fee:	f005 fb4f 	bl	800a690 <chprintf.constprop.26>
 8004ff2:	487f      	ldr	r0, [pc, #508]	; (80051f0 <moduleTRACKING+0x18b0>)
 8004ff4:	f004 fac4 	bl	8009580 <chMtxUnlock>
 8004ff8:	f44f 7180 	mov.w	r1, #256	; 0x100
 8004ffc:	4888      	ldr	r0, [pc, #544]	; (8005220 <moduleTRACKING+0x18e0>)
 8004ffe:	f007 fcbf 	bl	800c980 <log_error>
			tp->air_press = 0;
 8005002:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8005004:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8005006:	4413      	add	r3, r2
 8005008:	4a87      	ldr	r2, [pc, #540]	; (8005228 <moduleTRACKING+0x18e8>)
 800500a:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800500e:	2200      	movs	r2, #0
 8005010:	629a      	str	r2, [r3, #40]	; 0x28
			tp->air_hum = 0;
 8005012:	859a      	strh	r2, [r3, #44]	; 0x2c
			tp->air_temp = 0;
 8005014:	85da      	strh	r2, [r3, #46]	; 0x2e
 8005016:	f7ff ba90 	b.w	800453a <moduleTRACKING+0xbfa>
	}

	if(gps_set_airborne_model()) {
		TRACE_INFO("GPS  > Set airborne model OK");
	} else {
		TRACE_ERROR("GPS  > Set airborne model FAILED");
 800501a:	4875      	ldr	r0, [pc, #468]	; (80051f0 <moduleTRACKING+0x18b0>)
 800501c:	4c75      	ldr	r4, [pc, #468]	; (80051f4 <moduleTRACKING+0x18b4>)
 800501e:	f007 f8bf 	bl	800c1a0 <chMtxLock>
 8005022:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005026:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800502a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800502c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800502e:	4b72      	ldr	r3, [pc, #456]	; (80051f8 <moduleTRACKING+0x18b8>)
 8005030:	fb00 f101 	mul.w	r1, r0, r1
 8005034:	fba4 5101 	umull	r5, r1, r4, r1
 8005038:	0b49      	lsrs	r1, r1, #13
 800503a:	fba3 5301 	umull	r5, r3, r3, r1
 800503e:	fba4 4202 	umull	r4, r2, r4, r2
 8005042:	099b      	lsrs	r3, r3, #6
 8005044:	fb00 1313 	mls	r3, r0, r3, r1
 8005048:	0b52      	lsrs	r2, r2, #13
 800504a:	496c      	ldr	r1, [pc, #432]	; (80051fc <moduleTRACKING+0x18bc>)
 800504c:	486c      	ldr	r0, [pc, #432]	; (8005200 <moduleTRACKING+0x18c0>)
 800504e:	f005 fb1f 	bl	800a690 <chprintf.constprop.26>
 8005052:	4a6c      	ldr	r2, [pc, #432]	; (8005204 <moduleTRACKING+0x18c4>)
 8005054:	496c      	ldr	r1, [pc, #432]	; (8005208 <moduleTRACKING+0x18c8>)
 8005056:	486a      	ldr	r0, [pc, #424]	; (8005200 <moduleTRACKING+0x18c0>)
 8005058:	f005 fb1a 	bl	800a690 <chprintf.constprop.26>
 800505c:	f240 135f 	movw	r3, #351	; 0x15f
 8005060:	4a6a      	ldr	r2, [pc, #424]	; (800520c <moduleTRACKING+0x18cc>)
 8005062:	496b      	ldr	r1, [pc, #428]	; (8005210 <moduleTRACKING+0x18d0>)
 8005064:	4866      	ldr	r0, [pc, #408]	; (8005200 <moduleTRACKING+0x18c0>)
 8005066:	f005 fb13 	bl	800a690 <chprintf.constprop.26>
 800506a:	496a      	ldr	r1, [pc, #424]	; (8005214 <moduleTRACKING+0x18d4>)
 800506c:	4864      	ldr	r0, [pc, #400]	; (8005200 <moduleTRACKING+0x18c0>)
 800506e:	f005 fb0f 	bl	800a690 <chprintf.constprop.26>
 8005072:	496e      	ldr	r1, [pc, #440]	; (800522c <moduleTRACKING+0x18ec>)
 8005074:	4862      	ldr	r0, [pc, #392]	; (8005200 <moduleTRACKING+0x18c0>)
 8005076:	f005 fb0b 	bl	800a690 <chprintf.constprop.26>
 800507a:	4968      	ldr	r1, [pc, #416]	; (800521c <moduleTRACKING+0x18dc>)
 800507c:	4860      	ldr	r0, [pc, #384]	; (8005200 <moduleTRACKING+0x18c0>)
 800507e:	f005 fb07 	bl	800a690 <chprintf.constprop.26>
 8005082:	485b      	ldr	r0, [pc, #364]	; (80051f0 <moduleTRACKING+0x18b0>)
 8005084:	f004 fa7c 	bl	8009580 <chMtxUnlock>
 8005088:	f240 115f 	movw	r1, #351	; 0x15f
 800508c:	485f      	ldr	r0, [pc, #380]	; (800520c <moduleTRACKING+0x18cc>)
 800508e:	f007 fc77 	bl	800c980 <log_error>
 8005092:	f7ff b815 	b.w	80040c0 <moduleTRACKING+0x780>
	// Configure GPS
	TRACE_INFO("GPS  > Initialize GPS");
	if(gps_disable_nmea_output()) {
		TRACE_INFO("GPS  > Disable NMEA output OK");
	} else {
		TRACE_ERROR("GPS  > Disable NMEA output FAILED");
 8005096:	4856      	ldr	r0, [pc, #344]	; (80051f0 <moduleTRACKING+0x18b0>)
 8005098:	f007 f882 	bl	800c1a0 <chMtxLock>
 800509c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800509e:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80050a0:	4956      	ldr	r1, [pc, #344]	; (80051fc <moduleTRACKING+0x18bc>)
 80050a2:	fb06 f000 	mul.w	r0, r6, r0
 80050a6:	fba7 3000 	umull	r3, r0, r7, r0
 80050aa:	0b40      	lsrs	r0, r0, #13
 80050ac:	fba4 3400 	umull	r3, r4, r4, r0
 80050b0:	09a3      	lsrs	r3, r4, #6
 80050b2:	fba7 4202 	umull	r4, r2, r7, r2
 80050b6:	fb06 0313 	mls	r3, r6, r3, r0
 80050ba:	0b52      	lsrs	r2, r2, #13
 80050bc:	4850      	ldr	r0, [pc, #320]	; (8005200 <moduleTRACKING+0x18c0>)
 80050be:	f005 fae7 	bl	800a690 <chprintf.constprop.26>
 80050c2:	4a50      	ldr	r2, [pc, #320]	; (8005204 <moduleTRACKING+0x18c4>)
 80050c4:	4950      	ldr	r1, [pc, #320]	; (8005208 <moduleTRACKING+0x18c8>)
 80050c6:	484e      	ldr	r0, [pc, #312]	; (8005200 <moduleTRACKING+0x18c0>)
 80050c8:	f005 fae2 	bl	800a690 <chprintf.constprop.26>
 80050cc:	f44f 73ac 	mov.w	r3, #344	; 0x158
 80050d0:	4a4e      	ldr	r2, [pc, #312]	; (800520c <moduleTRACKING+0x18cc>)
 80050d2:	494f      	ldr	r1, [pc, #316]	; (8005210 <moduleTRACKING+0x18d0>)
 80050d4:	484a      	ldr	r0, [pc, #296]	; (8005200 <moduleTRACKING+0x18c0>)
 80050d6:	f005 fadb 	bl	800a690 <chprintf.constprop.26>
 80050da:	494e      	ldr	r1, [pc, #312]	; (8005214 <moduleTRACKING+0x18d4>)
 80050dc:	4848      	ldr	r0, [pc, #288]	; (8005200 <moduleTRACKING+0x18c0>)
 80050de:	f005 fad7 	bl	800a690 <chprintf.constprop.26>
 80050e2:	4953      	ldr	r1, [pc, #332]	; (8005230 <moduleTRACKING+0x18f0>)
 80050e4:	4846      	ldr	r0, [pc, #280]	; (8005200 <moduleTRACKING+0x18c0>)
 80050e6:	f005 fad3 	bl	800a690 <chprintf.constprop.26>
 80050ea:	494c      	ldr	r1, [pc, #304]	; (800521c <moduleTRACKING+0x18dc>)
 80050ec:	4844      	ldr	r0, [pc, #272]	; (8005200 <moduleTRACKING+0x18c0>)
 80050ee:	f005 facf 	bl	800a690 <chprintf.constprop.26>
 80050f2:	483f      	ldr	r0, [pc, #252]	; (80051f0 <moduleTRACKING+0x18b0>)
 80050f4:	f004 fa44 	bl	8009580 <chMtxUnlock>
 80050f8:	f44f 71ac 	mov.w	r1, #344	; 0x158
 80050fc:	4843      	ldr	r0, [pc, #268]	; (800520c <moduleTRACKING+0x18cc>)
 80050fe:	f007 fc3f 	bl	800c980 <log_error>
 8005102:	f7fe bf87 	b.w	8004014 <moduleTRACKING+0x6d4>
	} else {
		TRACE_ERROR("GPS  > Configure power save FAILED");
		status = 0;
	}
	if(gps_power_save(0)) {
		TRACE_INFO("GPS  > Disable power save OK");
 8005106:	483a      	ldr	r0, [pc, #232]	; (80051f0 <moduleTRACKING+0x18b0>)
 8005108:	4c3a      	ldr	r4, [pc, #232]	; (80051f4 <moduleTRACKING+0x18b4>)
 800510a:	f007 f849 	bl	800c1a0 <chMtxLock>
 800510e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005112:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005116:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005118:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800511a:	4b37      	ldr	r3, [pc, #220]	; (80051f8 <moduleTRACKING+0x18b8>)
 800511c:	fb00 f101 	mul.w	r1, r0, r1
 8005120:	fba4 5101 	umull	r5, r1, r4, r1
 8005124:	0b49      	lsrs	r1, r1, #13
 8005126:	fba3 5301 	umull	r5, r3, r3, r1
 800512a:	fba4 4202 	umull	r4, r2, r4, r2
 800512e:	099b      	lsrs	r3, r3, #6
 8005130:	fb00 1313 	mls	r3, r0, r3, r1
 8005134:	0b52      	lsrs	r2, r2, #13
 8005136:	4931      	ldr	r1, [pc, #196]	; (80051fc <moduleTRACKING+0x18bc>)
 8005138:	4831      	ldr	r0, [pc, #196]	; (8005200 <moduleTRACKING+0x18c0>)
 800513a:	f005 faa9 	bl	800a690 <chprintf.constprop.26>
 800513e:	4a3d      	ldr	r2, [pc, #244]	; (8005234 <moduleTRACKING+0x18f4>)
 8005140:	4931      	ldr	r1, [pc, #196]	; (8005208 <moduleTRACKING+0x18c8>)
 8005142:	482f      	ldr	r0, [pc, #188]	; (8005200 <moduleTRACKING+0x18c0>)
 8005144:	f005 faa4 	bl	800a690 <chprintf.constprop.26>
 8005148:	f240 1369 	movw	r3, #361	; 0x169
 800514c:	4a2f      	ldr	r2, [pc, #188]	; (800520c <moduleTRACKING+0x18cc>)
 800514e:	4930      	ldr	r1, [pc, #192]	; (8005210 <moduleTRACKING+0x18d0>)
 8005150:	482b      	ldr	r0, [pc, #172]	; (8005200 <moduleTRACKING+0x18c0>)
 8005152:	f005 fa9d 	bl	800a690 <chprintf.constprop.26>
 8005156:	492f      	ldr	r1, [pc, #188]	; (8005214 <moduleTRACKING+0x18d4>)
 8005158:	4829      	ldr	r0, [pc, #164]	; (8005200 <moduleTRACKING+0x18c0>)
 800515a:	f005 fa99 	bl	800a690 <chprintf.constprop.26>
 800515e:	4936      	ldr	r1, [pc, #216]	; (8005238 <moduleTRACKING+0x18f8>)
 8005160:	4827      	ldr	r0, [pc, #156]	; (8005200 <moduleTRACKING+0x18c0>)
 8005162:	f005 fa95 	bl	800a690 <chprintf.constprop.26>
 8005166:	492d      	ldr	r1, [pc, #180]	; (800521c <moduleTRACKING+0x18dc>)
 8005168:	4825      	ldr	r0, [pc, #148]	; (8005200 <moduleTRACKING+0x18c0>)
 800516a:	f005 fa91 	bl	800a690 <chprintf.constprop.26>
 800516e:	4820      	ldr	r0, [pc, #128]	; (80051f0 <moduleTRACKING+0x18b0>)
 8005170:	f004 fa06 	bl	8009580 <chMtxUnlock>
 8005174:	f7ff b84f 	b.w	8004216 <moduleTRACKING+0x8d6>
					TRACE_TAB, tp->adc_vbat/1000, (tp->adc_vbat%1000), tp->adc_vsol/1000, (tp->adc_vsol%1000), tp->adc_vusb/1000, (tp->adc_vusb%1000), tp->adc_pbat, tp->adc_psol,
					TRACE_TAB, tp->air_press/10, tp->air_press%10, tp->air_temp/100, tp->air_temp%100, tp->air_hum/10, tp->air_hum%10
		);

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
 8005178:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800517a:	2b04      	cmp	r3, #4
 800517c:	f67f ab0f 	bls.w	800479e <moduleTRACKING+0xe5e>
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
 8005180:	7a22      	ldrb	r2, [r4, #8]
 8005182:	7a61      	ldrb	r1, [r4, #9]
	timeC += (time.day-1) * 86400;
 8005184:	78ee      	ldrb	r6, [r5, #3]
  * @param time Date to be converted
  * @return UNIX timestamp in milliseconds
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
 8005186:	79af      	ldrb	r7, [r5, #6]
 8005188:	88a4      	ldrh	r4, [r4, #4]
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
 800518a:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 800518e:	fb03 f202 	mul.w	r2, r3, r2
  * @return UNIX timestamp in milliseconds
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
	timeC += time.minute * 60;
 8005192:	203c      	movs	r0, #60	; 0x3c
	timeC += time.hour * 3600;
 8005194:	17d3      	asrs	r3, r2, #31
 8005196:	fbc0 2381 	smlalbb	r2, r3, r0, r1
	timeC += (time.day-1) * 86400;
 800519a:	4828      	ldr	r0, [pc, #160]	; (800523c <moduleTRACKING+0x18fc>)
 800519c:	78a9      	ldrb	r1, [r5, #2]
 800519e:	892d      	ldrh	r5, [r5, #8]
 80051a0:	3e01      	subs	r6, #1
 80051a2:	fb00 f606 	mul.w	r6, r0, r6
  * @param time Date to be converted
  * @return UNIX timestamp in milliseconds
  */
uint64_t date2UnixTimestamp(ptime_t time) {
	uint64_t timeC = 0;
	timeC  = time.second;
 80051a6:	f04f 0800 	mov.w	r8, #0
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
 80051aa:	18ba      	adds	r2, r7, r2
 80051ac:	eb48 0303 	adc.w	r3, r8, r3
	timeC += (time.day-1) * 86400;
 80051b0:	1997      	adds	r7, r2, r6
 80051b2:	eb43 78e6 	adc.w	r8, r3, r6, asr #31

	if(time.year % 4 == 0) { // is leapyear?
 80051b6:	07a6      	lsls	r6, r4, #30
		timeC += leapYear[time.month-1] * 86400;
 80051b8:	f101 31ff 	add.w	r1, r1, #4294967295
	timeC  = time.second;
	timeC += time.minute * 60;
	timeC += time.hour * 3600;
	timeC += (time.day-1) * 86400;

	if(time.year % 4 == 0) { // is leapyear?
 80051bc:	f040 82b0 	bne.w	8005720 <moduleTRACKING+0x1de0>
		timeC += leapYear[time.month-1] * 86400;
 80051c0:	4b1f      	ldr	r3, [pc, #124]	; (8005240 <moduleTRACKING+0x1900>)
 80051c2:	f833 1011 	ldrh.w	r1, [r3, r1, lsl #1]
 80051c6:	fb00 f001 	mul.w	r0, r0, r1
 80051ca:	183a      	adds	r2, r7, r0
 80051cc:	eb48 73e0 	adc.w	r3, r8, r0, asr #31
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 80051d0:	f240 7eb2 	movw	lr, #1970	; 0x7b2
 80051d4:	4574      	cmp	r4, lr
 80051d6:	d94a      	bls.n	800526e <moduleTRACKING+0x192e>
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
		} else {
			timeC += 31536000;
 80051d8:	a103      	add	r1, pc, #12	; (adr r1, 80051e8 <moduleTRACKING+0x18a8>)
 80051da:	e9d1 0100 	ldrd	r0, r1, [r1]
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
 80051de:	4e19      	ldr	r6, [pc, #100]	; (8005244 <moduleTRACKING+0x1904>)
 80051e0:	2700      	movs	r7, #0
 80051e2:	e039      	b.n	8005258 <moduleTRACKING+0x1918>
 80051e4:	f3af 8000 	nop.w
 80051e8:	01e13380 	.word	0x01e13380
 80051ec:	00000000 	.word	0x00000000
 80051f0:	2001b720 	.word	0x2001b720
 80051f4:	d1b71759 	.word	0xd1b71759
 80051f8:	10624dd3 	.word	0x10624dd3
 80051fc:	0800ea50 	.word	0x0800ea50
 8005200:	2001ac28 	.word	0x2001ac28
 8005204:	0800ea5c 	.word	0x0800ea5c
 8005208:	0800ea64 	.word	0x0800ea64
 800520c:	0800f2d4 	.word	0x0800f2d4
 8005210:	0800ea7c 	.word	0x0800ea7c
 8005214:	0800f1e0 	.word	0x0800f1e0
 8005218:	0800f3dc 	.word	0x0800f3dc
 800521c:	0800eaa8 	.word	0x0800eaa8
 8005220:	0800f15c 	.word	0x0800f15c
 8005224:	0800f27c 	.word	0x0800f27c
 8005228:	20000810 	.word	0x20000810
 800522c:	0800f398 	.word	0x0800f398
 8005230:	0800f354 	.word	0x0800f354
 8005234:	0800f1dc 	.word	0x0800f1dc
 8005238:	0800f400 	.word	0x0800f400
 800523c:	00015180 	.word	0x00015180
 8005240:	0800f138 	.word	0x0800f138
 8005244:	01e28500 	.word	0x01e28500
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 8005248:	f10e 0e01 	add.w	lr, lr, #1
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
 800524c:	1992      	adds	r2, r2, r6
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 800524e:	fa1f fe8e 	uxth.w	lr, lr
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
 8005252:	417b      	adcs	r3, r7
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 8005254:	45a6      	cmp	lr, r4
 8005256:	d00a      	beq.n	800526e <moduleTRACKING+0x192e>
		if(i % 4 == 0) { // is leapyear?
 8005258:	f01e 0f03 	tst.w	lr, #3
 800525c:	d0f4      	beq.n	8005248 <moduleTRACKING+0x1908>
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 800525e:	f10e 0e01 	add.w	lr, lr, #1
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
		} else {
			timeC += 31536000;
 8005262:	1812      	adds	r2, r2, r0
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 8005264:	fa1f fe8e 	uxth.w	lr, lr
		if(i % 4 == 0) { // is leapyear?
			timeC += 31622400;
		} else {
			timeC += 31536000;
 8005268:	414b      	adcs	r3, r1
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
	}

	uint16_t i;
	for(i=1970; i<time.year; i++) {
 800526a:	45a6      	cmp	lr, r4
 800526c:	d1f4      	bne.n	8005258 <moduleTRACKING+0x1918>

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 800526e:	009c      	lsls	r4, r3, #2
 8005270:	ea44 7192 	orr.w	r1, r4, r2, lsr #30
 8005274:	0090      	lsls	r0, r2, #2
 8005276:	014c      	lsls	r4, r1, #5
 8005278:	ea44 64d0 	orr.w	r4, r4, r0, lsr #27
 800527c:	942f      	str	r4, [sp, #188]	; 0xbc
 800527e:	0144      	lsls	r4, r0, #5
 8005280:	942e      	str	r4, [sp, #184]	; 0xb8
 8005282:	e9dd 672e 	ldrd	r6, r7, [sp, #184]	; 0xb8
 8005286:	1a36      	subs	r6, r6, r0
 8005288:	4630      	mov	r0, r6
	ltp.gps_lat = tp->gps_lat;
 800528a:	9c2c      	ldr	r4, [sp, #176]	; 0xb0
 800528c:	9e2b      	ldr	r6, [sp, #172]	; 0xac
 800528e:	4b92      	ldr	r3, [pc, #584]	; (80054d8 <moduleTRACKING+0x1b98>)
 8005290:	4434      	add	r4, r6

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 8005292:	1886      	adds	r6, r0, r2
	ltp.gps_lat = tp->gps_lat;
 8005294:	eb03 1204 	add.w	r2, r3, r4, lsl #4

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 8005298:	00f4      	lsls	r4, r6, #3
	ltp.gps_lat = tp->gps_lat;
 800529a:	6913      	ldr	r3, [r2, #16]
 800529c:	933b      	str	r3, [sp, #236]	; 0xec

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 800529e:	4626      	mov	r6, r4
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;
 80052a0:	6994      	ldr	r4, [r2, #24]
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
 80052a2:	6952      	ldr	r2, [r2, #20]
 80052a4:	923c      	str	r2, [sp, #240]	; 0xf0
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 80052a6:	4a8d      	ldr	r2, [pc, #564]	; (80054dc <moduleTRACKING+0x1b9c>)

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 80052a8:	1970      	adds	r0, r6, r5
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;
 80052aa:	2c00      	cmp	r4, #0
 80052ac:	bfa8      	it	ge
 80052ae:	b2a3      	uxthge	r3, r4

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 80052b0:	6814      	ldr	r4, [r2, #0]

static void writeLogTrackPoint(trackPoint_t* tp)
{
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
 80052b2:	903a      	str	r0, [sp, #232]	; 0xe8
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 80052b4:	f504 0400 	add.w	r4, r4, #8388608	; 0x800000
 80052b8:	f504 4440 	add.w	r4, r4, #49152	; 0xc000
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;
 80052bc:	bfb8      	it	lt
 80052be:	2300      	movlt	r3, #0

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
 80052c0:	0124      	lsls	r4, r4, #4
	// Create Log track point
	logTrackPoint_t ltp;
	ltp.time = date2UnixTimestamp(tp->time);
	ltp.gps_lat = tp->gps_lat;
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;
 80052c2:	933d      	str	r3, [sp, #244]	; 0xf4

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
	if(address % LOG_FLASH_PAGE_SIZE == 0) // Found start of flash sector
 80052c4:	f3c4 0310 	ubfx	r3, r4, #0, #17
 80052c8:	2b00      	cmp	r3, #0
 80052ca:	f000 8101 	beq.w	80054d0 <moduleTRACKING+0x1b90>
			flashErase(address, LOG_FLASH_PAGE_SIZE);
		}
	}

	// Write data into flash
	TRACE_INFO("TRAC > Flash write (ADDR=%08x)", address);
 80052ce:	4884      	ldr	r0, [pc, #528]	; (80054e0 <moduleTRACKING+0x1ba0>)
 80052d0:	4d84      	ldr	r5, [pc, #528]	; (80054e4 <moduleTRACKING+0x1ba4>)
 80052d2:	f006 ff65 	bl	800c1a0 <chMtxLock>
 80052d6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80052da:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80052de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80052e0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80052e2:	4b81      	ldr	r3, [pc, #516]	; (80054e8 <moduleTRACKING+0x1ba8>)
 80052e4:	fb00 f101 	mul.w	r1, r0, r1
 80052e8:	fba5 6101 	umull	r6, r1, r5, r1
 80052ec:	0b49      	lsrs	r1, r1, #13
 80052ee:	fba3 6301 	umull	r6, r3, r3, r1
 80052f2:	fba5 5202 	umull	r5, r2, r5, r2
 80052f6:	099b      	lsrs	r3, r3, #6
 80052f8:	fb00 1313 	mls	r3, r0, r3, r1
 80052fc:	0b52      	lsrs	r2, r2, #13
 80052fe:	497b      	ldr	r1, [pc, #492]	; (80054ec <moduleTRACKING+0x1bac>)
 8005300:	487b      	ldr	r0, [pc, #492]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005302:	f005 f9c5 	bl	800a690 <chprintf.constprop.26>
 8005306:	4a7b      	ldr	r2, [pc, #492]	; (80054f4 <moduleTRACKING+0x1bb4>)
 8005308:	497b      	ldr	r1, [pc, #492]	; (80054f8 <moduleTRACKING+0x1bb8>)
 800530a:	4879      	ldr	r0, [pc, #484]	; (80054f0 <moduleTRACKING+0x1bb0>)
 800530c:	f005 f9c0 	bl	800a690 <chprintf.constprop.26>
 8005310:	2336      	movs	r3, #54	; 0x36
 8005312:	4a7a      	ldr	r2, [pc, #488]	; (80054fc <moduleTRACKING+0x1bbc>)
 8005314:	497a      	ldr	r1, [pc, #488]	; (8005500 <moduleTRACKING+0x1bc0>)
 8005316:	4876      	ldr	r0, [pc, #472]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005318:	f005 f9ba 	bl	800a690 <chprintf.constprop.26>
 800531c:	4979      	ldr	r1, [pc, #484]	; (8005504 <moduleTRACKING+0x1bc4>)
 800531e:	4874      	ldr	r0, [pc, #464]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005320:	f005 f9b6 	bl	800a690 <chprintf.constprop.26>
 8005324:	4622      	mov	r2, r4
 8005326:	4978      	ldr	r1, [pc, #480]	; (8005508 <moduleTRACKING+0x1bc8>)
 8005328:	4871      	ldr	r0, [pc, #452]	; (80054f0 <moduleTRACKING+0x1bb0>)
 800532a:	f005 f9b1 	bl	800a690 <chprintf.constprop.26>
 800532e:	4977      	ldr	r1, [pc, #476]	; (800550c <moduleTRACKING+0x1bcc>)
 8005330:	486f      	ldr	r0, [pc, #444]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005332:	f005 f9ad 	bl	800a690 <chprintf.constprop.26>
 8005336:	486a      	ldr	r0, [pc, #424]	; (80054e0 <moduleTRACKING+0x1ba0>)
 8005338:	f004 f922 	bl	8009580 <chMtxUnlock>
	flashSectorBegin(flashSectorAt(address));
 800533c:	4620      	mov	r0, r4
 800533e:	f002 fc1f 	bl	8007b80 <flashSectorAt>
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8005342:	b118      	cbz	r0, 800534c <moduleTRACKING+0x1a0c>
    {
        --sector;
 8005344:	3801      	subs	r0, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8005346:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 800534a:	d1fb      	bne.n	8005344 <moduleTRACKING+0x1a04>
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 800534c:	4b70      	ldr	r3, [pc, #448]	; (8005510 <moduleTRACKING+0x1bd0>)
 800534e:	691a      	ldr	r2, [r3, #16]
 8005350:	2a00      	cmp	r2, #0
 8005352:	db6e      	blt.n	8005432 <moduleTRACKING+0x1af2>
    /* Unlock flash for write access */
    if(flashUnlock() == FALSE)
        return FLASH_RETURN_NO_PERMISSION;

    /* Wait for any busy flags */
    flashWaitWhileBusy();
 8005354:	4a6e      	ldr	r2, [pc, #440]	; (8005510 <moduleTRACKING+0x1bd0>)
 8005356:	68d1      	ldr	r1, [r2, #12]
 8005358:	4b6d      	ldr	r3, [pc, #436]	; (8005510 <moduleTRACKING+0x1bd0>)
 800535a:	03c9      	lsls	r1, r1, #15
 800535c:	d4fb      	bmi.n	8005356 <moduleTRACKING+0x1a16>

    /* Setup parallelism before any program/erase */
    FLASH->CR &= ~FLASH_CR_PSIZE_MASK;
 800535e:	691a      	ldr	r2, [r3, #16]
 8005360:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8005364:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_PSIZE_VALUE;
 8005366:	691a      	ldr	r2, [r3, #16]
 8005368:	611a      	str	r2, [r3, #16]

    /* Write the data */
    *(flashdata_t*)address = data;

    /* Wait for completion */
    flashWaitWhileBusy();
 800536a:	461e      	mov	r6, r3
 800536c:	f10d 00e7 	add.w	r0, sp, #231	; 0xe7
 8005370:	1e65      	subs	r5, r4, #1
}

static void flashWriteData(flashaddr_t address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8005372:	691a      	ldr	r2, [r3, #16]
    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
    {
        flashWriteData(address, *(const flashdata_t*)buffer);
 8005374:	f810 1f01 	ldrb.w	r1, [r0, #1]!
}

static void flashWriteData(flashaddr_t address, const flashdata_t data)
{
    /* Enter flash programming mode */
    FLASH->CR |= FLASH_CR_PG;
 8005378:	f042 0201 	orr.w	r2, r2, #1
 800537c:	611a      	str	r2, [r3, #16]

    /* Write the data */
    *(flashdata_t*)address = data;
 800537e:	f805 1f01 	strb.w	r1, [r5, #1]!

    /* Wait for completion */
    flashWaitWhileBusy();
 8005382:	68da      	ldr	r2, [r3, #12]
 8005384:	4962      	ldr	r1, [pc, #392]	; (8005510 <moduleTRACKING+0x1bd0>)
 8005386:	03d2      	lsls	r2, r2, #15
 8005388:	d4fb      	bmi.n	8005382 <moduleTRACKING+0x1a42>

    /* Exit flash programming mode */
    FLASH->CR &= ~FLASH_CR_PG;
 800538a:	6932      	ldr	r2, [r6, #16]
 800538c:	f022 0201 	bic.w	r2, r2, #1
 8005390:	6132      	str	r2, [r6, #16]
    }

    /* Now, address is correctly aligned. One can copy data directly from
     * buffer's data to flash memory until the size of the data remaining to be
     * copied requires special treatment. */
    while (size >= sizeof(flashdata_t))
 8005392:	f10d 02f7 	add.w	r2, sp, #247	; 0xf7
 8005396:	4282      	cmp	r2, r0
 8005398:	d1eb      	bne.n	8005372 <moduleTRACKING+0x1a32>
        memcpy(&tmp, buffer, size);
        flashWriteData(address, tmp);
    }

    /* Lock flash again */
    flashLock();
 800539a:	690b      	ldr	r3, [r1, #16]
 800539c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80053a0:	610b      	str	r3, [r1, #16]
 80053a2:	ab3a      	add	r3, sp, #232	; 0xe8
 80053a4:	f104 0210 	add.w	r2, r4, #16
 80053a8:	e001      	b.n	80053ae <moduleTRACKING+0x1a6e>

bool flashCompare(flashaddr_t address, const char* buffer, size_t size)
{
    /* For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 80053aa:	4294      	cmp	r4, r2
 80053ac:	d049      	beq.n	8005442 <moduleTRACKING+0x1b02>
    {
        if (*(volatile flashdata_t*)address != *(flashdata_t*)buffer)
 80053ae:	7820      	ldrb	r0, [r4, #0]
 80053b0:	f813 1b01 	ldrb.w	r1, [r3], #1
 80053b4:	4288      	cmp	r0, r1
            return FALSE;
        address += sizeof(flashdata_t);
 80053b6:	f104 0401 	add.w	r4, r4, #1
{
    /* For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
    {
        if (*(volatile flashdata_t*)address != *(flashdata_t*)buffer)
 80053ba:	d0f6      	beq.n	80053aa <moduleTRACKING+0x1a6a>

	// Verify
	if(flashCompare(address, (char*)&ltp, sizeof(logTrackPoint_t)))
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");
 80053bc:	4848      	ldr	r0, [pc, #288]	; (80054e0 <moduleTRACKING+0x1ba0>)
 80053be:	4c49      	ldr	r4, [pc, #292]	; (80054e4 <moduleTRACKING+0x1ba4>)
 80053c0:	f006 feee 	bl	800c1a0 <chMtxLock>
 80053c4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80053c8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80053cc:	6a50      	ldr	r0, [r2, #36]	; 0x24
 80053ce:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80053d0:	4945      	ldr	r1, [pc, #276]	; (80054e8 <moduleTRACKING+0x1ba8>)
 80053d2:	fb03 f202 	mul.w	r2, r3, r2
 80053d6:	fba4 5202 	umull	r5, r2, r4, r2
 80053da:	0b55      	lsrs	r5, r2, #13
 80053dc:	fba1 2105 	umull	r2, r1, r1, r5
 80053e0:	0989      	lsrs	r1, r1, #6
 80053e2:	fba4 0200 	umull	r0, r2, r4, r0
 80053e6:	fb03 5311 	mls	r3, r3, r1, r5
 80053ea:	0b52      	lsrs	r2, r2, #13
 80053ec:	493f      	ldr	r1, [pc, #252]	; (80054ec <moduleTRACKING+0x1bac>)
 80053ee:	4840      	ldr	r0, [pc, #256]	; (80054f0 <moduleTRACKING+0x1bb0>)
 80053f0:	f005 f94e 	bl	800a690 <chprintf.constprop.26>
 80053f4:	4a47      	ldr	r2, [pc, #284]	; (8005514 <moduleTRACKING+0x1bd4>)
 80053f6:	4940      	ldr	r1, [pc, #256]	; (80054f8 <moduleTRACKING+0x1bb8>)
 80053f8:	483d      	ldr	r0, [pc, #244]	; (80054f0 <moduleTRACKING+0x1bb0>)
 80053fa:	f005 f949 	bl	800a690 <chprintf.constprop.26>
 80053fe:	233f      	movs	r3, #63	; 0x3f
 8005400:	4a3e      	ldr	r2, [pc, #248]	; (80054fc <moduleTRACKING+0x1bbc>)
 8005402:	493f      	ldr	r1, [pc, #252]	; (8005500 <moduleTRACKING+0x1bc0>)
 8005404:	483a      	ldr	r0, [pc, #232]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005406:	f005 f943 	bl	800a690 <chprintf.constprop.26>
 800540a:	493e      	ldr	r1, [pc, #248]	; (8005504 <moduleTRACKING+0x1bc4>)
 800540c:	4838      	ldr	r0, [pc, #224]	; (80054f0 <moduleTRACKING+0x1bb0>)
 800540e:	f005 f93f 	bl	800a690 <chprintf.constprop.26>
 8005412:	4941      	ldr	r1, [pc, #260]	; (8005518 <moduleTRACKING+0x1bd8>)
 8005414:	4836      	ldr	r0, [pc, #216]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005416:	f005 f93b 	bl	800a690 <chprintf.constprop.26>
 800541a:	493c      	ldr	r1, [pc, #240]	; (800550c <moduleTRACKING+0x1bcc>)
 800541c:	4834      	ldr	r0, [pc, #208]	; (80054f0 <moduleTRACKING+0x1bb0>)
 800541e:	f005 f937 	bl	800a690 <chprintf.constprop.26>
 8005422:	482f      	ldr	r0, [pc, #188]	; (80054e0 <moduleTRACKING+0x1ba0>)
 8005424:	f004 f8ac 	bl	8009580 <chMtxUnlock>
 8005428:	213f      	movs	r1, #63	; 0x3f
 800542a:	4834      	ldr	r0, [pc, #208]	; (80054fc <moduleTRACKING+0x1bbc>)
 800542c:	f007 faa8 	bl	800c980 <log_error>
 8005430:	e03d      	b.n	80054ae <moduleTRACKING+0x1b6e>
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
        return TRUE;

    /* Write magic unlock sequence */
    FLASH->KEYR = 0x45670123;
 8005432:	493a      	ldr	r1, [pc, #232]	; (800551c <moduleTRACKING+0x1bdc>)
    FLASH->KEYR = 0xCDEF89AB;
 8005434:	4a3a      	ldr	r2, [pc, #232]	; (8005520 <moduleTRACKING+0x1be0>)
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
        return TRUE;

    /* Write magic unlock sequence */
    FLASH->KEYR = 0x45670123;
 8005436:	6059      	str	r1, [r3, #4]
    FLASH->KEYR = 0xCDEF89AB;
 8005438:	605a      	str	r2, [r3, #4]

    /* Check if unlock was successful */
    if (FLASH->CR & FLASH_CR_LOCK)
 800543a:	691b      	ldr	r3, [r3, #16]
 800543c:	2b00      	cmp	r3, #0
 800543e:	da89      	bge.n	8005354 <moduleTRACKING+0x1a14>
 8005440:	e7af      	b.n	80053a2 <moduleTRACKING+0x1a62>
	flashWrite(address, (char*)&ltp, sizeof(logTrackPoint_t));
	flashSectorEnd(flashSectorAt(address));

	// Verify
	if(flashCompare(address, (char*)&ltp, sizeof(logTrackPoint_t)))
		TRACE_INFO("TRAC > Flash write OK")
 8005442:	4827      	ldr	r0, [pc, #156]	; (80054e0 <moduleTRACKING+0x1ba0>)
 8005444:	4c27      	ldr	r4, [pc, #156]	; (80054e4 <moduleTRACKING+0x1ba4>)
 8005446:	f006 feab 	bl	800c1a0 <chMtxLock>
 800544a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800544e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8005452:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8005454:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8005456:	4924      	ldr	r1, [pc, #144]	; (80054e8 <moduleTRACKING+0x1ba8>)
 8005458:	fb03 f202 	mul.w	r2, r3, r2
 800545c:	fba4 5202 	umull	r5, r2, r4, r2
 8005460:	0b55      	lsrs	r5, r2, #13
 8005462:	fba1 2105 	umull	r2, r1, r1, r5
 8005466:	0989      	lsrs	r1, r1, #6
 8005468:	fba4 0200 	umull	r0, r2, r4, r0
 800546c:	fb03 5311 	mls	r3, r3, r1, r5
 8005470:	0b52      	lsrs	r2, r2, #13
 8005472:	491e      	ldr	r1, [pc, #120]	; (80054ec <moduleTRACKING+0x1bac>)
 8005474:	481e      	ldr	r0, [pc, #120]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005476:	f005 f90b 	bl	800a690 <chprintf.constprop.26>
 800547a:	4a1e      	ldr	r2, [pc, #120]	; (80054f4 <moduleTRACKING+0x1bb4>)
 800547c:	491e      	ldr	r1, [pc, #120]	; (80054f8 <moduleTRACKING+0x1bb8>)
 800547e:	481c      	ldr	r0, [pc, #112]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005480:	f005 f906 	bl	800a690 <chprintf.constprop.26>
 8005484:	233d      	movs	r3, #61	; 0x3d
 8005486:	4a1d      	ldr	r2, [pc, #116]	; (80054fc <moduleTRACKING+0x1bbc>)
 8005488:	491d      	ldr	r1, [pc, #116]	; (8005500 <moduleTRACKING+0x1bc0>)
 800548a:	4819      	ldr	r0, [pc, #100]	; (80054f0 <moduleTRACKING+0x1bb0>)
 800548c:	f005 f900 	bl	800a690 <chprintf.constprop.26>
 8005490:	491c      	ldr	r1, [pc, #112]	; (8005504 <moduleTRACKING+0x1bc4>)
 8005492:	4817      	ldr	r0, [pc, #92]	; (80054f0 <moduleTRACKING+0x1bb0>)
 8005494:	f005 f8fc 	bl	800a690 <chprintf.constprop.26>
 8005498:	4922      	ldr	r1, [pc, #136]	; (8005524 <moduleTRACKING+0x1be4>)
 800549a:	4815      	ldr	r0, [pc, #84]	; (80054f0 <moduleTRACKING+0x1bb0>)
 800549c:	f005 f8f8 	bl	800a690 <chprintf.constprop.26>
 80054a0:	491a      	ldr	r1, [pc, #104]	; (800550c <moduleTRACKING+0x1bcc>)
 80054a2:	4813      	ldr	r0, [pc, #76]	; (80054f0 <moduleTRACKING+0x1bb0>)
 80054a4:	f005 f8f4 	bl	800a690 <chprintf.constprop.26>
 80054a8:	480d      	ldr	r0, [pc, #52]	; (80054e0 <moduleTRACKING+0x1ba0>)
 80054aa:	f004 f869 	bl	8009580 <chMtxUnlock>
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80054ae:	4b0b      	ldr	r3, [pc, #44]	; (80054dc <moduleTRACKING+0x1b9c>)
 80054b0:	490a      	ldr	r1, [pc, #40]	; (80054dc <moduleTRACKING+0x1b9c>)
 80054b2:	681a      	ldr	r2, [r3, #0]

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80054b4:	4b1c      	ldr	r3, [pc, #112]	; (8005528 <moduleTRACKING+0x1be8>)
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80054b6:	3201      	adds	r2, #1

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80054b8:	681b      	ldr	r3, [r3, #0]
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80054ba:	f3c2 020d 	ubfx	r2, r2, #0, #14

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80054be:	f503 13f4 	add.w	r3, r3, #1998848	; 0x1e8000
		TRACE_INFO("TRAC > Flash write OK")
	else
		TRACE_ERROR("TRAC > Flash write failed");

	// Increment log counter
	logEntryCounter = (logEntryCounter+1) % (LOG_FLASH_SIZE/sizeof(logTrackPoint_t));
 80054c2:	600a      	str	r2, [r1, #0]

		// Append logging (timeout)
		if(nextLogEntryTimer <= chVTGetSystemTimeX() && isGPSLocked(&gpsFix))
		{
			writeLogTrackPoint(tp);
			nextLogEntryTimer += S2ST(LOG_CYCLE_TIME);
 80054c4:	4a18      	ldr	r2, [pc, #96]	; (8005528 <moduleTRACKING+0x1be8>)
 80054c6:	f503 6390 	add.w	r3, r3, #1152	; 0x480
 80054ca:	6013      	str	r3, [r2, #0]
 80054cc:	f7ff b967 	b.w	800479e <moduleTRACKING+0xe5e>
 80054d0:	f504 3200 	add.w	r2, r4, #131072	; 0x20000
	ltp.gps_lon = tp->gps_lon;
	ltp.gps_alt = tp->gps_alt < 0 ? 0 : (uint16_t)tp->gps_alt & 0xFFFF;

	// Erase flash if start of new sector is reached
	uint32_t address = LOG_FLASH_ADDR + logEntryCounter * sizeof(logTrackPoint_t);
	if(address % LOG_FLASH_PAGE_SIZE == 0) // Found start of flash sector
 80054d4:	4623      	mov	r3, r4
 80054d6:	e02c      	b.n	8005532 <moduleTRACKING+0x1bf2>
 80054d8:	20000810 	.word	0x20000810
 80054dc:	2000080c 	.word	0x2000080c
 80054e0:	2001b720 	.word	0x2001b720
 80054e4:	d1b71759 	.word	0xd1b71759
 80054e8:	10624dd3 	.word	0x10624dd3
 80054ec:	0800ea50 	.word	0x0800ea50
 80054f0:	2001ac28 	.word	0x2001ac28
 80054f4:	0800f1dc 	.word	0x0800f1dc
 80054f8:	0800ea64 	.word	0x0800ea64
 80054fc:	0800f15c 	.word	0x0800f15c
 8005500:	0800ea7c 	.word	0x0800ea7c
 8005504:	0800f1e0 	.word	0x0800f1e0
 8005508:	0800f748 	.word	0x0800f748
 800550c:	0800eaa8 	.word	0x0800eaa8
 8005510:	40023c00 	.word	0x40023c00
 8005514:	0800ea5c 	.word	0x0800ea5c
 8005518:	0800f72c 	.word	0x0800f72c
 800551c:	45670123 	.word	0x45670123
 8005520:	cdef89ab 	.word	0xcdef89ab
 8005524:	0800f714 	.word	0x0800f714
 8005528:	20000870 	.word	0x20000870
bool flashIsErased(flashaddr_t address, size_t size)
{
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 800552c:	429a      	cmp	r2, r3
 800552e:	f43f aece 	beq.w	80052ce <moduleTRACKING+0x198e>
    {
        if (*(volatile flashdata_t*)address != (flashdata_t)(-1)) // flashdata_t being unsigned, -1 is 0xFF..FF
 8005532:	7819      	ldrb	r1, [r3, #0]
 8005534:	29ff      	cmp	r1, #255	; 0xff
            return FALSE;
        address += sizeof(flashdata_t);
 8005536:	f103 0301 	add.w	r3, r3, #1
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
    {
        if (*(volatile flashdata_t*)address != (flashdata_t)(-1)) // flashdata_t being unsigned, -1 is 0xFF..FF
 800553a:	d0f7      	beq.n	800552c <moduleTRACKING+0x1bec>
	{
		if(!flashIsErased(address, LOG_FLASH_PAGE_SIZE))
		{
			TRACE_INFO("TRAC > Erase flash %08x", address);
 800553c:	48b8      	ldr	r0, [pc, #736]	; (8005820 <moduleTRACKING+0x1ee0>)
 800553e:	4eb9      	ldr	r6, [pc, #740]	; (8005824 <moduleTRACKING+0x1ee4>)
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 8005540:	4db9      	ldr	r5, [pc, #740]	; (8005828 <moduleTRACKING+0x1ee8>)
        return TRUE;

    /* Write magic unlock sequence */
    FLASH->KEYR = 0x45670123;
 8005542:	f8df 8328 	ldr.w	r8, [pc, #808]	; 800586c <moduleTRACKING+0x1f2c>
 8005546:	f006 fe2b 	bl	800c1a0 <chMtxLock>
 800554a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800554e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005552:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8005554:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8005556:	fb00 f101 	mul.w	r1, r0, r1
 800555a:	fba6 3101 	umull	r3, r1, r6, r1
 800555e:	4bb3      	ldr	r3, [pc, #716]	; (800582c <moduleTRACKING+0x1eec>)
 8005560:	0b49      	lsrs	r1, r1, #13
 8005562:	fba3 7301 	umull	r7, r3, r3, r1
 8005566:	fba6 6202 	umull	r6, r2, r6, r2
 800556a:	099b      	lsrs	r3, r3, #6
 800556c:	fb00 1313 	mls	r3, r0, r3, r1
 8005570:	0b52      	lsrs	r2, r2, #13
 8005572:	49af      	ldr	r1, [pc, #700]	; (8005830 <moduleTRACKING+0x1ef0>)
 8005574:	48af      	ldr	r0, [pc, #700]	; (8005834 <moduleTRACKING+0x1ef4>)
    FLASH->KEYR = 0xCDEF89AB;
 8005576:	4fb0      	ldr	r7, [pc, #704]	; (8005838 <moduleTRACKING+0x1ef8>)
 8005578:	f005 f88a 	bl	800a690 <chprintf.constprop.26>
 800557c:	4aaf      	ldr	r2, [pc, #700]	; (800583c <moduleTRACKING+0x1efc>)
 800557e:	49b0      	ldr	r1, [pc, #704]	; (8005840 <moduleTRACKING+0x1f00>)
 8005580:	48ac      	ldr	r0, [pc, #688]	; (8005834 <moduleTRACKING+0x1ef4>)
 8005582:	f005 f885 	bl	800a690 <chprintf.constprop.26>
 8005586:	2330      	movs	r3, #48	; 0x30
 8005588:	4aae      	ldr	r2, [pc, #696]	; (8005844 <moduleTRACKING+0x1f04>)
 800558a:	49af      	ldr	r1, [pc, #700]	; (8005848 <moduleTRACKING+0x1f08>)
 800558c:	48a9      	ldr	r0, [pc, #676]	; (8005834 <moduleTRACKING+0x1ef4>)
 800558e:	f005 f87f 	bl	800a690 <chprintf.constprop.26>
 8005592:	49ae      	ldr	r1, [pc, #696]	; (800584c <moduleTRACKING+0x1f0c>)
 8005594:	48a7      	ldr	r0, [pc, #668]	; (8005834 <moduleTRACKING+0x1ef4>)
 8005596:	f005 f87b 	bl	800a690 <chprintf.constprop.26>
 800559a:	4622      	mov	r2, r4
 800559c:	49ac      	ldr	r1, [pc, #688]	; (8005850 <moduleTRACKING+0x1f10>)
 800559e:	48a5      	ldr	r0, [pc, #660]	; (8005834 <moduleTRACKING+0x1ef4>)
 80055a0:	f005 f876 	bl	800a690 <chprintf.constprop.26>
 80055a4:	49ab      	ldr	r1, [pc, #684]	; (8005854 <moduleTRACKING+0x1f14>)
 80055a6:	48a3      	ldr	r0, [pc, #652]	; (8005834 <moduleTRACKING+0x1ef4>)
 80055a8:	f005 f872 	bl	800a690 <chprintf.constprop.26>
 80055ac:	46a3      	mov	fp, r4
 80055ae:	489c      	ldr	r0, [pc, #624]	; (8005820 <moduleTRACKING+0x1ee0>)
 80055b0:	f003 ffe6 	bl	8009580 <chMtxUnlock>

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 80055b4:	4658      	mov	r0, fp
 80055b6:	f002 fae3 	bl	8007b80 <flashSectorAt>
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 80055ba:	692b      	ldr	r3, [r5, #16]
 80055bc:	2b00      	cmp	r3, #0
 80055be:	f44f 3600 	mov.w	r6, #131072	; 0x20000

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 80055c2:	4682      	mov	sl, r0
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 80055c4:	f2c0 80a4 	blt.w	8005710 <moduleTRACKING+0x1dd0>
    /* Unlock flash for write access */
    if(flashUnlock() == FALSE)
        return FLASH_RETURN_NO_PERMISSION;

    /* Wait for any busy flags. */
    flashWaitWhileBusy();
 80055c8:	68ea      	ldr	r2, [r5, #12]
 80055ca:	4b97      	ldr	r3, [pc, #604]	; (8005828 <moduleTRACKING+0x1ee8>)
 80055cc:	03d2      	lsls	r2, r2, #15
 80055ce:	d4fb      	bmi.n	80055c8 <moduleTRACKING+0x1c88>

    /* Setup parallelism before any program/erase */
    FLASH->CR &= ~FLASH_CR_PSIZE_MASK;
 80055d0:	691a      	ldr	r2, [r3, #16]
 80055d2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80055d6:	611a      	str	r2, [r3, #16]
    FLASH->CR |= FLASH_CR_PSIZE_VALUE;
 80055d8:	691a      	ldr	r2, [r3, #16]
 80055da:	611a      	str	r2, [r3, #16]
     * 0000 sector 0
     * 0001 sector 1
     * ...
     * 1011 sector 11
     * others not allowed */
    FLASH->CR &= ~(FLASH_CR_SNB_0 | FLASH_CR_SNB_1 | FLASH_CR_SNB_2 | FLASH_CR_SNB_3);
 80055dc:	691a      	ldr	r2, [r3, #16]
    if (sector & 0x1) FLASH->CR |= FLASH_CR_SNB_0;
 80055de:	f01a 0f01 	tst.w	sl, #1
     * 0000 sector 0
     * 0001 sector 1
     * ...
     * 1011 sector 11
     * others not allowed */
    FLASH->CR &= ~(FLASH_CR_SNB_0 | FLASH_CR_SNB_1 | FLASH_CR_SNB_2 | FLASH_CR_SNB_3);
 80055e2:	f022 0278 	bic.w	r2, r2, #120	; 0x78
 80055e6:	611a      	str	r2, [r3, #16]
    if (sector & 0x1) FLASH->CR |= FLASH_CR_SNB_0;
 80055e8:	d003      	beq.n	80055f2 <moduleTRACKING+0x1cb2>
 80055ea:	691a      	ldr	r2, [r3, #16]
 80055ec:	f042 0208 	orr.w	r2, r2, #8
 80055f0:	611a      	str	r2, [r3, #16]
    if (sector & 0x2) FLASH->CR |= FLASH_CR_SNB_1;
 80055f2:	f01a 0f02 	tst.w	sl, #2
 80055f6:	d003      	beq.n	8005600 <moduleTRACKING+0x1cc0>
 80055f8:	692b      	ldr	r3, [r5, #16]
 80055fa:	f043 0310 	orr.w	r3, r3, #16
 80055fe:	612b      	str	r3, [r5, #16]
    if (sector & 0x4) FLASH->CR |= FLASH_CR_SNB_2;
 8005600:	f01a 0f04 	tst.w	sl, #4
 8005604:	d003      	beq.n	800560e <moduleTRACKING+0x1cce>
 8005606:	692b      	ldr	r3, [r5, #16]
 8005608:	f043 0320 	orr.w	r3, r3, #32
 800560c:	612b      	str	r3, [r5, #16]
    if (sector & 0x8) FLASH->CR |= FLASH_CR_SNB_3;
 800560e:	f01a 0f08 	tst.w	sl, #8
 8005612:	d003      	beq.n	800561c <moduleTRACKING+0x1cdc>
 8005614:	692b      	ldr	r3, [r5, #16]
 8005616:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800561a:	612b      	str	r3, [r5, #16]
    FLASH->CR |= FLASH_CR_SER;
 800561c:	692b      	ldr	r3, [r5, #16]
 800561e:	f043 0302 	orr.w	r3, r3, #2
 8005622:	612b      	str	r3, [r5, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8005624:	692b      	ldr	r3, [r5, #16]
 8005626:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800562a:	612b      	str	r3, [r5, #16]

    /* Wait until it's finished. */
    flashWaitWhileBusy();
 800562c:	68ea      	ldr	r2, [r5, #12]
 800562e:	4b7e      	ldr	r3, [pc, #504]	; (8005828 <moduleTRACKING+0x1ee8>)
 8005630:	03d0      	lsls	r0, r2, #15
 8005632:	d4fb      	bmi.n	800562c <moduleTRACKING+0x1cec>

    /* Sector erase flag does not clear automatically. */
    FLASH->CR &= ~FLASH_CR_SER;
 8005634:	691a      	ldr	r2, [r3, #16]
 8005636:	f022 0202 	bic.w	r2, r2, #2
 800563a:	611a      	str	r2, [r3, #16]

    /* Lock flash again */
    flashLock();
 800563c:	691a      	ldr	r2, [r3, #16]
 800563e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8005642:	611a      	str	r2, [r3, #16]
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8005644:	f1ba 0f00 	cmp.w	sl, #0
 8005648:	d079      	beq.n	800573e <moduleTRACKING+0x1dfe>
 800564a:	46d3      	mov	fp, sl
 800564c:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
    {
        --sector;
 8005650:	f10b 3bff 	add.w	fp, fp, #4294967295
 8005654:	fa5f fb8b 	uxtb.w	fp, fp
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8005658:	f1bb 0f03 	cmp.w	fp, #3
 800565c:	4658      	mov	r0, fp
 800565e:	d90a      	bls.n	8005676 <moduleTRACKING+0x1d36>
 8005660:	f008 fd1e 	bl	800e0a0 <flashSectorSize.part.1.lto_priv.135>
flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
 8005664:	f10b 3bff 	add.w	fp, fp, #4294967295
 8005668:	fa5f fb8b 	uxtb.w	fp, fp
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 800566c:	f1bb 0f03 	cmp.w	fp, #3
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 8005670:	4481      	add	r9, r0
 8005672:	4658      	mov	r0, fp
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8005674:	d8f4      	bhi.n	8005660 <moduleTRACKING+0x1d20>
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 8005676:	f509 4980 	add.w	r9, r9, #16384	; 0x4000
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 800567a:	f1bb 0f00 	cmp.w	fp, #0
 800567e:	d1e7      	bne.n	8005650 <moduleTRACKING+0x1d10>
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8005680:	f1ba 0f03 	cmp.w	sl, #3
 8005684:	d958      	bls.n	8005738 <moduleTRACKING+0x1df8>
 8005686:	4650      	mov	r0, sl
 8005688:	f008 fd0a 	bl	800e0a0 <flashSectorSize.part.1.lto_priv.135>
bool flashIsErased(flashaddr_t address, size_t size)
{
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 800568c:	b178      	cbz	r0, 80056ae <moduleTRACKING+0x1d6e>
    {
        if (*(volatile flashdata_t*)address != (flashdata_t)(-1)) // flashdata_t being unsigned, -1 is 0xFF..FF
 800568e:	f899 3000 	ldrb.w	r3, [r9]
 8005692:	2bff      	cmp	r3, #255	; 0xff
 8005694:	f47f ae1b 	bne.w	80052ce <moduleTRACKING+0x198e>
 8005698:	4448      	add	r0, r9
 800569a:	f109 0901 	add.w	r9, r9, #1
 800569e:	e004      	b.n	80056aa <moduleTRACKING+0x1d6a>
 80056a0:	f819 3b01 	ldrb.w	r3, [r9], #1
 80056a4:	2bff      	cmp	r3, #255	; 0xff
 80056a6:	f47f ae12 	bne.w	80052ce <moduleTRACKING+0x198e>
bool flashIsErased(flashaddr_t address, size_t size)
{
    /* Check for default set bits in the flash memory
     * For efficiency, compare flashdata_t values as much as possible,
     * then, fallback to byte per byte comparison. */
    while (size >= sizeof(flashdata_t))
 80056aa:	4548      	cmp	r0, r9
 80056ac:	d1f8      	bne.n	80056a0 <moduleTRACKING+0x1d60>
    return address;
}

flashaddr_t flashSectorEnd(flashsector_t sector)
{
    return flashSectorBegin(sector + 1);
 80056ae:	f10a 0901 	add.w	r9, sl, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 80056b2:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
 80056b6:	f04f 6b00 	mov.w	fp, #134217728	; 0x8000000
 80056ba:	d017      	beq.n	80056ec <moduleTRACKING+0x1dac>
    {
        --sector;
 80056bc:	f109 39ff 	add.w	r9, r9, #4294967295
 80056c0:	fa5f f989 	uxtb.w	r9, r9
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80056c4:	f1b9 0f03 	cmp.w	r9, #3
 80056c8:	4648      	mov	r0, r9
 80056ca:	d90a      	bls.n	80056e2 <moduleTRACKING+0x1da2>
 80056cc:	f008 fce8 	bl	800e0a0 <flashSectorSize.part.1.lto_priv.135>
flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
 80056d0:	f109 39ff 	add.w	r9, r9, #4294967295
 80056d4:	fa5f f989 	uxtb.w	r9, r9
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80056d8:	f1b9 0f03 	cmp.w	r9, #3
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 80056dc:	4483      	add	fp, r0
 80056de:	4648      	mov	r0, r9
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80056e0:	d8f4      	bhi.n	80056cc <moduleTRACKING+0x1d8c>
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 80056e2:	f50b 4b80 	add.w	fp, fp, #16384	; 0x4000
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 80056e6:	f1b9 0f00 	cmp.w	r9, #0
 80056ea:	d1e7      	bne.n	80056bc <moduleTRACKING+0x1d7c>
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 80056ec:	f1ba 0f03 	cmp.w	sl, #3
 80056f0:	d91f      	bls.n	8005732 <moduleTRACKING+0x1df2>
 80056f2:	4650      	mov	r0, sl
 80056f4:	f008 fcd4 	bl	800e0a0 <flashSectorSize.part.1.lto_priv.135>
        int err = flashSectorErase(sector);
        if (err != FLASH_RETURN_SUCCESS)
            return err;
        address = flashSectorEnd(sector);
        size_t sector_size = flashSectorSize(sector);
        if (sector_size >= size)
 80056f8:	4286      	cmp	r6, r0
 80056fa:	f67f ade8 	bls.w	80052ce <moduleTRACKING+0x198e>
            break;
        else
            size -= sector_size;
 80056fe:	1a36      	subs	r6, r6, r0

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 8005700:	4658      	mov	r0, fp
 8005702:	f002 fa3d 	bl	8007b80 <flashSectorAt>
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 8005706:	692b      	ldr	r3, [r5, #16]
 8005708:	2b00      	cmp	r3, #0

int flashErase(flashaddr_t address, size_t size)
{
    while (size > 0)
    {
        flashsector_t sector = flashSectorAt(address);
 800570a:	4682      	mov	sl, r0
 * @return FALSE    Unlock failed.
 */
static bool flashUnlock(void)
{
    /* Check if unlock is really needed */
    if (!(FLASH->CR & FLASH_CR_LOCK))
 800570c:	f6bf af5c 	bge.w	80055c8 <moduleTRACKING+0x1c88>
        return TRUE;

    /* Write magic unlock sequence */
    FLASH->KEYR = 0x45670123;
 8005710:	f8c5 8004 	str.w	r8, [r5, #4]
    FLASH->KEYR = 0xCDEF89AB;
 8005714:	606f      	str	r7, [r5, #4]

    /* Check if unlock was successful */
    if (FLASH->CR & FLASH_CR_LOCK)
 8005716:	692b      	ldr	r3, [r5, #16]
 8005718:	2b00      	cmp	r3, #0
 800571a:	f6bf af55 	bge.w	80055c8 <moduleTRACKING+0x1c88>
 800571e:	e5d6      	b.n	80052ce <moduleTRACKING+0x198e>
	timeC += (time.day-1) * 86400;

	if(time.year % 4 == 0) { // is leapyear?
		timeC += leapYear[time.month-1] * 86400;
	} else {
		timeC += nonLeapYear[time.month-1] * 86400;
 8005720:	4b4d      	ldr	r3, [pc, #308]	; (8005858 <moduleTRACKING+0x1f18>)
 8005722:	f833 1011 	ldrh.w	r1, [r3, r1, lsl #1]
 8005726:	fb00 f001 	mul.w	r0, r0, r1
 800572a:	183a      	adds	r2, r7, r0
 800572c:	eb48 73e0 	adc.w	r3, r8, r0, asr #31
 8005730:	e54e      	b.n	80051d0 <moduleTRACKING+0x1890>
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
 8005732:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8005736:	e7df      	b.n	80056f8 <moduleTRACKING+0x1db8>
 8005738:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800573c:	e7a7      	b.n	800568e <moduleTRACKING+0x1d4e>
    return 0;
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
 800573e:	f04f 6900 	mov.w	r9, #134217728	; 0x8000000
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
 8005742:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8005746:	e7a2      	b.n	800568e <moduleTRACKING+0x1d4e>
		BME280_Init(&bme280, BME280_ADDRESS_INT);
		lastTrackPoint->air_press = BME280_getPressure(&bme280, 256);
		lastTrackPoint->air_hum = BME280_getHumidity(&bme280);
		lastTrackPoint->air_temp = BME280_getTemperature(&bme280);
	} else { // No internal BME280 found
		TRACE_ERROR("TRAC > Internal BME280 not available");
 8005748:	4835      	ldr	r0, [pc, #212]	; (8005820 <moduleTRACKING+0x1ee0>)
 800574a:	4c36      	ldr	r4, [pc, #216]	; (8005824 <moduleTRACKING+0x1ee4>)
 800574c:	f006 fd28 	bl	800c1a0 <chMtxLock>
 8005750:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005754:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8005758:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800575a:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800575c:	4b33      	ldr	r3, [pc, #204]	; (800582c <moduleTRACKING+0x1eec>)
 800575e:	fb00 f101 	mul.w	r1, r0, r1
 8005762:	fba4 5101 	umull	r5, r1, r4, r1
 8005766:	0b49      	lsrs	r1, r1, #13
 8005768:	fba3 5301 	umull	r5, r3, r3, r1
 800576c:	fba4 4202 	umull	r4, r2, r4, r2
 8005770:	099b      	lsrs	r3, r3, #6
 8005772:	fb00 1313 	mls	r3, r0, r3, r1
 8005776:	0b52      	lsrs	r2, r2, #13
 8005778:	492d      	ldr	r1, [pc, #180]	; (8005830 <moduleTRACKING+0x1ef0>)
 800577a:	482e      	ldr	r0, [pc, #184]	; (8005834 <moduleTRACKING+0x1ef4>)
 800577c:	f004 ff88 	bl	800a690 <chprintf.constprop.26>
 8005780:	4a36      	ldr	r2, [pc, #216]	; (800585c <moduleTRACKING+0x1f1c>)
 8005782:	492f      	ldr	r1, [pc, #188]	; (8005840 <moduleTRACKING+0x1f00>)
 8005784:	482b      	ldr	r0, [pc, #172]	; (8005834 <moduleTRACKING+0x1ef4>)
 8005786:	f004 ff83 	bl	800a690 <chprintf.constprop.26>
 800578a:	2395      	movs	r3, #149	; 0x95
 800578c:	4a2d      	ldr	r2, [pc, #180]	; (8005844 <moduleTRACKING+0x1f04>)
 800578e:	492e      	ldr	r1, [pc, #184]	; (8005848 <moduleTRACKING+0x1f08>)
 8005790:	4828      	ldr	r0, [pc, #160]	; (8005834 <moduleTRACKING+0x1ef4>)
 8005792:	f004 ff7d 	bl	800a690 <chprintf.constprop.26>
 8005796:	492d      	ldr	r1, [pc, #180]	; (800584c <moduleTRACKING+0x1f0c>)
 8005798:	4826      	ldr	r0, [pc, #152]	; (8005834 <moduleTRACKING+0x1ef4>)
 800579a:	f004 ff79 	bl	800a690 <chprintf.constprop.26>
 800579e:	4930      	ldr	r1, [pc, #192]	; (8005860 <moduleTRACKING+0x1f20>)
 80057a0:	4824      	ldr	r0, [pc, #144]	; (8005834 <moduleTRACKING+0x1ef4>)
 80057a2:	f004 ff75 	bl	800a690 <chprintf.constprop.26>
 80057a6:	492b      	ldr	r1, [pc, #172]	; (8005854 <moduleTRACKING+0x1f14>)
 80057a8:	4822      	ldr	r0, [pc, #136]	; (8005834 <moduleTRACKING+0x1ef4>)
 80057aa:	f004 ff71 	bl	800a690 <chprintf.constprop.26>
 80057ae:	481c      	ldr	r0, [pc, #112]	; (8005820 <moduleTRACKING+0x1ee0>)
 80057b0:	f003 fee6 	bl	8009580 <chMtxUnlock>
 80057b4:	2195      	movs	r1, #149	; 0x95
 80057b6:	4823      	ldr	r0, [pc, #140]	; (8005844 <moduleTRACKING+0x1f04>)
 80057b8:	f007 f8e2 	bl	800c980 <log_error>
		lastTrackPoint->air_press = 0;
 80057bc:	4b29      	ldr	r3, [pc, #164]	; (8005864 <moduleTRACKING+0x1f24>)
 80057be:	681b      	ldr	r3, [r3, #0]
 80057c0:	2200      	movs	r2, #0
 80057c2:	629a      	str	r2, [r3, #40]	; 0x28
		lastTrackPoint->air_hum = 0;
 80057c4:	859a      	strh	r2, [r3, #44]	; 0x2c
		lastTrackPoint->air_temp = 0;
 80057c6:	85da      	strh	r2, [r3, #46]	; 0x2e
 80057c8:	f7fe ba19 	b.w	8003bfe <moduleTRACKING+0x2be>
			TRACE_TAB, lastTrackPoint->gps_lat/10000000, (lastTrackPoint->gps_lat > 0 ? 1:-1)*lastTrackPoint->gps_lat%10000000,
			TRACE_TAB, lastTrackPoint->gps_lon/10000000, (lastTrackPoint->gps_lon > 0 ? 1:-1)*lastTrackPoint->gps_lon%10000000,
			TRACE_TAB, lastTrackPoint->gps_alt
		);
	} else {
		TRACE_INFO("TRAC > No GPS position in memory");
 80057cc:	f006 fce8 	bl	800c1a0 <chMtxLock>
 80057d0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80057d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80057d4:	fb05 f303 	mul.w	r3, r5, r3
 80057d8:	fba6 1303 	umull	r1, r3, r6, r3
 80057dc:	0b5b      	lsrs	r3, r3, #13
 80057de:	fba4 0103 	umull	r0, r1, r4, r3
 80057e2:	fba6 0202 	umull	r0, r2, r6, r2
 80057e6:	0989      	lsrs	r1, r1, #6
 80057e8:	fb05 3311 	mls	r3, r5, r1, r3
 80057ec:	0b52      	lsrs	r2, r2, #13
 80057ee:	4910      	ldr	r1, [pc, #64]	; (8005830 <moduleTRACKING+0x1ef0>)
 80057f0:	4810      	ldr	r0, [pc, #64]	; (8005834 <moduleTRACKING+0x1ef4>)
 80057f2:	f004 ff4d 	bl	800a690 <chprintf.constprop.26>
 80057f6:	4a11      	ldr	r2, [pc, #68]	; (800583c <moduleTRACKING+0x1efc>)
 80057f8:	4911      	ldr	r1, [pc, #68]	; (8005840 <moduleTRACKING+0x1f00>)
 80057fa:	480e      	ldr	r0, [pc, #56]	; (8005834 <moduleTRACKING+0x1ef4>)
 80057fc:	f004 ff48 	bl	800a690 <chprintf.constprop.26>
 8005800:	2382      	movs	r3, #130	; 0x82
 8005802:	4a10      	ldr	r2, [pc, #64]	; (8005844 <moduleTRACKING+0x1f04>)
 8005804:	4910      	ldr	r1, [pc, #64]	; (8005848 <moduleTRACKING+0x1f08>)
 8005806:	480b      	ldr	r0, [pc, #44]	; (8005834 <moduleTRACKING+0x1ef4>)
 8005808:	f004 ff42 	bl	800a690 <chprintf.constprop.26>
 800580c:	490f      	ldr	r1, [pc, #60]	; (800584c <moduleTRACKING+0x1f0c>)
 800580e:	4809      	ldr	r0, [pc, #36]	; (8005834 <moduleTRACKING+0x1ef4>)
 8005810:	f004 ff3e 	bl	800a690 <chprintf.constprop.26>
 8005814:	4914      	ldr	r1, [pc, #80]	; (8005868 <moduleTRACKING+0x1f28>)
 8005816:	4807      	ldr	r0, [pc, #28]	; (8005834 <moduleTRACKING+0x1ef4>)
 8005818:	f004 ff3a 	bl	800a690 <chprintf.constprop.26>
 800581c:	f7fe b9a9 	b.w	8003b72 <moduleTRACKING+0x232>
 8005820:	2001b720 	.word	0x2001b720
 8005824:	d1b71759 	.word	0xd1b71759
 8005828:	40023c00 	.word	0x40023c00
 800582c:	10624dd3 	.word	0x10624dd3
 8005830:	0800ea50 	.word	0x0800ea50
 8005834:	2001ac28 	.word	0x2001ac28
 8005838:	cdef89ab 	.word	0xcdef89ab
 800583c:	0800f1dc 	.word	0x0800f1dc
 8005840:	0800ea64 	.word	0x0800ea64
 8005844:	0800f15c 	.word	0x0800f15c
 8005848:	0800ea7c 	.word	0x0800ea7c
 800584c:	0800f1e0 	.word	0x0800f1e0
 8005850:	0800f6fc 	.word	0x0800f6fc
 8005854:	0800eaa8 	.word	0x0800eaa8
 8005858:	0800f11c 	.word	0x0800f11c
 800585c:	0800ea5c 	.word	0x0800ea5c
 8005860:	0800f27c 	.word	0x0800f27c
 8005864:	2001b730 	.word	0x2001b730
 8005868:	0800f258 	.word	0x0800f258
 800586c:	45670123 	.word	0x45670123

08005870 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 8005870:	4b20      	ldr	r3, [pc, #128]	; (80058f4 <main+0x84>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8005872:	4c21      	ldr	r4, [pc, #132]	; (80058f8 <main+0x88>)
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 8005874:	691a      	ldr	r2, [r3, #16]
 8005876:	f04f 31ff 	mov.w	r1, #4294967295
 800587a:	2200      	movs	r2, #0
}

/**
  * Main routine is starting up system, runs the software watchdog (module monitoring), controls LEDs
  */
int main(void) {
 800587c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8005880:	6119      	str	r1, [r3, #16]
 8005882:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8005884:	6958      	ldr	r0, [r3, #20]
 8005886:	6159      	str	r1, [r3, #20]
 8005888:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800588a:	6a18      	ldr	r0, [r3, #32]
 800588c:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8005890:	6218      	str	r0, [r3, #32]
 8005892:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8005894:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005896:	6259      	str	r1, [r3, #36]	; 0x24
 8005898:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800589a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800589c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80058a0:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80058a2:	6821      	ldr	r1, [r4, #0]
 80058a4:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80058a8:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80058aa:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80058ac:	f401 7140 	and.w	r1, r1, #768	; 0x300
 80058b0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 80058b4:	b08f      	sub	sp, #60	; 0x3c
 80058b6:	d003      	beq.n	80058c0 <main+0x50>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80058b8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 80058bc:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 80058be:	671a      	str	r2, [r3, #112]	; 0x70
#endif

#if HAL_USE_RTC
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80058c0:	4b0c      	ldr	r3, [pc, #48]	; (80058f4 <main+0x84>)
 80058c2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80058c4:	0411      	lsls	r1, r2, #16
 80058c6:	d407      	bmi.n	80058d8 <main+0x68>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 80058c8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80058ca:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80058ce:	671a      	str	r2, [r3, #112]	; 0x70

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 80058d0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80058d2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80058d6:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 80058d8:	4e07      	ldr	r6, [pc, #28]	; (80058f8 <main+0x88>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 80058da:	4f08      	ldr	r7, [pc, #32]	; (80058fc <main+0x8c>)
 80058dc:	6871      	ldr	r1, [r6, #4]
 80058de:	4a08      	ldr	r2, [pc, #32]	; (8005900 <main+0x90>)
 80058e0:	4808      	ldr	r0, [pc, #32]	; (8005904 <main+0x94>)
 80058e2:	4d09      	ldr	r5, [pc, #36]	; (8005908 <main+0x98>)
 80058e4:	2400      	movs	r4, #0
 80058e6:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 80058ea:	6071      	str	r1, [r6, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80058ec:	4623      	mov	r3, r4
    _stm32_dma_streams[i].stream->CR = 0U;
 80058ee:	4621      	mov	r1, r4
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 80058f0:	603c      	str	r4, [r7, #0]
 80058f2:	e00d      	b.n	8005910 <main+0xa0>
 80058f4:	40023800 	.word	0x40023800
 80058f8:	40007000 	.word	0x40007000
 80058fc:	20019974 	.word	0x20019974
 8005900:	0800f7b4 	.word	0x0800f7b4
 8005904:	40026010 	.word	0x40026010
 8005908:	200198d0 	.word	0x200198d0
 800590c:	f852 0c0c 	ldr.w	r0, [r2, #-12]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
 8005910:	6001      	str	r1, [r0, #0]
    dma_isr_redir[i].dma_func = NULL;
 8005912:	f845 1033 	str.w	r1, [r5, r3, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8005916:	3301      	adds	r3, #1
 8005918:	2b10      	cmp	r3, #16
 800591a:	f102 020c 	add.w	r2, r2, #12
    _stm32_dma_streams[i].stream->CR = 0U;
 800591e:	f04f 0400 	mov.w	r4, #0
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8005922:	d1f3      	bne.n	800590c <main+0x9c>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8005924:	4ea3      	ldr	r6, [pc, #652]	; (8005bb4 <main+0x344>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8005926:	48a4      	ldr	r0, [pc, #656]	; (8005bb8 <main+0x348>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8005928:	4da4      	ldr	r5, [pc, #656]	; (8005bbc <main+0x34c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800592a:	4aa5      	ldr	r2, [pc, #660]	; (8005bc0 <main+0x350>)
 800592c:	4ba5      	ldr	r3, [pc, #660]	; (8005bc4 <main+0x354>)
 800592e:	f8df e344 	ldr.w	lr, [pc, #836]	; 8005c74 <main+0x404>
 8005932:	4fa5      	ldr	r7, [pc, #660]	; (8005bc8 <main+0x358>)
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 8005934:	f8df 8340 	ldr.w	r8, [pc, #832]	; 8005c78 <main+0x408>
  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8005938:	f04f 31ff 	mov.w	r1, #4294967295
 800593c:	60b1      	str	r1, [r6, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 800593e:	60f1      	str	r1, [r6, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8005940:	6081      	str	r1, [r0, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8005942:	60c1      	str	r1, [r0, #12]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8005944:	6b28      	ldr	r0, [r5, #48]	; 0x30
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005946:	49a1      	ldr	r1, [pc, #644]	; (8005bcc <main+0x35c>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8005948:	ea6f 2050 	mvn.w	r0, r0, lsr #9
 800594c:	ea6f 2040 	mvn.w	r0, r0, lsl #9
 8005950:	6328      	str	r0, [r5, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8005952:	6d28      	ldr	r0, [r5, #80]	; 0x50
 8005954:	ea6f 2050 	mvn.w	r0, r0, lsr #9
 8005958:	ea6f 2040 	mvn.w	r0, r0, lsl #9
 800595c:	6528      	str	r0, [r5, #80]	; 0x50
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800595e:	f5a5 157c 	sub.w	r5, r5, #4128768	; 0x3f0000
 8005962:	f5a5 65a0 	sub.w	r5, r5, #1280	; 0x500
  gpiop->PUPDR   = config->pupdr;
 8005966:	489a      	ldr	r0, [pc, #616]	; (8005bd0 <main+0x360>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005968:	6054      	str	r4, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800596a:	6095      	str	r5, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800596c:	60d0      	str	r0, [r2, #12]
  gpiop->ODR     = config->odr;
 800596e:	f64f 75ff 	movw	r5, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
 8005972:	4898      	ldr	r0, [pc, #608]	; (8005bd4 <main+0x364>)
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8005974:	6155      	str	r5, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8005976:	6210      	str	r0, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8005978:	4897      	ldr	r0, [pc, #604]	; (8005bd8 <main+0x368>)
 800597a:	6250      	str	r0, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800597c:	4897      	ldr	r0, [pc, #604]	; (8005bdc <main+0x36c>)
 800597e:	6010      	str	r0, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005980:	f44f 7240 	mov.w	r2, #768	; 0x300
 8005984:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005986:	4896      	ldr	r0, [pc, #600]	; (8005be0 <main+0x370>)
  gpiop->PUPDR   = config->pupdr;
 8005988:	4a96      	ldr	r2, [pc, #600]	; (8005be4 <main+0x374>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800598a:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 800598c:	f04f 4c5d 	mov.w	ip, #3707764736	; 0xdd000000

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8005990:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8005992:	4a95      	ldr	r2, [pc, #596]	; (8005be8 <main+0x378>)
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8005994:	615d      	str	r5, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8005996:	f8c3 c020 	str.w	ip, [r3, #32]
  gpiop->AFRH    = config->afrh;
 800599a:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800599c:	4a93      	ldr	r2, [pc, #588]	; (8005bec <main+0x37c>)
 800599e:	601a      	str	r2, [r3, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80059a0:	4b93      	ldr	r3, [pc, #588]	; (8005bf0 <main+0x380>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059a2:	f8ce 4004 	str.w	r4, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80059a6:	f8ce 3008 	str.w	r3, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 80059aa:	4b92      	ldr	r3, [pc, #584]	; (8005bf4 <main+0x384>)
 80059ac:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80059b0:	4b91      	ldr	r3, [pc, #580]	; (8005bf8 <main+0x388>)
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80059b2:	f8ce 5014 	str.w	r5, [lr, #20]
  gpiop->AFRL    = config->afrl;
 80059b6:	f8ce c020 	str.w	ip, [lr, #32]
  gpiop->AFRH    = config->afrh;
 80059ba:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059be:	4b8f      	ldr	r3, [pc, #572]	; (8005bfc <main+0x38c>)
 80059c0:	f8ce 3000 	str.w	r3, [lr]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80059c4:	4b8e      	ldr	r3, [pc, #568]	; (8005c00 <main+0x390>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059c6:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80059c8:	f04f 3e55 	mov.w	lr, #1431655765	; 0x55555555
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80059cc:	608b      	str	r3, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80059ce:	f44f 6300 	mov.w	r3, #2048	; 0x800

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80059d2:	f8c1 e00c 	str.w	lr, [r1, #12]
  gpiop->ODR     = config->odr;
 80059d6:	614d      	str	r5, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80059d8:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80059da:	f04f 43a8 	mov.w	r3, #1409286144	; 0x54000000
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80059de:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059e0:	600b      	str	r3, [r1, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80059e2:	f44f 537c 	mov.w	r3, #16128	; 0x3f00
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059e6:	607c      	str	r4, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80059e8:	60bb      	str	r3, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 80059ea:	4b86      	ldr	r3, [pc, #536]	; (8005c04 <main+0x394>)
 80059ec:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80059ee:	4b86      	ldr	r3, [pc, #536]	; (8005c08 <main+0x398>)
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80059f0:	617d      	str	r5, [r7, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059f2:	f5a6 4698 	sub.w	r6, r6, #19456	; 0x4c00
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80059f6:	623b      	str	r3, [r7, #32]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80059f8:	4a84      	ldr	r2, [pc, #528]	; (8005c0c <main+0x39c>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80059fa:	627c      	str	r4, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80059fc:	f44f 5328 	mov.w	r3, #10752	; 0x2a00
 8005a00:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005a02:	4883      	ldr	r0, [pc, #524]	; (8005c10 <main+0x3a0>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8005a04:	4f83      	ldr	r7, [pc, #524]	; (8005c14 <main+0x3a4>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005a06:	6074      	str	r4, [r6, #4]
 8005a08:	f501 51a0 	add.w	r1, r1, #5120	; 0x1400
  gpiop->OSPEEDR = config->ospeedr;
 8005a0c:	60b4      	str	r4, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8005a0e:	60f7      	str	r7, [r6, #12]
  gpiop->ODR     = config->odr;
 8005a10:	6175      	str	r5, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8005a12:	6234      	str	r4, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8005a14:	6274      	str	r4, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a16:	6034      	str	r4, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005a18:	6054      	str	r4, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005a1a:	6094      	str	r4, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8005a1c:	f8c2 e00c 	str.w	lr, [r2, #12]
  gpiop->ODR     = config->odr;
 8005a20:	6155      	str	r5, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8005a22:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8005a24:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a26:	6014      	str	r4, [r2, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8005a28:	2203      	movs	r2, #3
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8005a2a:	4b7b      	ldr	r3, [pc, #492]	; (8005c18 <main+0x3a8>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005a2c:	6044      	str	r4, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005a2e:	6082      	str	r2, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8005a30:	4a7a      	ldr	r2, [pc, #488]	; (8005c1c <main+0x3ac>)
 8005a32:	60c2      	str	r2, [r0, #12]
  gpiop->ODR     = config->odr;
 8005a34:	6145      	str	r5, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8005a36:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8005a38:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a3a:	6004      	str	r4, [r0, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8005a3c:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8005a3e:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8005a40:	f8c1 e00c 	str.w	lr, [r1, #12]
  gpiop->ODR     = config->odr;
 8005a44:	614d      	str	r5, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8005a46:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8005a48:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8005a4a:	600c      	str	r4, [r1, #0]
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 8005a4c:	f5a1 3180 	sub.w	r1, r1, #65536	; 0x10000
 8005a50:	6299      	str	r1, [r3, #40]	; 0x28

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8005a52:	4f73      	ldr	r7, [pc, #460]	; (8005c20 <main+0x3b0>)
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8005a54:	4973      	ldr	r1, [pc, #460]	; (8005c24 <main+0x3b4>)
 8005a56:	6319      	str	r1, [r3, #48]	; 0x30
 8005a58:	2501      	movs	r5, #1
 8005a5a:	2160      	movs	r1, #96	; 0x60

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA_STREAM(STM32_ADC_ADC1_DMA_STREAM);
 8005a5c:	4e72      	ldr	r6, [pc, #456]	; (8005c28 <main+0x3b8>)
 8005a5e:	701d      	strb	r5, [r3, #0]
  adcp->config   = NULL;
 8005a60:	605c      	str	r4, [r3, #4]
  adcp->samples  = NULL;
 8005a62:	609c      	str	r4, [r3, #8]
  adcp->depth    = 0;
 8005a64:	60dc      	str	r4, [r3, #12]
  adcp->grpp     = NULL;
 8005a66:	611c      	str	r4, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8005a68:	615c      	str	r4, [r3, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8005a6a:	621c      	str	r4, [r3, #32]
 8005a6c:	f887 1312 	strb.w	r1, [r7, #786]	; 0x312
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005a70:	f44f 2180 	mov.w	r1, #262144	; 0x40000
 8005a74:	f8c7 1180 	str.w	r1, [r7, #384]	; 0x180
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8005a78:	4a6c      	ldr	r2, [pc, #432]	; (8005c2c <main+0x3bc>)
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005a7a:	6039      	str	r1, [r7, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005a7c:	f103 0118 	add.w	r1, r3, #24
 8005a80:	62de      	str	r6, [r3, #44]	; 0x2c
 8005a82:	6199      	str	r1, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 8005a84:	61d9      	str	r1, [r3, #28]

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8005a86:	f1a6 0154 	sub.w	r1, r6, #84	; 0x54
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8005a8a:	4b69      	ldr	r3, [pc, #420]	; (8005c30 <main+0x3c0>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8005a8c:	62d1      	str	r1, [r2, #44]	; 0x2c
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8005a8e:	6353      	str	r3, [r2, #52]	; 0x34
  sdObjectInit(&SD4, NULL, notify4);
  SD4.usart = UART4;
#endif

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5, NULL, notify5);
 8005a90:	4f68      	ldr	r7, [pc, #416]	; (8005c34 <main+0x3c4>)
 8005a92:	6154      	str	r4, [r2, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005a94:	f102 030c 	add.w	r3, r2, #12
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8005a98:	f1a6 0148 	sub.w	r1, r6, #72	; 0x48
 8005a9c:	6311      	str	r1, [r2, #48]	; 0x30
 8005a9e:	60d3      	str	r3, [r2, #12]
  tqp->prev = (thread_t *)tqp;
 8005aa0:	6113      	str	r3, [r2, #16]
  sdObjectInit(&SD2, NULL, notify2);
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
 8005aa2:	4640      	mov	r0, r8
 8005aa4:	4964      	ldr	r1, [pc, #400]	; (8005c38 <main+0x3c8>)
 8005aa6:	7015      	strb	r5, [r2, #0]
  i2cp->config = NULL;
 8005aa8:	6054      	str	r4, [r2, #4]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 8005aaa:	61d4      	str	r4, [r2, #28]
 8005aac:	f004 fcb8 	bl	800a420 <sdObjectInit.constprop.80>
  SD3.usart = USART3;
 8005ab0:	4b62      	ldr	r3, [pc, #392]	; (8005c3c <main+0x3cc>)
  sdObjectInit(&SD4, NULL, notify4);
  SD4.usart = UART4;
#endif

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5, NULL, notify5);
 8005ab2:	4963      	ldr	r1, [pc, #396]	; (8005c40 <main+0x3d0>)
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
  SD3.usart = USART3;
 8005ab4:	f8c8 3074 	str.w	r3, [r8, #116]	; 0x74
  sdObjectInit(&SD4, NULL, notify4);
  SD4.usart = UART4;
#endif

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5, NULL, notify5);
 8005ab8:	4638      	mov	r0, r7
 8005aba:	f004 fcb1 	bl	800a420 <sdObjectInit.constprop.80>
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8005abe:	4a61      	ldr	r2, [pc, #388]	; (8005c44 <main+0x3d4>)
  SD5.usart = UART5;
 8005ac0:	4961      	ldr	r1, [pc, #388]	; (8005c48 <main+0x3d8>)
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8005ac2:	4b62      	ldr	r3, [pc, #392]	; (8005c4c <main+0x3dc>)
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 8005ac4:	4862      	ldr	r0, [pc, #392]	; (8005c50 <main+0x3e0>)
 8005ac6:	6779      	str	r1, [r7, #116]	; 0x74
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8005ac8:	f1a6 076c 	sub.w	r7, r6, #108	; 0x6c
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 8005acc:	f1a6 0160 	sub.w	r1, r6, #96	; 0x60
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 8005ad0:	6217      	str	r7, [r2, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 8005ad2:	6251      	str	r1, [r2, #36]	; 0x24
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 8005ad4:	61d0      	str	r0, [r2, #28]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005ad6:	f102 010c 	add.w	r1, r2, #12
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8005ada:	f8df e1a0 	ldr.w	lr, [pc, #416]	; 8005c7c <main+0x40c>
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8005ade:	4f5d      	ldr	r7, [pc, #372]	; (8005c54 <main+0x3e4>)
  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 8005ae0:	485d      	ldr	r0, [pc, #372]	; (8005c58 <main+0x3e8>)
 8005ae2:	60d1      	str	r1, [r2, #12]

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8005ae4:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
  tqp->prev = (thread_t *)tqp;
 8005ae8:	6111      	str	r1, [r2, #16]
 8005aea:	7015      	strb	r5, [r2, #0]
  spip->config = NULL;
 8005aec:	6054      	str	r4, [r2, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8005aee:	6094      	str	r4, [r2, #8]
 8005af0:	6154      	str	r4, [r2, #20]
#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8005af2:	f8c2 e028 	str.w	lr, [r2, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8005af6:	62d7      	str	r7, [r2, #44]	; 0x2c
 8005af8:	701d      	strb	r5, [r3, #0]
  usbp->config       = NULL;
 8005afa:	605c      	str	r4, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8005afc:	61dc      	str	r4, [r3, #28]
    usbp->out_params[i] = NULL;
 8005afe:	629c      	str	r4, [r3, #40]	; 0x28
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8005b00:	621c      	str	r4, [r3, #32]
    usbp->out_params[i] = NULL;
 8005b02:	62dc      	str	r4, [r3, #44]	; 0x2c
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8005b04:	625c      	str	r4, [r3, #36]	; 0x24
    usbp->out_params[i] = NULL;
 8005b06:	631c      	str	r4, [r3, #48]	; 0x30
  }
  usbp->transmitting = 0;
 8005b08:	811c      	strh	r4, [r3, #8]
  usbp->receiving    = 0;
 8005b0a:	815c      	strh	r4, [r3, #10]
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 8005b0c:	665c      	str	r4, [r3, #100]	; 0x64
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8005b0e:	669c      	str	r4, [r3, #104]	; 0x68

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8005b10:	655e      	str	r6, [r3, #84]	; 0x54
  USBD1.otgparams = &fsparams;
 8005b12:	6598      	str	r0, [r3, #88]	; 0x58

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8005b14:	f103 0270 	add.w	r2, r3, #112	; 0x70
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8005b18:	2155      	movs	r1, #85	; 0x55
 8005b1a:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8005b1e:	f802 1b01 	strb.w	r1, [r2], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8005b22:	429a      	cmp	r2, r3
 8005b24:	d1fb      	bne.n	8005b1e <main+0x2ae>

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 8005b26:	4a4d      	ldr	r2, [pc, #308]	; (8005c5c <main+0x3ec>)
 8005b28:	4b4d      	ldr	r3, [pc, #308]	; (8005c60 <main+0x3f0>)
 8005b2a:	6013      	str	r3, [r2, #0]

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 8005b2c:	21ca      	movs	r1, #202	; 0xca
  RTCD1.rtc->WPR = 0x53;
 8005b2e:	2253      	movs	r2, #83	; 0x53

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 8005b30:	6259      	str	r1, [r3, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 8005b32:	625a      	str	r2, [r3, #36]	; 0x24

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8005b34:	68da      	ldr	r2, [r3, #12]
 8005b36:	f012 0f10 	tst.w	r2, #16
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 8005b3a:	68da      	ldr	r2, [r3, #12]
  RTCD1.rtc->WPR = 0xCA;
  RTCD1.rtc->WPR = 0x53;

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8005b3c:	f000 8137 	beq.w	8005dae <main+0x53e>
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;

    rtc_exit_init();
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 8005b40:	f022 0220 	bic.w	r2, r2, #32
 8005b44:	60da      	str	r2, [r3, #12]
 * @notapi
 */
void wdg_lld_init(void) {

#if STM32_WDG_USE_IWDG
  WDGD1.state = WDG_STOP;
 8005b46:	4d47      	ldr	r5, [pc, #284]	; (8005c64 <main+0x3f4>)
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
	palClearPad(PORT(IO_LED4), PIN(IO_LED4));	// Show I'M ALIVE
 8005b48:	4b1f      	ldr	r3, [pc, #124]	; (8005bc8 <main+0x358>)
  WDGD1.wdg   = IWDG;
 8005b4a:	4a47      	ldr	r2, [pc, #284]	; (8005c68 <main+0x3f8>)
 8005b4c:	60aa      	str	r2, [r5, #8]
 * @notapi
 */
void wdg_lld_init(void) {

#if STM32_WDG_USE_IWDG
  WDGD1.state = WDG_STOP;
 8005b4e:	2101      	movs	r1, #1

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8005b50:	481a      	ldr	r0, [pc, #104]	; (8005bbc <main+0x34c>)
 8005b52:	7029      	strb	r1, [r5, #0]
 8005b54:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8005b58:	835a      	strh	r2, [r3, #26]
 8005b5a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005b5c:	4c43      	ldr	r4, [pc, #268]	; (8005c6c <main+0x3fc>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8005b5e:	4e44      	ldr	r6, [pc, #272]	; (8005c70 <main+0x400>)
  tqp->prev = (thread_t *)tqp;
 8005b60:	6064      	str	r4, [r4, #4]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8005b62:	430b      	orrs	r3, r1
 8005b64:	6403      	str	r3, [r0, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8005b66:	68b0      	ldr	r0, [r6, #8]
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8005b68:	6124      	str	r4, [r4, #16]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005b6a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8005b6e:	4308      	orrs	r0, r1
 8005b70:	60b0      	str	r0, [r6, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005b72:	f640 2e27 	movw	lr, #2599	; 0xa27
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005b76:	f04f 30ff 	mov.w	r0, #4294967295
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8005b7a:	270f      	movs	r7, #15

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8005b7c:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8005b80:	2600      	movs	r6, #0
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8005b82:	62d8      	str	r0, [r3, #44]	; 0x2c

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8005b84:	4a26      	ldr	r2, [pc, #152]	; (8005c20 <main+0x3b0>)
 8005b86:	8727      	strh	r7, [r4, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8005b88:	f104 0e40 	add.w	lr, r4, #64	; 0x40
 8005b8c:	2780      	movs	r7, #128	; 0x80
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8005b8e:	6260      	str	r0, [r4, #36]	; 0x24
  ch.rlist.older = (thread_t *)&ch.rlist;
 8005b90:	6164      	str	r4, [r4, #20]
 8005b92:	f8c4 e03c 	str.w	lr, [r4, #60]	; 0x3c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005b96:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
  STM32_ST_TIM->CCMR1  = 0;
 8005b9a:	619e      	str	r6, [r3, #24]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8005b9c:	60a6      	str	r6, [r4, #8]
  STM32_ST_TIM->CCR[0] = 0;
 8005b9e:	635e      	str	r6, [r3, #52]	; 0x34
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8005ba0:	62a6      	str	r6, [r4, #40]	; 0x28
  STM32_ST_TIM->DIER   = 0;
 8005ba2:	60de      	str	r6, [r3, #12]
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8005ba4:	8767      	strh	r7, [r4, #58]	; 0x3a
  STM32_ST_TIM->CR2    = 0;
 8005ba6:	605e      	str	r6, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8005ba8:	6159      	str	r1, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8005baa:	6019      	str	r1, [r3, #0]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8005bac:	f104 031c 	add.w	r3, r4, #28
 8005bb0:	e066      	b.n	8005c80 <main+0x410>
 8005bb2:	bf00      	nop
 8005bb4:	40026000 	.word	0x40026000
 8005bb8:	40026400 	.word	0x40026400
 8005bbc:	40023800 	.word	0x40023800
 8005bc0:	40020000 	.word	0x40020000
 8005bc4:	40020400 	.word	0x40020400
 8005bc8:	40021000 	.word	0x40021000
 8005bcc:	40020c00 	.word	0x40020c00
 8005bd0:	65541115 	.word	0x65541115
 8005bd4:	0d0d0000 	.word	0x0d0d0000
 8005bd8:	000aaa00 	.word	0x000aaa00
 8005bdc:	68a22600 	.word	0x68a22600
 8005be0:	fc35f0f0 	.word	0xfc35f0f0
 8005be4:	55905510 	.word	0x55905510
 8005be8:	55500744 	.word	0x55500744
 8005bec:	a82aa080 	.word	0xa82aa080
 8005bf0:	310ff000 	.word	0x310ff000
 8005bf4:	45555155 	.word	0x45555155
 8005bf8:	000866dd 	.word	0x000866dd
 8005bfc:	010aa000 	.word	0x010aa000
 8005c00:	003f0010 	.word	0x003f0010
 8005c04:	45445555 	.word	0x45445555
 8005c08:	0ddd0000 	.word	0x0ddd0000
 8005c0c:	40021800 	.word	0x40021800
 8005c10:	40021c00 	.word	0x40021c00
 8005c14:	55155595 	.word	0x55155595
 8005c18:	2001a9e8 	.word	0x2001a9e8
 8005c1c:	55555554 	.word	0x55555554
 8005c20:	e000e100 	.word	0xe000e100
 8005c24:	00022c16 	.word	0x00022c16
 8005c28:	0800f838 	.word	0x0800f838
 8005c2c:	2001aca4 	.word	0x2001aca4
 8005c30:	40005400 	.word	0x40005400
 8005c34:	2001b6a4 	.word	0x2001b6a4
 8005c38:	08006d41 	.word	0x08006d41
 8005c3c:	40004800 	.word	0x40004800
 8005c40:	08006d31 	.word	0x08006d31
 8005c44:	2001b590 	.word	0x2001b590
 8005c48:	40005000 	.word	0x40005000
 8005c4c:	2001aa70 	.word	0x2001aa70
 8005c50:	40003800 	.word	0x40003800
 8005c54:	00010046 	.word	0x00010046
 8005c58:	0800fab0 	.word	0x0800fab0
 8005c5c:	2001997c 	.word	0x2001997c
 8005c60:	40002800 	.word	0x40002800
 8005c64:	2001b564 	.word	0x2001b564
 8005c68:	40003000 	.word	0x40003000
 8005c6c:	2001acdc 	.word	0x2001acdc
 8005c70:	e0042000 	.word	0xe0042000
 8005c74:	40020800 	.word	0x40020800
 8005c78:	2001ac28 	.word	0x2001ac28
 8005c7c:	00010016 	.word	0x00010016

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8005c80:	f882 731c 	strb.w	r7, [r2, #796]	; 0x31c
 8005c84:	61e3      	str	r3, [r4, #28]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005c86:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8005c8a:	6223      	str	r3, [r4, #32]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005c8c:	6010      	str	r0, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005c8e:	6024      	str	r4, [r4, #0]
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005c90:	3601      	adds	r6, #1
 8005c92:	eb04 1306 	add.w	r3, r4, r6, lsl #4
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005c96:	2e80      	cmp	r6, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005c98:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 8005c9c:	49aa      	ldr	r1, [pc, #680]	; (8005f48 <main+0x6d8>)
 8005c9e:	f36f 0202 	bfc	r2, #0, #3
 8005ca2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005ca6:	d1f3      	bne.n	8005c90 <main+0x420>
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 8005ca8:	2700      	movs	r7, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8005caa:	f04f 3eff 	mov.w	lr, #4294967295
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8005cae:	2200      	movs	r2, #0
 8005cb0:	2300      	movs	r3, #0
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8005cb2:	a808      	add	r0, sp, #32
 8005cb4:	630f      	str	r7, [r1, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8005cb6:	634f      	str	r7, [r1, #52]	; 0x34
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8005cb8:	f8c1 7884 	str.w	r7, [r1, #2180]	; 0x884

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8005cbc:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8005cc0:	9107      	str	r1, [sp, #28]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8005cc2:	f8cd e020 	str.w	lr, [sp, #32]
  tmp->worst      = (rtcnt_t)0;
 8005cc6:	9709      	str	r7, [sp, #36]	; 0x24
  tmp->last       = (rtcnt_t)0;
 8005cc8:	970a      	str	r7, [sp, #40]	; 0x28
  tmp->n          = (ucnt_t)0;
 8005cca:	970b      	str	r7, [sp, #44]	; 0x2c
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8005ccc:	f004 fb78 	bl	800a3c0 <chTMStartMeasurementX.constprop.93>
  chTMStopMeasurementX(&tm);
 8005cd0:	a808      	add	r0, sp, #32
 8005cd2:	f005 fecd 	bl	800ba70 <chTMStopMeasurementX>
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8005cd6:	489d      	ldr	r0, [pc, #628]	; (8005f4c <main+0x6dc>)
  endmem  = __heap_end__;
 8005cd8:	4a9d      	ldr	r2, [pc, #628]	; (8005f50 <main+0x6e0>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8005cda:	f8df e2bc 	ldr.w	lr, [pc, #700]	; 8005f98 <main+0x728>
 8005cde:	f8c0 e000 	str.w	lr, [r0]
  endmem  = __heap_end__;
 8005ce2:	f8df e2b8 	ldr.w	lr, [pc, #696]	; 8005f9c <main+0x72c>
 8005ce6:	f8c2 e000 	str.w	lr, [r2]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8005cea:	4a9a      	ldr	r2, [pc, #616]	; (8005f54 <main+0x6e4>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8005cec:	4b9a      	ldr	r3, [pc, #616]	; (8005f58 <main+0x6e8>)
 8005cee:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8005cf2:	489a      	ldr	r0, [pc, #616]	; (8005f5c <main+0x6ec>)
 8005cf4:	6018      	str	r0, [r3, #0]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8005cf6:	f8df e2a8 	ldr.w	lr, [pc, #680]	; 8005fa0 <main+0x730>
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005cfa:	9907      	ldr	r1, [sp, #28]
 8005cfc:	619f      	str	r7, [r3, #24]
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8005cfe:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 8005d02:	ea0c 0000 	and.w	r0, ip, r0
  reg_value  =  (reg_value                                   |
 8005d06:	ea40 0e0e 	orr.w	lr, r0, lr
 8005d0a:	f103 0010 	add.w	r0, r3, #16
 8005d0e:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8005d10:	6158      	str	r0, [r3, #20]
  ch.tm.offset = tm.last;
 8005d12:	980a      	ldr	r0, [sp, #40]	; 0x28
 8005d14:	f8d1 8014 	ldr.w	r8, [r1, #20]
 8005d18:	f8c1 0884 	str.w	r0, [r1, #2180]	; 0x884
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8005d1c:	4890      	ldr	r0, [pc, #576]	; (8005f60 <main+0x6f0>)
 8005d1e:	f8c1 0858 	str.w	r0, [r1, #2136]	; 0x858
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005d22:	f04f 0c01 	mov.w	ip, #1
  tp->name      = name;
  REG_INSERT(tp);
 8005d26:	f501 6004 	add.w	r0, r1, #2112	; 0x840
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005d2a:	f881 7861 	strb.w	r7, [r1, #2145]	; 0x861
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8005d2e:	f8c1 7874 	str.w	r7, [r1, #2164]	; 0x874
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8005d32:	f8c1 7878 	str.w	r7, [r1, #2168]	; 0x878
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8005d36:	f8c1 6848 	str.w	r6, [r1, #2120]	; 0x848
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8005d3a:	f8c1 687c 	str.w	r6, [r1, #2172]	; 0x87c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005d3e:	f881 c862 	strb.w	ip, [r1, #2146]	; 0x862
  tp->name      = name;
  REG_INSERT(tp);
 8005d42:	f8c1 1850 	str.w	r1, [r1, #2128]	; 0x850
 8005d46:	f8c1 8854 	str.w	r8, [r1, #2132]	; 0x854
 8005d4a:	f8c8 0010 	str.w	r0, [r8, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8005d4e:	f8c2 e00c 	str.w	lr, [r2, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8005d52:	f8df e250 	ldr.w	lr, [pc, #592]	; 8005fa4 <main+0x734>
  H_NEXT(&default_heap.header) = NULL;
 8005d56:	609f      	str	r7, [r3, #8]
 8005d58:	f8de 600c 	ldr.w	r6, [lr, #12]
  H_PAGES(&default_heap.header) = 0;
 8005d5c:	60df      	str	r7, [r3, #12]
 8005d5e:	f046 7380 	orr.w	r3, r6, #16777216	; 0x1000000
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8005d62:	4e80      	ldr	r6, [pc, #512]	; (8005f64 <main+0x6f4>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8005d64:	f8ce 300c 	str.w	r3, [lr, #12]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8005d68:	f601 0768 	addw	r7, r1, #2152	; 0x868
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005d6c:	f601 036c 	addw	r3, r1, #2156	; 0x86c
 8005d70:	6148      	str	r0, [r1, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8005d72:	6188      	str	r0, [r1, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8005d74:	487c      	ldr	r0, [pc, #496]	; (8005f68 <main+0x6f8>)
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8005d76:	f8c1 7868 	str.w	r7, [r1, #2152]	; 0x868
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005d7a:	f8c1 386c 	str.w	r3, [r1, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
 8005d7e:	f8c1 3870 	str.w	r3, [r1, #2160]	; 0x870
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8005d82:	f881 c860 	strb.w	ip, [r1, #2144]	; 0x860
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8005d86:	f8c1 085c 	str.w	r0, [r1, #2140]	; 0x85c
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8005d8a:	6833      	ldr	r3, [r6, #0]
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005d8c:	6b08      	ldr	r0, [r1, #48]	; 0x30
 8005d8e:	ea43 030c 	orr.w	r3, r3, ip
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8005d92:	f04f 0e10 	mov.w	lr, #16
 8005d96:	2720      	movs	r7, #32
 8005d98:	6033      	str	r3, [r6, #0]
 8005d9a:	f882 e01f 	strb.w	lr, [r2, #31]
 8005d9e:	f882 7022 	strb.w	r7, [r2, #34]	; 0x22
 8005da2:	b908      	cbnz	r0, 8005da8 <main+0x538>
 8005da4:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8005da6:	b1ab      	cbz	r3, 8005dd4 <main+0x564>
    chSysHalt("SV#3");
 8005da8:	4870      	ldr	r0, [pc, #448]	; (8005f6c <main+0x6fc>)
 8005daa:	f005 fee1 	bl	800bb70 <chSysHalt>
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 8005dae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005db2:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 8005db4:	68da      	ldr	r2, [r3, #12]
 8005db6:	496e      	ldr	r1, [pc, #440]	; (8005f70 <main+0x700>)
 8005db8:	0652      	lsls	r2, r2, #25
 8005dba:	d5fb      	bpl.n	8005db4 <main+0x544>

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8005dbc:	4b6d      	ldr	r3, [pc, #436]	; (8005f74 <main+0x704>)
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 8005dbe:	2000      	movs	r0, #0
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8005dc0:	2280      	movs	r2, #128	; 0x80
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {

    rtc_enter_init();

    RTCD1.rtc->CR   = 0;
 8005dc2:	6088      	str	r0, [r1, #8]
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8005dc4:	60ca      	str	r2, [r1, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8005dc6:	610b      	str	r3, [r1, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8005dc8:	610b      	str	r3, [r1, #16]
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8005dca:	68cb      	ldr	r3, [r1, #12]
 8005dcc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005dd0:	60cb      	str	r3, [r1, #12]
 8005dd2:	e6b8      	b.n	8005b46 <main+0x2d6>
 8005dd4:	9107      	str	r1, [sp, #28]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8005dd6:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005dda:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8005ddc:	f387 8811 	msr	BASEPRI, r7
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005de0:	f006 f9ce 	bl	800c180 <_dbg_check_lock>
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8005de4:	9907      	ldr	r1, [sp, #28]
 8005de6:	690f      	ldr	r7, [r1, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8005de8:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8005dec:	3301      	adds	r3, #1
 8005dee:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005df2:	f006 f9b5 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005df6:	9907      	ldr	r1, [sp, #28]
 8005df8:	680b      	ldr	r3, [r1, #0]
 8005dfa:	428b      	cmp	r3, r1
 8005dfc:	d004      	beq.n	8005e08 <main+0x598>
 8005dfe:	698a      	ldr	r2, [r1, #24]
 8005e00:	689b      	ldr	r3, [r3, #8]
 8005e02:	6892      	ldr	r2, [r2, #8]
 8005e04:	429a      	cmp	r2, r3
 8005e06:	d349      	bcc.n	8005e9c <main+0x62c>
 8005e08:	f04f 0800 	mov.w	r8, #0
 8005e0c:	f388 8811 	msr	BASEPRI, r8
 8005e10:	f8df a134 	ldr.w	sl, [pc, #308]	; 8005f48 <main+0x6d8>
 8005e14:	f04f 0920 	mov.w	r9, #32
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8005e18:	69fb      	ldr	r3, [r7, #28]
 8005e1a:	4a57      	ldr	r2, [pc, #348]	; (8005f78 <main+0x708>)
 8005e1c:	4293      	cmp	r3, r2
 8005e1e:	f000 8086 	beq.w	8005f2e <main+0x6be>
 8005e22:	f389 8811 	msr	BASEPRI, r9
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005e26:	f006 f9ab 	bl	800c180 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8005e2a:	693e      	ldr	r6, [r7, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8005e2c:	42a6      	cmp	r6, r4
 8005e2e:	f000 8089 	beq.w	8005f44 <main+0x6d4>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8005e32:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 8005e36:	2bff      	cmp	r3, #255	; 0xff
 8005e38:	d039      	beq.n	8005eae <main+0x63e>
    ntp->refs++;
 8005e3a:	3301      	adds	r3, #1
 8005e3c:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005e40:	f006 f98e 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005e44:	6823      	ldr	r3, [r4, #0]
 8005e46:	42a3      	cmp	r3, r4
 8005e48:	d005      	beq.n	8005e56 <main+0x5e6>
 8005e4a:	f8da 2018 	ldr.w	r2, [sl, #24]
 8005e4e:	689b      	ldr	r3, [r3, #8]
 8005e50:	6892      	ldr	r2, [r2, #8]
 8005e52:	429a      	cmp	r2, r3
 8005e54:	d322      	bcc.n	8005e9c <main+0x62c>
 8005e56:	f388 8811 	msr	BASEPRI, r8
 8005e5a:	f389 8811 	msr	BASEPRI, r9
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005e5e:	f006 f98f 	bl	800c180 <_dbg_check_lock>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8005e62:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8005e66:	b1fb      	cbz	r3, 8005ea8 <main+0x638>
  tp->refs--;
 8005e68:	3b01      	subs	r3, #1
 8005e6a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8005e6e:	6a3b      	ldr	r3, [r7, #32]
 8005e70:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8005e74:	2b0f      	cmp	r3, #15
 8005e76:	d01d      	beq.n	8005eb4 <main+0x644>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005e78:	f006 f972 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005e7c:	6823      	ldr	r3, [r4, #0]
 8005e7e:	42a3      	cmp	r3, r4
 8005e80:	d005      	beq.n	8005e8e <main+0x61e>
 8005e82:	f8da 2018 	ldr.w	r2, [sl, #24]
 8005e86:	689b      	ldr	r3, [r3, #8]
 8005e88:	6892      	ldr	r2, [r2, #8]
 8005e8a:	429a      	cmp	r2, r3
 8005e8c:	d309      	bcc.n	8005ea2 <main+0x632>
 8005e8e:	f388 8811 	msr	BASEPRI, r8
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 8005e92:	2e00      	cmp	r6, #0
 8005e94:	f000 8088 	beq.w	8005fa8 <main+0x738>
 8005e98:	4637      	mov	r7, r6
 8005e9a:	e7bd      	b.n	8005e18 <main+0x5a8>
 8005e9c:	4837      	ldr	r0, [pc, #220]	; (8005f7c <main+0x70c>)
 8005e9e:	f005 fe67 	bl	800bb70 <chSysHalt>
 8005ea2:	4837      	ldr	r0, [pc, #220]	; (8005f80 <main+0x710>)
 8005ea4:	f005 fe64 	bl	800bb70 <chSysHalt>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8005ea8:	4836      	ldr	r0, [pc, #216]	; (8005f84 <main+0x714>)
 8005eaa:	f005 fe61 	bl	800bb70 <chSysHalt>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8005eae:	4836      	ldr	r0, [pc, #216]	; (8005f88 <main+0x718>)
 8005eb0:	f005 fe5e 	bl	800bb70 <chSysHalt>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 8005eb4:	697b      	ldr	r3, [r7, #20]
 8005eb6:	693a      	ldr	r2, [r7, #16]
 8005eb8:	611a      	str	r2, [r3, #16]
 8005eba:	693a      	ldr	r2, [r7, #16]
 8005ebc:	6153      	str	r3, [r2, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005ebe:	f006 f94f 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005ec2:	6823      	ldr	r3, [r4, #0]
 8005ec4:	42a3      	cmp	r3, r4
 8005ec6:	d005      	beq.n	8005ed4 <main+0x664>
 8005ec8:	f8da 2018 	ldr.w	r2, [sl, #24]
 8005ecc:	689b      	ldr	r3, [r3, #8]
 8005ece:	6892      	ldr	r2, [r2, #8]
 8005ed0:	429a      	cmp	r2, r3
 8005ed2:	d3e6      	bcc.n	8005ea2 <main+0x632>
 8005ed4:	f388 8811 	msr	BASEPRI, r8
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8005ed8:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8005edc:	f003 0303 	and.w	r3, r3, #3
 8005ee0:	2b01      	cmp	r3, #1
 8005ee2:	d027      	beq.n	8005f34 <main+0x6c4>
 8005ee4:	2b02      	cmp	r3, #2
 8005ee6:	d1d4      	bne.n	8005e92 <main+0x622>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8005ee8:	f8d7 b040 	ldr.w	fp, [r7, #64]	; 0x40
 8005eec:	69ff      	ldr	r7, [r7, #28]
 8005eee:	f389 8811 	msr	BASEPRI, r9
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005ef2:	f006 f945 	bl	800c180 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8005ef6:	f005 fe9b 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8005efa:	f1bb 0f00 	cmp.w	fp, #0
 8005efe:	f000 8125 	beq.w	800614c <main+0x8dc>
 8005f02:	2f00      	cmp	r7, #0
 8005f04:	f000 8122 	beq.w	800614c <main+0x8dc>

  php->next = mp->next;
 8005f08:	f8db 3000 	ldr.w	r3, [fp]
 8005f0c:	603b      	str	r3, [r7, #0]
  mp->next = php;
 8005f0e:	f8cb 7000 	str.w	r7, [fp]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005f12:	f006 f925 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005f16:	6823      	ldr	r3, [r4, #0]
 8005f18:	42a3      	cmp	r3, r4
 8005f1a:	d0b8      	beq.n	8005e8e <main+0x61e>
 8005f1c:	f8da 2018 	ldr.w	r2, [sl, #24]
 8005f20:	689b      	ldr	r3, [r3, #8]
 8005f22:	6892      	ldr	r2, [r2, #8]
 8005f24:	429a      	cmp	r2, r3
 8005f26:	d2b2      	bcs.n	8005e8e <main+0x61e>
 8005f28:	4818      	ldr	r0, [pc, #96]	; (8005f8c <main+0x71c>)
 8005f2a:	f005 fe21 	bl	800bb70 <chSysHalt>
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8005f2e:	4818      	ldr	r0, [pc, #96]	; (8005f90 <main+0x720>)
 8005f30:	f005 fe1e 	bl	800bb70 <chSysHalt>
 8005f34:	69ff      	ldr	r7, [r7, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8005f36:	b117      	cbz	r7, 8005f3e <main+0x6ce>
 8005f38:	077b      	lsls	r3, r7, #29
 8005f3a:	f000 810a 	beq.w	8006152 <main+0x8e2>
 8005f3e:	4815      	ldr	r0, [pc, #84]	; (8005f94 <main+0x724>)
 8005f40:	f005 fe16 	bl	800bb70 <chSysHalt>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8005f44:	2600      	movs	r6, #0
 8005f46:	e77b      	b.n	8005e40 <main+0x5d0>
 8005f48:	2001acdc 	.word	0x2001acdc
 8005f4c:	2001a9d4 	.word	0x2001a9d4
 8005f50:	20019978 	.word	0x20019978
 8005f54:	e000ed00 	.word	0xe000ed00
 8005f58:	2001b570 	.word	0x2001b570
 8005f5c:	080094f1 	.word	0x080094f1
 8005f60:	0800fa98 	.word	0x0800fa98
 8005f64:	e0001000 	.word	0xe0001000
 8005f68:	20000400 	.word	0x20000400
 8005f6c:	0800f870 	.word	0x0800f870
 8005f70:	40002800 	.word	0x40002800
 8005f74:	001f03ff 	.word	0x001f03ff
 8005f78:	20019980 	.word	0x20019980
 8005f7c:	0800fb08 	.word	0x0800fb08
 8005f80:	0800f774 	.word	0x0800f774
 8005f84:	0800faf8 	.word	0x0800faf8
 8005f88:	0800f798 	.word	0x0800f798
 8005f8c:	0800f780 	.word	0x0800f780
 8005f90:	0800f768 	.word	0x0800f768
 8005f94:	0800fad4 	.word	0x0800fad4
 8005f98:	2001b778 	.word	0x2001b778
 8005f9c:	20030000 	.word	0x20030000
 8005fa0:	05fa0300 	.word	0x05fa0300
 8005fa4:	e000edf0 	.word	0xe000edf0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8005fa8:	2355      	movs	r3, #85	; 0x55
 8005faa:	4a91      	ldr	r2, [pc, #580]	; (80061f0 <main+0x980>)
 8005fac:	5593      	strb	r3, [r2, r6]
 8005fae:	3601      	adds	r6, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8005fb0:	2ed8      	cmp	r6, #216	; 0xd8
 8005fb2:	d1fa      	bne.n	8005faa <main+0x73a>
 8005fb4:	2320      	movs	r3, #32
 8005fb6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8005fba:	f006 f8e1 	bl	800c180 <_dbg_check_lock>
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8005fbe:	488d      	ldr	r0, [pc, #564]	; (80061f4 <main+0x984>)
 8005fc0:	f005 fe46 	bl	800bc50 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8005fc4:	f004 f9bc 	bl	800a340 <chSchWakeupS.constprop.96>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8005fc8:	f006 f8ca 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8005fcc:	6823      	ldr	r3, [r4, #0]
 8005fce:	4a8a      	ldr	r2, [pc, #552]	; (80061f8 <main+0x988>)
 8005fd0:	42a3      	cmp	r3, r4
 8005fd2:	d005      	beq.n	8005fe0 <main+0x770>
 8005fd4:	6992      	ldr	r2, [r2, #24]
 8005fd6:	689b      	ldr	r3, [r3, #8]
 8005fd8:	6892      	ldr	r2, [r2, #8]
 8005fda:	429a      	cmp	r2, r3
 8005fdc:	f4ff af61 	bcc.w	8005ea2 <main+0x632>
 8005fe0:	f04f 0900 	mov.w	r9, #0
 8005fe4:	f389 8811 	msr	BASEPRI, r9
{
	if(boost)
	{

		// Ramp up to 3.07V
		palClearPad(PORT(VBOOST), PIN(VBOOST));
 8005fe8:	4f84      	ldr	r7, [pc, #528]	; (80061fc <main+0x98c>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005fea:	4e85      	ldr	r6, [pc, #532]	; (8006200 <main+0x990>)
 8005fec:	f44f 6800 	mov.w	r8, #2048	; 0x800
 8005ff0:	f8a7 801a 	strh.w	r8, [r7, #26]
		palSetPadMode(PORT(VBOOST), PIN(VBOOST), PAL_MODE_OUTPUT_PUSHPULL);
 8005ff4:	4641      	mov	r1, r8
 8005ff6:	4638      	mov	r0, r7
 8005ff8:	2201      	movs	r2, #1
 8005ffa:	f004 f899 	bl	800a130 <_pal_lld_setgroupmode>
		palClearPad(PORT(VBOOST), PIN(VBOOST));
		vcc_ref = VCC_REF_HIGH;
 8005ffe:	4b81      	ldr	r3, [pc, #516]	; (8006204 <main+0x994>)
	{

		// Ramp up to 3.07V
		palClearPad(PORT(VBOOST), PIN(VBOOST));
		palSetPadMode(PORT(VBOOST), PIN(VBOOST), PAL_MODE_OUTPUT_PUSHPULL);
		palClearPad(PORT(VBOOST), PIN(VBOOST));
 8006000:	f8a7 801a 	strh.w	r8, [r7, #26]
	chThdSleepMilliseconds(3000);
	usbStart(serusbcfg.usbp, &usbcfg);
	usbConnectBus(serusbcfg.usbp);*/


	DEBUG_INIT();				// Debug Init (Serial debug port, LEDs)
 8006004:	2201      	movs	r2, #1
		vcc_ref = VCC_REF_HIGH;
 8006006:	f640 37fe 	movw	r7, #3070	; 0xbfe
 800600a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800600e:	487e      	ldr	r0, [pc, #504]	; (8006208 <main+0x998>)
 8006010:	801f      	strh	r7, [r3, #0]
 8006012:	f004 f88d 	bl	800a130 <_pal_lld_setgroupmode>
 8006016:	2201      	movs	r2, #1
 8006018:	f44f 7180 	mov.w	r1, #256	; 0x100
 800601c:	487a      	ldr	r0, [pc, #488]	; (8006208 <main+0x998>)
 800601e:	f004 f887 	bl	800a130 <_pal_lld_setgroupmode>
 8006022:	2201      	movs	r2, #1
 8006024:	4611      	mov	r1, r2
 8006026:	4879      	ldr	r0, [pc, #484]	; (800620c <main+0x99c>)
 8006028:	f004 f882 	bl	800a130 <_pal_lld_setgroupmode>
 800602c:	2201      	movs	r2, #1
 800602e:	2102      	movs	r1, #2
 8006030:	4876      	ldr	r0, [pc, #472]	; (800620c <main+0x99c>)
 8006032:	f004 f87d 	bl	800a130 <_pal_lld_setgroupmode>
 8006036:	4976      	ldr	r1, [pc, #472]	; (8006210 <main+0x9a0>)
 8006038:	4876      	ldr	r0, [pc, #472]	; (8006214 <main+0x9a4>)
 800603a:	f002 fff1 	bl	8009020 <sdStart>
 800603e:	f240 3282 	movw	r2, #898	; 0x382
 8006042:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8006046:	4871      	ldr	r0, [pc, #452]	; (800620c <main+0x99c>)
 8006048:	f004 f872 	bl	800a130 <_pal_lld_setgroupmode>
 800604c:	4630      	mov	r0, r6
 800604e:	6036      	str	r6, [r6, #0]
  tqp->prev = (thread_t *)tqp;
 8006050:	6076      	str	r6, [r6, #4]
 8006052:	f8c6 9008 	str.w	r9, [r6, #8]
 8006056:	f006 f8a3 	bl	800c1a0 <chMtxLock>
 800605a:	496f      	ldr	r1, [pc, #444]	; (8006218 <main+0x9a8>)
 800605c:	486d      	ldr	r0, [pc, #436]	; (8006214 <main+0x9a4>)
 800605e:	f004 fb17 	bl	800a690 <chprintf.constprop.26>
 8006062:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
 8006066:	4630      	mov	r0, r6
 8006068:	f003 fa8a 	bl	8009580 <chMtxUnlock>
	TRACE_INFO("MAIN > Startup");
 800606c:	4630      	mov	r0, r6
 800606e:	f006 f897 	bl	800c1a0 <chMtxLock>
 8006072:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8006076:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800607a:	4968      	ldr	r1, [pc, #416]	; (800621c <main+0x9ac>)
 800607c:	4865      	ldr	r0, [pc, #404]	; (8006214 <main+0x9a4>)
 800607e:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8006082:	f242 7810 	movw	r8, #10000	; 0x2710
 8006086:	fb07 f303 	mul.w	r3, r7, r3
 800608a:	fbb2 f2f8 	udiv	r2, r2, r8
 800608e:	fbb3 f3f8 	udiv	r3, r3, r8
 8006092:	fbb3 fef7 	udiv	lr, r3, r7
 8006096:	fb07 331e 	mls	r3, r7, lr, r3
 800609a:	f004 faf9 	bl	800a690 <chprintf.constprop.26>
 800609e:	4a60      	ldr	r2, [pc, #384]	; (8006220 <main+0x9b0>)
 80060a0:	4960      	ldr	r1, [pc, #384]	; (8006224 <main+0x9b4>)
 80060a2:	485c      	ldr	r0, [pc, #368]	; (8006214 <main+0x9a4>)
 80060a4:	f004 faf4 	bl	800a690 <chprintf.constprop.26>
 80060a8:	2356      	movs	r3, #86	; 0x56
 80060aa:	4a5f      	ldr	r2, [pc, #380]	; (8006228 <main+0x9b8>)
 80060ac:	495f      	ldr	r1, [pc, #380]	; (800622c <main+0x9bc>)
 80060ae:	4859      	ldr	r0, [pc, #356]	; (8006214 <main+0x9a4>)
 80060b0:	f004 faee 	bl	800a690 <chprintf.constprop.26>
 80060b4:	495e      	ldr	r1, [pc, #376]	; (8006230 <main+0x9c0>)
 80060b6:	4857      	ldr	r0, [pc, #348]	; (8006214 <main+0x9a4>)
 80060b8:	f004 faea 	bl	800a690 <chprintf.constprop.26>
 80060bc:	495d      	ldr	r1, [pc, #372]	; (8006234 <main+0x9c4>)
 80060be:	4855      	ldr	r0, [pc, #340]	; (8006214 <main+0x9a4>)
 80060c0:	f004 fae6 	bl	800a690 <chprintf.constprop.26>
 80060c4:	4954      	ldr	r1, [pc, #336]	; (8006218 <main+0x9a8>)
 80060c6:	4853      	ldr	r0, [pc, #332]	; (8006214 <main+0x9a4>)
 80060c8:	f004 fae2 	bl	800a690 <chprintf.constprop.26>
 80060cc:	4630      	mov	r0, r6
 80060ce:	f003 fa57 	bl	8009580 <chMtxUnlock>

	// Initialize Watchdog
	TRACE_INFO("MAIN > Initialize Watchdog");
 80060d2:	4630      	mov	r0, r6
 80060d4:	f006 f864 	bl	800c1a0 <chMtxLock>
 80060d8:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 80060dc:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 80060e0:	fbb2 f2f8 	udiv	r2, r2, r8
 80060e4:	fb07 f303 	mul.w	r3, r7, r3
 80060e8:	494c      	ldr	r1, [pc, #304]	; (800621c <main+0x9ac>)
 80060ea:	fbb3 f3f8 	udiv	r3, r3, r8
 80060ee:	4849      	ldr	r0, [pc, #292]	; (8006214 <main+0x9a4>)
 80060f0:	fbb3 fef7 	udiv	lr, r3, r7
 80060f4:	fb07 331e 	mls	r3, r7, lr, r3
 80060f8:	f004 faca 	bl	800a690 <chprintf.constprop.26>
 80060fc:	4a48      	ldr	r2, [pc, #288]	; (8006220 <main+0x9b0>)
 80060fe:	4949      	ldr	r1, [pc, #292]	; (8006224 <main+0x9b4>)
 8006100:	4844      	ldr	r0, [pc, #272]	; (8006214 <main+0x9a4>)
 8006102:	f004 fac5 	bl	800a690 <chprintf.constprop.26>
 8006106:	2359      	movs	r3, #89	; 0x59
 8006108:	4a47      	ldr	r2, [pc, #284]	; (8006228 <main+0x9b8>)
 800610a:	4948      	ldr	r1, [pc, #288]	; (800622c <main+0x9bc>)
 800610c:	4841      	ldr	r0, [pc, #260]	; (8006214 <main+0x9a4>)
 800610e:	f004 fabf 	bl	800a690 <chprintf.constprop.26>
 8006112:	4947      	ldr	r1, [pc, #284]	; (8006230 <main+0x9c0>)
 8006114:	483f      	ldr	r0, [pc, #252]	; (8006214 <main+0x9a4>)
 8006116:	f004 fabb 	bl	800a690 <chprintf.constprop.26>
 800611a:	4947      	ldr	r1, [pc, #284]	; (8006238 <main+0x9c8>)
 800611c:	483d      	ldr	r0, [pc, #244]	; (8006214 <main+0x9a4>)
 800611e:	f004 fab7 	bl	800a690 <chprintf.constprop.26>
 8006122:	493d      	ldr	r1, [pc, #244]	; (8006218 <main+0x9a8>)
 8006124:	483b      	ldr	r0, [pc, #236]	; (8006214 <main+0x9a4>)
 8006126:	f004 fab3 	bl	800a690 <chprintf.constprop.26>
 800612a:	4630      	mov	r0, r6
 800612c:	f003 fa28 	bl	8009580 <chMtxUnlock>
 8006130:	2320      	movs	r3, #32
 8006132:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006136:	f006 f823 	bl	800c180 <_dbg_check_lock>
void wdgStart(WDGDriver *wdgp, const WDGConfig *config) {

  osalDbgCheck((wdgp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((wdgp->state == WDG_STOP) || (wdgp->state == WDG_READY),
 800613a:	782b      	ldrb	r3, [r5, #0]
 800613c:	4a3f      	ldr	r2, [pc, #252]	; (800623c <main+0x9cc>)
 800613e:	3b01      	subs	r3, #1
 8006140:	2b01      	cmp	r3, #1
 8006142:	f240 8081 	bls.w	8006248 <main+0x9d8>
 8006146:	483e      	ldr	r0, [pc, #248]	; (8006240 <main+0x9d0>)
 8006148:	f005 fd12 	bl	800bb70 <chSysHalt>
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
 800614c:	483d      	ldr	r0, [pc, #244]	; (8006244 <main+0x9d4>)
 800614e:	f005 fd0f 	bl	800bb70 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8006152:	e917 000c 	ldmdb	r7, {r2, r3}
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8006156:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8006158:	f102 0110 	add.w	r1, r2, #16
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800615c:	08db      	lsrs	r3, r3, #3
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800615e:	4608      	mov	r0, r1
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8006160:	f847 3c04 	str.w	r3, [r7, #-4]

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8006164:	f102 0b08 	add.w	fp, r2, #8
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8006168:	9107      	str	r1, [sp, #28]
 800616a:	f006 f819 	bl	800c1a0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 800616e:	9907      	ldr	r1, [sp, #28]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8006170:	f1a7 0008 	sub.w	r0, r7, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8006174:	465b      	mov	r3, fp

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8006176:	4298      	cmp	r0, r3
 8006178:	d306      	bcc.n	8006188 <main+0x918>
 800617a:	685a      	ldr	r2, [r3, #4]
 800617c:	3201      	adds	r2, #1
 800617e:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8006182:	4290      	cmp	r0, r2
 8006184:	f4ff aedb 	bcc.w	8005f3e <main+0x6ce>

    if (((qp == &heapp->header) || (hp > qp)) &&
 8006188:	459b      	cmp	fp, r3
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800618a:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 800618c:	d001      	beq.n	8006192 <main+0x922>
 800618e:	4298      	cmp	r0, r3
 8006190:	d92c      	bls.n	80061ec <main+0x97c>
 8006192:	b10a      	cbz	r2, 8006198 <main+0x928>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8006194:	4290      	cmp	r0, r2
 8006196:	d229      	bcs.n	80061ec <main+0x97c>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8006198:	f847 2c08 	str.w	r2, [r7, #-8]
      H_NEXT(qp) = hp;
 800619c:	6018      	str	r0, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800619e:	f857 cc04 	ldr.w	ip, [r7, #-4]
 80061a2:	f857 2c08 	ldr.w	r2, [r7, #-8]
 80061a6:	f10c 0e01 	add.w	lr, ip, #1
 80061aa:	eb00 0bce 	add.w	fp, r0, lr, lsl #3
 80061ae:	4593      	cmp	fp, r2
 80061b0:	d109      	bne.n	80061c6 <main+0x956>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80061b2:	f8db 2004 	ldr.w	r2, [fp, #4]
 80061b6:	4462      	add	r2, ip
 80061b8:	3201      	adds	r2, #1
 80061ba:	f847 2c04 	str.w	r2, [r7, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80061be:	f850 203e 	ldr.w	r2, [r0, lr, lsl #3]
 80061c2:	f847 2c08 	str.w	r2, [r7, #-8]
      }
      if ((H_LIMIT(qp) == hp)) {
 80061c6:	685a      	ldr	r2, [r3, #4]
 80061c8:	f102 0e01 	add.w	lr, r2, #1
 80061cc:	eb03 0ece 	add.w	lr, r3, lr, lsl #3
 80061d0:	4570      	cmp	r0, lr
 80061d2:	d107      	bne.n	80061e4 <main+0x974>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80061d4:	f857 0c04 	ldr.w	r0, [r7, #-4]
 80061d8:	4402      	add	r2, r0
 80061da:	3201      	adds	r2, #1
 80061dc:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80061de:	f857 2c08 	ldr.w	r2, [r7, #-8]
 80061e2:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80061e4:	4608      	mov	r0, r1
 80061e6:	f003 f9cb 	bl	8009580 <chMtxUnlock>
 80061ea:	e652      	b.n	8005e92 <main+0x622>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 80061ec:	4613      	mov	r3, r2
 80061ee:	e7c2      	b.n	8006176 <main+0x906>
 80061f0:	20019980 	.word	0x20019980
 80061f4:	0800fabc 	.word	0x0800fabc
 80061f8:	2001acdc 	.word	0x2001acdc
 80061fc:	40021400 	.word	0x40021400
 8006200:	2001b720 	.word	0x2001b720
 8006204:	20000800 	.word	0x20000800
 8006208:	40021000 	.word	0x40021000
 800620c:	40020400 	.word	0x40020400
 8006210:	0800fb14 	.word	0x0800fb14
 8006214:	2001ac28 	.word	0x2001ac28
 8006218:	0800eaa8 	.word	0x0800eaa8
 800621c:	0800ea50 	.word	0x0800ea50
 8006220:	0800f1dc 	.word	0x0800f1dc
 8006224:	0800ea64 	.word	0x0800ea64
 8006228:	0800f878 	.word	0x0800f878
 800622c:	0800ea7c 	.word	0x0800ea7c
 8006230:	0800f1e0 	.word	0x0800f1e0
 8006234:	0800f880 	.word	0x0800f880
 8006238:	0800f890 	.word	0x0800f890
 800623c:	2001b564 	.word	0x2001b564
 8006240:	0800fae0 	.word	0x0800fae0
 8006244:	0800faec 	.word	0x0800faec

  /* This also triggers a refresh.*/
  wdgp->wdg->WINR = wdgp->config->winr;
#else
  /* Unlock IWDG.*/
  wdgp->wdg->KR   = KR_KEY_WRITE;
 8006248:	6893      	ldr	r3, [r2, #8]
                "invalid state");
  wdgp->config = config;
 800624a:	49d8      	ldr	r1, [pc, #864]	; (80065ac <main+0xd3c>)
 800624c:	6051      	str	r1, [r2, #4]
 800624e:	f245 5255 	movw	r2, #21845	; 0x5555
 8006252:	601a      	str	r2, [r3, #0]

  /* Write configuration.*/
  while (wdgp->wdg->SR != 0)
 8006254:	68da      	ldr	r2, [r3, #12]
 8006256:	2a00      	cmp	r2, #0
 8006258:	d1fc      	bne.n	8006254 <main+0x9e4>
    ;
  wdgp->wdg->PR   = wdgp->config->pr;
  wdgp->wdg->RLR  = wdgp->config->rlr;
 800625a:	f242 7210 	movw	r2, #10000	; 0x2710

  /* Start operations.*/
  wdgp->wdg->KR   = KR_KEY_RELOAD;
 800625e:	f64a 20aa 	movw	r0, #43690	; 0xaaaa
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 8006262:	f64c 41cc 	movw	r1, #52428	; 0xcccc
  wdgp->wdg->KR   = KR_KEY_WRITE;

  /* Write configuration.*/
  while (wdgp->wdg->SR != 0)
    ;
  wdgp->wdg->PR   = wdgp->config->pr;
 8006266:	2606      	movs	r6, #6
 8006268:	605e      	str	r6, [r3, #4]
  wdgp->wdg->RLR  = wdgp->config->rlr;
 800626a:	609a      	str	r2, [r3, #8]

  /* Start operations.*/
  wdgp->wdg->KR   = KR_KEY_RELOAD;
 800626c:	6018      	str	r0, [r3, #0]
  wdg_lld_start(wdgp);
  wdgp->state = WDG_READY;
 800626e:	2202      	movs	r2, #2
  wdgp->wdg->KR   = KR_KEY_ENABLE;
 8006270:	6019      	str	r1, [r3, #0]
 8006272:	702a      	strb	r2, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8006274:	f005 ff74 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8006278:	6823      	ldr	r3, [r4, #0]
 800627a:	4acd      	ldr	r2, [pc, #820]	; (80065b0 <main+0xd40>)
 800627c:	42a3      	cmp	r3, r4
 800627e:	d005      	beq.n	800628c <main+0xa1c>
 8006280:	6992      	ldr	r2, [r2, #24]
 8006282:	689b      	ldr	r3, [r3, #8]
 8006284:	6892      	ldr	r2, [r2, #8]
 8006286:	429a      	cmp	r2, r3
 8006288:	f0c0 84dd 	bcc.w	8006c46 <main+0x13d6>
 800628c:	2600      	movs	r6, #0
 800628e:	f386 8811 	msr	BASEPRI, r6
 8006292:	f04f 4a80 	mov.w	sl, #1073741824	; 0x40000000
	wdgStart(&WDGD1, &wdgcfg);
	wdgReset(&WDGD1);
 8006296:	f004 fd53 	bl	800ad40 <wdgReset.constprop.35>
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
}

void pi2cInit(void)
{
	TRACE_INFO("I2C  > Initialize I2C");
 800629a:	48c6      	ldr	r0, [pc, #792]	; (80065b4 <main+0xd44>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800629c:	f8df b380 	ldr.w	fp, [pc, #896]	; 8006620 <main+0xdb0>
 80062a0:	f8df 8380 	ldr.w	r8, [pc, #896]	; 8006624 <main+0xdb4>

// Put your configuration settings here
void initModules(void)
{
	// Module POSITION, APRS 2m AFSK
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
 80062a4:	4dc4      	ldr	r5, [pc, #784]	; (80065b8 <main+0xd48>)
 80062a6:	f005 ff7b 	bl	800c1a0 <chMtxLock>
 80062aa:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 80062ae:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 80062b2:	49c2      	ldr	r1, [pc, #776]	; (80065bc <main+0xd4c>)
 80062b4:	48c2      	ldr	r0, [pc, #776]	; (80065c0 <main+0xd50>)
 80062b6:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 80062ba:	f242 7910 	movw	r9, #10000	; 0x2710
 80062be:	fb07 f303 	mul.w	r3, r7, r3
 80062c2:	fbb2 f2f9 	udiv	r2, r2, r9
 80062c6:	fbb3 f3f9 	udiv	r3, r3, r9
 80062ca:	fbb3 fef7 	udiv	lr, r3, r7
 80062ce:	fb07 331e 	mls	r3, r7, lr, r3
 80062d2:	f004 f9dd 	bl	800a690 <chprintf.constprop.26>
 80062d6:	4abb      	ldr	r2, [pc, #748]	; (80065c4 <main+0xd54>)
 80062d8:	49bb      	ldr	r1, [pc, #748]	; (80065c8 <main+0xd58>)
 80062da:	48b9      	ldr	r0, [pc, #740]	; (80065c0 <main+0xd50>)
	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
 80062dc:	4fbb      	ldr	r7, [pc, #748]	; (80065cc <main+0xd5c>)
 80062de:	f004 f9d7 	bl	800a690 <chprintf.constprop.26>
 80062e2:	2326      	movs	r3, #38	; 0x26
 80062e4:	4aba      	ldr	r2, [pc, #744]	; (80065d0 <main+0xd60>)
 80062e6:	49bb      	ldr	r1, [pc, #748]	; (80065d4 <main+0xd64>)
 80062e8:	48b5      	ldr	r0, [pc, #724]	; (80065c0 <main+0xd50>)
 80062ea:	f004 f9d1 	bl	800a690 <chprintf.constprop.26>
 80062ee:	49ba      	ldr	r1, [pc, #744]	; (80065d8 <main+0xd68>)
 80062f0:	48b3      	ldr	r0, [pc, #716]	; (80065c0 <main+0xd50>)
 80062f2:	f004 f9cd 	bl	800a690 <chprintf.constprop.26>
 80062f6:	49b9      	ldr	r1, [pc, #740]	; (80065dc <main+0xd6c>)
 80062f8:	48b1      	ldr	r0, [pc, #708]	; (80065c0 <main+0xd50>)
 80062fa:	f004 f9c9 	bl	800a690 <chprintf.constprop.26>
 80062fe:	49b8      	ldr	r1, [pc, #736]	; (80065e0 <main+0xd70>)
 8006300:	48af      	ldr	r0, [pc, #700]	; (80065c0 <main+0xd50>)
 8006302:	f004 f9c5 	bl	800a690 <chprintf.constprop.26>
 8006306:	48ab      	ldr	r0, [pc, #684]	; (80065b4 <main+0xd44>)
 8006308:	f003 f93a 	bl	8009580 <chMtxUnlock>
	i2cStart(&I2CD1, &_i2cfg);
 800630c:	f004 fa98 	bl	800a840 <i2cStart.constprop.66>
 8006310:	f8df c314 	ldr.w	ip, [pc, #788]	; 8006628 <main+0xdb8>
 8006314:	f8df e314 	ldr.w	lr, [pc, #788]	; 800662c <main+0xdbc>
 8006318:	f8cc c000 	str.w	ip, [ip]
  tqp->prev = (thread_t *)tqp;
 800631c:	f8cc c004 	str.w	ip, [ip, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006320:	f8ce e000 	str.w	lr, [lr]
  tqp->prev = (thread_t *)tqp;
 8006324:	f8ce e004 	str.w	lr, [lr, #4]

	pi2cInit();					// Startup I2C
	initEssentialModules();		// Startup required modules (input/output modules)
 8006328:	4633      	mov	r3, r6
 800632a:	4aae      	ldr	r2, [pc, #696]	; (80065e4 <main+0xd74>)
 800632c:	49ae      	ldr	r1, [pc, #696]	; (80065e8 <main+0xd78>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800632e:	f8cb b000 	str.w	fp, [fp]
  tqp->prev = (thread_t *)tqp;
 8006332:	f8cb b004 	str.w	fp, [fp, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006336:	f8c8 8000 	str.w	r8, [r8]
  tqp->prev = (thread_t *)tqp;
 800633a:	f8c8 8004 	str.w	r8, [r8, #4]
 800633e:	f241 00c8 	movw	r0, #4296	; 0x10c8
 8006342:	f8cc 6008 	str.w	r6, [ip, #8]
 8006346:	f8ce 6008 	str.w	r6, [lr, #8]
 800634a:	f8cb 6008 	str.w	r6, [fp, #8]
 800634e:	f8c8 6008 	str.w	r6, [r8, #8]
 8006352:	f004 f9b5 	bl	800a6c0 <chThdCreateFromHeap.constprop.86>
 8006356:	4648      	mov	r0, r9
 8006358:	f005 fff2 	bl	800c340 <chThdSleep>

// Put your configuration settings here
void initModules(void)
{
	// Module POSITION, APRS 2m AFSK
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
 800635c:	4628      	mov	r0, r5
 800635e:	4aa3      	ldr	r2, [pc, #652]	; (80065ec <main+0xd7c>)
 8006360:	2111      	movs	r1, #17
 8006362:	f001 fa55 	bl	8007810 <chsnprintf>
	config[0].power = 20;									// Power 20 dBm
 8006366:	f04f 0314 	mov.w	r3, #20
 800636a:	f885 3020 	strb.w	r3, [r5, #32]
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
 800636e:	4ba0      	ldr	r3, [pc, #640]	; (80065f0 <main+0xd80>)
 8006370:	62ab      	str	r3, [r5, #40]	; 0x28
void initModules(void)
{
	// Module POSITION, APRS 2m AFSK
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
	config[0].power = 20;									// Power 20 dBm
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
 8006372:	f04f 0801 	mov.w	r8, #1
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 8006376:	4b9f      	ldr	r3, [pc, #636]	; (80065f4 <main+0xd84>)
	config[0].init_delay = 0;								// Module startup delay in msec
 8006378:	636e      	str	r6, [r5, #52]	; 0x34
void initModules(void)
{
	// Module POSITION, APRS 2m AFSK
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
	config[0].power = 20;									// Power 20 dBm
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
 800637a:	f885 8030 	strb.w	r8, [r5, #48]	; 0x30
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
 800637e:	f885 8024 	strb.w	r8, [r5, #36]	; 0x24
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[0].init_delay = 0;								// Module startup delay in msec
	config[0].trigger.type = TRIG_EVENT;					// Trigger transmission on event
 8006382:	f885 8044 	strb.w	r8, [r5, #68]	; 0x44
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
 8006386:	f885 804c 	strb.w	r8, [r5, #76]	; 0x4c
	chsnprintf(config[0].name, 17, "POS APRS 2m AFSK");		// Instance name
	config[0].power = 20;									// Power 20 dBm
	config[0].protocol = PROT_APRS_AFSK;					// Protocol APRS, modulation AFSK
	config[0].frequency.type = FREQ_DYNAMIC;				// Dynamic frequency allocation
	config[0].frequency.hz = 144800000;						// Default frequency 144.800 MHz
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 800638a:	62eb      	str	r3, [r5, #44]	; 0x2c
	config[0].init_delay = 0;								// Module startup delay in msec
	config[0].trigger.type = TRIG_EVENT;					// Trigger transmission on event
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
 800638c:	f105 0058 	add.w	r0, r5, #88	; 0x58
 8006390:	4a99      	ldr	r2, [pc, #612]	; (80065f8 <main+0xd88>)
 8006392:	2107      	movs	r1, #7
 8006394:	f001 fa3c 	bl	8007810 <chsnprintf>
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
 8006398:	f642 734f 	movw	r3, #12111	; 0x2f4f
 800639c:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
	config[0].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[0].init_delay = 0;								// Module startup delay in msec
	config[0].trigger.type = TRIG_EVENT;					// Trigger transmission on event
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
 80063a0:	f04f 030b 	mov.w	r3, #11
 80063a4:	f885 3068 	strb.w	r3, [r5, #104]	; 0x68
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
 80063a8:	f105 006c 	add.w	r0, r5, #108	; 0x6c
 80063ac:	4a93      	ldr	r2, [pc, #588]	; (80065fc <main+0xd8c>)
 80063ae:	2110      	movs	r1, #16
 80063b0:	f001 fa2e 	bl	8007810 <chsnprintf>
	config[0].aprs_config.preamble = 300;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_PBAT;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_PRESS;				// APRS Telemetry parameter 3
 80063b4:	2306      	movs	r3, #6
	chsnprintf(config[0].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 300;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
 80063b6:	f04f 0b02 	mov.w	fp, #2
	config[0].aprs_config.tel[1] = TEL_PBAT;				// APRS Telemetry parameter 2
 80063ba:	f04f 0e04 	mov.w	lr, #4
	config[0].aprs_config.tel[2] = TEL_PRESS;				// APRS Telemetry parameter 3
 80063be:	f885 3080 	strb.w	r3, [r5, #128]	; 0x80
 80063c2:	9307      	str	r3, [sp, #28]
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 300;					// APRS Preamble
 80063c4:	f44f 7096 	mov.w	r0, #300	; 0x12c
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_PBAT;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_PRESS;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_TEMP;				// APRS Telemetry parameter 4
 80063c8:	f04f 0307 	mov.w	r3, #7
	config[0].aprs_config.tel[4] = TEL_HUM;					// APRS Telemetry parameter 5
 80063cc:	2208      	movs	r2, #8
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
 80063ce:	f44f 6161 	mov.w	r1, #3600	; 0xe10
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 300;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_PBAT;				// APRS Telemetry parameter 2
 80063d2:	f885 e07f 	strb.w	lr, [r5, #127]	; 0x7f
	config[0].aprs_config.tel[2] = TEL_PRESS;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_TEMP;				// APRS Telemetry parameter 4
 80063d6:	f885 3081 	strb.w	r3, [r5, #129]	; 0x81
	config[0].aprs_config.tel[4] = TEL_HUM;					// APRS Telemetry parameter 5
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
 80063da:	f885 8083 	strb.w	r8, [r5, #131]	; 0x83
	config[0].trigger.event = EVENT_NEW_POINT;				// Trigger when new track point released
	chsnprintf(config[0].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 300;					// APRS Preamble
 80063de:	f8a5 007c 	strh.w	r0, [r5, #124]	; 0x7c
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
	config[0].aprs_config.tel[1] = TEL_PBAT;				// APRS Telemetry parameter 2
	config[0].aprs_config.tel[2] = TEL_PRESS;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_TEMP;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_HUM;					// APRS Telemetry parameter 5
 80063e2:	f885 2082 	strb.w	r2, [r5, #130]	; 0x82
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
 80063e6:	f8a5 1084 	strh.w	r1, [r5, #132]	; 0x84
	chsnprintf(config[0].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[0].aprs_config.ssid = 11;						// APRS SSID
	config[0].aprs_config.symbol = SYM_BALLOON;				// APRS Symbol
	chsnprintf(config[0].aprs_config.path, 16, "WIDE1-1");	// APRS Path
	config[0].aprs_config.preamble = 300;					// APRS Preamble
	config[0].aprs_config.tel[0] = TEL_VBAT;				// APRS Telemetry parameter 1
 80063ea:	f885 b07e 	strb.w	fp, [r5, #126]	; 0x7e
	config[0].aprs_config.tel[2] = TEL_PRESS;				// APRS Telemetry parameter 3
	config[0].aprs_config.tel[3] = TEL_TEMP;				// APRS Telemetry parameter 4
	config[0].aprs_config.tel[4] = TEL_HUM;					// APRS Telemetry parameter 5
	config[0].aprs_config.tel_encoding = TRUE;				// Transmit Telemetry encoding information activated
	config[0].aprs_config.tel_encoding_cycle = 3600;		// Transmit Telemetry encoding information every 3600sec
	chsnprintf(config[0].aprs_config.tel_comment, 18, "http://tkrahn.org");// Telemetry comment
 80063ee:	f105 0086 	add.w	r0, r5, #134	; 0x86
 80063f2:	4a83      	ldr	r2, [pc, #524]	; (8006600 <main+0xd90>)
 80063f4:	2112      	movs	r1, #18
 80063f6:	f001 fa0b 	bl	8007810 <chsnprintf>
	chsnprintf(config[2].ukhas_config.callsign, 6, "DK0TU");// UKHAS Callsign
	chsnprintf(config[2].ukhas_config.format, 94, "<CALL>,<ID>,<TIME>,<LAT>,<LON>,<ALT>,<SATS>,<TTFF>,<VBAT>,<PBAT>,<PRESS>,<TEMP>,<HUM>"); // UKHAS Format
	MODULE_POSITION(&config[2]);*/

	// Module IMAGE, APRS 2m AFSK low-duty cycle
	chsnprintf(config[3].name, 12, "IMG AFSK 2m");			// Instance name
 80063fa:	f505 60a5 	add.w	r0, r5, #1320	; 0x528
 80063fe:	4a81      	ldr	r2, [pc, #516]	; (8006604 <main+0xd94>)
 8006400:	210c      	movs	r1, #12
 8006402:	f001 fa05 	bl	8007810 <chsnprintf>
	config[3].power = 20;									// Power 20 dBm
 8006406:	f04f 0314 	mov.w	r3, #20
 800640a:	f885 3548 	strb.w	r3, [r5, #1352]	; 0x548
	config[3].protocol = PROT_APRS_AFSK;					// Protocol APRS SSDV, modulation AFSK
	config[3].frequency.type = FREQ_DYNAMIC;				// Static frequency allocation
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
 800640e:	4b78      	ldr	r3, [pc, #480]	; (80065f0 <main+0xd80>)
 8006410:	f8c5 3550 	str.w	r3, [r5, #1360]	; 0x550
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
 8006414:	4b77      	ldr	r3, [pc, #476]	; (80065f4 <main+0xd84>)
 8006416:	f8c5 3554 	str.w	r3, [r5, #1364]	; 0x554
	config[3].init_delay = 10000;							// Module startup delay in msec
	config[3].packet_spacing = 20000;						// Packet spacing in ms
 800641a:	f644 6e20 	movw	lr, #20000	; 0x4e20
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[3].trigger.timeout = 10;							// Timeout 10 sec
 800641e:	230a      	movs	r3, #10
	MODULE_POSITION(&config[2]);*/

	// Module IMAGE, APRS 2m AFSK low-duty cycle
	chsnprintf(config[3].name, 12, "IMG AFSK 2m");			// Instance name
	config[3].power = 20;									// Power 20 dBm
	config[3].protocol = PROT_APRS_AFSK;					// Protocol APRS SSDV, modulation AFSK
 8006420:	f885 8558 	strb.w	r8, [r5, #1368]	; 0x558
	config[3].frequency.type = FREQ_DYNAMIC;				// Static frequency allocation
 8006424:	f885 854c 	strb.w	r8, [r5, #1356]	; 0x54c
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[3].init_delay = 10000;							// Module startup delay in msec
 8006428:	f8c5 955c 	str.w	r9, [r5, #1372]	; 0x55c
	config[3].packet_spacing = 20000;						// Packet spacing in ms
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
 800642c:	f885 b56c 	strb.w	fp, [r5, #1388]	; 0x56c
	config[3].protocol = PROT_APRS_AFSK;					// Protocol APRS SSDV, modulation AFSK
	config[3].frequency.type = FREQ_DYNAMIC;				// Static frequency allocation
	config[3].frequency.hz = 144800000;						// Transmission frequency 144.800 MHz
	config[3].frequency.method = APRS_REGION_FREQ_2M;		// Determine local APRS frequency on 2m
	config[3].init_delay = 10000;							// Module startup delay in msec
	config[3].packet_spacing = 20000;						// Packet spacing in ms
 8006430:	f8c5 e560 	str.w	lr, [r5, #1376]	; 0x560
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[3].trigger.timeout = 10;							// Timeout 10 sec
 8006434:	f8c5 3570 	str.w	r3, [r5, #1392]	; 0x570
	chsnprintf(config[3].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
 8006438:	2107      	movs	r1, #7
 800643a:	f505 60b0 	add.w	r0, r5, #1408	; 0x580
 800643e:	4a6e      	ldr	r2, [pc, #440]	; (80065f8 <main+0xd88>)
 8006440:	f001 f9e6 	bl	8007810 <chsnprintf>
	config[3].aprs_config.ssid = 11;						// APRS SSID
	config[3].aprs_config.preamble = 200;					// APRS Preamble
 8006444:	f04f 0ec8 	mov.w	lr, #200	; 0xc8
	config[3].init_delay = 10000;							// Module startup delay in msec
	config[3].packet_spacing = 20000;						// Packet spacing in ms
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[3].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[3].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[3].aprs_config.ssid = 11;						// APRS SSID
 8006448:	f04f 030b 	mov.w	r3, #11
	config[3].aprs_config.preamble = 200;					// APRS Preamble
 800644c:	f8a5 e5a4 	strh.w	lr, [r5, #1444]	; 0x5a4
	config[3].init_delay = 10000;							// Module startup delay in msec
	config[3].packet_spacing = 20000;						// Packet spacing in ms
	config[3].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[3].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[3].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[3].aprs_config.ssid = 11;						// APRS SSID
 8006450:	f885 3590 	strb.w	r3, [r5, #1424]	; 0x590
	config[3].aprs_config.preamble = 200;					// APRS Preamble
	chsnprintf(config[3].ssdv_config.callsign, 7, "LU4CMF");// SSDV Callsign
 8006454:	2107      	movs	r1, #7
 8006456:	f205 6034 	addw	r0, r5, #1588	; 0x634
 800645a:	4a67      	ldr	r2, [pc, #412]	; (80065f8 <main+0xd88>)
 800645c:	f001 f9d8 	bl	8007810 <chsnprintf>
	config[3].ssdv_config.ram_buffer = ssdv_buffer;		// Camera buffer
 8006460:	4b69      	ldr	r3, [pc, #420]	; (8006608 <main+0xd98>)
 8006462:	f8c5 3640 	str.w	r3, [r5, #1600]	; 0x640
	config[3].ssdv_config.ram_size = sizeof(ssdv_buffer);	// Buffer size
 8006466:	f44f 33c8 	mov.w	r3, #102400	; 0x19000
	config[3].ssdv_config.res = RES_QVGA;					// Resolution QVGA
 800646a:	f885 863c 	strb.w	r8, [r5, #1596]	; 0x63c
	chsnprintf(config[3].aprs_config.callsign, 7, "LU4CMF");// APRS Callsign
	config[3].aprs_config.ssid = 11;						// APRS SSID
	config[3].aprs_config.preamble = 200;					// APRS Preamble
	chsnprintf(config[3].ssdv_config.callsign, 7, "LU4CMF");// SSDV Callsign
	config[3].ssdv_config.ram_buffer = ssdv_buffer;		// Camera buffer
	config[3].ssdv_config.ram_size = sizeof(ssdv_buffer);	// Buffer size
 800646e:	f8c5 3644 	str.w	r3, [r5, #1604]	; 0x644
	chsnprintf(config[4].morse_config.callsign, 6, "DK0TU");// Morse Callsign
	chsnprintf(config[4].morse_config.format, 43, "BALLOON <CALL> <LOC> <ALT>M WWW.TKRAHN.NET"); // Morse Format
	MODULE_POSITION(&config[4]);*/

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
 8006472:	f605 0098 	addw	r0, r5, #2200	; 0x898
 8006476:	4a65      	ldr	r2, [pc, #404]	; (800660c <main+0xd9c>)
 8006478:	210d      	movs	r1, #13
 800647a:	f001 f9c9 	bl	8007810 <chsnprintf>
	config[5].init_delay = 0;								// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 800647e:	9b07      	ldr	r3, [sp, #28]

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
 8006480:	f885 68bc 	strb.w	r6, [r5, #2236]	; 0x8bc
	config[5].init_delay = 0;								// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 8006484:	4619      	mov	r1, r3
	chsnprintf(config[4].morse_config.format, 43, "BALLOON <CALL> <LOC> <ALT>M WWW.TKRAHN.NET"); // Morse Format
	MODULE_POSITION(&config[4]);*/

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
 8006486:	f04f 0314 	mov.w	r3, #20
 800648a:	f885 38b8 	strb.w	r3, [r5, #2232]	; 0x8b8
	config[5].frequency.method = FREQ_STATIC;				// Determine local APRS frequency on 2m
	config[5].init_delay = 0;								// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
 800648e:	230a      	movs	r3, #10
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
	config[5].frequency.method = FREQ_STATIC;				// Determine local APRS frequency on 2m
 8006490:	f8c5 68c4 	str.w	r6, [r5, #2244]	; 0x8c4
	config[5].init_delay = 0;								// Module startup delay in msec
 8006494:	f8c5 68cc 	str.w	r6, [r5, #2252]	; 0x8cc
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
 8006498:	f8a5 68d6 	strh.w	r6, [r5, #2262]	; 0x8d6
	MODULE_POSITION(&config[4]);*/

	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
 800649c:	f885 b8c8 	strb.w	fp, [r5, #2248]	; 0x8c8
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
	config[5].frequency.method = FREQ_STATIC;				// Determine local APRS frequency on 2m
	config[5].init_delay = 0;								// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
 80064a0:	f885 88d4 	strb.w	r8, [r5, #2260]	; 0x8d4
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
 80064a4:	f885 b8dc 	strb.w	fp, [r5, #2268]	; 0x8dc
	config[5].trigger.timeout = 10;							// Timeout 10 sec
 80064a8:	f8c5 38e0 	str.w	r3, [r5, #2272]	; 0x8e0
	// Module IMAGE, APRS 2m 2GFSK
	chsnprintf(config[5].name, 13, "IMG 2GFSK 2m");			// Instance name
	config[5].power = 20;									// Power 20 dBm
	config[5].protocol = PROT_APRS_2GFSK;					// Protocol APRS SSDV, modulation 2GFSK
	config[5].frequency.type = FREQ_STATIC;					// Static frequency allocation
	config[5].frequency.hz = 144860000;						// Transmission frequency 144.860 MHz
 80064ac:	f8c5 78c0 	str.w	r7, [r5, #2240]	; 0x8c0
	config[5].init_delay = 0;								// Module startup delay in msec
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
 80064b0:	4a57      	ldr	r2, [pc, #348]	; (8006610 <main+0xda0>)
 80064b2:	f505 600f 	add.w	r0, r5, #2288	; 0x8f0
 80064b6:	f001 f9ab 	bl	8007810 <chsnprintf>
	config[5].aprs_config.ssid = 14;						// APRS SSID
	config[5].aprs_config.preamble = 20;					// APRS Preamble
 80064ba:	f04f 0714 	mov.w	r7, #20
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 14;						// APRS SSID
 80064be:	230e      	movs	r3, #14
	config[5].aprs_config.preamble = 20;					// APRS Preamble
 80064c0:	f8a5 7914 	strh.w	r7, [r5, #2324]	; 0x914
	config[5].sleep_config.type = SLEEP_WHEN_VBAT_BELOW_THRES;// Sleeping type
	config[5].sleep_config.vbat_thres = 0;					// Sleeping voltage threshold
	config[5].trigger.type = TRIG_TIMEOUT;					// Trigger transmission on timeout (Periodic cycling)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 14;						// APRS SSID
 80064c4:	f885 3900 	strb.w	r3, [r5, #2304]	; 0x900
	config[5].aprs_config.preamble = 20;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 7, "DL7AD"); // SSDV Callsign
 80064c8:	2107      	movs	r1, #7
 80064ca:	f605 10a4 	addw	r0, r5, #2468	; 0x9a4
 80064ce:	4a50      	ldr	r2, [pc, #320]	; (8006610 <main+0xda0>)
 80064d0:	f001 f99e 	bl	8007810 <chsnprintf>
	config[5].ssdv_config.ram_buffer = ssdv_buffer;			// Camera buffer
	config[5].ssdv_config.ram_size = sizeof(ssdv_buffer);	// Buffer size
 80064d4:	f44f 37c8 	mov.w	r7, #102400	; 0x19000
	config[5].ssdv_config.res = RES_VGA;					// Resolution VGA
	MODULE_IMAGE(&config[5]);
 80064d8:	f605 0398 	addw	r3, r5, #2200	; 0x898
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 14;						// APRS SSID
	config[5].aprs_config.preamble = 20;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 7, "DL7AD"); // SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv_buffer;			// Camera buffer
 80064dc:	484a      	ldr	r0, [pc, #296]	; (8006608 <main+0xd98>)
	config[5].ssdv_config.ram_size = sizeof(ssdv_buffer);	// Buffer size
	config[5].ssdv_config.res = RES_VGA;					// Resolution VGA
	MODULE_IMAGE(&config[5]);
 80064de:	4a4d      	ldr	r2, [pc, #308]	; (8006614 <main+0xda4>)
	config[5].trigger.timeout = 10;							// Timeout 10 sec
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 14;						// APRS SSID
	config[5].aprs_config.preamble = 20;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 7, "DL7AD"); // SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv_buffer;			// Camera buffer
 80064e0:	f8c5 09b0 	str.w	r0, [r5, #2480]	; 0x9b0
	config[5].ssdv_config.ram_size = sizeof(ssdv_buffer);	// Buffer size
	config[5].ssdv_config.res = RES_VGA;					// Resolution VGA
	MODULE_IMAGE(&config[5]);
 80064e4:	4619      	mov	r1, r3
	chsnprintf(config[5].aprs_config.callsign, 6, "DL7AD");	// APRS Callsign
	config[5].aprs_config.ssid = 14;						// APRS SSID
	config[5].aprs_config.preamble = 20;					// APRS Preamble
	chsnprintf(config[5].ssdv_config.callsign, 7, "DL7AD"); // SSDV Callsign
	config[5].ssdv_config.ram_buffer = ssdv_buffer;			// Camera buffer
	config[5].ssdv_config.ram_size = sizeof(ssdv_buffer);	// Buffer size
 80064e6:	f8c5 79b4 	str.w	r7, [r5, #2484]	; 0x9b4
	config[5].ssdv_config.res = RES_VGA;					// Resolution VGA
 80064ea:	f885 b9ac 	strb.w	fp, [r5, #2476]	; 0x9ac
	MODULE_IMAGE(&config[5]);
 80064ee:	f243 00c8 	movw	r0, #12488	; 0x30c8
 80064f2:	f004 f8e5 	bl	800a6c0 <chThdCreateFromHeap.constprop.86>
 80064f6:	f885 8a4c 	strb.w	r8, [r5, #2636]	; 0xa4c
	}
}

void pac1720_init(void)
{
	TRACE_INFO("PAC  > Init PAC1720");
 80064fa:	482e      	ldr	r0, [pc, #184]	; (80065b4 <main+0xd44>)
 80064fc:	f005 fe50 	bl	800c1a0 <chMtxLock>
 8006500:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 8006504:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 8006508:	fbb2 f2f9 	udiv	r2, r2, r9
 800650c:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8006510:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8006514:	fb01 f303 	mul.w	r3, r1, r3
 8006518:	4829      	ldr	r0, [pc, #164]	; (80065c0 <main+0xd50>)
 800651a:	fbb3 f3f9 	udiv	r3, r3, r9
 800651e:	4927      	ldr	r1, [pc, #156]	; (80065bc <main+0xd4c>)
 8006520:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8006524:	fbb3 f5f5 	udiv	r5, r3, r5
 8006528:	fb07 3315 	mls	r3, r7, r5, r3
 800652c:	f004 f8b0 	bl	800a690 <chprintf.constprop.26>
 8006530:	4a24      	ldr	r2, [pc, #144]	; (80065c4 <main+0xd54>)
 8006532:	4925      	ldr	r1, [pc, #148]	; (80065c8 <main+0xd58>)
 8006534:	4822      	ldr	r0, [pc, #136]	; (80065c0 <main+0xd50>)
 8006536:	f004 f8ab 	bl	800a690 <chprintf.constprop.26>
 800653a:	2370      	movs	r3, #112	; 0x70
 800653c:	4a36      	ldr	r2, [pc, #216]	; (8006618 <main+0xda8>)
 800653e:	4925      	ldr	r1, [pc, #148]	; (80065d4 <main+0xd64>)
 8006540:	481f      	ldr	r0, [pc, #124]	; (80065c0 <main+0xd50>)
 8006542:	f004 f8a5 	bl	800a690 <chprintf.constprop.26>
 8006546:	4924      	ldr	r1, [pc, #144]	; (80065d8 <main+0xd68>)
 8006548:	481d      	ldr	r0, [pc, #116]	; (80065c0 <main+0xd50>)
 800654a:	f004 f8a1 	bl	800a690 <chprintf.constprop.26>
 800654e:	4933      	ldr	r1, [pc, #204]	; (800661c <main+0xdac>)
 8006550:	481b      	ldr	r0, [pc, #108]	; (80065c0 <main+0xd50>)
 8006552:	f004 f89d 	bl	800a690 <chprintf.constprop.26>
 8006556:	4922      	ldr	r1, [pc, #136]	; (80065e0 <main+0xd70>)
 8006558:	4819      	ldr	r0, [pc, #100]	; (80065c0 <main+0xd50>)
 800655a:	f004 f899 	bl	800a690 <chprintf.constprop.26>
 800655e:	4815      	ldr	r0, [pc, #84]	; (80065b4 <main+0xd44>)
 8006560:	f003 f80e 	bl	8009580 <chMtxUnlock>
	/* Write for both channels
	 * Current sensor sampling time	80ms (Denominator 2047)
	 * Current sensing average disabled
	 * Current sensing range +-80mV (FSR)
	 */
	I2C_write8(PAC1720_ADDRESS, PAC1720_CH1_VSENSE_SAMP_CONFIG, 0x53);
 8006564:	210b      	movs	r1, #11
 8006566:	2253      	movs	r2, #83	; 0x53
 8006568:	204c      	movs	r0, #76	; 0x4c
 800656a:	f006 f8a9 	bl	800c6c0 <I2C_write8>
	I2C_write8(PAC1720_ADDRESS, PAC1720_CH2_VSENSE_SAMP_CONFIG, 0x53);
 800656e:	2253      	movs	r2, #83	; 0x53
 8006570:	210c      	movs	r1, #12
 8006572:	204c      	movs	r0, #76	; 0x4c
 8006574:	f006 f8a4 	bl	800c6c0 <I2C_write8>
	I2C_write8(PAC1720_ADDRESS, PAC1720_V_SOURCE_SAMP_CONFIG,   0xFF);
 8006578:	210a      	movs	r1, #10
 800657a:	22ff      	movs	r2, #255	; 0xff
 800657c:	204c      	movs	r0, #76	; 0x4c
 800657e:	f006 f89f 	bl	800c6c0 <I2C_write8>

	TRACE_INFO("PAC  > Init PAC1720 continuous measurement");
 8006582:	480c      	ldr	r0, [pc, #48]	; (80065b4 <main+0xd44>)
 8006584:	f005 fe0c 	bl	800c1a0 <chMtxLock>
 8006588:	f8da 2024 	ldr.w	r2, [sl, #36]	; 0x24
 800658c:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 8006590:	fbb2 f2f9 	udiv	r2, r2, r9
 8006594:	fb07 f303 	mul.w	r3, r7, r3
 8006598:	4908      	ldr	r1, [pc, #32]	; (80065bc <main+0xd4c>)
 800659a:	fbb3 f9f9 	udiv	r9, r3, r9
 800659e:	4808      	ldr	r0, [pc, #32]	; (80065c0 <main+0xd50>)
 80065a0:	fbb9 f3f7 	udiv	r3, r9, r7
 80065a4:	fb07 9313 	mls	r3, r7, r3, r9
 80065a8:	e042      	b.n	8006630 <main+0xdc0>
 80065aa:	bf00      	nop
 80065ac:	0800f868 	.word	0x0800f868
 80065b0:	2001acdc 	.word	0x2001acdc
 80065b4:	2001b720 	.word	0x2001b720
 80065b8:	20019a58 	.word	0x20019a58
 80065bc:	0800ea50 	.word	0x0800ea50
 80065c0:	2001ac28 	.word	0x2001ac28
 80065c4:	0800f1dc 	.word	0x0800f1dc
 80065c8:	0800ea64 	.word	0x0800ea64
 80065cc:	08a26360 	.word	0x08a26360
 80065d0:	0800f8bc 	.word	0x0800f8bc
 80065d4:	0800ea7c 	.word	0x0800ea7c
 80065d8:	0800f1e0 	.word	0x0800f1e0
 80065dc:	0800f8c4 	.word	0x0800f8c4
 80065e0:	0800eaa8 	.word	0x0800eaa8
 80065e4:	08003941 	.word	0x08003941
 80065e8:	0800f8dc 	.word	0x0800f8dc
 80065ec:	0800f8e8 	.word	0x0800f8e8
 80065f0:	08a17900 	.word	0x08a17900
 80065f4:	0800dc51 	.word	0x0800dc51
 80065f8:	0800f8fc 	.word	0x0800f8fc
 80065fc:	0800f904 	.word	0x0800f904
 8006600:	0800f90c 	.word	0x0800f90c
 8006604:	0800f920 	.word	0x0800f920
 8006608:	200008d0 	.word	0x200008d0
 800660c:	0800f92c 	.word	0x0800f92c
 8006610:	0800f93c 	.word	0x0800f93c
 8006614:	0800ada1 	.word	0x0800ada1
 8006618:	0800f94c 	.word	0x0800f94c
 800661c:	0800f958 	.word	0x0800f958
 8006620:	2001aa30 	.word	0x2001aa30
 8006624:	2001aa1c 	.word	0x2001aa1c
 8006628:	2001a9d8 	.word	0x2001a9d8
 800662c:	20019950 	.word	0x20019950
 8006630:	f004 f82e 	bl	800a690 <chprintf.constprop.26>
 8006634:	4a32      	ldr	r2, [pc, #200]	; (8006700 <main+0xe90>)
 8006636:	4933      	ldr	r1, [pc, #204]	; (8006704 <main+0xe94>)
 8006638:	4833      	ldr	r0, [pc, #204]	; (8006708 <main+0xe98>)
 800663a:	f004 f829 	bl	800a690 <chprintf.constprop.26>
 800663e:	237b      	movs	r3, #123	; 0x7b
 8006640:	4a32      	ldr	r2, [pc, #200]	; (800670c <main+0xe9c>)
 8006642:	4933      	ldr	r1, [pc, #204]	; (8006710 <main+0xea0>)
 8006644:	4830      	ldr	r0, [pc, #192]	; (8006708 <main+0xe98>)
 8006646:	f004 f823 	bl	800a690 <chprintf.constprop.26>
 800664a:	4932      	ldr	r1, [pc, #200]	; (8006714 <main+0xea4>)
 800664c:	482e      	ldr	r0, [pc, #184]	; (8006708 <main+0xe98>)
 800664e:	f004 f81f 	bl	800a690 <chprintf.constprop.26>
 8006652:	4931      	ldr	r1, [pc, #196]	; (8006718 <main+0xea8>)
 8006654:	482c      	ldr	r0, [pc, #176]	; (8006708 <main+0xe98>)
 8006656:	f004 f81b 	bl	800a690 <chprintf.constprop.26>
 800665a:	4930      	ldr	r1, [pc, #192]	; (800671c <main+0xeac>)
 800665c:	482a      	ldr	r0, [pc, #168]	; (8006708 <main+0xe98>)
 800665e:	f004 f817 	bl	800a690 <chprintf.constprop.26>
 8006662:	482f      	ldr	r0, [pc, #188]	; (8006720 <main+0xeb0>)
 8006664:	f002 ff8c 	bl	8009580 <chMtxUnlock>
	chThdCreateFromHeap(NULL, THD_WORKING_AREA_SIZE(256), "PAC1720", NORMALPRIO, pac1720_thd, NULL);
 8006668:	4633      	mov	r3, r6
 800666a:	4a2e      	ldr	r2, [pc, #184]	; (8006724 <main+0xeb4>)
 800666c:	492e      	ldr	r1, [pc, #184]	; (8006728 <main+0xeb8>)
 800666e:	f44f 70e4 	mov.w	r0, #456	; 0x1c8
 8006672:	f004 f825 	bl	800a6c0 <chThdCreateFromHeap.constprop.86>
	initModules();				// Startup optional modules (eg. POSITION, LOG, ...)
	pac1720_init();				// Startup current measurement

	chThdSleepMilliseconds(100);
 8006676:	4638      	mov	r0, r7
 8006678:	f005 fe62 	bl	800c340 <chThdSleep>
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 800667c:	4b2b      	ldr	r3, [pc, #172]	; (800672c <main+0xebc>)
 800667e:	60de      	str	r6, [r3, #12]
 8006680:	2320      	movs	r3, #32
 8006682:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8006686:	f005 fd7b 	bl	800c180 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800668a:	f005 fad1 	bl	800bc30 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800668e:	4b27      	ldr	r3, [pc, #156]	; (800672c <main+0xebc>)
 8006690:	68db      	ldr	r3, [r3, #12]
 8006692:	b113      	cbz	r3, 800669a <main+0xe2a>
    chVTDoResetI(vtp);
 8006694:	4825      	ldr	r0, [pc, #148]	; (800672c <main+0xebc>)
 8006696:	f005 fbd3 	bl	800be40 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800669a:	2300      	movs	r3, #0
 800669c:	4a24      	ldr	r2, [pc, #144]	; (8006730 <main+0xec0>)
 800669e:	4823      	ldr	r0, [pc, #140]	; (800672c <main+0xebc>)
 80066a0:	f241 3188 	movw	r1, #5000	; 0x1388
 80066a4:	f005 fc14 	bl	800bed0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80066a8:	f005 fd5a 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80066ac:	6823      	ldr	r3, [r4, #0]
 80066ae:	4a21      	ldr	r2, [pc, #132]	; (8006734 <main+0xec4>)
 80066b0:	42a3      	cmp	r3, r4
 80066b2:	d005      	beq.n	80066c0 <main+0xe50>
 80066b4:	6992      	ldr	r2, [r2, #24]
 80066b6:	689b      	ldr	r3, [r3, #8]
 80066b8:	6892      	ldr	r2, [r2, #8]
 80066ba:	429a      	cmp	r2, r3
 80066bc:	f0c0 82c6 	bcc.w	8006c4c <main+0x13dc>
 80066c0:	2300      	movs	r3, #0
 80066c2:	f383 8811 	msr	BASEPRI, r3
 80066c6:	f8df 9074 	ldr.w	r9, [pc, #116]	; 800673c <main+0xecc>

	chThdSleepMilliseconds(1000);

	while(true) {
		// Print time every 10 sec
		if(counter % 10 == 0)
 80066ca:	f8df a074 	ldr.w	sl, [pc, #116]	; 8006740 <main+0xed0>
			PRINT_TIME("MAIN");
 80066ce:	f8df 8074 	ldr.w	r8, [pc, #116]	; 8006744 <main+0xed4>
 80066d2:	f8df b074 	ldr.w	fp, [pc, #116]	; 8006748 <main+0xed8>

	// Initialize LED timer
	chVTObjectInit(&vt);
	chVTSet(&vt, MS2ST(500), led_cb, 0);

	chThdSleepMilliseconds(1000);
 80066d6:	f242 7010 	movw	r0, #10000	; 0x2710
 80066da:	f005 fe31 	bl	800c340 <chThdSleep>
 80066de:	f8d9 2000 	ldr.w	r2, [r9]

	while(true) {
		// Print time every 10 sec
		if(counter % 10 == 0)
 80066e2:	fbaa 1302 	umull	r1, r3, sl, r2
 80066e6:	08db      	lsrs	r3, r3, #3
 80066e8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80066ec:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 80066f0:	f000 8212 	beq.w	8006b18 <main+0x12a8>
 80066f4:	4c10      	ldr	r4, [pc, #64]	; (8006738 <main+0xec8>)
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 80066f6:	2300      	movs	r3, #0
 80066f8:	9307      	str	r3, [sp, #28]
 80066fa:	f604 7778 	addw	r7, r4, #3960	; 0xf78
 80066fe:	e088      	b.n	8006812 <main+0xfa2>
 8006700:	0800f1dc 	.word	0x0800f1dc
 8006704:	0800ea64 	.word	0x0800ea64
 8006708:	2001ac28 	.word	0x2001ac28
 800670c:	0800f94c 	.word	0x0800f94c
 8006710:	0800ea7c 	.word	0x0800ea7c
 8006714:	0800f1e0 	.word	0x0800f1e0
 8006718:	0800f96c 	.word	0x0800f96c
 800671c:	0800eaa8 	.word	0x0800eaa8
 8006720:	2001b720 	.word	0x2001b720
 8006724:	08008361 	.word	0x08008361
 8006728:	0800f964 	.word	0x0800f964
 800672c:	20019960 	.word	0x20019960
 8006730:	0800de91 	.word	0x0800de91
 8006734:	2001acdc 	.word	0x2001acdc
 8006738:	20019a58 	.word	0x20019a58
 800673c:	2001a9d0 	.word	0x2001a9d0
 8006740:	cccccccd 	.word	0xcccccccd
 8006744:	d1b71759 	.word	0xd1b71759
 8006748:	10624dd3 	.word	0x10624dd3
			
			if(config[i].active) { // Is active?

				// Determine health
				healthy = true;
				switch(config[i].trigger.type)
 800674c:	2b03      	cmp	r3, #3
 800674e:	f000 8163 	beq.w	8006a18 <main+0x11a8>
 8006752:	2b01      	cmp	r3, #1
 8006754:	f000 816e 	beq.w	8006a34 <main+0x11c4>
						break;
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();

				// Debugging every 10 sec
				if(counter % 10 == 0) {
 8006758:	f8d9 2000 	ldr.w	r2, [r9]
 800675c:	fbaa 1302 	umull	r1, r3, sl, r2
 8006760:	08db      	lsrs	r3, r3, #3
 8006762:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8006766:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 800676a:	d14d      	bne.n	8006808 <main+0xf98>
 800676c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
					lu = chVTGetSystemTimeX() - config[i].last_update;
 8006770:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
 8006774:	6a56      	ldr	r6, [r2, #36]	; 0x24
 8006776:	1af6      	subs	r6, r6, r3
					if(healthy) {
						TRACE_INFO("WDG  > Module %s OK (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
 8006778:	48b8      	ldr	r0, [pc, #736]	; (8006a5c <main+0x11ec>)
 800677a:	f005 fd11 	bl	800c1a0 <chMtxLock>
 800677e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006782:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8006786:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006788:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800678a:	49b5      	ldr	r1, [pc, #724]	; (8006a60 <main+0x11f0>)
 800678c:	48b5      	ldr	r0, [pc, #724]	; (8006a64 <main+0x11f4>)
 800678e:	fb05 fe03 	mul.w	lr, r5, r3
 8006792:	fba8 3e0e 	umull	r3, lr, r8, lr
 8006796:	ea4f 3e5e 	mov.w	lr, lr, lsr #13
 800679a:	fbab c30e 	umull	ip, r3, fp, lr
 800679e:	fba8 c202 	umull	ip, r2, r8, r2
 80067a2:	099b      	lsrs	r3, r3, #6
 80067a4:	fb05 e313 	mls	r3, r5, r3, lr
 80067a8:	0b52      	lsrs	r2, r2, #13
 80067aa:	f003 ff71 	bl	800a690 <chprintf.constprop.26>
 80067ae:	4aae      	ldr	r2, [pc, #696]	; (8006a68 <main+0x11f8>)
 80067b0:	49ae      	ldr	r1, [pc, #696]	; (8006a6c <main+0x11fc>)
 80067b2:	48ac      	ldr	r0, [pc, #688]	; (8006a64 <main+0x11f4>)
 80067b4:	f003 ff6c 	bl	800a690 <chprintf.constprop.26>
 80067b8:	4aad      	ldr	r2, [pc, #692]	; (8006a70 <main+0x1200>)
 80067ba:	49ae      	ldr	r1, [pc, #696]	; (8006a74 <main+0x1204>)
 80067bc:	48a9      	ldr	r0, [pc, #676]	; (8006a64 <main+0x11f4>)
 80067be:	239a      	movs	r3, #154	; 0x9a
 80067c0:	f003 ff66 	bl	800a690 <chprintf.constprop.26>
 80067c4:	49ac      	ldr	r1, [pc, #688]	; (8006a78 <main+0x1208>)
 80067c6:	48a7      	ldr	r0, [pc, #668]	; (8006a64 <main+0x11f4>)
 80067c8:	f003 ff62 	bl	800a690 <chprintf.constprop.26>
 80067cc:	fb05 f306 	mul.w	r3, r5, r6
 80067d0:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 80067d4:	330f      	adds	r3, #15
 80067d6:	fba8 2103 	umull	r2, r1, r8, r3
 80067da:	0b49      	lsrs	r1, r1, #13
 80067dc:	fbab 0201 	umull	r0, r2, fp, r1
 80067e0:	48a6      	ldr	r0, [pc, #664]	; (8006a7c <main+0x120c>)
 80067e2:	0992      	lsrs	r2, r2, #6
 80067e4:	fb05 1512 	mls	r5, r5, r2, r1
 80067e8:	fba0 0303 	umull	r0, r3, r0, r3
 80067ec:	0d9b      	lsrs	r3, r3, #22
 80067ee:	4622      	mov	r2, r4
 80067f0:	49a3      	ldr	r1, [pc, #652]	; (8006a80 <main+0x1210>)
 80067f2:	9500      	str	r5, [sp, #0]
 80067f4:	489b      	ldr	r0, [pc, #620]	; (8006a64 <main+0x11f4>)
 80067f6:	f003 ff4b 	bl	800a690 <chprintf.constprop.26>
 80067fa:	49a2      	ldr	r1, [pc, #648]	; (8006a84 <main+0x1214>)
 80067fc:	4899      	ldr	r0, [pc, #612]	; (8006a64 <main+0x11f4>)
 80067fe:	f003 ff47 	bl	800a690 <chprintf.constprop.26>
 8006802:	4896      	ldr	r0, [pc, #600]	; (8006a5c <main+0x11ec>)
 8006804:	f002 febc 	bl	8009580 <chMtxUnlock>
 8006808:	f504 74dc 	add.w	r4, r4, #440	; 0x1b8
		// Thread monitor
		bool aerror = false; // Temporary error flag
		bool healthy;
		systime_t lu;

		for(uint8_t i=0; i<sizeof(config)/sizeof(module_conf_t); i++) {
 800680c:	42bc      	cmp	r4, r7
 800680e:	f000 8085 	beq.w	800691c <main+0x10ac>
			
			if(config[i].active) { // Is active?
 8006812:	f894 31b4 	ldrb.w	r3, [r4, #436]	; 0x1b4
 8006816:	2b00      	cmp	r3, #0
 8006818:	d0f6      	beq.n	8006808 <main+0xf98>

				// Determine health
				healthy = true;
				switch(config[i].trigger.type)
 800681a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800681e:	2b02      	cmp	r3, #2
 8006820:	d194      	bne.n	800674c <main+0xedc>
								break;
						}
						break;

					case TRIG_TIMEOUT:
						healthy = config[i].last_update + S2ST(config[i].trigger.timeout) + wdg_buffer > chVTGetSystemTimeX();
 8006822:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
 8006826:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8006828:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800682c:	f501 2212 	add.w	r2, r1, #598016	; 0x92000
 8006830:	f502 62f8 	add.w	r2, r2, #1984	; 0x7c0
 8006834:	f242 7510 	movw	r5, #10000	; 0x2710
 8006838:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800683a:	fb05 2200 	mla	r2, r5, r0, r2
 800683e:	4293      	cmp	r3, r2
 8006840:	bf2c      	ite	cs
 8006842:	2200      	movcs	r2, #0
 8006844:	2201      	movcc	r2, #1

					case TRIG_CONTINOUSLY:
						healthy = config[i].last_update + wdg_buffer > chVTGetSystemTimeX();
						break;
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();
 8006846:	2a00      	cmp	r2, #0
 8006848:	f040 80d6 	bne.w	80069f8 <main+0x1188>
 800684c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800684e:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8006852:	f503 2312 	add.w	r3, r3, #598016	; 0x92000
 8006856:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8006858:	f503 63f8 	add.w	r3, r3, #1984	; 0x7c0
 800685c:	429a      	cmp	r2, r3
 800685e:	f0c0 80cb 	bcc.w	80069f8 <main+0x1188>

				// Debugging every 10 sec
				if(counter % 10 == 0) {
 8006862:	f8d9 2000 	ldr.w	r2, [r9]
 8006866:	fbaa 0302 	umull	r0, r3, sl, r2
 800686a:	08db      	lsrs	r3, r3, #3
 800686c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8006870:	ebb2 0f43 	cmp.w	r2, r3, lsl #1
 8006874:	d14b      	bne.n	800690e <main+0x109e>
 8006876:	6a6e      	ldr	r6, [r5, #36]	; 0x24
					lu = chVTGetSystemTimeX() - config[i].last_update;
					if(healthy) {
						TRACE_INFO("WDG  > Module %s OK (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
					} else {
						TRACE_ERROR("WDG  > Module %s failed (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
 8006878:	4878      	ldr	r0, [pc, #480]	; (8006a5c <main+0x11ec>)
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();

				// Debugging every 10 sec
				if(counter % 10 == 0) {
					lu = chVTGetSystemTimeX() - config[i].last_update;
 800687a:	1a76      	subs	r6, r6, r1
					if(healthy) {
						TRACE_INFO("WDG  > Module %s OK (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
					} else {
						TRACE_ERROR("WDG  > Module %s failed (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
 800687c:	f005 fc90 	bl	800c1a0 <chMtxLock>
 8006880:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8006882:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8006884:	4976      	ldr	r1, [pc, #472]	; (8006a60 <main+0x11f0>)
 8006886:	4877      	ldr	r0, [pc, #476]	; (8006a64 <main+0x11f4>)
 8006888:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800688c:	fb05 fe03 	mul.w	lr, r5, r3
 8006890:	fba8 3e0e 	umull	r3, lr, r8, lr
 8006894:	ea4f 3e5e 	mov.w	lr, lr, lsr #13
 8006898:	fbab c30e 	umull	ip, r3, fp, lr
 800689c:	fba8 c202 	umull	ip, r2, r8, r2
 80068a0:	099b      	lsrs	r3, r3, #6
 80068a2:	fb05 e313 	mls	r3, r5, r3, lr
 80068a6:	0b52      	lsrs	r2, r2, #13
 80068a8:	f003 fef2 	bl	800a690 <chprintf.constprop.26>
 80068ac:	4a76      	ldr	r2, [pc, #472]	; (8006a88 <main+0x1218>)
 80068ae:	496f      	ldr	r1, [pc, #444]	; (8006a6c <main+0x11fc>)
 80068b0:	486c      	ldr	r0, [pc, #432]	; (8006a64 <main+0x11f4>)
 80068b2:	f003 feed 	bl	800a690 <chprintf.constprop.26>
 80068b6:	4a6e      	ldr	r2, [pc, #440]	; (8006a70 <main+0x1200>)
 80068b8:	496e      	ldr	r1, [pc, #440]	; (8006a74 <main+0x1204>)
 80068ba:	486a      	ldr	r0, [pc, #424]	; (8006a64 <main+0x11f4>)
 80068bc:	239c      	movs	r3, #156	; 0x9c
 80068be:	f003 fee7 	bl	800a690 <chprintf.constprop.26>
 80068c2:	496d      	ldr	r1, [pc, #436]	; (8006a78 <main+0x1208>)
 80068c4:	4867      	ldr	r0, [pc, #412]	; (8006a64 <main+0x11f4>)
 80068c6:	f003 fee3 	bl	800a690 <chprintf.constprop.26>
 80068ca:	fb05 f306 	mul.w	r3, r5, r6
 80068ce:	f503 531c 	add.w	r3, r3, #9984	; 0x2700
 80068d2:	330f      	adds	r3, #15
 80068d4:	fba8 2103 	umull	r2, r1, r8, r3
 80068d8:	0b49      	lsrs	r1, r1, #13
 80068da:	fbab 0201 	umull	r0, r2, fp, r1
 80068de:	4867      	ldr	r0, [pc, #412]	; (8006a7c <main+0x120c>)
 80068e0:	0992      	lsrs	r2, r2, #6
 80068e2:	fb05 1512 	mls	r5, r5, r2, r1
 80068e6:	fba0 0303 	umull	r0, r3, r0, r3
 80068ea:	0d9b      	lsrs	r3, r3, #22
 80068ec:	4622      	mov	r2, r4
 80068ee:	4967      	ldr	r1, [pc, #412]	; (8006a8c <main+0x121c>)
 80068f0:	9500      	str	r5, [sp, #0]
 80068f2:	485c      	ldr	r0, [pc, #368]	; (8006a64 <main+0x11f4>)
 80068f4:	f003 fecc 	bl	800a690 <chprintf.constprop.26>
 80068f8:	4962      	ldr	r1, [pc, #392]	; (8006a84 <main+0x1214>)
 80068fa:	485a      	ldr	r0, [pc, #360]	; (8006a64 <main+0x11f4>)
 80068fc:	f003 fec8 	bl	800a690 <chprintf.constprop.26>
 8006900:	4856      	ldr	r0, [pc, #344]	; (8006a5c <main+0x11ec>)
 8006902:	f002 fe3d 	bl	8009580 <chMtxUnlock>
 8006906:	219c      	movs	r1, #156	; 0x9c
 8006908:	4859      	ldr	r0, [pc, #356]	; (8006a70 <main+0x1200>)
 800690a:	f006 f839 	bl	800c980 <log_error>
 800690e:	f504 74dc 	add.w	r4, r4, #440	; 0x1b8
					}
				}

				if(!healthy)
					aerror = true; // Set error flag
 8006912:	2301      	movs	r3, #1
		// Thread monitor
		bool aerror = false; // Temporary error flag
		bool healthy;
		systime_t lu;

		for(uint8_t i=0; i<sizeof(config)/sizeof(module_conf_t); i++) {
 8006914:	42bc      	cmp	r4, r7
						TRACE_ERROR("WDG  > Module %s failed (last activity %d.%03d sec ago)", config[i].name, ST2MS(lu)/1000, ST2MS(lu)%1000);
					}
				}

				if(!healthy)
					aerror = true; // Set error flag
 8006916:	9307      	str	r3, [sp, #28]
		// Thread monitor
		bool aerror = false; // Temporary error flag
		bool healthy;
		systime_t lu;

		for(uint8_t i=0; i<sizeof(config)/sizeof(module_conf_t); i++) {
 8006918:	f47f af7b 	bne.w	8006812 <main+0xfa2>
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 800691c:	f8d9 1000 	ldr.w	r1, [r9]

			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 8006920:	4b5b      	ldr	r3, [pc, #364]	; (8006a90 <main+0x1220>)
 8006922:	6818      	ldr	r0, [r3, #0]
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 8006924:	fbaa 2301 	umull	r2, r3, sl, r1
 8006928:	08db      	lsrs	r3, r3, #3
 800692a:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 800692e:	eb03 0383 	add.w	r3, r3, r3, lsl #2

			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 8006932:	f500 12db 	add.w	r2, r0, #1794048	; 0x1b6000
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 8006936:	ebb1 0f43 	cmp.w	r1, r3, lsl #1
 800693a:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800693c:	6a65      	ldr	r5, [r4, #36]	; 0x24

			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
 800693e:	f502 52ba 	add.w	r2, r2, #5952	; 0x1740
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
 8006942:	f040 80ab 	bne.w	8006a9c <main+0x122c>
			if(healthy) {
 8006946:	42b2      	cmp	r2, r6
			}
		}

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
		lu = chVTGetSystemTimeX() - watchdog_tracking;
 8006948:	eba5 0500 	sub.w	r5, r5, r0
		if(counter % 10 == 0) {
			if(healthy) {
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
 800694c:	4843      	ldr	r0, [pc, #268]	; (8006a5c <main+0x11ec>)

		// Watchdog TRACKING
		healthy = watchdog_tracking + S2ST(TRACK_CYCLE_TIME) + wdg_buffer > chVTGetSystemTimeX();
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
			if(healthy) {
 800694e:	f240 8130 	bls.w	8006bb2 <main+0x1342>
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
 8006952:	f005 fc25 	bl	800c1a0 <chMtxLock>
 8006956:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006958:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800695a:	4941      	ldr	r1, [pc, #260]	; (8006a60 <main+0x11f0>)
 800695c:	4841      	ldr	r0, [pc, #260]	; (8006a64 <main+0x11f4>)
 800695e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8006962:	fb04 f303 	mul.w	r3, r4, r3
 8006966:	fba8 6303 	umull	r6, r3, r8, r3
 800696a:	0b5b      	lsrs	r3, r3, #13
 800696c:	fbab 7603 	umull	r7, r6, fp, r3
 8006970:	fba8 7202 	umull	r7, r2, r8, r2
 8006974:	09b6      	lsrs	r6, r6, #6
 8006976:	fb04 3316 	mls	r3, r4, r6, r3
 800697a:	0b52      	lsrs	r2, r2, #13
 800697c:	f003 fe88 	bl	800a690 <chprintf.constprop.26>
 8006980:	4a39      	ldr	r2, [pc, #228]	; (8006a68 <main+0x11f8>)
 8006982:	493a      	ldr	r1, [pc, #232]	; (8006a6c <main+0x11fc>)
 8006984:	4837      	ldr	r0, [pc, #220]	; (8006a64 <main+0x11f4>)
 8006986:	f003 fe83 	bl	800a690 <chprintf.constprop.26>
 800698a:	23ab      	movs	r3, #171	; 0xab
 800698c:	4a38      	ldr	r2, [pc, #224]	; (8006a70 <main+0x1200>)
 800698e:	4939      	ldr	r1, [pc, #228]	; (8006a74 <main+0x1204>)
 8006990:	4834      	ldr	r0, [pc, #208]	; (8006a64 <main+0x11f4>)
 8006992:	f003 fe7d 	bl	800a690 <chprintf.constprop.26>
 8006996:	4938      	ldr	r1, [pc, #224]	; (8006a78 <main+0x1208>)
 8006998:	4832      	ldr	r0, [pc, #200]	; (8006a64 <main+0x11f4>)
 800699a:	f003 fe79 	bl	800a690 <chprintf.constprop.26>
 800699e:	fb04 f205 	mul.w	r2, r4, r5
 80069a2:	f502 521c 	add.w	r2, r2, #9984	; 0x2700
 80069a6:	320f      	adds	r2, #15
 80069a8:	fba8 1302 	umull	r1, r3, r8, r2
 80069ac:	0b5b      	lsrs	r3, r3, #13
 80069ae:	fbab 0103 	umull	r0, r1, fp, r3
 80069b2:	4832      	ldr	r0, [pc, #200]	; (8006a7c <main+0x120c>)
 80069b4:	0989      	lsrs	r1, r1, #6
 80069b6:	fba0 0202 	umull	r0, r2, r0, r2
 80069ba:	fb04 3311 	mls	r3, r4, r1, r3
 80069be:	0d92      	lsrs	r2, r2, #22
 80069c0:	4934      	ldr	r1, [pc, #208]	; (8006a94 <main+0x1224>)
 80069c2:	4828      	ldr	r0, [pc, #160]	; (8006a64 <main+0x11f4>)
 80069c4:	f003 fe64 	bl	800a690 <chprintf.constprop.26>
 80069c8:	492e      	ldr	r1, [pc, #184]	; (8006a84 <main+0x1214>)
 80069ca:	4826      	ldr	r0, [pc, #152]	; (8006a64 <main+0x11f4>)
 80069cc:	f003 fe60 	bl	800a690 <chprintf.constprop.26>
 80069d0:	4822      	ldr	r0, [pc, #136]	; (8006a5c <main+0x11ec>)
 80069d2:	f002 fdd5 	bl	8009580 <chMtxUnlock>
		}
		if(!healthy)
			aerror = true; // Set error flag

		// Update hardware (LED, WDG)
		error = aerror;			// Update error LED flag
 80069d6:	4b30      	ldr	r3, [pc, #192]	; (8006a98 <main+0x1228>)
 80069d8:	9907      	ldr	r1, [sp, #28]
 80069da:	7019      	strb	r1, [r3, #0]
		if(!error)
 80069dc:	2900      	cmp	r1, #0
 80069de:	d162      	bne.n	8006aa6 <main+0x1236>
		{
			wdgReset(&WDGD1);	// Reset hardware watchdog at no error
 80069e0:	f004 f9ae 	bl	800ad40 <wdgReset.constprop.35>
		} else {
			TRACE_ERROR("WDG  > No reset");
		}

		chThdSleepMilliseconds(1000);
 80069e4:	f242 7010 	movw	r0, #10000	; 0x2710
 80069e8:	f005 fcaa 	bl	800c340 <chThdSleep>
		counter++;
 80069ec:	f8d9 2000 	ldr.w	r2, [r9]
 80069f0:	3201      	adds	r2, #1
 80069f2:	f8c9 2000 	str.w	r2, [r9]
 80069f6:	e674      	b.n	80066e2 <main+0xe72>
						break;
				}
				healthy = healthy || config[i].init_delay + wdg_buffer > chVTGetSystemTimeX();

				// Debugging every 10 sec
				if(counter % 10 == 0) {
 80069f8:	f8d9 3000 	ldr.w	r3, [r9]
 80069fc:	fbaa 0203 	umull	r0, r2, sl, r3
 8006a00:	08d2      	lsrs	r2, r2, #3
 8006a02:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8006a06:	ebb3 0f42 	cmp.w	r3, r2, lsl #1
 8006a0a:	f47f aefd 	bne.w	8006808 <main+0xf98>
 8006a0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006a12:	6a5e      	ldr	r6, [r3, #36]	; 0x24
					lu = chVTGetSystemTimeX() - config[i].last_update;
 8006a14:	1a76      	subs	r6, r6, r1
 8006a16:	e6af      	b.n	8006778 <main+0xf08>
					case TRIG_TIMEOUT:
						healthy = config[i].last_update + S2ST(config[i].trigger.timeout) + wdg_buffer > chVTGetSystemTimeX();
						break;

					case TRIG_CONTINOUSLY:
						healthy = config[i].last_update + wdg_buffer > chVTGetSystemTimeX();
 8006a18:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
 8006a1c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006a20:	f501 2212 	add.w	r2, r1, #598016	; 0x92000
 8006a24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006a26:	f502 62f8 	add.w	r2, r2, #1984	; 0x7c0
 8006a2a:	4293      	cmp	r3, r2
 8006a2c:	bf2c      	ite	cs
 8006a2e:	2200      	movcs	r2, #0
 8006a30:	2201      	movcc	r2, #1
 8006a32:	e708      	b.n	8006846 <main+0xfd6>
					case TRIG_ONCE:
						healthy = true;
						break;

					case TRIG_EVENT:
						switch(config[i].trigger.event)
 8006a34:	f894 304c 	ldrb.w	r3, [r4, #76]	; 0x4c
 8006a38:	2b01      	cmp	r3, #1
 8006a3a:	f47f ae8d 	bne.w	8006758 <main+0xee8>
						{
							case NO_EVENT:
								healthy = true;
								break;
							case EVENT_NEW_POINT:
								healthy = config[i].last_update + S2ST(TRACK_CYCLE_TIME*2) + wdg_buffer > chVTGetSystemTimeX();
 8006a3e:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
 8006a42:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006a46:	f501 1237 	add.w	r2, r1, #2998272	; 0x2dc000
 8006a4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006a4c:	f502 62d8 	add.w	r2, r2, #1728	; 0x6c0
 8006a50:	4293      	cmp	r3, r2
 8006a52:	bf2c      	ite	cs
 8006a54:	2200      	movcs	r2, #0
 8006a56:	2201      	movcc	r2, #1
 8006a58:	e6f5      	b.n	8006846 <main+0xfd6>
 8006a5a:	bf00      	nop
 8006a5c:	2001b720 	.word	0x2001b720
 8006a60:	0800ea50 	.word	0x0800ea50
 8006a64:	2001ac28 	.word	0x2001ac28
 8006a68:	0800f1dc 	.word	0x0800f1dc
 8006a6c:	0800ea64 	.word	0x0800ea64
 8006a70:	0800f878 	.word	0x0800f878
 8006a74:	0800ea7c 	.word	0x0800ea7c
 8006a78:	0800f1e0 	.word	0x0800f1e0
 8006a7c:	6b5fca6b 	.word	0x6b5fca6b
 8006a80:	0800f9a0 	.word	0x0800f9a0
 8006a84:	0800eaa8 	.word	0x0800eaa8
 8006a88:	0800ea5c 	.word	0x0800ea5c
 8006a8c:	0800fa58 	.word	0x0800fa58
 8006a90:	2001aa2c 	.word	0x2001aa2c
 8006a94:	0800f9d4 	.word	0x0800f9d4
 8006a98:	2001aa40 	.word	0x2001aa40
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
			} else {
				TRACE_ERROR("WDG  > Module TRAC failed (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
			}
		}
		if(!healthy)
 8006a9c:	42b2      	cmp	r2, r6
 8006a9e:	d89a      	bhi.n	80069d6 <main+0x1166>
			aerror = true; // Set error flag

		// Update hardware (LED, WDG)
		error = aerror;			// Update error LED flag
 8006aa0:	4a6c      	ldr	r2, [pc, #432]	; (8006c54 <main+0x13e4>)
 8006aa2:	2301      	movs	r3, #1
 8006aa4:	7013      	strb	r3, [r2, #0]
		if(!error)
		{
			wdgReset(&WDGD1);	// Reset hardware watchdog at no error
		} else {
			TRACE_ERROR("WDG  > No reset");
 8006aa6:	486c      	ldr	r0, [pc, #432]	; (8006c58 <main+0x13e8>)
 8006aa8:	f005 fb7a 	bl	800c1a0 <chMtxLock>
 8006aac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006ab0:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8006ab4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006ab6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8006ab8:	4968      	ldr	r1, [pc, #416]	; (8006c5c <main+0x13ec>)
 8006aba:	fb04 f000 	mul.w	r0, r4, r0
 8006abe:	fba8 3000 	umull	r3, r0, r8, r0
 8006ac2:	0b40      	lsrs	r0, r0, #13
 8006ac4:	fbab 5300 	umull	r5, r3, fp, r0
 8006ac8:	fba8 5202 	umull	r5, r2, r8, r2
 8006acc:	099b      	lsrs	r3, r3, #6
 8006ace:	fb04 0313 	mls	r3, r4, r3, r0
 8006ad2:	0b52      	lsrs	r2, r2, #13
 8006ad4:	4862      	ldr	r0, [pc, #392]	; (8006c60 <main+0x13f0>)
 8006ad6:	f003 fddb 	bl	800a690 <chprintf.constprop.26>
 8006ada:	4a62      	ldr	r2, [pc, #392]	; (8006c64 <main+0x13f4>)
 8006adc:	4962      	ldr	r1, [pc, #392]	; (8006c68 <main+0x13f8>)
 8006ade:	4860      	ldr	r0, [pc, #384]	; (8006c60 <main+0x13f0>)
 8006ae0:	f003 fdd6 	bl	800a690 <chprintf.constprop.26>
 8006ae4:	23b9      	movs	r3, #185	; 0xb9
 8006ae6:	4a61      	ldr	r2, [pc, #388]	; (8006c6c <main+0x13fc>)
 8006ae8:	4961      	ldr	r1, [pc, #388]	; (8006c70 <main+0x1400>)
 8006aea:	485d      	ldr	r0, [pc, #372]	; (8006c60 <main+0x13f0>)
 8006aec:	f003 fdd0 	bl	800a690 <chprintf.constprop.26>
 8006af0:	4960      	ldr	r1, [pc, #384]	; (8006c74 <main+0x1404>)
 8006af2:	485b      	ldr	r0, [pc, #364]	; (8006c60 <main+0x13f0>)
 8006af4:	f003 fdcc 	bl	800a690 <chprintf.constprop.26>
 8006af8:	495f      	ldr	r1, [pc, #380]	; (8006c78 <main+0x1408>)
 8006afa:	4859      	ldr	r0, [pc, #356]	; (8006c60 <main+0x13f0>)
 8006afc:	f003 fdc8 	bl	800a690 <chprintf.constprop.26>
 8006b00:	495e      	ldr	r1, [pc, #376]	; (8006c7c <main+0x140c>)
 8006b02:	4857      	ldr	r0, [pc, #348]	; (8006c60 <main+0x13f0>)
 8006b04:	f003 fdc4 	bl	800a690 <chprintf.constprop.26>
 8006b08:	4853      	ldr	r0, [pc, #332]	; (8006c58 <main+0x13e8>)
 8006b0a:	f002 fd39 	bl	8009580 <chMtxUnlock>
 8006b0e:	21b9      	movs	r1, #185	; 0xb9
 8006b10:	4856      	ldr	r0, [pc, #344]	; (8006c6c <main+0x13fc>)
 8006b12:	f005 ff35 	bl	800c980 <log_error>
 8006b16:	e765      	b.n	80069e4 <main+0x1174>
	chThdSleepMilliseconds(1000);

	while(true) {
		// Print time every 10 sec
		if(counter % 10 == 0)
			PRINT_TIME("MAIN");
 8006b18:	a808      	add	r0, sp, #32
 8006b1a:	f005 fd09 	bl	800c530 <getTime>
 8006b1e:	484e      	ldr	r0, [pc, #312]	; (8006c58 <main+0x13e8>)
 8006b20:	f005 fb3e 	bl	800c1a0 <chMtxLock>
 8006b24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006b28:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8006b2c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8006b2e:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8006b30:	494a      	ldr	r1, [pc, #296]	; (8006c5c <main+0x13ec>)
 8006b32:	fb04 f000 	mul.w	r0, r4, r0
 8006b36:	fba8 3000 	umull	r3, r0, r8, r0
 8006b3a:	0b40      	lsrs	r0, r0, #13
 8006b3c:	fbab 5300 	umull	r5, r3, fp, r0
 8006b40:	fba8 5202 	umull	r5, r2, r8, r2
 8006b44:	099b      	lsrs	r3, r3, #6
 8006b46:	fb04 0313 	mls	r3, r4, r3, r0
 8006b4a:	0b52      	lsrs	r2, r2, #13
 8006b4c:	4844      	ldr	r0, [pc, #272]	; (8006c60 <main+0x13f0>)
 8006b4e:	f003 fd9f 	bl	800a690 <chprintf.constprop.26>
 8006b52:	4a4b      	ldr	r2, [pc, #300]	; (8006c80 <main+0x1410>)
 8006b54:	4944      	ldr	r1, [pc, #272]	; (8006c68 <main+0x13f8>)
 8006b56:	4842      	ldr	r0, [pc, #264]	; (8006c60 <main+0x13f0>)
 8006b58:	f003 fd9a 	bl	800a690 <chprintf.constprop.26>
 8006b5c:	236d      	movs	r3, #109	; 0x6d
 8006b5e:	4a43      	ldr	r2, [pc, #268]	; (8006c6c <main+0x13fc>)
 8006b60:	4943      	ldr	r1, [pc, #268]	; (8006c70 <main+0x1400>)
 8006b62:	483f      	ldr	r0, [pc, #252]	; (8006c60 <main+0x13f0>)
 8006b64:	f003 fd94 	bl	800a690 <chprintf.constprop.26>
 8006b68:	4942      	ldr	r1, [pc, #264]	; (8006c74 <main+0x1404>)
 8006b6a:	483d      	ldr	r0, [pc, #244]	; (8006c60 <main+0x13f0>)
 8006b6c:	f003 fd90 	bl	800a690 <chprintf.constprop.26>
 8006b70:	f8bd 1028 	ldrh.w	r1, [sp, #40]	; 0x28
 8006b74:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
 8006b78:	f89d 0024 	ldrb.w	r0, [sp, #36]	; 0x24
 8006b7c:	f89d 4025 	ldrb.w	r4, [sp, #37]	; 0x25
 8006b80:	9105      	str	r1, [sp, #20]
 8006b82:	9204      	str	r2, [sp, #16]
 8006b84:	f89d 1023 	ldrb.w	r1, [sp, #35]	; 0x23
 8006b88:	f89d 2022 	ldrb.w	r2, [sp, #34]	; 0x22
 8006b8c:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8006b90:	9002      	str	r0, [sp, #8]
 8006b92:	9101      	str	r1, [sp, #4]
 8006b94:	9200      	str	r2, [sp, #0]
 8006b96:	9403      	str	r4, [sp, #12]
 8006b98:	4a3a      	ldr	r2, [pc, #232]	; (8006c84 <main+0x1414>)
 8006b9a:	493b      	ldr	r1, [pc, #236]	; (8006c88 <main+0x1418>)
 8006b9c:	4830      	ldr	r0, [pc, #192]	; (8006c60 <main+0x13f0>)
 8006b9e:	f003 fd77 	bl	800a690 <chprintf.constprop.26>
 8006ba2:	4936      	ldr	r1, [pc, #216]	; (8006c7c <main+0x140c>)
 8006ba4:	482e      	ldr	r0, [pc, #184]	; (8006c60 <main+0x13f0>)
 8006ba6:	f003 fd73 	bl	800a690 <chprintf.constprop.26>
 8006baa:	482b      	ldr	r0, [pc, #172]	; (8006c58 <main+0x13e8>)
 8006bac:	f002 fce8 	bl	8009580 <chMtxUnlock>
 8006bb0:	e5a0      	b.n	80066f4 <main+0xe84>
		lu = chVTGetSystemTimeX() - watchdog_tracking;
		if(counter % 10 == 0) {
			if(healthy) {
				TRACE_INFO("WDG  > Module TRAC OK (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
			} else {
				TRACE_ERROR("WDG  > Module TRAC failed (last activity %d.%03d sec ago)", ST2MS(lu)/1000, ST2MS(lu)%1000);
 8006bb2:	f005 faf5 	bl	800c1a0 <chMtxLock>
 8006bb6:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8006bb8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006bba:	4928      	ldr	r1, [pc, #160]	; (8006c5c <main+0x13ec>)
 8006bbc:	4828      	ldr	r0, [pc, #160]	; (8006c60 <main+0x13f0>)
 8006bbe:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8006bc2:	fb04 f303 	mul.w	r3, r4, r3
 8006bc6:	fba8 6303 	umull	r6, r3, r8, r3
 8006bca:	0b5b      	lsrs	r3, r3, #13
 8006bcc:	fbab 7603 	umull	r7, r6, fp, r3
 8006bd0:	fba8 7202 	umull	r7, r2, r8, r2
 8006bd4:	09b6      	lsrs	r6, r6, #6
 8006bd6:	fb04 3316 	mls	r3, r4, r6, r3
 8006bda:	0b52      	lsrs	r2, r2, #13
 8006bdc:	f003 fd58 	bl	800a690 <chprintf.constprop.26>
 8006be0:	4a20      	ldr	r2, [pc, #128]	; (8006c64 <main+0x13f4>)
 8006be2:	4921      	ldr	r1, [pc, #132]	; (8006c68 <main+0x13f8>)
 8006be4:	481e      	ldr	r0, [pc, #120]	; (8006c60 <main+0x13f0>)
 8006be6:	f003 fd53 	bl	800a690 <chprintf.constprop.26>
 8006bea:	23ad      	movs	r3, #173	; 0xad
 8006bec:	4a1f      	ldr	r2, [pc, #124]	; (8006c6c <main+0x13fc>)
 8006bee:	4920      	ldr	r1, [pc, #128]	; (8006c70 <main+0x1400>)
 8006bf0:	481b      	ldr	r0, [pc, #108]	; (8006c60 <main+0x13f0>)
 8006bf2:	f003 fd4d 	bl	800a690 <chprintf.constprop.26>
 8006bf6:	491f      	ldr	r1, [pc, #124]	; (8006c74 <main+0x1404>)
 8006bf8:	4819      	ldr	r0, [pc, #100]	; (8006c60 <main+0x13f0>)
 8006bfa:	f003 fd49 	bl	800a690 <chprintf.constprop.26>
 8006bfe:	fb04 f205 	mul.w	r2, r4, r5
 8006c02:	f502 521c 	add.w	r2, r2, #9984	; 0x2700
 8006c06:	320f      	adds	r2, #15
 8006c08:	fba8 1302 	umull	r1, r3, r8, r2
 8006c0c:	0b5b      	lsrs	r3, r3, #13
 8006c0e:	fbab 0103 	umull	r0, r1, fp, r3
 8006c12:	481e      	ldr	r0, [pc, #120]	; (8006c8c <main+0x141c>)
 8006c14:	0989      	lsrs	r1, r1, #6
 8006c16:	fba0 0202 	umull	r0, r2, r0, r2
 8006c1a:	fb04 3311 	mls	r3, r4, r1, r3
 8006c1e:	0d92      	lsrs	r2, r2, #22
 8006c20:	491b      	ldr	r1, [pc, #108]	; (8006c90 <main+0x1420>)
 8006c22:	480f      	ldr	r0, [pc, #60]	; (8006c60 <main+0x13f0>)
 8006c24:	f003 fd34 	bl	800a690 <chprintf.constprop.26>
 8006c28:	4914      	ldr	r1, [pc, #80]	; (8006c7c <main+0x140c>)
 8006c2a:	480d      	ldr	r0, [pc, #52]	; (8006c60 <main+0x13f0>)
 8006c2c:	f003 fd30 	bl	800a690 <chprintf.constprop.26>
 8006c30:	4809      	ldr	r0, [pc, #36]	; (8006c58 <main+0x13e8>)
 8006c32:	f002 fca5 	bl	8009580 <chMtxUnlock>
 8006c36:	21ad      	movs	r1, #173	; 0xad
 8006c38:	480c      	ldr	r0, [pc, #48]	; (8006c6c <main+0x13fc>)
 8006c3a:	f005 fea1 	bl	800c980 <log_error>
		}
		if(!healthy)
			aerror = true; // Set error flag

		// Update hardware (LED, WDG)
		error = aerror;			// Update error LED flag
 8006c3e:	4a05      	ldr	r2, [pc, #20]	; (8006c54 <main+0x13e4>)
 8006c40:	2301      	movs	r3, #1
 8006c42:	7013      	strb	r3, [r2, #0]
 8006c44:	e72f      	b.n	8006aa6 <main+0x1236>
 8006c46:	4813      	ldr	r0, [pc, #76]	; (8006c94 <main+0x1424>)
 8006c48:	f004 ff92 	bl	800bb70 <chSysHalt>
 8006c4c:	4812      	ldr	r0, [pc, #72]	; (8006c98 <main+0x1428>)
 8006c4e:	f004 ff8f 	bl	800bb70 <chSysHalt>
 8006c52:	bf00      	nop
 8006c54:	2001aa40 	.word	0x2001aa40
 8006c58:	2001b720 	.word	0x2001b720
 8006c5c:	0800ea50 	.word	0x0800ea50
 8006c60:	2001ac28 	.word	0x2001ac28
 8006c64:	0800ea5c 	.word	0x0800ea5c
 8006c68:	0800ea64 	.word	0x0800ea64
 8006c6c:	0800f878 	.word	0x0800f878
 8006c70:	0800ea7c 	.word	0x0800ea7c
 8006c74:	0800f1e0 	.word	0x0800f1e0
 8006c78:	0800fa48 	.word	0x0800fa48
 8006c7c:	0800eaa8 	.word	0x0800eaa8
 8006c80:	0800f1dc 	.word	0x0800f1dc
 8006c84:	0800f998 	.word	0x0800f998
 8006c88:	0800f594 	.word	0x0800f594
 8006c8c:	6b5fca6b 	.word	0x6b5fca6b
 8006c90:	0800fa0c 	.word	0x0800fa0c
 8006c94:	08010238 	.word	0x08010238
 8006c98:	0800f78c 	.word	0x0800f78c
 8006c9c:	00000000 	.word	0x00000000

08006ca0 <ch_ltoa>:
  while (--i);

  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8006ca0:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8006ca2:	f100 070b 	add.w	r7, r0, #11
 8006ca6:	463c      	mov	r4, r7
 8006ca8:	460d      	mov	r5, r1
  do {
    i = (int)(l % radix);
 8006caa:	fbb1 f6f2 	udiv	r6, r1, r2
 8006cae:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8006cb2:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8006cb6:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8006cb8:	bfc8      	it	gt
 8006cba:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 8006cbe:	b2db      	uxtb	r3, r3
 8006cc0:	f804 3d01 	strb.w	r3, [r4, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8006cc4:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8006cc8:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 8006cca:	2d00      	cmp	r5, #0
 8006ccc:	d1ed      	bne.n	8006caa <ch_ltoa+0xa>
 8006cce:	1b3a      	subs	r2, r7, r4
 8006cd0:	4402      	add	r2, r0
 8006cd2:	e001      	b.n	8006cd8 <ch_ltoa+0x38>
 8006cd4:	f814 3f01 	ldrb.w	r3, [r4, #1]!

  i = (int)(p + MAX_FILLER - q);
  do
    *p++ = *q++;
 8006cd8:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8006cdc:	4290      	cmp	r0, r2
 8006cde:	d1f9      	bne.n	8006cd4 <ch_ltoa+0x34>
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
}
 8006ce0:	bcf0      	pop	{r4, r5, r6, r7}
 8006ce2:	4770      	bx	lr
	...

08006cf0 <_get>:

static msg_t _get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 8006cf0:	6903      	ldr	r3, [r0, #16]
 8006cf2:	68c1      	ldr	r1, [r0, #12]
 8006cf4:	4299      	cmp	r1, r3
  *(msp->buffer + msp->eos) = b;
  msp->eos += 1;
  return MSG_OK;
}

static msg_t _get(void *ip) {
 8006cf6:	4602      	mov	r2, r0
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
 8006cf8:	d004      	beq.n	8006d04 <_get+0x14>
    return MSG_RESET;
  b = *(msp->buffer + msp->offset);
 8006cfa:	6841      	ldr	r1, [r0, #4]
 8006cfc:	5cc8      	ldrb	r0, [r1, r3]
  msp->offset += 1;
 8006cfe:	3301      	adds	r3, #1
 8006d00:	6113      	str	r3, [r2, #16]
 8006d02:	4770      	bx	lr
static msg_t _get(void *ip) {
  uint8_t b;
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset <= 0)
    return MSG_RESET;
 8006d04:	f06f 0001 	mvn.w	r0, #1
  b = *(msp->buffer + msp->offset);
  msp->offset += 1;
  return b;
}
 8006d08:	4770      	bx	lr
 8006d0a:	bf00      	nop
 8006d0c:	0000      	movs	r0, r0
	...

08006d10 <_put>:
}

static msg_t _put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
 8006d10:	68c3      	ldr	r3, [r0, #12]
 8006d12:	6882      	ldr	r2, [r0, #8]
 8006d14:	429a      	cmp	r2, r3
 8006d16:	d006      	beq.n	8006d26 <_put+0x16>
    return MSG_RESET;
  *(msp->buffer + msp->eos) = b;
 8006d18:	6842      	ldr	r2, [r0, #4]
 8006d1a:	54d1      	strb	r1, [r2, r3]
  msp->eos += 1;
 8006d1c:	68c3      	ldr	r3, [r0, #12]
 8006d1e:	3301      	adds	r3, #1
 8006d20:	60c3      	str	r3, [r0, #12]
  return MSG_OK;
 8006d22:	2000      	movs	r0, #0
 8006d24:	4770      	bx	lr

static msg_t _put(void *ip, uint8_t b) {
  MemoryStream *msp = ip;

  if (msp->size - msp->eos <= 0)
    return MSG_RESET;
 8006d26:	f06f 0001 	mvn.w	r0, #1
  *(msp->buffer + msp->eos) = b;
  msp->eos += 1;
  return MSG_OK;
}
 8006d2a:	4770      	bx	lr
 8006d2c:	0000      	movs	r0, r0
	...

08006d30 <notify5.lto_priv.130>:

#if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
static void notify5(io_queue_t *qp) {

  (void)qp;
  UART5->CR1 |= USART_CR1_TXEIE;
 8006d30:	4a02      	ldr	r2, [pc, #8]	; (8006d3c <notify5.lto_priv.130+0xc>)
 8006d32:	68d3      	ldr	r3, [r2, #12]
 8006d34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006d38:	60d3      	str	r3, [r2, #12]
 8006d3a:	4770      	bx	lr
 8006d3c:	40005000 	.word	0x40005000

08006d40 <notify3.lto_priv.129>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8006d40:	4a02      	ldr	r2, [pc, #8]	; (8006d4c <notify3.lto_priv.129+0xc>)
 8006d42:	68d3      	ldr	r3, [r2, #12]
 8006d44:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006d48:	60d3      	str	r3, [r2, #12]
 8006d4a:	4770      	bx	lr
 8006d4c:	40004800 	.word	0x40004800

08006d50 <_reads>:
  memcpy(msp->buffer + msp->eos, bp, n);
  msp->eos += n;
  return n;
}

static size_t _reads(void *ip, uint8_t *bp, size_t n) {
 8006d50:	b570      	push	{r4, r5, r6, lr}
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
 8006d52:	6903      	ldr	r3, [r0, #16]
 8006d54:	68c4      	ldr	r4, [r0, #12]
    n = msp->eos - msp->offset;
  memcpy(bp, msp->buffer + msp->offset, n);
 8006d56:	6846      	ldr	r6, [r0, #4]
}

static size_t _reads(void *ip, uint8_t *bp, size_t n) {
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
 8006d58:	1ae4      	subs	r4, r4, r3
 8006d5a:	4294      	cmp	r4, r2
 8006d5c:	bf28      	it	cs
 8006d5e:	4614      	movcs	r4, r2
  memcpy(msp->buffer + msp->eos, bp, n);
  msp->eos += n;
  return n;
}

static size_t _reads(void *ip, uint8_t *bp, size_t n) {
 8006d60:	4605      	mov	r5, r0
  MemoryStream *msp = ip;

  if (msp->eos - msp->offset < n)
    n = msp->eos - msp->offset;
  memcpy(bp, msp->buffer + msp->offset, n);
 8006d62:	4622      	mov	r2, r4
 8006d64:	4608      	mov	r0, r1
 8006d66:	18f1      	adds	r1, r6, r3
 8006d68:	f7fa faf2 	bl	8001350 <memcpy>
  msp->offset += n;
 8006d6c:	692b      	ldr	r3, [r5, #16]
 8006d6e:	4423      	add	r3, r4
 8006d70:	612b      	str	r3, [r5, #16]
  return n;
}
 8006d72:	4620      	mov	r0, r4
 8006d74:	bd70      	pop	{r4, r5, r6, pc}
 8006d76:	bf00      	nop
	...

08006d80 <_writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t _writes(void *ip, const uint8_t *bp, size_t n) {
 8006d80:	b538      	push	{r3, r4, r5, lr}
  MemoryStream *msp = ip;

  if (msp->size - msp->eos < n)
 8006d82:	68c3      	ldr	r3, [r0, #12]
 8006d84:	6884      	ldr	r4, [r0, #8]
 8006d86:	1ae4      	subs	r4, r4, r3

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t _writes(void *ip, const uint8_t *bp, size_t n) {
 8006d88:	4605      	mov	r5, r0
 8006d8a:	4294      	cmp	r4, r2
  MemoryStream *msp = ip;

  if (msp->size - msp->eos < n)
    n = msp->size - msp->eos;
  memcpy(msp->buffer + msp->eos, bp, n);
 8006d8c:	6840      	ldr	r0, [r0, #4]
 8006d8e:	bf28      	it	cs
 8006d90:	4614      	movcs	r4, r2
 8006d92:	4418      	add	r0, r3
 8006d94:	4622      	mov	r2, r4
 8006d96:	f7fa fadb 	bl	8001350 <memcpy>
  msp->eos += n;
 8006d9a:	68eb      	ldr	r3, [r5, #12]
 8006d9c:	4423      	add	r3, r4
 8006d9e:	60eb      	str	r3, [r5, #12]
  return n;
}
 8006da0:	4620      	mov	r0, r4
 8006da2:	bd38      	pop	{r3, r4, r5, pc}
	...

08006db0 <spi_lld_serve_tx_interrupt.lto_priv.110>:
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8006db0:	f011 0f0c 	tst.w	r1, #12
 8006db4:	d100      	bne.n	8006db8 <spi_lld_serve_tx_interrupt.lto_priv.110+0x8>
 8006db6:	4770      	bx	lr
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 8006db8:	b508      	push	{r3, lr}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8006dba:	4801      	ldr	r0, [pc, #4]	; (8006dc0 <spi_lld_serve_tx_interrupt.lto_priv.110+0x10>)
 8006dbc:	f004 fed8 	bl	800bb70 <chSysHalt>
 8006dc0:	0800fb48 	.word	0x0800fb48
	...

08006dd0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8006dd0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  USART_TypeDef *u = sdp->usart;
 8006dd4:	6f46      	ldr	r6, [r0, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8006dd6:	f8d6 a00c 	ldr.w	sl, [r6, #12]
  uint16_t sr = u->SR;
 8006dda:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8006ddc:	05d9      	lsls	r1, r3, #23
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8006dde:	4605      	mov	r5, r0
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8006de0:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8006de2:	f100 80aa 	bmi.w	8006f3a <serve_interrupt+0x16a>
 8006de6:	2320      	movs	r3, #32
 8006de8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006dec:	f005 f968 	bl	800c0c0 <_dbg_check_lock_from_isr>
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8006df0:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8006df4:	d046      	beq.n	8006e84 <serve_interrupt+0xb4>
    sts |= SD_PARITY_ERROR;
  if (sr & USART_SR_FE)
    sts |= SD_FRAMING_ERROR;
  if (sr & USART_SR_NE)
    sts |= SD_NOISE_ERROR;
  chnAddFlagsI(sdp, sts);
 8006df6:	f105 0804 	add.w	r8, r5, #4
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8006dfa:	f105 090c 	add.w	r9, r5, #12
 8006dfe:	e007      	b.n	8006e10 <serve_interrupt+0x40>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
 8006e00:	06a3      	lsls	r3, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8006e02:	6877      	ldr	r7, [r6, #4]
    if (sr & USART_SR_RXNE)
 8006e04:	d41d      	bmi.n	8006e42 <serve_interrupt+0x72>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8006e06:	6834      	ldr	r4, [r6, #0]
 8006e08:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8006e0a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8006e0e:	d039      	beq.n	8006e84 <serve_interrupt+0xb4>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8006e10:	0722      	lsls	r2, r4, #28
 8006e12:	d0f5      	beq.n	8006e00 <serve_interrupt+0x30>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8006e14:	f014 0f08 	tst.w	r4, #8
 8006e18:	bf0c      	ite	eq
 8006e1a:	2100      	moveq	r1, #0
 8006e1c:	2180      	movne	r1, #128	; 0x80
  if (sr & USART_SR_PE)
 8006e1e:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 8006e20:	bf48      	it	mi
 8006e22:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8006e26:	07a7      	lsls	r7, r4, #30
    sts |= SD_FRAMING_ERROR;
 8006e28:	bf48      	it	mi
 8006e2a:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 8006e2e:	0760      	lsls	r0, r4, #29
    sts |= SD_NOISE_ERROR;
 8006e30:	bf48      	it	mi
 8006e32:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8006e36:	4640      	mov	r0, r8
 8006e38:	f002 f8a2 	bl	8008f80 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
    if (sr & USART_SR_RXNE)
 8006e3c:	06a3      	lsls	r3, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8006e3e:	6877      	ldr	r7, [r6, #4]
    if (sr & USART_SR_RXNE)
 8006e40:	d5e1      	bpl.n	8006e06 <serve_interrupt+0x36>
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
 8006e42:	f004 fef5 	bl	800bc30 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8006e46:	696b      	ldr	r3, [r5, #20]
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = (uint8_t)u->DR & sdp->rxmask;
 8006e48:	f895 4078 	ldrb.w	r4, [r5, #120]	; 0x78
 8006e4c:	b333      	cbz	r3, 8006e9c <serve_interrupt+0xcc>
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();
 8006e4e:	f004 feef 	bl	800bc30 <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
 8006e52:	6a2b      	ldr	r3, [r5, #32]
 8006e54:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8006e56:	4293      	cmp	r3, r2
 8006e58:	d02a      	beq.n	8006eb0 <serve_interrupt+0xe0>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8006e5a:	696a      	ldr	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 8006e5c:	1c59      	adds	r1, r3, #1

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8006e5e:	3201      	adds	r2, #1
  *iqp->q_wrptr++ = b;
 8006e60:	4027      	ands	r7, r4

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8006e62:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 8006e64:	6229      	str	r1, [r5, #32]
 8006e66:	701f      	strb	r7, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8006e68:	6a2a      	ldr	r2, [r5, #32]
 8006e6a:	69eb      	ldr	r3, [r5, #28]
 8006e6c:	429a      	cmp	r2, r3
 8006e6e:	d301      	bcc.n	8006e74 <serve_interrupt+0xa4>
    iqp->q_wrptr = iqp->q_buffer;
 8006e70:	69ab      	ldr	r3, [r5, #24]
 8006e72:	622b      	str	r3, [r5, #32]
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 8006e74:	4648      	mov	r0, r9
 8006e76:	f003 fabb 	bl	800a3f0 <chThdDequeueNextI.constprop.88>
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8006e7a:	6834      	ldr	r4, [r6, #0]
 8006e7c:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8006e7e:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8006e82:	d1c5      	bne.n	8006e10 <serve_interrupt+0x40>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006e84:	f005 f904 	bl	800c090 <_dbg_check_unlock_from_isr>
 8006e88:	2300      	movs	r3, #0
 8006e8a:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8006e8e:	f01a 0f80 	tst.w	sl, #128	; 0x80
 8006e92:	d116      	bne.n	8006ec2 <serve_interrupt+0xf2>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8006e94:	0662      	lsls	r2, r4, #25
 8006e96:	d438      	bmi.n	8006f0a <serve_interrupt+0x13a>
 8006e98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8006e9c:	2104      	movs	r1, #4
 8006e9e:	4640      	mov	r0, r8
 8006ea0:	f002 f86e 	bl	8008f80 <chEvtBroadcastFlagsI>
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();
 8006ea4:	f004 fec4 	bl	800bc30 <chDbgCheckClassI>

  if (iqIsFullI(iqp)) {
 8006ea8:	6a2b      	ldr	r3, [r5, #32]
 8006eaa:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8006eac:	4293      	cmp	r3, r2
 8006eae:	d1d4      	bne.n	8006e5a <serve_interrupt+0x8a>
 8006eb0:	696a      	ldr	r2, [r5, #20]
 8006eb2:	2a00      	cmp	r2, #0
 8006eb4:	d0d1      	beq.n	8006e5a <serve_interrupt+0x8a>
 8006eb6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8006eba:	4640      	mov	r0, r8
 8006ebc:	f002 f860 	bl	8008f80 <chEvtBroadcastFlagsI>
 8006ec0:	e7a1      	b.n	8006e06 <serve_interrupt+0x36>
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8006ec2:	0621      	lsls	r1, r4, #24
 8006ec4:	d5e6      	bpl.n	8006e94 <serve_interrupt+0xc4>
 8006ec6:	2320      	movs	r3, #32
 8006ec8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006ecc:	f005 f8f8 	bl	800c0c0 <_dbg_check_lock_from_isr>
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();
 8006ed0:	f004 feae 	bl	800bc30 <chDbgCheckClassI>

  if (oqIsEmptyI(oqp)) {
 8006ed4:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8006ed6:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8006ed8:	429a      	cmp	r2, r3
 8006eda:	d049      	beq.n	8006f70 <serve_interrupt+0x1a0>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8006edc:	6baa      	ldr	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8006ede:	6c29      	ldr	r1, [r5, #64]	; 0x40
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8006ee0:	1c58      	adds	r0, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8006ee2:	3201      	adds	r2, #1
 8006ee4:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8006ee6:	64a8      	str	r0, [r5, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 8006ee8:	4288      	cmp	r0, r1
  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8006eea:	781f      	ldrb	r7, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8006eec:	d301      	bcc.n	8006ef2 <serve_interrupt+0x122>
    oqp->q_rdptr = oqp->q_buffer;
 8006eee:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8006ef0:	64ab      	str	r3, [r5, #72]	; 0x48
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueNextI(tqp, msg);
 8006ef2:	f105 0030 	add.w	r0, r5, #48	; 0x30
 8006ef6:	f003 fa7b 	bl	800a3f0 <chThdDequeueNextI.constprop.88>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8006efa:	6077      	str	r7, [r6, #4]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006efc:	f005 f8c8 	bl	800c090 <_dbg_check_unlock_from_isr>
 8006f00:	2300      	movs	r3, #0
 8006f02:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8006f06:	0662      	lsls	r2, r4, #25
 8006f08:	d5c6      	bpl.n	8006e98 <serve_interrupt+0xc8>
 8006f0a:	2320      	movs	r3, #32
 8006f0c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006f10:	f005 f8d6 	bl	800c0c0 <_dbg_check_lock_from_isr>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8006f14:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8006f16:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8006f18:	429a      	cmp	r2, r3
 8006f1a:	d021      	beq.n	8006f60 <serve_interrupt+0x190>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8006f1c:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8006f20:	ea0a 0303 	and.w	r3, sl, r3
    u->SR = ~USART_SR_TC;
 8006f24:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8006f28:	60f3      	str	r3, [r6, #12]
    u->SR = ~USART_SR_TC;
 8006f2a:	6032      	str	r2, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006f2c:	f005 f8b0 	bl	800c090 <_dbg_check_unlock_from_isr>
 8006f30:	2300      	movs	r3, #0
 8006f32:	f383 8811 	msr	BASEPRI, r3
 8006f36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006f3a:	2320      	movs	r3, #32
 8006f3c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8006f40:	f005 f8be 	bl	800c0c0 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8006f44:	1d28      	adds	r0, r5, #4
 8006f46:	f44f 7100 	mov.w	r1, #512	; 0x200
 8006f4a:	f002 f819 	bl	8008f80 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8006f4e:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8006f52:	6033      	str	r3, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8006f54:	f005 f89c 	bl	800c090 <_dbg_check_unlock_from_isr>
 8006f58:	2300      	movs	r3, #0
 8006f5a:	f383 8811 	msr	BASEPRI, r3
 8006f5e:	e742      	b.n	8006de6 <serve_interrupt+0x16>
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8006f60:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8006f62:	2b00      	cmp	r3, #0
 8006f64:	d0da      	beq.n	8006f1c <serve_interrupt+0x14c>
 8006f66:	1d28      	adds	r0, r5, #4
 8006f68:	2110      	movs	r1, #16
 8006f6a:	f002 f809 	bl	8008f80 <chEvtBroadcastFlagsI>
 8006f6e:	e7d5      	b.n	8006f1c <serve_interrupt+0x14c>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8006f70:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8006f72:	2a00      	cmp	r2, #0
 8006f74:	d0b2      	beq.n	8006edc <serve_interrupt+0x10c>
 8006f76:	2108      	movs	r1, #8
 8006f78:	1d28      	adds	r0, r5, #4
 8006f7a:	f002 f801 	bl	8008f80 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8006f7e:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8006f82:	ea0a 0303 	and.w	r3, sl, r3
 8006f86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006f8a:	60f3      	str	r3, [r6, #12]
 8006f8c:	e7b6      	b.n	8006efc <serve_interrupt+0x12c>
 8006f8e:	bf00      	nop

08006f90 <Vector114>:
/**
 * @brief   UART5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART5_HANDLER) {
 8006f90:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8006f92:	4c09      	ldr	r4, [pc, #36]	; (8006fb8 <Vector114+0x28>)
 8006f94:	4620      	mov	r0, r4
 8006f96:	f004 fdcb 	bl	800bb30 <_trace_isr_enter>
 8006f9a:	f005 f861 	bl	800c060 <_dbg_check_enter_isr>

  serve_interrupt(&SD5);
 8006f9e:	4807      	ldr	r0, [pc, #28]	; (8006fbc <Vector114+0x2c>)
 8006fa0:	f7ff ff16 	bl	8006dd0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006fa4:	f005 f844 	bl	800c030 <_dbg_check_leave_isr>
 8006fa8:	4620      	mov	r0, r4
 8006faa:	f004 fda1 	bl	800baf0 <_trace_isr_leave>
}
 8006fae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD5);

  OSAL_IRQ_EPILOGUE();
 8006fb2:	f001 bfb5 	b.w	8008f20 <_port_irq_epilogue>
 8006fb6:	bf00      	nop
 8006fb8:	0800fb9c 	.word	0x0800fb9c
 8006fbc:	2001b6a4 	.word	0x2001b6a4

08006fc0 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8006fc0:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();
 8006fc2:	4c09      	ldr	r4, [pc, #36]	; (8006fe8 <VectorDC+0x28>)
 8006fc4:	4620      	mov	r0, r4
 8006fc6:	f004 fdb3 	bl	800bb30 <_trace_isr_enter>
 8006fca:	f005 f849 	bl	800c060 <_dbg_check_enter_isr>

  serve_interrupt(&SD3);
 8006fce:	4807      	ldr	r0, [pc, #28]	; (8006fec <VectorDC+0x2c>)
 8006fd0:	f7ff fefe 	bl	8006dd0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8006fd4:	f005 f82c 	bl	800c030 <_dbg_check_leave_isr>
 8006fd8:	4620      	mov	r0, r4
 8006fda:	f004 fd89 	bl	800baf0 <_trace_isr_leave>
}
 8006fde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 8006fe2:	f001 bf9d 	b.w	8008f20 <_port_irq_epilogue>
 8006fe6:	bf00      	nop
 8006fe8:	0800fb5c 	.word	0x0800fb5c
 8006fec:	2001ac28 	.word	0x2001ac28

08006ff0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8006ff0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8006ff4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8006ff8:	482f      	ldr	r0, [pc, #188]	; (80070b8 <VectorB0+0xc8>)
 8006ffa:	f004 fd99 	bl	800bb30 <_trace_isr_enter>
 8006ffe:	f005 f82f 	bl	800c060 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8007002:	693b      	ldr	r3, [r7, #16]
 8007004:	079b      	lsls	r3, r3, #30
 8007006:	d408      	bmi.n	800701a <VectorB0+0x2a>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8007008:	f005 f812 	bl	800c030 <_dbg_check_leave_isr>
 800700c:	482a      	ldr	r0, [pc, #168]	; (80070b8 <VectorB0+0xc8>)
 800700e:	f004 fd6f 	bl	800baf0 <_trace_isr_leave>
}
 8007012:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8007016:	f001 bf83 	b.w	8008f20 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 800701a:	2600      	movs	r6, #0
 800701c:	613e      	str	r6, [r7, #16]
 800701e:	f04f 0820 	mov.w	r8, #32
 8007022:	f388 8811 	msr	BASEPRI, r8
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8007026:	4d25      	ldr	r5, [pc, #148]	; (80070bc <VectorB0+0xcc>)
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8007028:	f005 f84a 	bl	800c0c0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 800702c:	f004 fe00 	bl	800bc30 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 8007030:	f004 fdfe 	bl	800bc30 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8007034:	69ec      	ldr	r4, [r5, #28]
 8007036:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8007038:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800703a:	68a1      	ldr	r1, [r4, #8]
 800703c:	1ac2      	subs	r2, r0, r3
 800703e:	428a      	cmp	r2, r1
 8007040:	f105 091c 	add.w	r9, r5, #28
 8007044:	d31c      	bcc.n	8007080 <VectorB0+0x90>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8007046:	6822      	ldr	r2, [r4, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 8007048:	f8d4 a00c 	ldr.w	sl, [r4, #12]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 800704c:	440b      	add	r3, r1
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 800704e:	454a      	cmp	r2, r9
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8007050:	62ab      	str	r3, [r5, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8007052:	f8c2 9004 	str.w	r9, [r2, #4]
    ch.vtlist.next = vtp->next;
 8007056:	61ea      	str	r2, [r5, #28]
    fn = vtp->func;
    vtp->func = NULL;
 8007058:	60e6      	str	r6, [r4, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800705a:	bf08      	it	eq
 800705c:	60fe      	streq	r6, [r7, #12]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800705e:	f005 f817 	bl	800c090 <_dbg_check_unlock_from_isr>
 8007062:	f386 8811 	msr	BASEPRI, r6
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8007066:	6920      	ldr	r0, [r4, #16]
 8007068:	47d0      	blx	sl
 800706a:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800706e:	f005 f827 	bl	800c0c0 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8007072:	69ec      	ldr	r4, [r5, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8007074:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8007076:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8007078:	68a1      	ldr	r1, [r4, #8]
 800707a:	1ac2      	subs	r2, r0, r3
 800707c:	4291      	cmp	r1, r2
 800707e:	d9e2      	bls.n	8007046 <VectorB0+0x56>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8007080:	454c      	cmp	r4, r9
 8007082:	d010      	beq.n	80070a6 <VectorB0+0xb6>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8007084:	440b      	add	r3, r1
 8007086:	1a1b      	subs	r3, r3, r0
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8007088:	2b01      	cmp	r3, #1
 800708a:	bf98      	it	ls
 800708c:	2302      	movls	r3, #2
  }
  port_timer_set_alarm(now + delta);
 800708e:	181c      	adds	r4, r3, r0
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8007090:	4620      	mov	r0, r4
 8007092:	f001 ff35 	bl	8008f00 <stSetAlarm>
 8007096:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 800709a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 800709c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800709e:	1a63      	subs	r3, r4, r1
 80070a0:	1a52      	subs	r2, r2, r1
 80070a2:	429a      	cmp	r2, r3
 80070a4:	d805      	bhi.n	80070b2 <VectorB0+0xc2>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80070a6:	f004 fff3 	bl	800c090 <_dbg_check_unlock_from_isr>
 80070aa:	2300      	movs	r3, #0
 80070ac:	f383 8811 	msr	BASEPRI, r3
 80070b0:	e7aa      	b.n	8007008 <VectorB0+0x18>
 80070b2:	4803      	ldr	r0, [pc, #12]	; (80070c0 <VectorB0+0xd0>)
 80070b4:	f004 fd5c 	bl	800bb70 <chSysHalt>
 80070b8:	0800fb20 	.word	0x0800fb20
 80070bc:	2001acdc 	.word	0x2001acdc
 80070c0:	0800fb2c 	.word	0x0800fb2c
	...

080070d0 <spi_lld_serve_rx_interrupt.lto_priv.109>:
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80070d0:	f011 0f0c 	tst.w	r1, #12
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 80070d4:	b538      	push	{r3, r4, r5, lr}

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80070d6:	d139      	bne.n	800714c <spi_lld_serve_rx_interrupt.lto_priv.109+0x7c>
 80070d8:	4604      	mov	r4, r0
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 80070da:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80070dc:	6802      	ldr	r2, [r0, #0]
 80070de:	6813      	ldr	r3, [r2, #0]
 80070e0:	f023 031f 	bic.w	r3, r3, #31
 80070e4:	6013      	str	r3, [r2, #0]
 80070e6:	6813      	ldr	r3, [r2, #0]
 80070e8:	07d9      	lsls	r1, r3, #31
 80070ea:	d4fc      	bmi.n	80070e6 <spi_lld_serve_rx_interrupt.lto_priv.109+0x16>
 80070ec:	7a05      	ldrb	r5, [r0, #8]
  dmaStreamDisable(spip->dmarx);
 80070ee:	6a21      	ldr	r1, [r4, #32]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 80070f0:	6840      	ldr	r0, [r0, #4]
  dmaStreamDisable(spip->dmarx);
 80070f2:	680a      	ldr	r2, [r1, #0]
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 80070f4:	233d      	movs	r3, #61	; 0x3d
 80070f6:	40ab      	lsls	r3, r5
 80070f8:	6003      	str	r3, [r0, #0]
  dmaStreamDisable(spip->dmarx);
 80070fa:	6813      	ldr	r3, [r2, #0]
 80070fc:	f023 031f 	bic.w	r3, r3, #31
 8007100:	6013      	str	r3, [r2, #0]
 8007102:	6813      	ldr	r3, [r2, #0]
 8007104:	07db      	lsls	r3, r3, #31
 8007106:	d4fc      	bmi.n	8007102 <spi_lld_serve_rx_interrupt.lto_priv.109+0x32>

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8007108:	6863      	ldr	r3, [r4, #4]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 800710a:	7a08      	ldrb	r0, [r1, #8]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800710c:	681a      	ldr	r2, [r3, #0]
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
  dmaStreamDisable(spip->dmarx);
 800710e:	6849      	ldr	r1, [r1, #4]
 8007110:	233d      	movs	r3, #61	; 0x3d
 8007112:	4083      	lsls	r3, r0
 8007114:	600b      	str	r3, [r1, #0]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 8007116:	b1b2      	cbz	r2, 8007146 <spi_lld_serve_rx_interrupt.lto_priv.109+0x76>
 8007118:	2304      	movs	r3, #4
 800711a:	7023      	strb	r3, [r4, #0]
 800711c:	4620      	mov	r0, r4
 800711e:	4790      	blx	r2
 8007120:	7823      	ldrb	r3, [r4, #0]
 8007122:	2b04      	cmp	r3, #4
 8007124:	d00f      	beq.n	8007146 <spi_lld_serve_rx_interrupt.lto_priv.109+0x76>
 8007126:	2320      	movs	r3, #32
 8007128:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800712c:	f004 ffc8 	bl	800c0c0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8007130:	f104 0008 	add.w	r0, r4, #8
 8007134:	2100      	movs	r1, #0
 8007136:	f004 fe6b 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800713a:	f004 ffa9 	bl	800c090 <_dbg_check_unlock_from_isr>
 800713e:	2300      	movs	r3, #0
 8007140:	f383 8811 	msr	BASEPRI, r3
 8007144:	bd38      	pop	{r3, r4, r5, pc}
 8007146:	2302      	movs	r3, #2
 8007148:	7023      	strb	r3, [r4, #0]
 800714a:	e7ec      	b.n	8007126 <spi_lld_serve_rx_interrupt.lto_priv.109+0x56>
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 800714c:	4801      	ldr	r0, [pc, #4]	; (8007154 <spi_lld_serve_rx_interrupt.lto_priv.109+0x84>)
 800714e:	f004 fd0f 	bl	800bb70 <chSysHalt>
 8007152:	bf00      	nop
 8007154:	0800fb48 	.word	0x0800fb48
	...

08007160 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8007160:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8007164:	4eb9      	ldr	r6, [pc, #740]	; (800744c <Vector14C+0x2ec>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8007166:	48ba      	ldr	r0, [pc, #744]	; (8007450 <Vector14C+0x2f0>)
 8007168:	f004 fce2 	bl	800bb30 <_trace_isr_enter>
 800716c:	f004 ff78 	bl	800c060 <_dbg_check_enter_isr>
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8007170:	6d75      	ldr	r5, [r6, #84]	; 0x54
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8007172:	696f      	ldr	r7, [r5, #20]
  sts &= otgp->GINTMSK;
 8007174:	69ab      	ldr	r3, [r5, #24]
 8007176:	401f      	ands	r7, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8007178:	f417 5980 	ands.w	r9, r7, #4096	; 0x1000
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 800717c:	616f      	str	r7, [r5, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 800717e:	f040 80e4 	bne.w	800734a <Vector14C+0x1ea>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8007182:	2f00      	cmp	r7, #0
 8007184:	db67      	blt.n	8007256 <Vector14C+0xf6>

    _usb_wakeup(usbp);
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8007186:	053b      	lsls	r3, r7, #20
 8007188:	d456      	bmi.n	8007238 <Vector14C+0xd8>
    /* Default suspend action.*/
    _usb_suspend(usbp);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 800718a:	04bc      	lsls	r4, r7, #18
 800718c:	d50c      	bpl.n	80071a8 <Vector14C+0x48>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 800718e:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
 8007192:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8007196:	68eb      	ldr	r3, [r5, #12]
 8007198:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 800719c:	bf0c      	ite	eq
 800719e:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 80071a2:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 80071a6:	60eb      	str	r3, [r5, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 80071a8:	0738      	lsls	r0, r7, #28
 80071aa:	d504      	bpl.n	80071b6 <Vector14C+0x56>
    _usb_isr_invoke_sof_cb(usbp);
 80071ac:	6873      	ldr	r3, [r6, #4]
 80071ae:	68db      	ldr	r3, [r3, #12]
 80071b0:	b10b      	cbz	r3, 80071b6 <Vector14C+0x56>
 80071b2:	48a6      	ldr	r0, [pc, #664]	; (800744c <Vector14C+0x2ec>)
 80071b4:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 80071b6:	02fa      	lsls	r2, r7, #11
 80071b8:	d468      	bmi.n	800728c <Vector14C+0x12c>
    otg_isoc_in_failed_handler(usbp);
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 80071ba:	02bb      	lsls	r3, r7, #10
 80071bc:	f100 813f 	bmi.w	800743e <Vector14C+0x2de>
    otg_isoc_out_failed_handler(usbp);
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 80071c0:	06fe      	lsls	r6, r7, #27
 80071c2:	d426      	bmi.n	8007212 <Vector14C+0xb2>
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 80071c4:	f8d5 4818 	ldr.w	r4, [r5, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 80071c8:	033d      	lsls	r5, r7, #12
 80071ca:	d50b      	bpl.n	80071e4 <Vector14C+0x84>
    if (src & (1 << 16))
 80071cc:	03e0      	lsls	r0, r4, #15
 80071ce:	f100 818d 	bmi.w	80074ec <Vector14C+0x38c>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 80071d2:	03a1      	lsls	r1, r4, #14
 80071d4:	f100 8186 	bmi.w	80074e4 <Vector14C+0x384>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 80071d8:	0362      	lsls	r2, r4, #13
 80071da:	f100 817f 	bmi.w	80074dc <Vector14C+0x37c>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 80071de:	0323      	lsls	r3, r4, #12
 80071e0:	f100 8164 	bmi.w	80074ac <Vector14C+0x34c>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 80071e4:	037f      	lsls	r7, r7, #13
 80071e6:	d50b      	bpl.n	8007200 <Vector14C+0xa0>
    if (src & (1 << 0))
 80071e8:	07e6      	lsls	r6, r4, #31
 80071ea:	f100 8173 	bmi.w	80074d4 <Vector14C+0x374>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 80071ee:	07a5      	lsls	r5, r4, #30
 80071f0:	f100 8166 	bmi.w	80074c0 <Vector14C+0x360>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 80071f4:	0760      	lsls	r0, r4, #29
 80071f6:	f100 8169 	bmi.w	80074cc <Vector14C+0x36c>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 80071fa:	0721      	lsls	r1, r4, #28
 80071fc:	f100 811b 	bmi.w	8007436 <Vector14C+0x2d6>

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 8007200:	f004 ff16 	bl	800c030 <_dbg_check_leave_isr>
 8007204:	4892      	ldr	r0, [pc, #584]	; (8007450 <Vector14C+0x2f0>)
 8007206:	f004 fc73 	bl	800baf0 <_trace_isr_leave>
}
 800720a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800720e:	f001 be87 	b.w	8008f20 <_port_irq_epilogue>
 8007212:	2320      	movs	r3, #32
 8007214:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8007218:	f004 ff52 	bl	800c0c0 <_dbg_check_lock_from_isr>
  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 800721c:	69ab      	ldr	r3, [r5, #24]
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800721e:	488d      	ldr	r0, [pc, #564]	; (8007454 <Vector14C+0x2f4>)
 8007220:	f023 0310 	bic.w	r3, r3, #16
 8007224:	61ab      	str	r3, [r5, #24]
 8007226:	2100      	movs	r1, #0
 8007228:	f004 fdf2 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800722c:	f004 ff30 	bl	800c090 <_dbg_check_unlock_from_isr>
 8007230:	2300      	movs	r3, #0
 8007232:	f383 8811 	msr	BASEPRI, r3
 8007236:	e7c5      	b.n	80071c4 <Vector14C+0x64>
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8007238:	6873      	ldr	r3, [r6, #4]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 800723a:	7832      	ldrb	r2, [r6, #0]
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800723c:	681b      	ldr	r3, [r3, #0]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 800723e:	f886 2050 	strb.w	r2, [r6, #80]	; 0x50

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8007242:	2100      	movs	r1, #0
  usbp->state       = USB_SUSPENDED;
 8007244:	2205      	movs	r2, #5
 8007246:	6631      	str	r1, [r6, #96]	; 0x60
 8007248:	7032      	strb	r2, [r6, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 800724a:	2b00      	cmp	r3, #0
 800724c:	d09d      	beq.n	800718a <Vector14C+0x2a>
 800724e:	2104      	movs	r1, #4
 8007250:	487e      	ldr	r0, [pc, #504]	; (800744c <Vector14C+0x2ec>)
 8007252:	4798      	blx	r3
 8007254:	e799      	b.n	800718a <Vector14C+0x2a>

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8007256:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 800725a:	079a      	lsls	r2, r3, #30
 800725c:	d005      	beq.n	800726a <Vector14C+0x10a>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 800725e:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 8007262:	f023 0303 	bic.w	r3, r3, #3
 8007266:	f8c5 3e00 	str.w	r3, [r5, #3584]	; 0xe00

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 800726a:	6872      	ldr	r2, [r6, #4]
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 800726c:	f8d5 3804 	ldr.w	r3, [r5, #2052]	; 0x804
 8007270:	6812      	ldr	r2, [r2, #0]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8007272:	f896 1050 	ldrb.w	r1, [r6, #80]	; 0x50
 8007276:	7031      	strb	r1, [r6, #0]
 8007278:	f043 0301 	orr.w	r3, r3, #1
 800727c:	f8c5 3804 	str.w	r3, [r5, #2052]	; 0x804

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8007280:	2a00      	cmp	r2, #0
 8007282:	d080      	beq.n	8007186 <Vector14C+0x26>
 8007284:	2105      	movs	r1, #5
 8007286:	4871      	ldr	r0, [pc, #452]	; (800744c <Vector14C+0x2ec>)
 8007288:	4790      	blx	r2
 800728a:	e77c      	b.n	8007186 <Vector14C+0x26>
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 800728c:	f8d6 a054 	ldr.w	sl, [r6, #84]	; 0x54
 8007290:	2400      	movs	r4, #0

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 8007292:	f04f 0801 	mov.w	r8, #1
 8007296:	e007      	b.n	80072a8 <Vector14C+0x148>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8007298:	6db3      	ldr	r3, [r6, #88]	; 0x58
 800729a:	4a6c      	ldr	r2, [pc, #432]	; (800744c <Vector14C+0x2ec>)
 800729c:	689b      	ldr	r3, [r3, #8]
 800729e:	3401      	adds	r4, #1
 80072a0:	b2e4      	uxtb	r4, r4
 80072a2:	429c      	cmp	r4, r3
 80072a4:	46a1      	mov	r9, r4
 80072a6:	d84a      	bhi.n	800733e <Vector14C+0x1de>
 80072a8:	eb0a 1244 	add.w	r2, sl, r4, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80072ac:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 80072b0:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 80072b4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80072b8:	d1ee      	bne.n	8007298 <Vector14C+0x138>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 80072ba:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 80072be:	2b00      	cmp	r3, #0
 80072c0:	daea      	bge.n	8007298 <Vector14C+0x138>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 80072c2:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 80072c6:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 80072ca:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 80072ce:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 80072d2:	2b00      	cmp	r3, #0
 80072d4:	dbfb      	blt.n	80072ce <Vector14C+0x16e>
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80072d6:	ea4f 1989 	mov.w	r9, r9, lsl #6
 80072da:	6d72      	ldr	r2, [r6, #84]	; 0x54
 80072dc:	f049 0320 	orr.w	r3, r9, #32
 80072e0:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80072e2:	6913      	ldr	r3, [r2, #16]
 80072e4:	0699      	lsls	r1, r3, #26
 80072e6:	d4fc      	bmi.n	80072e2 <Vector14C+0x182>
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 80072e8:	f003 f872 	bl	800a3d0 <chSysPolledDelayX.constprop.92>

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 80072ec:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 80072f0:	fa08 f904 	lsl.w	r9, r8, r4
 80072f4:	68da      	ldr	r2, [r3, #12]
 80072f6:	8933      	ldrh	r3, [r6, #8]
 80072f8:	6892      	ldr	r2, [r2, #8]
 80072fa:	ea6f 0b09 	mvn.w	fp, r9
 80072fe:	ea0b 0303 	and.w	r3, fp, r3
 8007302:	8133      	strh	r3, [r6, #8]
 8007304:	b112      	cbz	r2, 800730c <Vector14C+0x1ac>
 8007306:	4621      	mov	r1, r4
 8007308:	4850      	ldr	r0, [pc, #320]	; (800744c <Vector14C+0x2ec>)
 800730a:	4790      	blx	r2
 800730c:	2320      	movs	r3, #32
 800730e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8007312:	f004 fed5 	bl	800c0c0 <_dbg_check_lock_from_isr>

      /* Pump out data for next frame */
      osalSysLockFromISR();
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8007316:	f8da 2834 	ldr.w	r2, [sl, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 800731a:	6e33      	ldr	r3, [r6, #96]	; 0x60
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800731c:	484d      	ldr	r0, [pc, #308]	; (8007454 <Vector14C+0x2f4>)
      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);

      /* Pump out data for next frame */
      osalSysLockFromISR();
      otgp->DIEPEMPMSK &= ~(1 << ep);
 800731e:	ea0b 0202 	and.w	r2, fp, r2
      usbp->txpending |= (1 << ep);
 8007322:	ea43 0309 	orr.w	r3, r3, r9
      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);

      /* Pump out data for next frame */
      osalSysLockFromISR();
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8007326:	f8ca 2834 	str.w	r2, [sl, #2100]	; 0x834
 800732a:	2100      	movs	r1, #0
      usbp->txpending |= (1 << ep);
 800732c:	6633      	str	r3, [r6, #96]	; 0x60
 800732e:	f004 fd6f 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8007332:	f004 fead 	bl	800c090 <_dbg_check_unlock_from_isr>
 8007336:	2300      	movs	r3, #0
 8007338:	f383 8811 	msr	BASEPRI, r3
 800733c:	e7ac      	b.n	8007298 <Vector14C+0x138>
  if (sts & GINTSTS_IISOIXFR) {
    otg_isoc_in_failed_handler(usbp);
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 800733e:	02bb      	lsls	r3, r7, #10
 8007340:	f57f af3e 	bpl.w	80071c0 <Vector14C+0x60>
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8007344:	f8d2 8054 	ldr.w	r8, [r2, #84]	; 0x54
 8007348:	e07b      	b.n	8007442 <Vector14C+0x2e2>

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 800734a:	2300      	movs	r3, #0
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 800734c:	2102      	movs	r1, #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800734e:	2220      	movs	r2, #32

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8007350:	6633      	str	r3, [r6, #96]	; 0x60

  /* Resetting internal state.*/
  usbp->status        = 0;
 8007352:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
  usbp->address       = 0;
 8007356:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
  usbp->configuration = 0;
 800735a:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 800735e:	60f3      	str	r3, [r6, #12]
 8007360:	6133      	str	r3, [r6, #16]
 8007362:	6173      	str	r3, [r6, #20]
 8007364:	61b3      	str	r3, [r6, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8007366:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34

  /* Resetting internal state.*/
  usbp->status        = 0;
  usbp->address       = 0;
  usbp->configuration = 0;
  usbp->transmitting  = 0;
 800736a:	8133      	strh	r3, [r6, #8]
  usbp->receiving     = 0;
 800736c:	8173      	strh	r3, [r6, #10]
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 800736e:	7031      	strb	r1, [r6, #0]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8007370:	612a      	str	r2, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8007372:	692b      	ldr	r3, [r5, #16]
 8007374:	f013 0420 	ands.w	r4, r3, #32
 8007378:	d1fb      	bne.n	8007372 <Vector14C+0x212>
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 800737a:	f003 f829 	bl	800a3d0 <chSysPolledDelayX.constprop.92>
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800737e:	f8d6 e058 	ldr.w	lr, [r6, #88]	; 0x58

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8007382:	f8c5 4834 	str.w	r4, [r5, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8007386:	f04f 1201 	mov.w	r2, #65537	; 0x10001

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800738a:	f8de 7008 	ldr.w	r7, [lr, #8]
  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800738e:	f8c5 281c 	str.w	r2, [r5, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8007392:	4623      	mov	r3, r4
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8007394:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8007398:	f04f 31ff 	mov.w	r1, #4294967295
 800739c:	eb05 1243 	add.w	r2, r5, r3, lsl #5
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80073a0:	3301      	adds	r3, #1
 80073a2:	42bb      	cmp	r3, r7
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 80073a4:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 80073a8:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80073ac:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80073b0:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80073b4:	d9f2      	bls.n	800739c <Vector14C+0x23c>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 80073b6:	f8de 3000 	ldr.w	r3, [lr]
 80073ba:	65f3      	str	r3, [r6, #92]	; 0x5c

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80073bc:	f8de 2000 	ldr.w	r2, [lr]
 80073c0:	6d73      	ldr	r3, [r6, #84]	; 0x54
 80073c2:	626a      	str	r2, [r5, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80073c4:	2210      	movs	r2, #16
 80073c6:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80073c8:	6919      	ldr	r1, [r3, #16]
 80073ca:	f011 0410 	ands.w	r4, r1, #16
 80073ce:	d1fb      	bne.n	80073c8 <Vector14C+0x268>
 80073d0:	f002 fffe 	bl	800a3d0 <chSysPolledDelayX.constprop.92>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80073d4:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 80073d8:	6df2      	ldr	r2, [r6, #92]	; 0x5c
 80073da:	6db7      	ldr	r7, [r6, #88]	; 0x58
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 80073dc:	481e      	ldr	r0, [pc, #120]	; (8007458 <Vector14C+0x2f8>)
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80073de:	491f      	ldr	r1, [pc, #124]	; (800745c <Vector14C+0x2fc>)
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80073e0:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80073e4:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80073e8:	69ab      	ldr	r3, [r5, #24]
 80073ea:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 80073ee:	f043 0310 	orr.w	r3, r3, #16
 80073f2:	61ab      	str	r3, [r5, #24]
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 80073f4:	f102 0310 	add.w	r3, r2, #16
 80073f8:	65f3      	str	r3, [r6, #92]	; 0x5c
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 80073fa:	687f      	ldr	r7, [r7, #4]
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 80073fc:	60f0      	str	r0, [r6, #12]
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 80073fe:	42bb      	cmp	r3, r7
  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8007400:	f04f 0009 	mov.w	r0, #9
 8007404:	f8c5 0810 	str.w	r0, [r5, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8007408:	f8c5 0814 	str.w	r0, [r5, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
 800740c:	f8c5 4b10 	str.w	r4, [r5, #2832]	; 0xb10
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8007410:	480e      	ldr	r0, [pc, #56]	; (800744c <Vector14C+0x2ec>)
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8007412:	f8c5 1b00 	str.w	r1, [r5, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8007416:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 800741a:	f8c5 1900 	str.w	r1, [r5, #2304]	; 0x900
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800741e:	d84c      	bhi.n	80074ba <Vector14C+0x35a>

  /* Low level reset.*/
  usb_lld_reset(usbp);

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8007420:	6843      	ldr	r3, [r0, #4]
 8007422:	681b      	ldr	r3, [r3, #0]
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8007424:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8007428:	62aa      	str	r2, [r5, #40]	; 0x28
 800742a:	2b00      	cmp	r3, #0
 800742c:	f43f aee8 	beq.w	8007200 <Vector14C+0xa0>
 8007430:	4621      	mov	r1, r4
 8007432:	4798      	blx	r3
 8007434:	e6e4      	b.n	8007200 <Vector14C+0xa0>
    if (src & (1 << 1))
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
      otg_epin_handler(usbp, 3);
 8007436:	2003      	movs	r0, #3
 8007438:	f003 f8c2 	bl	800a5c0 <otg_epin_handler.constprop.29>
 800743c:	e6e0      	b.n	8007200 <Vector14C+0xa0>
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 800743e:	f8d6 8054 	ldr.w	r8, [r6, #84]	; 0x54
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8007442:	2400      	movs	r4, #0
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8007444:	f04f 0901 	mov.w	r9, #1
 8007448:	e011      	b.n	800746e <Vector14C+0x30e>
 800744a:	bf00      	nop
 800744c:	2001aa70 	.word	0x2001aa70
 8007450:	0800fba8 	.word	0x0800fba8
 8007454:	2001aad4 	.word	0x2001aad4
 8007458:	0800fb68 	.word	0x0800fb68
 800745c:	10008040 	.word	0x10008040
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8007460:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8007462:	3401      	adds	r4, #1
 8007464:	689b      	ldr	r3, [r3, #8]
 8007466:	b2e4      	uxtb	r4, r4
 8007468:	429c      	cmp	r4, r3
 800746a:	f63f aea9 	bhi.w	80071c0 <Vector14C+0x60>
 800746e:	eb08 1244 	add.w	r2, r8, r4, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8007472:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8007476:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 800747a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800747e:	d1ef      	bne.n	8007460 <Vector14C+0x300>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8007480:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8007484:	2b00      	cmp	r3, #0
 8007486:	daeb      	bge.n	8007460 <Vector14C+0x300>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8007488:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 800748c:	8972      	ldrh	r2, [r6, #10]
 800748e:	68d9      	ldr	r1, [r3, #12]
 8007490:	fa09 f304 	lsl.w	r3, r9, r4
 8007494:	f8d1 a00c 	ldr.w	sl, [r1, #12]
 8007498:	ea22 0303 	bic.w	r3, r2, r3
 800749c:	8173      	strh	r3, [r6, #10]
 800749e:	f1ba 0f00 	cmp.w	sl, #0
 80074a2:	d0dd      	beq.n	8007460 <Vector14C+0x300>
 80074a4:	4621      	mov	r1, r4
 80074a6:	4813      	ldr	r0, [pc, #76]	; (80074f4 <Vector14C+0x394>)
 80074a8:	47d0      	blx	sl
 80074aa:	e7d9      	b.n	8007460 <Vector14C+0x300>
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
      otg_epout_handler(usbp, 3);
 80074ac:	2003      	movs	r0, #3
 80074ae:	f003 f827 	bl	800a500 <otg_epout_handler.constprop.30>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 80074b2:	037f      	lsls	r7, r7, #13
 80074b4:	f57f aea4 	bpl.w	8007200 <Vector14C+0xa0>
 80074b8:	e696      	b.n	80071e8 <Vector14C+0x88>
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 80074ba:	480f      	ldr	r0, [pc, #60]	; (80074f8 <Vector14C+0x398>)
 80074bc:	f004 fb58 	bl	800bb70 <chSysHalt>
  }
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
      otg_epin_handler(usbp, 1);
 80074c0:	2001      	movs	r0, #1
 80074c2:	f003 f87d 	bl	800a5c0 <otg_epin_handler.constprop.29>
    if (src & (1 << 2))
 80074c6:	0760      	lsls	r0, r4, #29
 80074c8:	f57f ae97 	bpl.w	80071fa <Vector14C+0x9a>
      otg_epin_handler(usbp, 2);
 80074cc:	2002      	movs	r0, #2
 80074ce:	f003 f877 	bl	800a5c0 <otg_epin_handler.constprop.29>
 80074d2:	e692      	b.n	80071fa <Vector14C+0x9a>
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 80074d4:	2000      	movs	r0, #0
 80074d6:	f003 f873 	bl	800a5c0 <otg_epin_handler.constprop.29>
 80074da:	e688      	b.n	80071ee <Vector14C+0x8e>
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
 80074dc:	2002      	movs	r0, #2
 80074de:	f003 f80f 	bl	800a500 <otg_epout_handler.constprop.30>
 80074e2:	e67c      	b.n	80071de <Vector14C+0x7e>
  src = otgp->DAINT;
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
 80074e4:	2001      	movs	r0, #1
 80074e6:	f003 f80b 	bl	800a500 <otg_epout_handler.constprop.30>
 80074ea:	e675      	b.n	80071d8 <Vector14C+0x78>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 80074ec:	2000      	movs	r0, #0
 80074ee:	f003 f807 	bl	800a500 <otg_epout_handler.constprop.30>
 80074f2:	e66e      	b.n	80071d2 <Vector14C+0x72>
 80074f4:	2001aa70 	.word	0x2001aa70
 80074f8:	0800fb38 	.word	0x0800fb38
 80074fc:	00000000 	.word	0x00000000

08007500 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8007500:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007504:	b087      	sub	sp, #28
 8007506:	4617      	mov	r7, r2
 8007508:	f10d 030d 	add.w	r3, sp, #13
 800750c:	aa03      	add	r2, sp, #12
 800750e:	1a9b      	subs	r3, r3, r2
 8007510:	4606      	mov	r6, r0
 8007512:	460d      	mov	r5, r1
 8007514:	9301      	str	r3, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8007516:	f04f 0a00 	mov.w	sl, #0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800751a:	7829      	ldrb	r1, [r5, #0]
 800751c:	1c6a      	adds	r2, r5, #1
    if (c == 0)
 800751e:	b161      	cbz	r1, 800753a <chvprintf+0x3a>
      return n;
    if (c != '%') {
 8007520:	2925      	cmp	r1, #37	; 0x25
 8007522:	d00e      	beq.n	8007542 <chvprintf+0x42>
      streamPut(chp, (uint8_t)c);
 8007524:	6833      	ldr	r3, [r6, #0]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8007526:	4615      	mov	r5, r2
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8007528:	689b      	ldr	r3, [r3, #8]
 800752a:	4630      	mov	r0, r6
 800752c:	4798      	blx	r3
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 800752e:	7829      	ldrb	r1, [r5, #0]
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
 8007530:	f10a 0a01 	add.w	sl, sl, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8007534:	1c6a      	adds	r2, r5, #1
    if (c == 0)
 8007536:	2900      	cmp	r1, #0
 8007538:	d1f2      	bne.n	8007520 <chvprintf+0x20>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 800753a:	4650      	mov	r0, sl
 800753c:	b007      	add	sp, #28
 800753e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8007542:	7869      	ldrb	r1, [r5, #1]
 8007544:	292d      	cmp	r1, #45	; 0x2d
 8007546:	bf03      	ittte	eq
 8007548:	78a9      	ldrbeq	r1, [r5, #2]
      fmt++;
 800754a:	1caa      	addeq	r2, r5, #2
      left_align = TRUE;
 800754c:	f04f 0b01 	moveq.w	fp, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8007550:	f04f 0b00 	movne.w	fp, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8007554:	2930      	cmp	r1, #48	; 0x30
 8007556:	bf03      	ittte	eq
 8007558:	7851      	ldrbeq	r1, [r2, #1]
      fmt++;
 800755a:	3201      	addeq	r2, #1
      filler = '0';
 800755c:	f04f 0830 	moveq.w	r8, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8007560:	f04f 0820 	movne.w	r8, #32
 8007564:	1c50      	adds	r0, r2, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8007566:	f04f 0900 	mov.w	r9, #0
 800756a:	e005      	b.n	8007578 <chvprintf+0x78>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 800756c:	783b      	ldrb	r3, [r7, #0]
 800756e:	3704      	adds	r7, #4
 8007570:	7829      	ldrb	r1, [r5, #0]
      else
        break;
      width = width * 10 + c;
 8007572:	eb03 0942 	add.w	r9, r3, r2, lsl #1
 8007576:	3001      	adds	r0, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8007578:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 800757c:	b2db      	uxtb	r3, r3
 800757e:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 8007580:	4605      	mov	r5, r0
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 8007582:	eb09 0289 	add.w	r2, r9, r9, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 8007586:	d9f3      	bls.n	8007570 <chvprintf+0x70>
        c -= '0';
      else if (c == '*')
 8007588:	292a      	cmp	r1, #42	; 0x2a
 800758a:	d0ef      	beq.n	800756c <chvprintf+0x6c>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 800758c:	292e      	cmp	r1, #46	; 0x2e
 800758e:	f04f 0000 	mov.w	r0, #0
 8007592:	d043      	beq.n	800761c <chvprintf+0x11c>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8007594:	f001 02df 	and.w	r2, r1, #223	; 0xdf
 8007598:	2a4c      	cmp	r2, #76	; 0x4c
 800759a:	d04e      	beq.n	800763a <chvprintf+0x13a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800759c:	f1a1 0244 	sub.w	r2, r1, #68	; 0x44
 80075a0:	2a34      	cmp	r2, #52	; 0x34
 80075a2:	f200 80f9 	bhi.w	8007798 <chvprintf+0x298>
 80075a6:	e8df f012 	tbh	[pc, r2, lsl #1]
 80075aa:	00ee      	.short	0x00ee
 80075ac:	00f700f7 	.word	0x00f700f7
 80075b0:	00f700f7 	.word	0x00f700f7
 80075b4:	00f700ee 	.word	0x00f700ee
 80075b8:	00f700f7 	.word	0x00f700f7
 80075bc:	00f700f7 	.word	0x00f700f7
 80075c0:	00f700ec 	.word	0x00f700ec
 80075c4:	00f700f7 	.word	0x00f700f7
 80075c8:	00f700f7 	.word	0x00f700f7
 80075cc:	00f700b9 	.word	0x00f700b9
 80075d0:	006f00f7 	.word	0x006f00f7
 80075d4:	00f700f7 	.word	0x00f700f7
 80075d8:	00f700f7 	.word	0x00f700f7
 80075dc:	00f700f7 	.word	0x00f700f7
 80075e0:	00f700f7 	.word	0x00f700f7
 80075e4:	00f700f7 	.word	0x00f700f7
 80075e8:	00ee00e0 	.word	0x00ee00e0
 80075ec:	00f700f7 	.word	0x00f700f7
 80075f0:	00f700f7 	.word	0x00f700f7
 80075f4:	00f700ee 	.word	0x00f700ee
 80075f8:	00f700f7 	.word	0x00f700f7
 80075fc:	00f700f7 	.word	0x00f700f7
 8007600:	00f700ec 	.word	0x00f700ec
 8007604:	00f700f7 	.word	0x00f700f7
 8007608:	00f700bb 	.word	0x00f700bb
 800760c:	00f700b9 	.word	0x00f700b9
 8007610:	006f00f7 	.word	0x006f00f7
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8007614:	783b      	ldrb	r3, [r7, #0]
 8007616:	3704      	adds	r7, #4
        else
          break;
        precision *= 10;
        precision += c;
 8007618:	eb03 0042 	add.w	r0, r3, r2, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 800761c:	f815 1b01 	ldrb.w	r1, [r5], #1
        if (c >= '0' && c <= '9')
 8007620:	f1a1 0330 	sub.w	r3, r1, #48	; 0x30
 8007624:	b2db      	uxtb	r3, r3
 8007626:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 8007628:	eb00 0280 	add.w	r2, r0, r0, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 800762c:	d9f4      	bls.n	8007618 <chvprintf+0x118>
          c -= '0';
        else if (c == '*')
 800762e:	292a      	cmp	r1, #42	; 0x2a
 8007630:	d0f0      	beq.n	8007614 <chvprintf+0x114>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8007632:	f001 02df 	and.w	r2, r1, #223	; 0xdf
 8007636:	2a4c      	cmp	r2, #76	; 0x4c
 8007638:	d1b0      	bne.n	800759c <chvprintf+0x9c>
      is_long = TRUE;
      if (*fmt)
 800763a:	782c      	ldrb	r4, [r5, #0]
 800763c:	2c00      	cmp	r4, #0
 800763e:	f000 80ab 	beq.w	8007798 <chvprintf+0x298>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8007642:	f1a4 0244 	sub.w	r2, r4, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 8007646:	3501      	adds	r5, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8007648:	2a34      	cmp	r2, #52	; 0x34
 800764a:	f200 80a4 	bhi.w	8007796 <chvprintf+0x296>
 800764e:	e8df f002 	tbb	[pc, r2]
 8007652:	a29a      	.short	0xa29a
 8007654:	9aa2a2a2 	.word	0x9aa2a2a2
 8007658:	a2a2a2a2 	.word	0xa2a2a2a2
 800765c:	a2a298a2 	.word	0xa2a298a2
 8007660:	65a2a2a2 	.word	0x65a2a2a2
 8007664:	a21ba2a2 	.word	0xa21ba2a2
 8007668:	a2a2a2a2 	.word	0xa2a2a2a2
 800766c:	a2a2a2a2 	.word	0xa2a2a2a2
 8007670:	a29a8ca2 	.word	0xa29a8ca2
 8007674:	9aa2a2a2 	.word	0x9aa2a2a2
 8007678:	a2a2a2a2 	.word	0xa2a2a2a2
 800767c:	a2a298a2 	.word	0xa2a298a2
 8007680:	65a267a2 	.word	0x65a267a2
 8007684:	a2a2      	.short	0xa2a2
 8007686:	1b          	.byte	0x1b
 8007687:	00          	.byte	0x00
 8007688:	2210      	movs	r2, #16
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 800768a:	6839      	ldr	r1, [r7, #0]
      p = ch_ltoa(p, l, c);
 800768c:	a803      	add	r0, sp, #12
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 800768e:	3704      	adds	r7, #4
      p = ch_ltoa(p, l, c);
 8007690:	f7ff fb06 	bl	8006ca0 <ch_ltoa>
 8007694:	ab03      	add	r3, sp, #12
 8007696:	1ac0      	subs	r0, r0, r3
 8007698:	1e43      	subs	r3, r0, #1
 800769a:	9300      	str	r3, [sp, #0]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800769c:	ac03      	add	r4, sp, #12
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 800769e:	ebc0 0909 	rsb	r9, r0, r9
 80076a2:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
      width = 0;
    if (left_align == FALSE)
 80076a6:	f1bb 0f00 	cmp.w	fp, #0
 80076aa:	d15a      	bne.n	8007762 <chvprintf+0x262>
      width = -width;
 80076ac:	f1c9 0b00 	rsb	fp, r9, #0
    if (width < 0) {
 80076b0:	f1bb 0f00 	cmp.w	fp, #0
 80076b4:	d078      	beq.n	80077a8 <chvprintf+0x2a8>
      if (*s == '-' && filler == '0') {
 80076b6:	7821      	ldrb	r1, [r4, #0]
 80076b8:	292d      	cmp	r1, #45	; 0x2d
 80076ba:	f000 8088 	beq.w	80077ce <chvprintf+0x2ce>
        streamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 80076be:	6833      	ldr	r3, [r6, #0]
 80076c0:	4641      	mov	r1, r8
 80076c2:	689b      	ldr	r3, [r3, #8]
 80076c4:	4630      	mov	r0, r6
 80076c6:	4798      	blx	r3
        n++;
      } while (++width != 0);
 80076c8:	f11b 0b01 	adds.w	fp, fp, #1
 80076cc:	d1f7      	bne.n	80076be <chvprintf+0x1be>
    }
    while (--i >= 0) {
 80076ce:	9b00      	ldr	r3, [sp, #0]
 80076d0:	2b00      	cmp	r3, #0
 80076d2:	44ca      	add	sl, r9
 80076d4:	f6ff af21 	blt.w	800751a <chvprintf+0x1a>
 80076d8:	46d9      	mov	r9, fp
 80076da:	f8dd b000 	ldr.w	fp, [sp]
      streamPut(chp, (uint8_t)*s++);
 80076de:	6833      	ldr	r3, [r6, #0]
 80076e0:	f814 1b01 	ldrb.w	r1, [r4], #1
 80076e4:	689b      	ldr	r3, [r3, #8]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80076e6:	f10b 3bff 	add.w	fp, fp, #4294967295
      streamPut(chp, (uint8_t)*s++);
 80076ea:	4630      	mov	r0, r6
 80076ec:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80076ee:	f1bb 3fff 	cmp.w	fp, #4294967295
 80076f2:	d1f4      	bne.n	80076de <chvprintf+0x1de>
 80076f4:	9b00      	ldr	r3, [sp, #0]
 80076f6:	f10a 0a01 	add.w	sl, sl, #1
 80076fa:	2b00      	cmp	r3, #0
 80076fc:	bfa8      	it	ge
 80076fe:	449a      	addge	sl, r3
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8007700:	f1b9 0f00 	cmp.w	r9, #0
 8007704:	f43f af09 	beq.w	800751a <chvprintf+0x1a>
 8007708:	464c      	mov	r4, r9
      streamPut(chp, (uint8_t)filler);
 800770a:	6833      	ldr	r3, [r6, #0]
 800770c:	4641      	mov	r1, r8
 800770e:	689b      	ldr	r3, [r3, #8]
 8007710:	4630      	mov	r0, r6
 8007712:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8007714:	3c01      	subs	r4, #1
 8007716:	d1f8      	bne.n	800770a <chvprintf+0x20a>
 8007718:	44ca      	add	sl, r9
 800771a:	e6fe      	b.n	800751a <chvprintf+0x1a>
 800771c:	220a      	movs	r2, #10
 800771e:	e7b4      	b.n	800768a <chvprintf+0x18a>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8007720:	683c      	ldr	r4, [r7, #0]
        s = "(null)";
 8007722:	4a37      	ldr	r2, [pc, #220]	; (8007800 <chvprintf+0x300>)
 8007724:	2c00      	cmp	r4, #0
 8007726:	bf08      	it	eq
 8007728:	4614      	moveq	r4, r2
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 800772a:	3704      	adds	r7, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 800772c:	7822      	ldrb	r2, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 800772e:	2800      	cmp	r0, #0
 8007730:	d03e      	beq.n	80077b0 <chvprintf+0x2b0>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8007732:	2a00      	cmp	r2, #0
 8007734:	d040      	beq.n	80077b8 <chvprintf+0x2b8>
 8007736:	3801      	subs	r0, #1
 8007738:	4622      	mov	r2, r4
 800773a:	e001      	b.n	8007740 <chvprintf+0x240>
 800773c:	1c43      	adds	r3, r0, #1
 800773e:	d004      	beq.n	800774a <chvprintf+0x24a>
 8007740:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8007744:	3801      	subs	r0, #1
 8007746:	2b00      	cmp	r3, #0
 8007748:	d1f8      	bne.n	800773c <chvprintf+0x23c>
 800774a:	1b10      	subs	r0, r2, r4
 800774c:	1e43      	subs	r3, r0, #1
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 800774e:	ebc0 0909 	rsb	r9, r0, r9
 8007752:	9300      	str	r3, [sp, #0]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8007754:	f04f 0820 	mov.w	r8, #32
 8007758:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 800775c:	f1bb 0f00 	cmp.w	fp, #0
 8007760:	d0a4      	beq.n	80076ac <chvprintf+0x1ac>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8007762:	9b00      	ldr	r3, [sp, #0]
 8007764:	2b00      	cmp	r3, #0
 8007766:	dab8      	bge.n	80076da <chvprintf+0x1da>
 8007768:	e7ca      	b.n	8007700 <chvprintf+0x200>
 800776a:	9b01      	ldr	r3, [sp, #4]

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 800776c:	683a      	ldr	r2, [r7, #0]
 800776e:	f88d 200c 	strb.w	r2, [sp, #12]
 8007772:	4618      	mov	r0, r3
 8007774:	3b01      	subs	r3, #1
 8007776:	3704      	adds	r7, #4
 8007778:	9300      	str	r3, [sp, #0]
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 800777a:	f04f 0820 	mov.w	r8, #32
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 800777e:	ac03      	add	r4, sp, #12
 8007780:	e78d      	b.n	800769e <chvprintf+0x19e>
 8007782:	2208      	movs	r2, #8
 8007784:	e781      	b.n	800768a <chvprintf+0x18a>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8007786:	6839      	ldr	r1, [r7, #0]
      if (l < 0) {
 8007788:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 800778a:	f107 0704 	add.w	r7, r7, #4
      if (l < 0) {
 800778e:	db2d      	blt.n	80077ec <chvprintf+0x2ec>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8007790:	a803      	add	r0, sp, #12
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
        l = -l;
      }
      p = ch_ltoa(p, l, 10);
 8007792:	220a      	movs	r2, #10
 8007794:	e77c      	b.n	8007690 <chvprintf+0x190>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8007796:	4621      	mov	r1, r4
 8007798:	9b01      	ldr	r3, [sp, #4]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 800779a:	f88d 100c 	strb.w	r1, [sp, #12]
 800779e:	4618      	mov	r0, r3
 80077a0:	3b01      	subs	r3, #1
 80077a2:	9300      	str	r3, [sp, #0]
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80077a4:	ac03      	add	r4, sp, #12
 80077a6:	e77a      	b.n	800769e <chvprintf+0x19e>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80077a8:	9b00      	ldr	r3, [sp, #0]
 80077aa:	2b00      	cmp	r3, #0
 80077ac:	da94      	bge.n	80076d8 <chvprintf+0x1d8>
 80077ae:	e6b4      	b.n	800751a <chvprintf+0x1a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 80077b0:	f647 70fe 	movw	r0, #32766	; 0x7ffe
 80077b4:	2a00      	cmp	r2, #0
 80077b6:	d1bf      	bne.n	8007738 <chvprintf+0x238>
 80077b8:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 80077bc:	f1bb 0f00 	cmp.w	fp, #0
 80077c0:	d11b      	bne.n	80077fa <chvprintf+0x2fa>
 80077c2:	f04f 33ff 	mov.w	r3, #4294967295
 80077c6:	9300      	str	r3, [sp, #0]
 80077c8:	f04f 0820 	mov.w	r8, #32
 80077cc:	e76e      	b.n	80076ac <chvprintf+0x1ac>
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 80077ce:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 80077d2:	f47f af74 	bne.w	80076be <chvprintf+0x1be>
        streamPut(chp, (uint8_t)*s++);
 80077d6:	6832      	ldr	r2, [r6, #0]
 80077d8:	4630      	mov	r0, r6
 80077da:	6892      	ldr	r2, [r2, #8]
 80077dc:	4790      	blx	r2
 80077de:	9b00      	ldr	r3, [sp, #0]
 80077e0:	3b01      	subs	r3, #1
 80077e2:	3401      	adds	r4, #1
        n++;
 80077e4:	f10a 0a01 	add.w	sl, sl, #1
 80077e8:	9300      	str	r3, [sp, #0]
 80077ea:	e768      	b.n	80076be <chvprintf+0x1be>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 80077ec:	222d      	movs	r2, #45	; 0x2d
        l = -l;
 80077ee:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 80077f0:	f88d 200c 	strb.w	r2, [sp, #12]
 80077f4:	f10d 000d 	add.w	r0, sp, #13
 80077f8:	e7cb      	b.n	8007792 <chvprintf+0x292>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 80077fa:	f04f 0820 	mov.w	r8, #32
 80077fe:	e77f      	b.n	8007700 <chvprintf+0x200>
 8007800:	0800fb54 	.word	0x0800fb54
	...

08007810 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 8007810:	b40c      	push	{r2, r3}
 8007812:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007814:	b087      	sub	sp, #28
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
 8007816:	ab0d      	add	r3, sp, #52	; 0x34
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 8007818:	4605      	mov	r5, r0
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 800781a:	460c      	mov	r4, r1
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
  retval = chvprintf(chp, fmt, ap);
 800781c:	461a      	mov	r2, r3
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 800781e:	b1b9      	cbz	r1, 8007850 <chsnprintf+0x40>
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 8007820:	f8df e044 	ldr.w	lr, [pc, #68]	; 8007868 <chsnprintf+0x58>
  msp->buffer = buffer;
 8007824:	9002      	str	r0, [sp, #8]
  msp->size   = size;
 8007826:	1e4f      	subs	r7, r1, #1
  msp->eos    = eos;
 8007828:	2600      	movs	r6, #0
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
  retval = chvprintf(chp, fmt, ap);
 800782a:	990c      	ldr	r1, [sp, #48]	; 0x30
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
 800782c:	9300      	str	r3, [sp, #0]
  retval = chvprintf(chp, fmt, ap);
 800782e:	a801      	add	r0, sp, #4
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 8007830:	f8cd e004 	str.w	lr, [sp, #4]
  msp->buffer = buffer;
  msp->size   = size;
 8007834:	9703      	str	r7, [sp, #12]
  msp->eos    = eos;
 8007836:	9604      	str	r6, [sp, #16]
  msp->offset = 0;
 8007838:	9605      	str	r6, [sp, #20]
 800783a:	f7ff fe61 	bl	8007500 <chvprintf>
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 800783e:	9b04      	ldr	r3, [sp, #16]
 8007840:	429c      	cmp	r4, r3
 8007842:	d900      	bls.n	8007846 <chsnprintf+0x36>
      str[ms.eos] = 0;
 8007844:	54ee      	strb	r6, [r5, r3]

  /* Return number of bytes that would have been written.*/
  return retval;
}
 8007846:	b007      	add	sp, #28
 8007848:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 800784c:	b002      	add	sp, #8
 800784e:	4770      	bx	lr
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 8007850:	4e05      	ldr	r6, [pc, #20]	; (8007868 <chsnprintf+0x58>)
  msp->buffer = buffer;
 8007852:	9002      	str	r0, [sp, #8]
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
  va_start(ap, fmt);
  retval = chvprintf(chp, fmt, ap);
 8007854:	990c      	ldr	r1, [sp, #48]	; 0x30
  msp->size   = size;
 8007856:	9403      	str	r4, [sp, #12]
 8007858:	a801      	add	r0, sp, #4
  msp->eos    = eos;
 800785a:	9404      	str	r4, [sp, #16]
  msp->offset = 0;
 800785c:	9405      	str	r4, [sp, #20]
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {

  msp->vmt    = &vmt;
 800785e:	e88d 0048 	stmia.w	sp, {r3, r6}
 8007862:	f7ff fe4d 	bl	8007500 <chvprintf>
 8007866:	e7ee      	b.n	8007846 <chsnprintf+0x36>
 8007868:	0800fb8c 	.word	0x0800fb8c
 800786c:	00000000 	.word	0x00000000

08007870 <__early_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8007870:	4934      	ldr	r1, [pc, #208]	; (8007944 <__early_init+0xd4>)
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8007872:	4b35      	ldr	r3, [pc, #212]	; (8007948 <__early_init+0xd8>)
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8007874:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8007878:	f44f 4280 	mov.w	r2, #16384	; 0x4000
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800787c:	6408      	str	r0, [r1, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800787e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8007880:	680b      	ldr	r3, [r1, #0]
 8007882:	f043 0301 	orr.w	r3, r3, #1
 8007886:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8007888:	680a      	ldr	r2, [r1, #0]
 800788a:	4b2e      	ldr	r3, [pc, #184]	; (8007944 <__early_init+0xd4>)
 800788c:	0790      	lsls	r0, r2, #30
 800788e:	d5fb      	bpl.n	8007888 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8007890:	689a      	ldr	r2, [r3, #8]
 8007892:	f022 0203 	bic.w	r2, r2, #3
 8007896:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8007898:	689a      	ldr	r2, [r3, #8]
 800789a:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800789c:	4619      	mov	r1, r3
 800789e:	688b      	ldr	r3, [r1, #8]
 80078a0:	4a28      	ldr	r2, [pc, #160]	; (8007944 <__early_init+0xd4>)
 80078a2:	f013 030c 	ands.w	r3, r3, #12
 80078a6:	d1fa      	bne.n	800789e <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80078a8:	6811      	ldr	r1, [r2, #0]
 80078aa:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 80078ae:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80078b0:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 80078b2:	6813      	ldr	r3, [r2, #0]
 80078b4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80078b8:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 80078ba:	6811      	ldr	r1, [r2, #0]
 80078bc:	4b21      	ldr	r3, [pc, #132]	; (8007944 <__early_init+0xd4>)
 80078be:	0389      	lsls	r1, r1, #14
 80078c0:	d5fb      	bpl.n	80078ba <__early_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80078c2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80078c4:	f042 0201 	orr.w	r2, r2, #1
 80078c8:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80078ca:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 80078cc:	491d      	ldr	r1, [pc, #116]	; (8007944 <__early_init+0xd4>)
 80078ce:	0790      	lsls	r0, r2, #30
 80078d0:	d5fb      	bpl.n	80078ca <__early_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 80078d2:	4b1e      	ldr	r3, [pc, #120]	; (800794c <__early_init+0xdc>)
 80078d4:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80078d6:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80078d8:	4a1b      	ldr	r2, [pc, #108]	; (8007948 <__early_init+0xd8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 80078da:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80078de:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 80078e0:	6853      	ldr	r3, [r2, #4]
 80078e2:	0459      	lsls	r1, r3, #17
 80078e4:	d5fc      	bpl.n	80078e0 <__early_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80078e6:	4917      	ldr	r1, [pc, #92]	; (8007944 <__early_init+0xd4>)
 80078e8:	680b      	ldr	r3, [r1, #0]
 80078ea:	4a16      	ldr	r2, [pc, #88]	; (8007944 <__early_init+0xd4>)
 80078ec:	019b      	lsls	r3, r3, #6
 80078ee:	d5fb      	bpl.n	80078e8 <__early_init+0x78>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80078f0:	4b17      	ldr	r3, [pc, #92]	; (8007950 <__early_init+0xe0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80078f2:	4918      	ldr	r1, [pc, #96]	; (8007954 <__early_init+0xe4>)
 80078f4:	6091      	str	r1, [r2, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80078f6:	681a      	ldr	r2, [r3, #0]
 80078f8:	4b17      	ldr	r3, [pc, #92]	; (8007958 <__early_init+0xe8>)
 80078fa:	429a      	cmp	r2, r3
 80078fc:	d017      	beq.n	800792e <__early_init+0xbe>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80078fe:	4b17      	ldr	r3, [pc, #92]	; (800795c <__early_init+0xec>)
 8007900:	f240 7201 	movw	r2, #1793	; 0x701
 8007904:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8007906:	4a0f      	ldr	r2, [pc, #60]	; (8007944 <__early_init+0xd4>)
 8007908:	6893      	ldr	r3, [r2, #8]
 800790a:	f043 0301 	orr.w	r3, r3, #1
 800790e:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8007910:	6893      	ldr	r3, [r2, #8]
 8007912:	490c      	ldr	r1, [pc, #48]	; (8007944 <__early_init+0xd4>)
 8007914:	f003 030c 	and.w	r3, r3, #12
 8007918:	2b04      	cmp	r3, #4
 800791a:	d1f9      	bne.n	8007910 <__early_init+0xa0>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800791c:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800791e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8007922:	644b      	str	r3, [r1, #68]	; 0x44
 8007924:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8007926:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800792a:	664b      	str	r3, [r1, #100]	; 0x64
 800792c:	4770      	bx	lr

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800792e:	4a0c      	ldr	r2, [pc, #48]	; (8007960 <__early_init+0xf0>)
 8007930:	4b0c      	ldr	r3, [pc, #48]	; (8007964 <__early_init+0xf4>)
 8007932:	6812      	ldr	r2, [r2, #0]
 8007934:	429a      	cmp	r2, r3
 8007936:	d1e2      	bne.n	80078fe <__early_init+0x8e>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8007938:	4b08      	ldr	r3, [pc, #32]	; (800795c <__early_init+0xec>)
 800793a:	f240 1201 	movw	r2, #257	; 0x101
 800793e:	601a      	str	r2, [r3, #0]
 8007940:	e7e1      	b.n	8007906 <__early_init+0x96>
 8007942:	bf00      	nop
 8007944:	40023800 	.word	0x40023800
 8007948:	40007000 	.word	0x40007000
 800794c:	0740541a 	.word	0x0740541a
 8007950:	e0042000 	.word	0xe0042000
 8007954:	3ec80000 	.word	0x3ec80000
 8007958:	20006411 	.word	0x20006411
 800795c:	40023c00 	.word	0x40023c00
 8007960:	e000ed00 	.word	0xe000ed00
 8007964:	410fc241 	.word	0x410fc241
	...

08007970 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007970:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8007974:	b4f0      	push	{r4, r5, r6, r7}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8007976:	68dc      	ldr	r4, [r3, #12]
 8007978:	6965      	ldr	r5, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800797a:	682b      	ldr	r3, [r5, #0]
 800797c:	60eb      	str	r3, [r5, #12]
  if (isp->txsize == 0) {
 800797e:	b9f3      	cbnz	r3, 80079be <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8007980:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8007982:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8007986:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800798a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800798e:	6823      	ldr	r3, [r4, #0]
 8007990:	f003 0303 	and.w	r3, r3, #3
 8007994:	2b01      	cmp	r3, #1
 8007996:	d026      	beq.n	80079e6 <usb_lld_start_in+0x76>
 8007998:	b20b      	sxth	r3, r1
 800799a:	eb00 1343 	add.w	r3, r0, r3, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800799e:	2201      	movs	r2, #1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80079a0:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 80079a4:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80079a8:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80079ac:	f8d0 3834 	ldr.w	r3, [r0, #2100]	; 0x834
 80079b0:	fa02 f101 	lsl.w	r1, r2, r1
 80079b4:	4319      	orrs	r1, r3
 80079b6:	f8c0 1834 	str.w	r1, [r0, #2100]	; 0x834
}
 80079ba:	bcf0      	pop	{r4, r5, r6, r7}
 80079bc:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 80079be:	b319      	cbz	r1, 8007a08 <usb_lld_start_in+0x98>
 80079c0:	1e5d      	subs	r5, r3, #1
 80079c2:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80079c6:	6d40      	ldr	r0, [r0, #84]	; 0x54
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80079c8:	8a26      	ldrh	r6, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80079ca:	eb00 1741 	add.w	r7, r0, r1, lsl #5
 80079ce:	1973      	adds	r3, r6, r5
 80079d0:	fbb3 f3f6 	udiv	r3, r3, r6
 80079d4:	ea42 43c3 	orr.w	r3, r2, r3, lsl #19
 80079d8:	f8c7 3910 	str.w	r3, [r7, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80079dc:	6823      	ldr	r3, [r4, #0]
 80079de:	f003 0303 	and.w	r3, r3, #3
 80079e2:	2b01      	cmp	r3, #1
 80079e4:	d1d8      	bne.n	8007998 <usb_lld_start_in+0x28>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80079e6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80079ea:	f413 7f80 	tst.w	r3, #256	; 0x100
 80079ee:	b20b      	sxth	r3, r1
 80079f0:	eb00 1443 	add.w	r4, r0, r3, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 80079f4:	f8d4 2900 	ldr.w	r2, [r4, #2304]	; 0x900
 80079f8:	bf14      	ite	ne
 80079fa:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 80079fe:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
 8007a02:	f8c4 2900 	str.w	r2, [r4, #2304]	; 0x900
 8007a06:	e7c8      	b.n	800799a <usb_lld_start_in+0x2a>
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8007a08:	2b40      	cmp	r3, #64	; 0x40
 8007a0a:	d9d9      	bls.n	80079c0 <usb_lld_start_in+0x50>
      isp->txsize = EP0_MAX_INSIZE;
 8007a0c:	2340      	movs	r3, #64	; 0x40
 8007a0e:	602b      	str	r3, [r5, #0]
 8007a10:	4a01      	ldr	r2, [pc, #4]	; (8007a18 <usb_lld_start_in+0xa8>)
 8007a12:	253f      	movs	r5, #63	; 0x3f
 8007a14:	e7d7      	b.n	80079c6 <usb_lld_start_in+0x56>
 8007a16:	bf00      	nop
 8007a18:	20000040 	.word	0x20000040
 8007a1c:	00000000 	.word	0x00000000

08007a20 <usb_lld_start_out>:
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8007a20:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8007a24:	b430      	push	{r4, r5}
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8007a26:	68dc      	ldr	r4, [r3, #12]
 8007a28:	69a2      	ldr	r2, [r4, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 8007a2a:	6813      	ldr	r3, [r2, #0]
 8007a2c:	60d3      	str	r3, [r2, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8007a2e:	b909      	cbnz	r1, 8007a34 <usb_lld_start_out+0x14>
 8007a30:	2b40      	cmp	r3, #64	; 0x40
 8007a32:	d822      	bhi.n	8007a7a <usb_lld_start_out+0x5a>
 8007a34:	1e5a      	subs	r2, r3, #1
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007a36:	8a63      	ldrh	r3, [r4, #18]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007a38:	6d40      	ldr	r0, [r0, #84]	; 0x54
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007a3a:	6824      	ldr	r4, [r4, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8007a3c:	441a      	add	r2, r3
 8007a3e:	fbb2 f2f3 	udiv	r2, r2, r3
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007a42:	fb02 f303 	mul.w	r3, r2, r3
 8007a46:	3303      	adds	r3, #3
 8007a48:	f023 0303 	bic.w	r3, r3, #3
 8007a4c:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8007a50:	eb00 1541 	add.w	r5, r0, r1, lsl #5
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007a54:	f004 0203 	and.w	r2, r4, #3
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007a58:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007a5c:	2a01      	cmp	r2, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8007a5e:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8007a62:	d00e      	beq.n	8007a82 <usb_lld_start_out+0x62>
 8007a64:	b209      	sxth	r1, r1
 8007a66:	eb00 1141 	add.w	r1, r0, r1, lsl #5
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
}
 8007a6a:	bc30      	pop	{r4, r5}
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8007a6c:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8007a70:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8007a74:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8007a78:	4770      	bx	lr
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;
 8007a7a:	2340      	movs	r3, #64	; 0x40
 8007a7c:	6013      	str	r3, [r2, #0]
 8007a7e:	223f      	movs	r2, #63	; 0x3f
 8007a80:	e7d9      	b.n	8007a36 <usb_lld_start_out+0x16>
 8007a82:	b209      	sxth	r1, r1
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8007a84:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8007a88:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8007a8c:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8007a90:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8007a94:	bf14      	ite	ne
 8007a96:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8007a9a:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8007a9e:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8007aa2:	e7e0      	b.n	8007a66 <usb_lld_start_out+0x46>
	...

08007ab0 <OV2640_dma_avail>:

	return size;
}

void OV2640_dma_avail(uint32_t flags)
{
 8007ab0:	b570      	push	{r4, r5, r6, lr}
	(void)flags;
	TRACE_DEBUG("DMA Interrupt");
 8007ab2:	4822      	ldr	r0, [pc, #136]	; (8007b3c <OV2640_dma_avail+0x8c>)
 8007ab4:	4e22      	ldr	r6, [pc, #136]	; (8007b40 <OV2640_dma_avail+0x90>)
 8007ab6:	f004 fb73 	bl	800c1a0 <chMtxLock>
 8007aba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8007abe:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8007ac2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007ac4:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8007ac6:	4b1f      	ldr	r3, [pc, #124]	; (8007b44 <OV2640_dma_avail+0x94>)
 8007ac8:	491f      	ldr	r1, [pc, #124]	; (8007b48 <OV2640_dma_avail+0x98>)
 8007aca:	4820      	ldr	r0, [pc, #128]	; (8007b4c <OV2640_dma_avail+0x9c>)
 8007acc:	fb05 f404 	mul.w	r4, r5, r4
 8007ad0:	fba6 e404 	umull	lr, r4, r6, r4
 8007ad4:	0b64      	lsrs	r4, r4, #13
 8007ad6:	fba3 e304 	umull	lr, r3, r3, r4
 8007ada:	fba6 6202 	umull	r6, r2, r6, r2
 8007ade:	099b      	lsrs	r3, r3, #6
 8007ae0:	fb05 4313 	mls	r3, r5, r3, r4
 8007ae4:	0b52      	lsrs	r2, r2, #13
 8007ae6:	f002 fdd3 	bl	800a690 <chprintf.constprop.26>
 8007aea:	4a19      	ldr	r2, [pc, #100]	; (8007b50 <OV2640_dma_avail+0xa0>)
 8007aec:	4919      	ldr	r1, [pc, #100]	; (8007b54 <OV2640_dma_avail+0xa4>)
 8007aee:	4817      	ldr	r0, [pc, #92]	; (8007b4c <OV2640_dma_avail+0x9c>)
 8007af0:	f002 fdce 	bl	800a690 <chprintf.constprop.26>
 8007af4:	f240 23a7 	movw	r3, #679	; 0x2a7
 8007af8:	4a17      	ldr	r2, [pc, #92]	; (8007b58 <OV2640_dma_avail+0xa8>)
 8007afa:	4918      	ldr	r1, [pc, #96]	; (8007b5c <OV2640_dma_avail+0xac>)
 8007afc:	4813      	ldr	r0, [pc, #76]	; (8007b4c <OV2640_dma_avail+0x9c>)
 8007afe:	f002 fdc7 	bl	800a690 <chprintf.constprop.26>
 8007b02:	4917      	ldr	r1, [pc, #92]	; (8007b60 <OV2640_dma_avail+0xb0>)
 8007b04:	4811      	ldr	r0, [pc, #68]	; (8007b4c <OV2640_dma_avail+0x9c>)
 8007b06:	f002 fdc3 	bl	800a690 <chprintf.constprop.26>
 8007b0a:	4916      	ldr	r1, [pc, #88]	; (8007b64 <OV2640_dma_avail+0xb4>)
 8007b0c:	480f      	ldr	r0, [pc, #60]	; (8007b4c <OV2640_dma_avail+0x9c>)
 8007b0e:	f002 fdbf 	bl	800a690 <chprintf.constprop.26>
 8007b12:	4915      	ldr	r1, [pc, #84]	; (8007b68 <OV2640_dma_avail+0xb8>)
 8007b14:	480d      	ldr	r0, [pc, #52]	; (8007b4c <OV2640_dma_avail+0x9c>)
 8007b16:	f002 fdbb 	bl	800a690 <chprintf.constprop.26>
 8007b1a:	4808      	ldr	r0, [pc, #32]	; (8007b3c <OV2640_dma_avail+0x8c>)
 8007b1c:	f001 fd30 	bl	8009580 <chMtxUnlock>
	ov2640_samplingFinished = true;
	dmaStreamDisable(STM32_DMA2_STREAM1);
 8007b20:	4a12      	ldr	r2, [pc, #72]	; (8007b6c <OV2640_dma_avail+0xbc>)
 8007b22:	6813      	ldr	r3, [r2, #0]
 8007b24:	f023 031f 	bic.w	r3, r3, #31
 8007b28:	6013      	str	r3, [r2, #0]
 8007b2a:	6813      	ldr	r3, [r2, #0]
 8007b2c:	07db      	lsls	r3, r3, #31
 8007b2e:	d4fc      	bmi.n	8007b2a <OV2640_dma_avail+0x7a>
 8007b30:	4b0f      	ldr	r3, [pc, #60]	; (8007b70 <OV2640_dma_avail+0xc0>)
 8007b32:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8007b36:	601a      	str	r2, [r3, #0]
 8007b38:	bd70      	pop	{r4, r5, r6, pc}
 8007b3a:	bf00      	nop
 8007b3c:	2001b720 	.word	0x2001b720
 8007b40:	d1b71759 	.word	0xd1b71759
 8007b44:	10624dd3 	.word	0x10624dd3
 8007b48:	0800ea50 	.word	0x0800ea50
 8007b4c:	2001ac28 	.word	0x2001ac28
 8007b50:	0800fd50 	.word	0x0800fd50
 8007b54:	0800ea64 	.word	0x0800ea64
 8007b58:	0800fd60 	.word	0x0800fd60
 8007b5c:	0800ea7c 	.word	0x0800ea7c
 8007b60:	0800f1e0 	.word	0x0800f1e0
 8007b64:	0800fd6c 	.word	0x0800fd6c
 8007b68:	0800eaa8 	.word	0x0800eaa8
 8007b6c:	40026428 	.word	0x40026428
 8007b70:	40026408 	.word	0x40026408
	...

08007b80 <flashSectorAt>:
{
    return flashSectorBegin(sector + 1);
}

flashsector_t flashSectorAt(flashaddr_t address)
{
 8007b80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    flashsector_t sector = 0;
 8007b84:	2700      	movs	r7, #0
    return address;
}

flashaddr_t flashSectorEnd(flashsector_t sector)
{
    return flashSectorBegin(sector + 1);
 8007b86:	1c7b      	adds	r3, r7, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8007b88:	f013 06ff 	ands.w	r6, r3, #255	; 0xff
{
    return flashSectorBegin(sector + 1);
}

flashsector_t flashSectorAt(flashaddr_t address)
{
 8007b8c:	4680      	mov	r8, r0
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8007b8e:	d01a      	beq.n	8007bc6 <flashSectorAt+0x46>
 8007b90:	4634      	mov	r4, r6
 8007b92:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
    {
        --sector;
 8007b96:	3c01      	subs	r4, #1
 8007b98:	b2e4      	uxtb	r4, r4
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8007b9a:	2c03      	cmp	r4, #3
 8007b9c:	4620      	mov	r0, r4
 8007b9e:	d907      	bls.n	8007bb0 <flashSectorAt+0x30>
 8007ba0:	f006 fa7e 	bl	800e0a0 <flashSectorSize.part.1.lto_priv.135>
flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
 8007ba4:	3c01      	subs	r4, #1
 8007ba6:	b2e4      	uxtb	r4, r4
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8007ba8:	2c03      	cmp	r4, #3
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 8007baa:	4405      	add	r5, r0
 8007bac:	4620      	mov	r0, r4
#include "flash.h"
#include <string.h>

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
 8007bae:	d8f7      	bhi.n	8007ba0 <flashSectorAt+0x20>
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
    {
        --sector;
        address += flashSectorSize(sector);
 8007bb0:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8007bb4:	2c00      	cmp	r4, #0
 8007bb6:	d1ee      	bne.n	8007b96 <flashSectorAt+0x16>
}

flashsector_t flashSectorAt(flashaddr_t address)
{
    flashsector_t sector = 0;
    while (address >= flashSectorEnd(sector))
 8007bb8:	45a8      	cmp	r8, r5
 8007bba:	d308      	bcc.n	8007bce <flashSectorAt+0x4e>
    return address;
}

flashaddr_t flashSectorEnd(flashsector_t sector)
{
    return flashSectorBegin(sector + 1);
 8007bbc:	4637      	mov	r7, r6
 8007bbe:	1c7b      	adds	r3, r7, #1
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
    while (sector > 0)
 8007bc0:	f013 06ff 	ands.w	r6, r3, #255	; 0xff
 8007bc4:	d1e4      	bne.n	8007b90 <flashSectorAt+0x10>
    return 0;
}

flashaddr_t flashSectorBegin(flashsector_t sector)
{
    flashaddr_t address = FLASH_BASE;
 8007bc6:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
}

flashsector_t flashSectorAt(flashaddr_t address)
{
    flashsector_t sector = 0;
    while (address >= flashSectorEnd(sector))
 8007bca:	45a8      	cmp	r8, r5
 8007bcc:	d2f6      	bcs.n	8007bbc <flashSectorAt+0x3c>
        ++sector;
    return sector;
}
 8007bce:	4638      	mov	r0, r7
 8007bd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08007be0 <OV2640_init>:

	for(uint32_t i=0; (ov2640_jpeg_regs[i].reg != 0xff) || (ov2640_jpeg_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_jpeg_regs[i].reg, ov2640_jpeg_regs[i].val);
}

void OV2640_init(ssdv_config_t *config) {
 8007be0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	ov2640_config = config;
 8007be4:	4eb4      	ldr	r6, [pc, #720]	; (8007eb8 <OV2640_init+0x2d8>)
 8007be6:	6030      	str	r0, [r6, #0]
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 8007be8:	48b4      	ldr	r0, [pc, #720]	; (8007ebc <OV2640_init+0x2dc>)
 8007bea:	f004 fad9 	bl	800c1a0 <chMtxLock>
	// Take I2C (due to silicon bug of OV2640, it interferes if byte 0x30 transmitted on I2C bus)
	I2C_lock();

	// Clearing buffer
	uint32_t i;
	for(i=0; i<ov2640_config->ram_size; i++)
 8007bee:	6832      	ldr	r2, [r6, #0]
 8007bf0:	6913      	ldr	r3, [r2, #16]
 8007bf2:	b143      	cbz	r3, 8007c06 <OV2640_init+0x26>
 8007bf4:	2300      	movs	r3, #0
		ov2640_config->ram_buffer[i] = 0;
 8007bf6:	4618      	mov	r0, r3
 8007bf8:	68d2      	ldr	r2, [r2, #12]
 8007bfa:	54d0      	strb	r0, [r2, r3]
	// Take I2C (due to silicon bug of OV2640, it interferes if byte 0x30 transmitted on I2C bus)
	I2C_lock();

	// Clearing buffer
	uint32_t i;
	for(i=0; i<ov2640_config->ram_size; i++)
 8007bfc:	6832      	ldr	r2, [r6, #0]
 8007bfe:	6911      	ldr	r1, [r2, #16]
 8007c00:	3301      	adds	r3, #1
 8007c02:	4299      	cmp	r1, r3
 8007c04:	d8f8      	bhi.n	8007bf8 <OV2640_init+0x18>
 8007c06:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
		ov2640_config->ram_buffer[i] = 0;

	TRACE_INFO("CAM  > Init pins");
 8007c0a:	48ad      	ldr	r0, [pc, #692]	; (8007ec0 <OV2640_init+0x2e0>)
 8007c0c:	f8df 8304 	ldr.w	r8, [pc, #772]	; 8007f14 <OV2640_init+0x334>
 8007c10:	4dac      	ldr	r5, [pc, #688]	; (8007ec4 <OV2640_init+0x2e4>)
  * Initializes GPIO (for DCMI)
  * The high speed clock supports communication by I2C (XCLK = 16MHz)
  */
void OV2640_InitGPIO(void)
{
	palSetPadMode(PORT(CAM_HREF), PIN(CAM_HREF), PAL_MODE_ALTERNATE(13));		// HSYNC -> PA4
 8007c12:	f8df a304 	ldr.w	sl, [pc, #772]	; 8007f18 <OV2640_init+0x338>
	palSetPadMode(PORT(CAM_PCLK), PIN(CAM_PCLK), PAL_MODE_ALTERNATE(13));		// PCLK  -> PA6
	palSetPadMode(PORT(CAM_VSYNC), PIN(CAM_VSYNC), PAL_MODE_ALTERNATE(13));		// VSYNC -> PB7
 8007c16:	f8df b304 	ldr.w	fp, [pc, #772]	; 8007f1c <OV2640_init+0x33c>
 8007c1a:	4cab      	ldr	r4, [pc, #684]	; (8007ec8 <OV2640_init+0x2e8>)
	// Clearing buffer
	uint32_t i;
	for(i=0; i<ov2640_config->ram_size; i++)
		ov2640_config->ram_buffer[i] = 0;

	TRACE_INFO("CAM  > Init pins");
 8007c1c:	f004 fac0 	bl	800c1a0 <chMtxLock>
 8007c20:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8007c24:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8007c28:	49a8      	ldr	r1, [pc, #672]	; (8007ecc <OV2640_init+0x2ec>)
 8007c2a:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8007c2e:	fb07 f303 	mul.w	r3, r7, r3
 8007c32:	fba8 0303 	umull	r0, r3, r8, r3
 8007c36:	0b5b      	lsrs	r3, r3, #13
 8007c38:	fba5 e003 	umull	lr, r0, r5, r3
 8007c3c:	fba8 e202 	umull	lr, r2, r8, r2
 8007c40:	0980      	lsrs	r0, r0, #6
 8007c42:	fb07 3310 	mls	r3, r7, r0, r3
 8007c46:	0b52      	lsrs	r2, r2, #13
 8007c48:	48a1      	ldr	r0, [pc, #644]	; (8007ed0 <OV2640_init+0x2f0>)
 8007c4a:	f002 fd21 	bl	800a690 <chprintf.constprop.26>
 8007c4e:	4aa1      	ldr	r2, [pc, #644]	; (8007ed4 <OV2640_init+0x2f4>)
 8007c50:	49a1      	ldr	r1, [pc, #644]	; (8007ed8 <OV2640_init+0x2f8>)
 8007c52:	489f      	ldr	r0, [pc, #636]	; (8007ed0 <OV2640_init+0x2f0>)
 8007c54:	f002 fd1c 	bl	800a690 <chprintf.constprop.26>
 8007c58:	f240 333b 	movw	r3, #827	; 0x33b
 8007c5c:	4a9f      	ldr	r2, [pc, #636]	; (8007edc <OV2640_init+0x2fc>)
 8007c5e:	49a0      	ldr	r1, [pc, #640]	; (8007ee0 <OV2640_init+0x300>)
 8007c60:	489b      	ldr	r0, [pc, #620]	; (8007ed0 <OV2640_init+0x2f0>)
 8007c62:	f002 fd15 	bl	800a690 <chprintf.constprop.26>
 8007c66:	499f      	ldr	r1, [pc, #636]	; (8007ee4 <OV2640_init+0x304>)
 8007c68:	4899      	ldr	r0, [pc, #612]	; (8007ed0 <OV2640_init+0x2f0>)
 8007c6a:	f002 fd11 	bl	800a690 <chprintf.constprop.26>
 8007c6e:	499e      	ldr	r1, [pc, #632]	; (8007ee8 <OV2640_init+0x308>)
 8007c70:	4897      	ldr	r0, [pc, #604]	; (8007ed0 <OV2640_init+0x2f0>)
 8007c72:	f002 fd0d 	bl	800a690 <chprintf.constprop.26>
 8007c76:	499d      	ldr	r1, [pc, #628]	; (8007eec <OV2640_init+0x30c>)
 8007c78:	4895      	ldr	r0, [pc, #596]	; (8007ed0 <OV2640_init+0x2f0>)
 8007c7a:	f002 fd09 	bl	800a690 <chprintf.constprop.26>
 8007c7e:	4890      	ldr	r0, [pc, #576]	; (8007ec0 <OV2640_init+0x2e0>)
 8007c80:	f001 fc7e 	bl	8009580 <chMtxUnlock>
  * Initializes GPIO (for DCMI)
  * The high speed clock supports communication by I2C (XCLK = 16MHz)
  */
void OV2640_InitGPIO(void)
{
	palSetPadMode(PORT(CAM_HREF), PIN(CAM_HREF), PAL_MODE_ALTERNATE(13));		// HSYNC -> PA4
 8007c84:	4650      	mov	r0, sl
 8007c86:	f240 6282 	movw	r2, #1666	; 0x682
 8007c8a:	2110      	movs	r1, #16
 8007c8c:	f002 fa50 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_PCLK), PIN(CAM_PCLK), PAL_MODE_ALTERNATE(13));		// PCLK  -> PA6
 8007c90:	4650      	mov	r0, sl
 8007c92:	f240 6282 	movw	r2, #1666	; 0x682
 8007c96:	2140      	movs	r1, #64	; 0x40
 8007c98:	f002 fa4a 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_VSYNC), PIN(CAM_VSYNC), PAL_MODE_ALTERNATE(13));		// VSYNC -> PB7
 8007c9c:	4658      	mov	r0, fp
 8007c9e:	f240 6282 	movw	r2, #1666	; 0x682
 8007ca2:	2180      	movs	r1, #128	; 0x80
 8007ca4:	f002 fa44 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D2), PIN(CAM_D2), PAL_MODE_ALTERNATE(13));			// D0    -> PC6
 8007ca8:	f240 6282 	movw	r2, #1666	; 0x682
 8007cac:	2140      	movs	r1, #64	; 0x40
 8007cae:	4890      	ldr	r0, [pc, #576]	; (8007ef0 <OV2640_init+0x310>)
 8007cb0:	f002 fa3e 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D3), PIN(CAM_D3), PAL_MODE_ALTERNATE(13));			// D1    -> PC7
 8007cb4:	f240 6282 	movw	r2, #1666	; 0x682
 8007cb8:	2180      	movs	r1, #128	; 0x80
 8007cba:	488d      	ldr	r0, [pc, #564]	; (8007ef0 <OV2640_init+0x310>)
 8007cbc:	f002 fa38 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D4), PIN(CAM_D4), PAL_MODE_ALTERNATE(13));			// D2    -> PC8
 8007cc0:	f240 6282 	movw	r2, #1666	; 0x682
 8007cc4:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007cc8:	4889      	ldr	r0, [pc, #548]	; (8007ef0 <OV2640_init+0x310>)
 8007cca:	f002 fa31 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D5), PIN(CAM_D5), PAL_MODE_ALTERNATE(13));			// D3    -> PC9
 8007cce:	f240 6282 	movw	r2, #1666	; 0x682
 8007cd2:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007cd6:	4886      	ldr	r0, [pc, #536]	; (8007ef0 <OV2640_init+0x310>)
 8007cd8:	f002 fa2a 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D6), PIN(CAM_D6), PAL_MODE_ALTERNATE(13));			// D4    -> PE4
 8007cdc:	f240 6282 	movw	r2, #1666	; 0x682
 8007ce0:	2110      	movs	r1, #16
 8007ce2:	4884      	ldr	r0, [pc, #528]	; (8007ef4 <OV2640_init+0x314>)
 8007ce4:	f002 fa24 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D7), PIN(CAM_D7), PAL_MODE_ALTERNATE(13));			// D5    -> PB6
 8007ce8:	4658      	mov	r0, fp
 8007cea:	f240 6282 	movw	r2, #1666	; 0x682
 8007cee:	2140      	movs	r1, #64	; 0x40
 8007cf0:	f002 fa1e 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D8), PIN(CAM_D8), PAL_MODE_ALTERNATE(13));			// D6    -> PE5
 8007cf4:	f240 6282 	movw	r2, #1666	; 0x682
 8007cf8:	2120      	movs	r1, #32
 8007cfa:	487e      	ldr	r0, [pc, #504]	; (8007ef4 <OV2640_init+0x314>)
 8007cfc:	f002 fa18 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_D9), PIN(CAM_D9), PAL_MODE_ALTERNATE(13));			// D7    -> PE6
 8007d00:	f240 6282 	movw	r2, #1666	; 0x682
 8007d04:	2140      	movs	r1, #64	; 0x40
 8007d06:	487b      	ldr	r0, [pc, #492]	; (8007ef4 <OV2640_init+0x314>)
 8007d08:	f002 fa12 	bl	800a130 <_pal_lld_setgroupmode>

	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);			// CAM_EN
 8007d0c:	4658      	mov	r0, fp
 8007d0e:	2201      	movs	r2, #1
 8007d10:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8007d14:	f002 fa0c 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// CAM_RESET
 8007d18:	2201      	movs	r2, #1
 8007d1a:	2108      	movs	r1, #8
 8007d1c:	4650      	mov	r0, sl
 8007d1e:	f002 fa07 	bl	800a130 <_pal_lld_setgroupmode>

	TRACE_INFO("CAM  > Init pins");
	OV2640_InitGPIO();

	// Power on OV2640
	TRACE_INFO("CAM  > Switch on");
 8007d22:	4867      	ldr	r0, [pc, #412]	; (8007ec0 <OV2640_init+0x2e0>)
 8007d24:	f004 fa3c 	bl	800c1a0 <chMtxLock>
 8007d28:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8007d2c:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8007d30:	4966      	ldr	r1, [pc, #408]	; (8007ecc <OV2640_init+0x2ec>)
 8007d32:	fb07 f303 	mul.w	r3, r7, r3
 8007d36:	fba8 0303 	umull	r0, r3, r8, r3
 8007d3a:	0b5b      	lsrs	r3, r3, #13
 8007d3c:	fba5 e003 	umull	lr, r0, r5, r3
 8007d40:	fba8 e202 	umull	lr, r2, r8, r2
 8007d44:	0980      	lsrs	r0, r0, #6
 8007d46:	fb07 3310 	mls	r3, r7, r0, r3
 8007d4a:	0b52      	lsrs	r2, r2, #13
 8007d4c:	4860      	ldr	r0, [pc, #384]	; (8007ed0 <OV2640_init+0x2f0>)
 8007d4e:	f002 fc9f 	bl	800a690 <chprintf.constprop.26>
 8007d52:	4a60      	ldr	r2, [pc, #384]	; (8007ed4 <OV2640_init+0x2f4>)
 8007d54:	4960      	ldr	r1, [pc, #384]	; (8007ed8 <OV2640_init+0x2f8>)
 8007d56:	485e      	ldr	r0, [pc, #376]	; (8007ed0 <OV2640_init+0x2f0>)
 8007d58:	f002 fc9a 	bl	800a690 <chprintf.constprop.26>
 8007d5c:	f240 333f 	movw	r3, #831	; 0x33f
 8007d60:	4a5e      	ldr	r2, [pc, #376]	; (8007edc <OV2640_init+0x2fc>)
 8007d62:	495f      	ldr	r1, [pc, #380]	; (8007ee0 <OV2640_init+0x300>)
 8007d64:	485a      	ldr	r0, [pc, #360]	; (8007ed0 <OV2640_init+0x2f0>)
 8007d66:	f002 fc93 	bl	800a690 <chprintf.constprop.26>
 8007d6a:	495e      	ldr	r1, [pc, #376]	; (8007ee4 <OV2640_init+0x304>)
 8007d6c:	4858      	ldr	r0, [pc, #352]	; (8007ed0 <OV2640_init+0x2f0>)
 8007d6e:	f002 fc8f 	bl	800a690 <chprintf.constprop.26>
 8007d72:	4961      	ldr	r1, [pc, #388]	; (8007ef8 <OV2640_init+0x318>)
 8007d74:	4856      	ldr	r0, [pc, #344]	; (8007ed0 <OV2640_init+0x2f0>)
 8007d76:	f002 fc8b 	bl	800a690 <chprintf.constprop.26>
 8007d7a:	495c      	ldr	r1, [pc, #368]	; (8007eec <OV2640_init+0x30c>)
 8007d7c:	4854      	ldr	r0, [pc, #336]	; (8007ed0 <OV2640_init+0x2f0>)
 8007d7e:	f002 fc87 	bl	800a690 <chprintf.constprop.26>
 8007d82:	484f      	ldr	r0, [pc, #316]	; (8007ec0 <OV2640_init+0x2e0>)
 8007d84:	f001 fbfc 	bl	8009580 <chMtxUnlock>
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
 8007d88:	f44f 6200 	mov.w	r2, #2048	; 0x800
	palSetPad(PORT(CAM_RESET), PIN(CAM_RESET)); // Toggle reset
 8007d8c:	2308      	movs	r3, #8
	TRACE_INFO("CAM  > Init pins");
	OV2640_InitGPIO();

	// Power on OV2640
	TRACE_INFO("CAM  > Switch on");
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
 8007d8e:	f8ab 2018 	strh.w	r2, [fp, #24]
	palSetPad(PORT(CAM_RESET), PIN(CAM_RESET)); // Toggle reset

	// Send settings to OV2640
	TRACE_INFO("CAM  > Transmit config to camera");
 8007d92:	484b      	ldr	r0, [pc, #300]	; (8007ec0 <OV2640_init+0x2e0>)
	OV2640_InitGPIO();

	// Power on OV2640
	TRACE_INFO("CAM  > Switch on");
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
	palSetPad(PORT(CAM_RESET), PIN(CAM_RESET)); // Toggle reset
 8007d94:	f8aa 3018 	strh.w	r3, [sl, #24]

	// Send settings to OV2640
	TRACE_INFO("CAM  > Transmit config to camera");
 8007d98:	f004 fa02 	bl	800c1a0 <chMtxLock>
 8007d9c:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 8007da0:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8007da4:	4949      	ldr	r1, [pc, #292]	; (8007ecc <OV2640_init+0x2ec>)
 8007da6:	484a      	ldr	r0, [pc, #296]	; (8007ed0 <OV2640_init+0x2f0>)
 8007da8:	fb07 f303 	mul.w	r3, r7, r3
 8007dac:	fba8 e303 	umull	lr, r3, r8, r3
 8007db0:	0b5b      	lsrs	r3, r3, #13
 8007db2:	fba5 e503 	umull	lr, r5, r5, r3
 8007db6:	09ad      	lsrs	r5, r5, #6
 8007db8:	fba8 e202 	umull	lr, r2, r8, r2
 8007dbc:	fb07 3315 	mls	r3, r7, r5, r3
 8007dc0:	0b52      	lsrs	r2, r2, #13
 8007dc2:	f002 fc65 	bl	800a690 <chprintf.constprop.26>
 8007dc6:	4a43      	ldr	r2, [pc, #268]	; (8007ed4 <OV2640_init+0x2f4>)
 8007dc8:	4943      	ldr	r1, [pc, #268]	; (8007ed8 <OV2640_init+0x2f8>)
 8007dca:	4841      	ldr	r0, [pc, #260]	; (8007ed0 <OV2640_init+0x2f0>)
 8007dcc:	f002 fc60 	bl	800a690 <chprintf.constprop.26>
 8007dd0:	f44f 7351 	mov.w	r3, #836	; 0x344
 8007dd4:	4a41      	ldr	r2, [pc, #260]	; (8007edc <OV2640_init+0x2fc>)
 8007dd6:	4942      	ldr	r1, [pc, #264]	; (8007ee0 <OV2640_init+0x300>)
 8007dd8:	483d      	ldr	r0, [pc, #244]	; (8007ed0 <OV2640_init+0x2f0>)
 8007dda:	f002 fc59 	bl	800a690 <chprintf.constprop.26>
 8007dde:	4941      	ldr	r1, [pc, #260]	; (8007ee4 <OV2640_init+0x304>)
 8007de0:	483b      	ldr	r0, [pc, #236]	; (8007ed0 <OV2640_init+0x2f0>)
 8007de2:	f002 fc55 	bl	800a690 <chprintf.constprop.26>
 8007de6:	4945      	ldr	r1, [pc, #276]	; (8007efc <OV2640_init+0x31c>)
 8007de8:	4839      	ldr	r0, [pc, #228]	; (8007ed0 <OV2640_init+0x2f0>)
 8007dea:	f002 fc51 	bl	800a690 <chprintf.constprop.26>
 8007dee:	493f      	ldr	r1, [pc, #252]	; (8007eec <OV2640_init+0x30c>)
 8007df0:	4837      	ldr	r0, [pc, #220]	; (8007ed0 <OV2640_init+0x2f0>)
 8007df2:	f002 fc4d 	bl	800a690 <chprintf.constprop.26>
 8007df6:	4832      	ldr	r0, [pc, #200]	; (8007ec0 <OV2640_init+0x2e0>)
 8007df8:	f001 fbc2 	bl	8009580 <chMtxUnlock>
}

void OV2640_TransmitConfig(void)
{
	// Set to page 1
	I2C_write8_locked(OV2640_I2C_ADR, 0xff, 0x01);
 8007dfc:	2101      	movs	r1, #1
 8007dfe:	20ff      	movs	r0, #255	; 0xff
 8007e00:	f005 fed6 	bl	800dbb0 <I2C_write8_locked.constprop.1>
	I2C_write8_locked(OV2640_I2C_ADR, 0x12, 0x80);
 8007e04:	2180      	movs	r1, #128	; 0x80
 8007e06:	2012      	movs	r0, #18
 8007e08:	f005 fed2 	bl	800dbb0 <I2C_write8_locked.constprop.1>
	chThdSleepMilliseconds(50);
 8007e0c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007e10:	f004 fa96 	bl	800c340 <chThdSleep>
 8007e14:	20ff      	movs	r0, #255	; 0xff
 8007e16:	2300      	movs	r3, #0
 8007e18:	e005      	b.n	8007e26 <OV2640_init+0x246>

	/* Write selected arrays to the camera to initialize it and set the
	 * desired output format. */
	for(uint32_t i=0; (ov2640_init_regs[i].reg != 0xff) || (ov2640_init_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);
 8007e1a:	4619      	mov	r1, r3
 8007e1c:	f005 fec8 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8007e20:	78e3      	ldrb	r3, [r4, #3]
 8007e22:	f814 0f02 	ldrb.w	r0, [r4, #2]!
	I2C_write8_locked(OV2640_I2C_ADR, 0x12, 0x80);
	chThdSleepMilliseconds(50);

	/* Write selected arrays to the camera to initialize it and set the
	 * desired output format. */
	for(uint32_t i=0; (ov2640_init_regs[i].reg != 0xff) || (ov2640_init_regs[i].val != 0xff); i++)
 8007e26:	28ff      	cmp	r0, #255	; 0xff
 8007e28:	d1f7      	bne.n	8007e1a <OV2640_init+0x23a>
 8007e2a:	2bff      	cmp	r3, #255	; 0xff
 8007e2c:	d1f5      	bne.n	8007e1a <OV2640_init+0x23a>
 8007e2e:	4d34      	ldr	r5, [pc, #208]	; (8007f00 <OV2640_init+0x320>)
 8007e30:	2400      	movs	r4, #0
 8007e32:	e006      	b.n	8007e42 <OV2640_init+0x262>
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);
 8007e34:	4621      	mov	r1, r4
 8007e36:	4618      	mov	r0, r3
 8007e38:	f005 feba 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8007e3c:	78ec      	ldrb	r4, [r5, #3]
 8007e3e:	f815 3f02 	ldrb.w	r3, [r5, #2]!
	/* Write selected arrays to the camera to initialize it and set the
	 * desired output format. */
	for(uint32_t i=0; (ov2640_init_regs[i].reg != 0xff) || (ov2640_init_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
 8007e42:	2bff      	cmp	r3, #255	; 0xff
 8007e44:	d1f6      	bne.n	8007e34 <OV2640_init+0x254>
 8007e46:	2cff      	cmp	r4, #255	; 0xff
 8007e48:	d1f4      	bne.n	8007e34 <OV2640_init+0x254>
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 8007e4a:	6833      	ldr	r3, [r6, #0]
 8007e4c:	7a1b      	ldrb	r3, [r3, #8]
 8007e4e:	2b04      	cmp	r3, #4
 8007e50:	f200 8175 	bhi.w	800813e <OV2640_init+0x55e>
 8007e54:	e8df f013 	tbh	[pc, r3, lsl #1]
 8007e58:	0166013f 	.word	0x0166013f
 8007e5c:	0159014c 	.word	0x0159014c
 8007e60:	0005      	.short	0x0005
 8007e62:	4d28      	ldr	r5, [pc, #160]	; (8007f04 <OV2640_init+0x324>)
 8007e64:	2050      	movs	r0, #80	; 0x50
 8007e66:	2180      	movs	r1, #128	; 0x80
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_xga_regs[i].reg, ov2640_xga_regs[i].val);
			break;

		case RES_UXGA:
			for(uint32_t i=0; (ov2640_uxga_regs[i].reg != 0xff) || (ov2640_uxga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_uxga_regs[i].reg, ov2640_uxga_regs[i].val);
 8007e68:	f005 fea2 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8007e6c:	78e9      	ldrb	r1, [r5, #3]
 8007e6e:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_xga_regs[i].reg != 0xff) || (ov2640_xga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_xga_regs[i].reg, ov2640_xga_regs[i].val);
			break;

		case RES_UXGA:
			for(uint32_t i=0; (ov2640_uxga_regs[i].reg != 0xff) || (ov2640_uxga_regs[i].val != 0xff); i++)
 8007e72:	28ff      	cmp	r0, #255	; 0xff
 8007e74:	d1f8      	bne.n	8007e68 <OV2640_init+0x288>
 8007e76:	29ff      	cmp	r1, #255	; 0xff
 8007e78:	d1f6      	bne.n	8007e68 <OV2640_init+0x288>
 8007e7a:	4d23      	ldr	r5, [pc, #140]	; (8007f08 <OV2640_init+0x328>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 8007e7c:	2100      	movs	r1, #0
 8007e7e:	e005      	b.n	8007e8c <OV2640_init+0x2ac>
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
	}

	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
 8007e80:	4620      	mov	r0, r4
 8007e82:	f005 fe95 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8007e86:	78e9      	ldrb	r1, [r5, #3]
 8007e88:	f815 4f02 	ldrb.w	r4, [r5, #2]!
		default: // Default QVGA
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
	}

	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
 8007e8c:	2cff      	cmp	r4, #255	; 0xff
 8007e8e:	d1f7      	bne.n	8007e80 <OV2640_init+0x2a0>
 8007e90:	29ff      	cmp	r1, #255	; 0xff
 8007e92:	d1f5      	bne.n	8007e80 <OV2640_init+0x2a0>
 8007e94:	4c1d      	ldr	r4, [pc, #116]	; (8007f0c <OV2640_init+0x32c>)
 8007e96:	2000      	movs	r0, #0
 8007e98:	23da      	movs	r3, #218	; 0xda
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
	for(uint32_t i=0; (ov2640_yuyv_regs[i].reg != 0xff) || (ov2640_yuyv_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_yuyv_regs[i].reg, ov2640_yuyv_regs[i].val);
 8007e9a:	4601      	mov	r1, r0
 8007e9c:	4618      	mov	r0, r3
 8007e9e:	f005 fe87 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8007ea2:	78e0      	ldrb	r0, [r4, #3]
 8007ea4:	f814 3f02 	ldrb.w	r3, [r4, #2]!
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
	}

	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
	for(uint32_t i=0; (ov2640_yuyv_regs[i].reg != 0xff) || (ov2640_yuyv_regs[i].val != 0xff); i++)
 8007ea8:	2bff      	cmp	r3, #255	; 0xff
 8007eaa:	d1f6      	bne.n	8007e9a <OV2640_init+0x2ba>
 8007eac:	28ff      	cmp	r0, #255	; 0xff
 8007eae:	d1f4      	bne.n	8007e9a <OV2640_init+0x2ba>
 8007eb0:	4c17      	ldr	r4, [pc, #92]	; (8007f10 <OV2640_init+0x330>)
 8007eb2:	2100      	movs	r1, #0
 8007eb4:	e039      	b.n	8007f2a <OV2640_init+0x34a>
 8007eb6:	bf00      	nop
 8007eb8:	2001aa5c 	.word	0x2001aa5c
 8007ebc:	2001aa30 	.word	0x2001aa30
 8007ec0:	2001b720 	.word	0x2001b720
 8007ec4:	10624dd3 	.word	0x10624dd3
 8007ec8:	0800fbd4 	.word	0x0800fbd4
 8007ecc:	0800ea50 	.word	0x0800ea50
 8007ed0:	2001ac28 	.word	0x2001ac28
 8007ed4:	0800f1dc 	.word	0x0800f1dc
 8007ed8:	0800ea64 	.word	0x0800ea64
 8007edc:	0800fd60 	.word	0x0800fd60
 8007ee0:	0800ea7c 	.word	0x0800ea7c
 8007ee4:	0800f1e0 	.word	0x0800f1e0
 8007ee8:	0800fd7c 	.word	0x0800fd7c
 8007eec:	0800eaa8 	.word	0x0800eaa8
 8007ef0:	40020800 	.word	0x40020800
 8007ef4:	40021000 	.word	0x40021000
 8007ef8:	0800fd90 	.word	0x0800fd90
 8007efc:	0800fda4 	.word	0x0800fda4
 8007f00:	0800fecc 	.word	0x0800fecc
 8007f04:	0800fd3c 	.word	0x0800fd3c
 8007f08:	0800fea0 	.word	0x0800fea0
 8007f0c:	0800febc 	.word	0x0800febc
 8007f10:	0800fea8 	.word	0x0800fea8
 8007f14:	d1b71759 	.word	0xd1b71759
 8007f18:	40020000 	.word	0x40020000
 8007f1c:	40020400 	.word	0x40020400
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_yuyv_regs[i].reg, ov2640_yuyv_regs[i].val);

	for(uint32_t i=0; (ov2640_jpeg_regs[i].reg != 0xff) || (ov2640_jpeg_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_jpeg_regs[i].reg, ov2640_jpeg_regs[i].val);
 8007f20:	f005 fe46 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8007f24:	78e1      	ldrb	r1, [r4, #3]
 8007f26:	f814 0f02 	ldrb.w	r0, [r4, #2]!
	for(uint32_t i=0; (ov2640_format_change_preamble_regs[i].reg != 0xff) || (ov2640_format_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_format_change_preamble_regs[i].reg, ov2640_format_change_preamble_regs[i].val);
	for(uint32_t i=0; (ov2640_yuyv_regs[i].reg != 0xff) || (ov2640_yuyv_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_yuyv_regs[i].reg, ov2640_yuyv_regs[i].val);

	for(uint32_t i=0; (ov2640_jpeg_regs[i].reg != 0xff) || (ov2640_jpeg_regs[i].val != 0xff); i++)
 8007f2a:	28ff      	cmp	r0, #255	; 0xff
 8007f2c:	d1f8      	bne.n	8007f20 <OV2640_init+0x340>
 8007f2e:	29ff      	cmp	r1, #255	; 0xff
 8007f30:	d1f6      	bne.n	8007f20 <OV2640_init+0x340>
 8007f32:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
	// Send settings to OV2640
	TRACE_INFO("CAM  > Transmit config to camera");
	OV2640_TransmitConfig();

	// DCMI DMA
	TRACE_INFO("CAM  > Init DMA");
 8007f36:	4888      	ldr	r0, [pc, #544]	; (8008158 <OV2640_init+0x578>)
 8007f38:	4f88      	ldr	r7, [pc, #544]	; (800815c <OV2640_init+0x57c>)
 8007f3a:	4c89      	ldr	r4, [pc, #548]	; (8008160 <OV2640_init+0x580>)
 8007f3c:	f004 f930 	bl	800c1a0 <chMtxLock>
 8007f40:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 8007f44:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8007f48:	4986      	ldr	r1, [pc, #536]	; (8008164 <OV2640_init+0x584>)
 8007f4a:	4887      	ldr	r0, [pc, #540]	; (8008168 <OV2640_init+0x588>)
 8007f4c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8007f50:	fb05 f303 	mul.w	r3, r5, r3
 8007f54:	fba7 e303 	umull	lr, r3, r7, r3
 8007f58:	0b5b      	lsrs	r3, r3, #13
 8007f5a:	fba4 ce03 	umull	ip, lr, r4, r3
 8007f5e:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8007f62:	fba7 c202 	umull	ip, r2, r7, r2
 8007f66:	fb05 331e 	mls	r3, r5, lr, r3
 8007f6a:	0b52      	lsrs	r2, r2, #13
 8007f6c:	f002 fb90 	bl	800a690 <chprintf.constprop.26>
 8007f70:	4a7e      	ldr	r2, [pc, #504]	; (800816c <OV2640_init+0x58c>)
 8007f72:	497f      	ldr	r1, [pc, #508]	; (8008170 <OV2640_init+0x590>)
 8007f74:	487c      	ldr	r0, [pc, #496]	; (8008168 <OV2640_init+0x588>)
 8007f76:	f002 fb8b 	bl	800a690 <chprintf.constprop.26>
 8007f7a:	f44f 7352 	mov.w	r3, #840	; 0x348
 8007f7e:	4a7d      	ldr	r2, [pc, #500]	; (8008174 <OV2640_init+0x594>)
 8007f80:	497d      	ldr	r1, [pc, #500]	; (8008178 <OV2640_init+0x598>)
 8007f82:	4879      	ldr	r0, [pc, #484]	; (8008168 <OV2640_init+0x588>)
 8007f84:	f002 fb84 	bl	800a690 <chprintf.constprop.26>
 8007f88:	497c      	ldr	r1, [pc, #496]	; (800817c <OV2640_init+0x59c>)
 8007f8a:	4877      	ldr	r0, [pc, #476]	; (8008168 <OV2640_init+0x588>)
 8007f8c:	f002 fb80 	bl	800a690 <chprintf.constprop.26>
 8007f90:	497b      	ldr	r1, [pc, #492]	; (8008180 <OV2640_init+0x5a0>)
 8007f92:	4875      	ldr	r0, [pc, #468]	; (8008168 <OV2640_init+0x588>)
 8007f94:	f002 fb7c 	bl	800a690 <chprintf.constprop.26>
 8007f98:	497a      	ldr	r1, [pc, #488]	; (8008184 <OV2640_init+0x5a4>)
 8007f9a:	4873      	ldr	r0, [pc, #460]	; (8008168 <OV2640_init+0x588>)
 8007f9c:	f002 fb78 	bl	800a690 <chprintf.constprop.26>
 8007fa0:	486d      	ldr	r0, [pc, #436]	; (8008158 <OV2640_init+0x578>)
 8007fa2:	f001 faed 	bl	8009580 <chMtxUnlock>
/**
  * Initializes DMA
  */
void OV2640_InitDMA(void)
{
	TRACE_INFO("CAM  > Available buffer %d byte", ov2640_config->ram_size);
 8007fa6:	486c      	ldr	r0, [pc, #432]	; (8008158 <OV2640_init+0x578>)
 8007fa8:	f004 f8fa 	bl	800c1a0 <chMtxLock>
 8007fac:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 8007fb0:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8007fb4:	496b      	ldr	r1, [pc, #428]	; (8008164 <OV2640_init+0x584>)
 8007fb6:	486c      	ldr	r0, [pc, #432]	; (8008168 <OV2640_init+0x588>)
 8007fb8:	fb05 f303 	mul.w	r3, r5, r3
 8007fbc:	fba7 e303 	umull	lr, r3, r7, r3
 8007fc0:	0b5b      	lsrs	r3, r3, #13
 8007fc2:	fba4 ce03 	umull	ip, lr, r4, r3
 8007fc6:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 8007fca:	fba7 c202 	umull	ip, r2, r7, r2
 8007fce:	fb05 331e 	mls	r3, r5, lr, r3
 8007fd2:	0b52      	lsrs	r2, r2, #13
 8007fd4:	f002 fb5c 	bl	800a690 <chprintf.constprop.26>
 8007fd8:	4a64      	ldr	r2, [pc, #400]	; (800816c <OV2640_init+0x58c>)
 8007fda:	4965      	ldr	r1, [pc, #404]	; (8008170 <OV2640_init+0x590>)
 8007fdc:	4862      	ldr	r0, [pc, #392]	; (8008168 <OV2640_init+0x588>)
 8007fde:	f002 fb57 	bl	800a690 <chprintf.constprop.26>
 8007fe2:	f240 23b1 	movw	r3, #689	; 0x2b1
 8007fe6:	4a63      	ldr	r2, [pc, #396]	; (8008174 <OV2640_init+0x594>)
 8007fe8:	4963      	ldr	r1, [pc, #396]	; (8008178 <OV2640_init+0x598>)
 8007fea:	485f      	ldr	r0, [pc, #380]	; (8008168 <OV2640_init+0x588>)
 8007fec:	f002 fb50 	bl	800a690 <chprintf.constprop.26>
 8007ff0:	4962      	ldr	r1, [pc, #392]	; (800817c <OV2640_init+0x59c>)
 8007ff2:	485d      	ldr	r0, [pc, #372]	; (8008168 <OV2640_init+0x588>)
 8007ff4:	f002 fb4c 	bl	800a690 <chprintf.constprop.26>
 8007ff8:	6833      	ldr	r3, [r6, #0]
 8007ffa:	4963      	ldr	r1, [pc, #396]	; (8008188 <OV2640_init+0x5a8>)
 8007ffc:	691a      	ldr	r2, [r3, #16]
 8007ffe:	485a      	ldr	r0, [pc, #360]	; (8008168 <OV2640_init+0x588>)
 8008000:	f002 fb46 	bl	800a690 <chprintf.constprop.26>
 8008004:	495f      	ldr	r1, [pc, #380]	; (8008184 <OV2640_init+0x5a4>)
 8008006:	4858      	ldr	r0, [pc, #352]	; (8008168 <OV2640_init+0x588>)
 8008008:	f002 fb42 	bl	800a690 <chprintf.constprop.26>
 800800c:	4852      	ldr	r0, [pc, #328]	; (8008158 <OV2640_init+0x578>)
 800800e:	f001 fab7 	bl	8009580 <chMtxUnlock>
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamAllocate(stream, 2, (stm32_dmaisr_t)OV2640_dma_avail, NULL);
 8008012:	2300      	movs	r3, #0
 8008014:	4a5d      	ldr	r2, [pc, #372]	; (800818c <OV2640_init+0x5ac>)
 8008016:	485e      	ldr	r0, [pc, #376]	; (8008190 <OV2640_init+0x5b0>)
 8008018:	2102      	movs	r1, #2
 800801a:	f002 f931 	bl	800a280 <dmaStreamAllocate>
	dmaStreamSetPeripheral(stream, ((uint32_t*)DCMI_REG_DR_ADDRESS));
 800801e:	4b5d      	ldr	r3, [pc, #372]	; (8008194 <OV2640_init+0x5b4>)
 8008020:	4a5d      	ldr	r2, [pc, #372]	; (8008198 <OV2640_init+0x5b8>)
 8008022:	609a      	str	r2, [r3, #8]
	dmaStreamSetMemory0(stream, (uint32_t)ov2640_config->ram_buffer);
 8008024:	6832      	ldr	r2, [r6, #0]
	dmaStreamSetTransactionSize(stream, ov2640_config->ram_size / sizeof(uint32_t));
	dmaStreamSetMode(stream, STM32_DMA_CR_CHSEL(1) | STM32_DMA_CR_DIR_P2M |
 8008026:	4e5d      	ldr	r6, [pc, #372]	; (800819c <OV2640_init+0x5bc>)
{
	TRACE_INFO("CAM  > Available buffer %d byte", ov2640_config->ram_size);
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamAllocate(stream, 2, (stm32_dmaisr_t)OV2640_dma_avail, NULL);
	dmaStreamSetPeripheral(stream, ((uint32_t*)DCMI_REG_DR_ADDRESS));
	dmaStreamSetMemory0(stream, (uint32_t)ov2640_config->ram_buffer);
 8008028:	68d1      	ldr	r1, [r2, #12]
 800802a:	60d9      	str	r1, [r3, #12]
	dmaStreamSetTransactionSize(stream, ov2640_config->ram_size / sizeof(uint32_t));
 800802c:	6912      	ldr	r2, [r2, #16]
	// DCMI DMA
	TRACE_INFO("CAM  > Init DMA");
	OV2640_InitDMA();

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
 800802e:	484a      	ldr	r0, [pc, #296]	; (8008158 <OV2640_init+0x578>)
	dmaStreamSetMode(stream, STM32_DMA_CR_CHSEL(1) | STM32_DMA_CR_DIR_P2M |
							 STM32_DMA_CR_MINC | STM32_DMA_CR_PSIZE_WORD |
							 STM32_DMA_CR_MSIZE_WORD | STM32_DMA_CR_MBURST_SINGLE |
							 STM32_DMA_CR_PBURST_SINGLE | STM32_DMA_CR_TEIE |
							 STM32_DMA_CR_PL(3));
	dmaStreamSetFIFO(stream, STM32_DMA_FCR_FTH_FULL);
 8008030:	2103      	movs	r1, #3
	TRACE_INFO("CAM  > Available buffer %d byte", ov2640_config->ram_size);
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamAllocate(stream, 2, (stm32_dmaisr_t)OV2640_dma_avail, NULL);
	dmaStreamSetPeripheral(stream, ((uint32_t*)DCMI_REG_DR_ADDRESS));
	dmaStreamSetMemory0(stream, (uint32_t)ov2640_config->ram_buffer);
	dmaStreamSetTransactionSize(stream, ov2640_config->ram_size / sizeof(uint32_t));
 8008032:	0892      	lsrs	r2, r2, #2
 8008034:	605a      	str	r2, [r3, #4]
	dmaStreamSetMode(stream, STM32_DMA_CR_CHSEL(1) | STM32_DMA_CR_DIR_P2M |
 8008036:	601e      	str	r6, [r3, #0]
							 STM32_DMA_CR_MINC | STM32_DMA_CR_PSIZE_WORD |
							 STM32_DMA_CR_MSIZE_WORD | STM32_DMA_CR_MBURST_SINGLE |
							 STM32_DMA_CR_PBURST_SINGLE | STM32_DMA_CR_TEIE |
							 STM32_DMA_CR_PL(3));
	dmaStreamSetFIFO(stream, STM32_DMA_FCR_FTH_FULL);
 8008038:	6159      	str	r1, [r3, #20]
	dmaStreamEnable(stream);
 800803a:	681a      	ldr	r2, [r3, #0]
 800803c:	f042 0201 	orr.w	r2, r2, #1
 8008040:	601a      	str	r2, [r3, #0]
	// DCMI DMA
	TRACE_INFO("CAM  > Init DMA");
	OV2640_InitDMA();

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
 8008042:	f004 f8ad 	bl	800c1a0 <chMtxLock>
 8008046:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800804a:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800804e:	4945      	ldr	r1, [pc, #276]	; (8008164 <OV2640_init+0x584>)
 8008050:	4845      	ldr	r0, [pc, #276]	; (8008168 <OV2640_init+0x588>)
 8008052:	fb05 f303 	mul.w	r3, r5, r3
 8008056:	fba7 6303 	umull	r6, r3, r7, r3
 800805a:	0b5b      	lsrs	r3, r3, #13
 800805c:	fba4 6403 	umull	r6, r4, r4, r3
 8008060:	09a4      	lsrs	r4, r4, #6
 8008062:	fba7 6202 	umull	r6, r2, r7, r2
 8008066:	fb05 3314 	mls	r3, r5, r4, r3
 800806a:	0b52      	lsrs	r2, r2, #13
 800806c:	f002 fb10 	bl	800a690 <chprintf.constprop.26>
 8008070:	4a3e      	ldr	r2, [pc, #248]	; (800816c <OV2640_init+0x58c>)
 8008072:	493f      	ldr	r1, [pc, #252]	; (8008170 <OV2640_init+0x590>)
 8008074:	483c      	ldr	r0, [pc, #240]	; (8008168 <OV2640_init+0x588>)
 8008076:	f002 fb0b 	bl	800a690 <chprintf.constprop.26>
 800807a:	f44f 7353 	mov.w	r3, #844	; 0x34c
 800807e:	4a3d      	ldr	r2, [pc, #244]	; (8008174 <OV2640_init+0x594>)
 8008080:	493d      	ldr	r1, [pc, #244]	; (8008178 <OV2640_init+0x598>)
 8008082:	4839      	ldr	r0, [pc, #228]	; (8008168 <OV2640_init+0x588>)
 8008084:	f002 fb04 	bl	800a690 <chprintf.constprop.26>
 8008088:	493c      	ldr	r1, [pc, #240]	; (800817c <OV2640_init+0x59c>)
 800808a:	4837      	ldr	r0, [pc, #220]	; (8008168 <OV2640_init+0x588>)
 800808c:	f002 fb00 	bl	800a690 <chprintf.constprop.26>
 8008090:	4943      	ldr	r1, [pc, #268]	; (80081a0 <OV2640_init+0x5c0>)
 8008092:	4835      	ldr	r0, [pc, #212]	; (8008168 <OV2640_init+0x588>)
 8008094:	f002 fafc 	bl	800a690 <chprintf.constprop.26>
 8008098:	493a      	ldr	r1, [pc, #232]	; (8008184 <OV2640_init+0x5a4>)
 800809a:	4833      	ldr	r0, [pc, #204]	; (8008168 <OV2640_init+0x588>)
 800809c:	f002 faf8 	bl	800a690 <chprintf.constprop.26>
 80080a0:	482d      	ldr	r0, [pc, #180]	; (8008158 <OV2640_init+0x578>)
 80080a2:	f001 fa6d 	bl	8009580 <chMtxUnlock>
  * Initializes DCMI
  */
void OV2640_InitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR |= RCC_AHB2Periph_DCMI;
 80080a6:	493f      	ldr	r1, [pc, #252]	; (80081a4 <OV2640_init+0x5c4>)
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 80080a8:	4b3f      	ldr	r3, [pc, #252]	; (80081a8 <OV2640_init+0x5c8>)
  * Initializes DCMI
  */
void OV2640_InitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR |= RCC_AHB2Periph_DCMI;
 80080aa:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 80080ac:	f042 0201 	orr.w	r2, r2, #1
 80080b0:	634a      	str	r2, [r1, #52]	; 0x34
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 80080b2:	681a      	ldr	r2, [r3, #0]
 80080b4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80080b8:	f022 0201 	bic.w	r2, r2, #1

	// Configure DCMI
	DCMI->CR = DCMI_CaptureMode_SnapShot | DCMI_CR_JPEG | DCMI_CR_PCKPOL;
 80080bc:	212a      	movs	r1, #42	; 0x2a
  */
void OV2640_InitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR |= RCC_AHB2Periph_DCMI;
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 80080be:	601a      	str	r2, [r3, #0]

	// Configure DCMI
	DCMI->CR = DCMI_CaptureMode_SnapShot | DCMI_CR_JPEG | DCMI_CR_PCKPOL;
 80080c0:	6019      	str	r1, [r3, #0]

	// DCMI enable
	DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
 80080c2:	681a      	ldr	r2, [r3, #0]
 80080c4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80080c8:	601a      	str	r2, [r3, #0]

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
	OV2640_InitDCMI();

	chThdSleepMilliseconds(3000);
 80080ca:	f247 5030 	movw	r0, #30000	; 0x7530
}
 80080ce:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	// DCMI Init
	TRACE_INFO("CAM  > Init DCMI");
	OV2640_InitDCMI();

	chThdSleepMilliseconds(3000);
 80080d2:	f004 b935 	b.w	800c340 <chThdSleep>
 80080d6:	4d35      	ldr	r5, [pc, #212]	; (80081ac <OV2640_init+0x5cc>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 80080d8:	219b      	movs	r1, #155	; 0x9b
 80080da:	2050      	movs	r0, #80	; 0x50
		case RES_QCIF:
			for(uint32_t i=0; (ov2640_qcif_regs[i].reg != 0xff) || (ov2640_qcif_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qcif_regs[i].reg, ov2640_qcif_regs[i].val);
 80080dc:	f005 fd68 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 80080e0:	78e9      	ldrb	r1, [r5, #3]
 80080e2:	f815 0f02 	ldrb.w	r0, [r5, #2]!
	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
		case RES_QCIF:
			for(uint32_t i=0; (ov2640_qcif_regs[i].reg != 0xff) || (ov2640_qcif_regs[i].val != 0xff); i++)
 80080e6:	28ff      	cmp	r0, #255	; 0xff
 80080e8:	d1f8      	bne.n	80080dc <OV2640_init+0x4fc>
 80080ea:	29ff      	cmp	r1, #255	; 0xff
 80080ec:	d1f6      	bne.n	80080dc <OV2640_init+0x4fc>
 80080ee:	e6c4      	b.n	8007e7a <OV2640_init+0x29a>
 80080f0:	4d2f      	ldr	r5, [pc, #188]	; (80081b0 <OV2640_init+0x5d0>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 80080f2:	2050      	movs	r0, #80	; 0x50
 80080f4:	2180      	movs	r1, #128	; 0x80
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
			break;

		case RES_VGA:
			for(uint32_t i=0; (ov2640_vga_regs[i].reg != 0xff) || (ov2640_vga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_vga_regs[i].reg, ov2640_vga_regs[i].val);
 80080f6:	f005 fd5b 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 80080fa:	78e9      	ldrb	r1, [r5, #3]
 80080fc:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
			break;

		case RES_VGA:
			for(uint32_t i=0; (ov2640_vga_regs[i].reg != 0xff) || (ov2640_vga_regs[i].val != 0xff); i++)
 8008100:	28ff      	cmp	r0, #255	; 0xff
 8008102:	d1f8      	bne.n	80080f6 <OV2640_init+0x516>
 8008104:	29ff      	cmp	r1, #255	; 0xff
 8008106:	d1f6      	bne.n	80080f6 <OV2640_init+0x516>
 8008108:	e6b7      	b.n	8007e7a <OV2640_init+0x29a>
 800810a:	4d2a      	ldr	r5, [pc, #168]	; (80081b4 <OV2640_init+0x5d4>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 800810c:	2050      	movs	r0, #80	; 0x50
 800810e:	2180      	movs	r1, #128	; 0x80
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_vga_regs[i].reg, ov2640_vga_regs[i].val);
			break;

		case RES_XGA:
			for(uint32_t i=0; (ov2640_xga_regs[i].reg != 0xff) || (ov2640_xga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_xga_regs[i].reg, ov2640_xga_regs[i].val);
 8008110:	f005 fd4e 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8008114:	78e9      	ldrb	r1, [r5, #3]
 8008116:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_vga_regs[i].reg != 0xff) || (ov2640_vga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_vga_regs[i].reg, ov2640_vga_regs[i].val);
			break;

		case RES_XGA:
			for(uint32_t i=0; (ov2640_xga_regs[i].reg != 0xff) || (ov2640_xga_regs[i].val != 0xff); i++)
 800811a:	28ff      	cmp	r0, #255	; 0xff
 800811c:	d1f8      	bne.n	8008110 <OV2640_init+0x530>
 800811e:	29ff      	cmp	r1, #255	; 0xff
 8008120:	d1f6      	bne.n	8008110 <OV2640_init+0x530>
 8008122:	e6aa      	b.n	8007e7a <OV2640_init+0x29a>
 8008124:	4d24      	ldr	r5, [pc, #144]	; (80081b8 <OV2640_init+0x5d8>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 8008126:	2192      	movs	r1, #146	; 0x92
 8008128:	2050      	movs	r0, #80	; 0x50
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qcif_regs[i].reg, ov2640_qcif_regs[i].val);
			break;

		case RES_QVGA:
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
 800812a:	f005 fd41 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 800812e:	78e9      	ldrb	r1, [r5, #3]
 8008130:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_qcif_regs[i].reg != 0xff) || (ov2640_qcif_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qcif_regs[i].reg, ov2640_qcif_regs[i].val);
			break;

		case RES_QVGA:
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
 8008134:	28ff      	cmp	r0, #255	; 0xff
 8008136:	d1f8      	bne.n	800812a <OV2640_init+0x54a>
 8008138:	29ff      	cmp	r1, #255	; 0xff
 800813a:	d1f6      	bne.n	800812a <OV2640_init+0x54a>
 800813c:	e69d      	b.n	8007e7a <OV2640_init+0x29a>
 800813e:	4d1e      	ldr	r5, [pc, #120]	; (80081b8 <OV2640_init+0x5d8>)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_init_regs[i].reg, ov2640_init_regs[i].val);

	for(uint32_t i=0; (ov2640_size_change_preamble_regs[i].reg != 0xff) || (ov2640_size_change_preamble_regs[i].val != 0xff); i++)
		I2C_write8_locked(OV2640_I2C_ADR, ov2640_size_change_preamble_regs[i].reg, ov2640_size_change_preamble_regs[i].val);

	switch(ov2640_config->res) {
 8008140:	2192      	movs	r1, #146	; 0x92
 8008142:	2050      	movs	r0, #80	; 0x50
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_uxga_regs[i].reg, ov2640_uxga_regs[i].val);
			break;

		default: // Default QVGA
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_qvga_regs[i].reg, ov2640_qvga_regs[i].val);
 8008144:	f005 fd34 	bl	800dbb0 <I2C_write8_locked.constprop.1>
 8008148:	78e9      	ldrb	r1, [r5, #3]
 800814a:	f815 0f02 	ldrb.w	r0, [r5, #2]!
			for(uint32_t i=0; (ov2640_uxga_regs[i].reg != 0xff) || (ov2640_uxga_regs[i].val != 0xff); i++)
				I2C_write8_locked(OV2640_I2C_ADR, ov2640_uxga_regs[i].reg, ov2640_uxga_regs[i].val);
			break;

		default: // Default QVGA
			for(uint32_t i=0; (ov2640_qvga_regs[i].reg != 0xff) || (ov2640_qvga_regs[i].val != 0xff); i++)
 800814e:	28ff      	cmp	r0, #255	; 0xff
 8008150:	d1f8      	bne.n	8008144 <OV2640_init+0x564>
 8008152:	29ff      	cmp	r1, #255	; 0xff
 8008154:	d1f6      	bne.n	8008144 <OV2640_init+0x564>
 8008156:	e690      	b.n	8007e7a <OV2640_init+0x29a>
 8008158:	2001b720 	.word	0x2001b720
 800815c:	d1b71759 	.word	0xd1b71759
 8008160:	10624dd3 	.word	0x10624dd3
 8008164:	0800ea50 	.word	0x0800ea50
 8008168:	2001ac28 	.word	0x2001ac28
 800816c:	0800f1dc 	.word	0x0800f1dc
 8008170:	0800ea64 	.word	0x0800ea64
 8008174:	0800fd60 	.word	0x0800fd60
 8008178:	0800ea7c 	.word	0x0800ea7c
 800817c:	0800f1e0 	.word	0x0800f1e0
 8008180:	0800fdc8 	.word	0x0800fdc8
 8008184:	0800eaa8 	.word	0x0800eaa8
 8008188:	0800fdd8 	.word	0x0800fdd8
 800818c:	08007ab1 	.word	0x08007ab1
 8008190:	0800f814 	.word	0x0800f814
 8008194:	40026428 	.word	0x40026428
 8008198:	50050028 	.word	0x50050028
 800819c:	02035404 	.word	0x02035404
 80081a0:	0800fdf8 	.word	0x0800fdf8
 80081a4:	40023800 	.word	0x40023800
 80081a8:	50050000 	.word	0x50050000
 80081ac:	0800fd2c 	.word	0x0800fd2c
 80081b0:	0800fbb4 	.word	0x0800fbb4
 80081b4:	0800fbc4 	.word	0x0800fbc4
 80081b8:	0800fe90 	.word	0x0800fe90
 80081bc:	00000000 	.word	0x00000000

080081c0 <OV2640_getBuffer>:
{
	return OV2640_getBuffer(NULL) > ov2640_config->ram_size-3;
}

uint32_t OV2640_getBuffer(uint8_t** buffer) {
	*buffer = ov2640_config->ram_buffer;
 80081c0:	4b07      	ldr	r3, [pc, #28]	; (80081e0 <OV2640_getBuffer+0x20>)
 80081c2:	681a      	ldr	r2, [r3, #0]
 80081c4:	68d2      	ldr	r2, [r2, #12]
 80081c6:	6002      	str	r2, [r0, #0]

	// Detect size
	uint32_t size = ov2640_config->ram_size;
 80081c8:	681b      	ldr	r3, [r3, #0]
 80081ca:	6918      	ldr	r0, [r3, #16]
 80081cc:	68db      	ldr	r3, [r3, #12]
 80081ce:	4403      	add	r3, r0
 80081d0:	e000      	b.n	80081d4 <OV2640_getBuffer+0x14>
	while(!ov2640_config->ram_buffer[size-1])
		size--;
 80081d2:	4608      	mov	r0, r1
uint32_t OV2640_getBuffer(uint8_t** buffer) {
	*buffer = ov2640_config->ram_buffer;

	// Detect size
	uint32_t size = ov2640_config->ram_size;
	while(!ov2640_config->ram_buffer[size-1])
 80081d4:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 80081d8:	1e41      	subs	r1, r0, #1
 80081da:	2a00      	cmp	r2, #0
 80081dc:	d0f9      	beq.n	80081d2 <OV2640_getBuffer+0x12>
		size--;

	return size;
}
 80081de:	4770      	bx	lr
 80081e0:	2001aa5c 	.word	0x2001aa5c
	...

080081f0 <OV2640_Snapshot2RAM>:

/**
  * Captures an image from the camera.
  */
bool OV2640_Snapshot2RAM(void)
{
 80081f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	palClearPad(PORT(IO_LED2), PIN(IO_LED2)); // Yellow LED shows when image is captured
 80081f2:	4e24      	ldr	r6, [pc, #144]	; (8008284 <OV2640_Snapshot2RAM+0x94>)

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
 80081f4:	4f24      	ldr	r7, [pc, #144]	; (8008288 <OV2640_Snapshot2RAM+0x98>)
 80081f6:	4c25      	ldr	r4, [pc, #148]	; (800828c <OV2640_Snapshot2RAM+0x9c>)
/**
  * Captures an image from the camera.
  */
bool OV2640_Snapshot2RAM(void)
{
	palClearPad(PORT(IO_LED2), PIN(IO_LED2)); // Yellow LED shows when image is captured
 80081f8:	2501      	movs	r5, #1

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
 80081fa:	4638      	mov	r0, r7
/**
  * Captures an image from the camera.
  */
bool OV2640_Snapshot2RAM(void)
{
	palClearPad(PORT(IO_LED2), PIN(IO_LED2)); // Yellow LED shows when image is captured
 80081fc:	8375      	strh	r5, [r6, #26]

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
 80081fe:	f003 ffcf 	bl	800c1a0 <chMtxLock>
 8008202:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008206:	f8df e0b0 	ldr.w	lr, [pc, #176]	; 80082b8 <OV2640_Snapshot2RAM+0xc8>
 800820a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800820c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800820e:	4b20      	ldr	r3, [pc, #128]	; (8008290 <OV2640_Snapshot2RAM+0xa0>)
 8008210:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008214:	fb00 f101 	mul.w	r1, r0, r1
 8008218:	fbae c101 	umull	ip, r1, lr, r1
 800821c:	0b49      	lsrs	r1, r1, #13
 800821e:	fba3 c301 	umull	ip, r3, r3, r1
 8008222:	fbae e202 	umull	lr, r2, lr, r2
 8008226:	099b      	lsrs	r3, r3, #6
 8008228:	fb00 1313 	mls	r3, r0, r3, r1
 800822c:	0b52      	lsrs	r2, r2, #13
 800822e:	4620      	mov	r0, r4
 8008230:	4918      	ldr	r1, [pc, #96]	; (8008294 <OV2640_Snapshot2RAM+0xa4>)
 8008232:	f002 fa2d 	bl	800a690 <chprintf.constprop.26>
 8008236:	4620      	mov	r0, r4
 8008238:	4a17      	ldr	r2, [pc, #92]	; (8008298 <OV2640_Snapshot2RAM+0xa8>)
 800823a:	4918      	ldr	r1, [pc, #96]	; (800829c <OV2640_Snapshot2RAM+0xac>)
 800823c:	f002 fa28 	bl	800a690 <chprintf.constprop.26>
 8008240:	f240 238b 	movw	r3, #651	; 0x28b
 8008244:	4a16      	ldr	r2, [pc, #88]	; (80082a0 <OV2640_Snapshot2RAM+0xb0>)
 8008246:	4917      	ldr	r1, [pc, #92]	; (80082a4 <OV2640_Snapshot2RAM+0xb4>)
 8008248:	4620      	mov	r0, r4
 800824a:	f002 fa21 	bl	800a690 <chprintf.constprop.26>
 800824e:	4620      	mov	r0, r4
 8008250:	4915      	ldr	r1, [pc, #84]	; (80082a8 <OV2640_Snapshot2RAM+0xb8>)
 8008252:	f002 fa1d 	bl	800a690 <chprintf.constprop.26>
 8008256:	4620      	mov	r0, r4
 8008258:	4914      	ldr	r1, [pc, #80]	; (80082ac <OV2640_Snapshot2RAM+0xbc>)
 800825a:	f002 fa19 	bl	800a690 <chprintf.constprop.26>
 800825e:	4914      	ldr	r1, [pc, #80]	; (80082b0 <OV2640_Snapshot2RAM+0xc0>)
 8008260:	4620      	mov	r0, r4
 8008262:	f002 fa15 	bl	800a690 <chprintf.constprop.26>
 8008266:	4638      	mov	r0, r7
 8008268:	f001 f98a 	bl	8009580 <chMtxUnlock>
}

void OV2640_CaptureDCMI(void)
{
	// DCMI capture
	DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
 800826c:	4a11      	ldr	r2, [pc, #68]	; (80082b4 <OV2640_Snapshot2RAM+0xc4>)
 800826e:	6813      	ldr	r3, [r2, #0]
 8008270:	432b      	orrs	r3, r5
 8008272:	6013      	str	r3, [r2, #0]
	palClearPad(PORT(IO_LED2), PIN(IO_LED2)); // Yellow LED shows when image is captured

	// Capture enable
	TRACE_INFO("CAM  > Capture image");
	OV2640_CaptureDCMI();
	chThdSleepMilliseconds(1000);
 8008274:	f242 7010 	movw	r0, #10000	; 0x2710
 8008278:	f004 f862 	bl	800c340 <chThdSleep>

	palSetPad(PORT(IO_LED2), PIN(IO_LED2));
 800827c:	8335      	strh	r5, [r6, #24]

	return true;
}
 800827e:	4628      	mov	r0, r5
 8008280:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008282:	bf00      	nop
 8008284:	40020400 	.word	0x40020400
 8008288:	2001b720 	.word	0x2001b720
 800828c:	2001ac28 	.word	0x2001ac28
 8008290:	10624dd3 	.word	0x10624dd3
 8008294:	0800ea50 	.word	0x0800ea50
 8008298:	0800f1dc 	.word	0x0800f1dc
 800829c:	0800ea64 	.word	0x0800ea64
 80082a0:	0800fd60 	.word	0x0800fd60
 80082a4:	0800ea7c 	.word	0x0800ea7c
 80082a8:	0800f1e0 	.word	0x0800f1e0
 80082ac:	0800fe0c 	.word	0x0800fe0c
 80082b0:	0800eaa8 	.word	0x0800eaa8
 80082b4:	50050000 	.word	0x50050000
 80082b8:	d1b71759 	.word	0xd1b71759
 80082bc:	00000000 	.word	0x00000000

080082c0 <pac1720_getPsol>:
	} else {
		return 0; // PAC1720 not available (maybe Vcc too low)
	}
}

int16_t pac1720_getPsol(void) {
 80082c0:	b500      	push	{lr}
 80082c2:	b083      	sub	sp, #12
	int32_t fsp = FSV * FSC;
	int16_t val;
	uint8_t sign;
	if(I2C_read16(PAC1720_ADDRESS, PAC1720_CH1_PWR_RAT_HIGH, (uint16_t*)&val)) {
 80082c4:	f10d 0206 	add.w	r2, sp, #6
 80082c8:	2115      	movs	r1, #21
 80082ca:	204c      	movs	r0, #76	; 0x4c
 80082cc:	f004 fa30 	bl	800c730 <I2C_read16>
 80082d0:	b1d0      	cbz	r0, 8008308 <pac1720_getPsol+0x48>
		I2C_read8(PAC1720_ADDRESS, PAC1720_CH1_VSENSE_HIGH, &sign);
 80082d2:	f10d 0205 	add.w	r2, sp, #5
 80082d6:	210d      	movs	r1, #13
 80082d8:	204c      	movs	r0, #76	; 0x4c
 80082da:	f004 f9d1 	bl	800c680 <I2C_read8>
		return (sign >> 7 ? 1 : -1) * (val * fsp / 65536);
 80082de:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 80082e2:	f99d 2005 	ldrsb.w	r2, [sp, #5]
 80082e6:	ebc3 1043 	rsb	r0, r3, r3, lsl #5
 80082ea:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80082ee:	2a00      	cmp	r2, #0
 80082f0:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80082f4:	bfb8      	it	lt
 80082f6:	2001      	movlt	r0, #1
 80082f8:	021b      	lsls	r3, r3, #8
 80082fa:	bf44      	itt	mi
 80082fc:	f503 437f 	addmi.w	r3, r3, #65280	; 0xff00
 8008300:	33ff      	addmi	r3, #255	; 0xff
 8008302:	fb13 f020 	smultb	r0, r3, r0
 8008306:	b200      	sxth	r0, r0
	} else {
		return 0; // PAC1720 not available (maybe Vcc too low)
	}
}
 8008308:	b003      	add	sp, #12
 800830a:	f85d fb04 	ldr.w	pc, [sp], #4
 800830e:	bf00      	nop

08008310 <pac1720_getPbat>:
static int32_t pac1720_psol;
static int32_t pac1720_pbat;
static int32_t pac1720_psol_counter;
static int32_t pac1720_pbat_counter;

int16_t pac1720_getPbat(void) {
 8008310:	b500      	push	{lr}
 8008312:	b083      	sub	sp, #12
	int32_t fsp = FSV * FSC;
	int16_t val;
	uint8_t sign;
	if(I2C_read16(PAC1720_ADDRESS, PAC1720_CH2_PWR_RAT_HIGH, (uint16_t*)&val)) {
 8008314:	f10d 0206 	add.w	r2, sp, #6
 8008318:	2117      	movs	r1, #23
 800831a:	204c      	movs	r0, #76	; 0x4c
 800831c:	f004 fa08 	bl	800c730 <I2C_read16>
 8008320:	b1d0      	cbz	r0, 8008358 <pac1720_getPbat+0x48>
		I2C_read8(PAC1720_ADDRESS, PAC1720_CH2_VSENSE_HIGH, &sign);
 8008322:	f10d 0205 	add.w	r2, sp, #5
 8008326:	210f      	movs	r1, #15
 8008328:	204c      	movs	r0, #76	; 0x4c
 800832a:	f004 f9a9 	bl	800c680 <I2C_read8>
		return (sign >> 7 ? 1 : -1) * (val * fsp / 65536);
 800832e:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 8008332:	f99d 2005 	ldrsb.w	r2, [sp, #5]
 8008336:	ebc3 1043 	rsb	r0, r3, r3, lsl #5
 800833a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800833e:	2a00      	cmp	r2, #0
 8008340:	f64f 70ff 	movw	r0, #65535	; 0xffff
 8008344:	bfb8      	it	lt
 8008346:	2001      	movlt	r0, #1
 8008348:	021b      	lsls	r3, r3, #8
 800834a:	bf44      	itt	mi
 800834c:	f503 437f 	addmi.w	r3, r3, #65280	; 0xff00
 8008350:	33ff      	addmi	r3, #255	; 0xff
 8008352:	fb13 f020 	smultb	r0, r3, r0
 8008356:	b200      	sxth	r0, r0
	} else {
		return 0; // PAC1720 not available (maybe Vcc too low)
	}
}
 8008358:	b003      	add	sp, #12
 800835a:	f85d fb04 	ldr.w	pc, [sp], #4
 800835e:	bf00      	nop

08008360 <pac1720_thd>:
	else
		return false; // PAC1720 not available (maybe Vcc too low)
}

THD_FUNCTION(pac1720_thd, arg)
{
 8008360:	b580      	push	{r7, lr}
 8008362:	4e0c      	ldr	r6, [pc, #48]	; (8008394 <pac1720_thd+0x34>)
 8008364:	4f0c      	ldr	r7, [pc, #48]	; (8008398 <pac1720_thd+0x38>)
 8008366:	4d0d      	ldr	r5, [pc, #52]	; (800839c <pac1720_thd+0x3c>)
 8008368:	4c0d      	ldr	r4, [pc, #52]	; (80083a0 <pac1720_thd+0x40>)
	(void)arg;

	while(true)
	{
		pac1720_psol += pac1720_getPsol();
 800836a:	f7ff ffa9 	bl	80082c0 <pac1720_getPsol>
 800836e:	683b      	ldr	r3, [r7, #0]
 8008370:	4418      	add	r0, r3
 8008372:	6038      	str	r0, [r7, #0]
		pac1720_pbat += pac1720_getPbat();
 8008374:	f7ff ffcc 	bl	8008310 <pac1720_getPbat>
 8008378:	6831      	ldr	r1, [r6, #0]
		pac1720_psol_counter++;
 800837a:	682a      	ldr	r2, [r5, #0]
		pac1720_pbat_counter++;
 800837c:	6823      	ldr	r3, [r4, #0]
	(void)arg;

	while(true)
	{
		pac1720_psol += pac1720_getPsol();
		pac1720_pbat += pac1720_getPbat();
 800837e:	4401      	add	r1, r0
		pac1720_psol_counter++;
 8008380:	3201      	adds	r2, #1
		pac1720_pbat_counter++;
 8008382:	3301      	adds	r3, #1

		chThdSleepMilliseconds(100);
 8008384:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	(void)arg;

	while(true)
	{
		pac1720_psol += pac1720_getPsol();
		pac1720_pbat += pac1720_getPbat();
 8008388:	6031      	str	r1, [r6, #0]
		pac1720_psol_counter++;
 800838a:	602a      	str	r2, [r5, #0]
		pac1720_pbat_counter++;
 800838c:	6023      	str	r3, [r4, #0]

		chThdSleepMilliseconds(100);
 800838e:	f003 ffd7 	bl	800c340 <chThdSleep>
 8008392:	e7ea      	b.n	800836a <pac1720_thd+0xa>
 8008394:	2001aa64 	.word	0x2001aa64
 8008398:	2001aa6c 	.word	0x2001aa6c
 800839c:	2001aa68 	.word	0x2001aa68
 80083a0:	2001aa60 	.word	0x2001aa60
	...

080083b0 <BME280_getHumidity>:

/**
  * Reads the relative humidity
  * @return rel. humidity in % * 10
  */
uint16_t BME280_getHumidity(bme280_t *handle) {
 80083b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80083b2:	4604      	mov	r4, r0
 80083b4:	b083      	sub	sp, #12
	int32_t adc_H;
	uint16_t tmp;
	I2C_read16(handle->address, BME280_REGISTER_HUMIDDATA, &tmp);
 80083b6:	f10d 0206 	add.w	r2, sp, #6
 80083ba:	21fd      	movs	r1, #253	; 0xfd
 80083bc:	7800      	ldrb	r0, [r0, #0]
 80083be:	f004 f9b7 	bl	800c730 <I2C_read16>
	adc_H = tmp;

	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));
 80083c2:	6863      	ldr	r3, [r4, #4]

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 80083c4:	f894 6024 	ldrb.w	r6, [r4, #36]	; 0x24
 80083c8:	f994 202a 	ldrsb.w	r2, [r4, #42]	; 0x2a
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 80083cc:	f9b4 c026 	ldrsh.w	ip, [r4, #38]	; 0x26
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 80083d0:	f9b4 1022 	ldrsh.w	r1, [r4, #34]	; 0x22
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 80083d4:	f9b4 0028 	ldrsh.w	r0, [r4, #40]	; 0x28
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));

	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((int32_t)handle->calib.dig_H1)) >> 4));
 80083d8:	f894 5020 	ldrb.w	r5, [r4, #32]
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 80083dc:	f8bd e006 	ldrh.w	lr, [sp, #6]
	I2C_read16(handle->address, BME280_REGISTER_HUMIDDATA, &tmp);
	adc_H = tmp;

	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));
 80083e0:	f5a3 3796 	sub.w	r7, r3, #76800	; 0x12c00

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 80083e4:	fb07 f606 	mul.w	r6, r7, r6
 80083e8:	fb07 f402 	mul.w	r4, r7, r2
 80083ec:	12f6      	asrs	r6, r6, #11
 80083ee:	f506 4600 	add.w	r6, r6, #32768	; 0x8000
 80083f2:	12a2      	asrs	r2, r4, #10
 80083f4:	fb02 f206 	mul.w	r2, r2, r6
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 80083f8:	ea4f 530c 	mov.w	r3, ip, lsl #20
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 80083fc:	1292      	asrs	r2, r2, #10
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 80083fe:	ebc3 338e 	rsb	r3, r3, lr, lsl #14
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 8008402:	f502 1200 	add.w	r2, r2, #2097152	; 0x200000
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 8008406:	fb07 3310 	mls	r3, r7, r0, r3
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 800840a:	fb01 f202 	mul.w	r2, r1, r2
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 800840e:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));
 8008412:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
 8008416:	1392      	asrs	r2, r2, #14
	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
 8008418:	13db      	asrs	r3, r3, #15

	int32_t v_x1_u32r;

	v_x1_u32r = (handle->t_fine - ((int32_t)76800));

	v_x1_u32r = (((((adc_H << 14) - (((int32_t)handle->calib.dig_H4) << 20) -
 800841a:	fb02 f303 	mul.w	r3, r2, r3
		(((int32_t)handle->calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *
		(((((((v_x1_u32r * ((int32_t)handle->calib.dig_H6)) >> 10) *
		(((v_x1_u32r * ((int32_t)handle->calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
		((int32_t)2097152)) * ((int32_t)handle->calib.dig_H2) + 8192) >> 14));

	v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((int32_t)handle->calib.dig_H1)) >> 4));
 800841e:	13d8      	asrs	r0, r3, #15
 8008420:	fb00 f000 	mul.w	r0, r0, r0
 8008424:	11c0      	asrs	r0, r0, #7
 8008426:	fb05 f000 	mul.w	r0, r5, r0
 800842a:	eba3 1020 	sub.w	r0, r3, r0, asr #4

	v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;
 800842e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;
	float h = (v_x1_u32r>>12);
	return h / 102;
 8008432:	f1b0 5fc8 	cmp.w	r0, #419430400	; 0x19000000
 8008436:	bfa8      	it	ge
 8008438:	f04f 50c8 	movge.w	r0, #419430400	; 0x19000000
 800843c:	1300      	asrs	r0, r0, #12
 800843e:	f7f8 fbe7 	bl	8000c10 <__aeabi_i2f>
 8008442:	4904      	ldr	r1, [pc, #16]	; (8008454 <BME280_getHumidity+0xa4>)
 8008444:	f7f8 fcec 	bl	8000e20 <__aeabi_fdiv>
 8008448:	f7f8 fd86 	bl	8000f58 <__aeabi_f2uiz>
}
 800844c:	b280      	uxth	r0, r0
 800844e:	b003      	add	sp, #12
 8008450:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008452:	bf00      	nop
 8008454:	42cc0000 	.word	0x42cc0000
	...

08008460 <BME280_getTemperature>:
/**
  * Reads the temperature
  * @return Temperature in degC * 100
  */
int16_t BME280_getTemperature(bme280_t *handle)
{
 8008460:	b570      	push	{r4, r5, r6, lr}
 8008462:	4604      	mov	r4, r0
 8008464:	b082      	sub	sp, #8
	int32_t var1, var2, adc_T;
	uint16_t tmp;

	I2C_read16(handle->address, BME280_REGISTER_TEMPDATA, &tmp);
 8008466:	f10d 0206 	add.w	r2, sp, #6
 800846a:	21fa      	movs	r1, #250	; 0xfa
 800846c:	7800      	ldrb	r0, [r0, #0]
 800846e:	f004 f95f 	bl	800c730 <I2C_read16>
	adc_T = tmp;
	I2C_read8(handle->address, BME280_REGISTER_TEMPDATA+2, (uint8_t*)&tmp);
 8008472:	f10d 0206 	add.w	r2, sp, #6
 8008476:	7820      	ldrb	r0, [r4, #0]
{
	int32_t var1, var2, adc_T;
	uint16_t tmp;

	I2C_read16(handle->address, BME280_REGISTER_TEMPDATA, &tmp);
	adc_T = tmp;
 8008478:	f8bd 6006 	ldrh.w	r6, [sp, #6]
	I2C_read8(handle->address, BME280_REGISTER_TEMPDATA+2, (uint8_t*)&tmp);
 800847c:	21fc      	movs	r1, #252	; 0xfc
 800847e:	f004 f8ff 	bl	800c680 <I2C_read8>
	adc_T <<= 8;
	adc_T |= tmp & 0xFF;
 8008482:	f89d 2006 	ldrb.w	r2, [sp, #6]
	adc_T >>= 4;

	var1 = ((((adc_T>>3) - ((int32_t)handle->calib.dig_T1 <<1))) * ((int32_t)handle->calib.dig_T2)) >> 11;
 8008486:	8920      	ldrh	r0, [r4, #8]
	var2 = (((((adc_T>>4) - ((int32_t)handle->calib.dig_T1)) * ((adc_T>>4) - ((int32_t)handle->calib.dig_T1))) >> 12) * ((int32_t)handle->calib.dig_T3)) >> 14;

	handle->t_fine = var1 + var2;
 8008488:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 800848c:	f9b4 500a 	ldrsh.w	r5, [r4, #10]

	I2C_read16(handle->address, BME280_REGISTER_TEMPDATA, &tmp);
	adc_T = tmp;
	I2C_read8(handle->address, BME280_REGISTER_TEMPDATA+2, (uint8_t*)&tmp);
	adc_T <<= 8;
	adc_T |= tmp & 0xFF;
 8008490:	ea42 2306 	orr.w	r3, r2, r6, lsl #8
	adc_T >>= 4;

	var1 = ((((adc_T>>3) - ((int32_t)handle->calib.dig_T1 <<1))) * ((int32_t)handle->calib.dig_T2)) >> 11;
	var2 = (((((adc_T>>4) - ((int32_t)handle->calib.dig_T1)) * ((adc_T>>4) - ((int32_t)handle->calib.dig_T1))) >> 12) * ((int32_t)handle->calib.dig_T3)) >> 14;
 8008494:	ebc0 2213 	rsb	r2, r0, r3, lsr #8

	handle->t_fine = var1 + var2;
 8008498:	fb02 f202 	mul.w	r2, r2, r2
 800849c:	1312      	asrs	r2, r2, #12
 800849e:	0040      	lsls	r0, r0, #1
 80084a0:	ebc0 10d3 	rsb	r0, r0, r3, lsr #7
 80084a4:	fb01 f202 	mul.w	r2, r1, r2
 80084a8:	fb05 f000 	mul.w	r0, r5, r0
 80084ac:	1392      	asrs	r2, r2, #14
 80084ae:	eb02 23e0 	add.w	r3, r2, r0, asr #11

	return (handle->t_fine * 5 + 128) >> 8;
 80084b2:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 80084b6:	3080      	adds	r0, #128	; 0x80
}
 80084b8:	f340 200f 	sbfx	r0, r0, #8, #16
	adc_T >>= 4;

	var1 = ((((adc_T>>3) - ((int32_t)handle->calib.dig_T1 <<1))) * ((int32_t)handle->calib.dig_T2)) >> 11;
	var2 = (((((adc_T>>4) - ((int32_t)handle->calib.dig_T1)) * ((adc_T>>4) - ((int32_t)handle->calib.dig_T1))) >> 12) * ((int32_t)handle->calib.dig_T3)) >> 14;

	handle->t_fine = var1 + var2;
 80084bc:	6063      	str	r3, [r4, #4]

	return (handle->t_fine * 5 + 128) >> 8;
}
 80084be:	b002      	add	sp, #8
 80084c0:	bd70      	pop	{r4, r5, r6, pc}
 80084c2:	bf00      	nop
	...

080084d0 <dBm2powerLvl>:
/**
  * Converts power level from dBm to Si4464 power level. The calculation
  * assumes Vcc = 2.6V and Si4464/Si4463 or Si4063.
  */
uint8_t dBm2powerLvl(int32_t dBm) {
	if(dBm < -35) {
 80084d0:	f110 0f23 	cmn.w	r0, #35	; 0x23
 80084d4:	db16      	blt.n	8008504 <dBm2powerLvl+0x34>
		return 0;
	} else if(dBm < -7) {
 80084d6:	1dc2      	adds	r2, r0, #7
 80084d8:	db09      	blt.n	80084ee <dBm2powerLvl+0x1e>
		return (uint8_t)((2*dBm+74)/15);
	} else if(dBm < 2) {
 80084da:	2801      	cmp	r0, #1
 80084dc:	dd23      	ble.n	8008526 <dBm2powerLvl+0x56>
		return (uint8_t)((2*dBm+26)/3);
	} else if(dBm < 8) {
 80084de:	2807      	cmp	r0, #7
 80084e0:	dd12      	ble.n	8008508 <dBm2powerLvl+0x38>
		return (uint8_t)((5*dBm+20)/3);
	} else if(dBm < 13) {
 80084e2:	280c      	cmp	r0, #12
 80084e4:	dd1a      	ble.n	800851c <dBm2powerLvl+0x4c>
		return (uint8_t)(3*dBm-4);
	} else if(dBm < 18) {
 80084e6:	2811      	cmp	r0, #17
 80084e8:	dd26      	ble.n	8008538 <dBm2powerLvl+0x68>
		return (uint8_t)((92*dBm-1021)/5);
	} else {
		return 127;
 80084ea:	207f      	movs	r0, #127	; 0x7f
	}
}
 80084ec:	4770      	bx	lr
  */
uint8_t dBm2powerLvl(int32_t dBm) {
	if(dBm < -35) {
		return 0;
	} else if(dBm < -7) {
		return (uint8_t)((2*dBm+74)/15);
 80084ee:	3025      	adds	r0, #37	; 0x25
 80084f0:	4a18      	ldr	r2, [pc, #96]	; (8008554 <dBm2powerLvl+0x84>)
 80084f2:	0043      	lsls	r3, r0, #1
 80084f4:	fb82 2003 	smull	r2, r0, r2, r3
 80084f8:	4418      	add	r0, r3
 80084fa:	17db      	asrs	r3, r3, #31
 80084fc:	ebc3 00e0 	rsb	r0, r3, r0, asr #3
 8008500:	b2c0      	uxtb	r0, r0
 8008502:	4770      	bx	lr
  * Converts power level from dBm to Si4464 power level. The calculation
  * assumes Vcc = 2.6V and Si4464/Si4463 or Si4063.
  */
uint8_t dBm2powerLvl(int32_t dBm) {
	if(dBm < -35) {
		return 0;
 8008504:	2000      	movs	r0, #0
 8008506:	4770      	bx	lr
	} else if(dBm < -7) {
		return (uint8_t)((2*dBm+74)/15);
	} else if(dBm < 2) {
		return (uint8_t)((2*dBm+26)/3);
	} else if(dBm < 8) {
		return (uint8_t)((5*dBm+20)/3);
 8008508:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800850c:	4b12      	ldr	r3, [pc, #72]	; (8008558 <dBm2powerLvl+0x88>)
 800850e:	3014      	adds	r0, #20
 8008510:	fb83 2300 	smull	r2, r3, r3, r0
 8008514:	eba3 70e0 	sub.w	r0, r3, r0, asr #31
 8008518:	b2c0      	uxtb	r0, r0
 800851a:	4770      	bx	lr
	} else if(dBm < 13) {
		return (uint8_t)(3*dBm-4);
 800851c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8008520:	3804      	subs	r0, #4
 8008522:	b2c0      	uxtb	r0, r0
 8008524:	4770      	bx	lr
	if(dBm < -35) {
		return 0;
	} else if(dBm < -7) {
		return (uint8_t)((2*dBm+74)/15);
	} else if(dBm < 2) {
		return (uint8_t)((2*dBm+26)/3);
 8008526:	300d      	adds	r0, #13
 8008528:	4b0b      	ldr	r3, [pc, #44]	; (8008558 <dBm2powerLvl+0x88>)
 800852a:	0040      	lsls	r0, r0, #1
 800852c:	fb83 2300 	smull	r2, r3, r3, r0
 8008530:	eba3 70e0 	sub.w	r0, r3, r0, asr #31
 8008534:	b2c0      	uxtb	r0, r0
 8008536:	4770      	bx	lr
	} else if(dBm < 8) {
		return (uint8_t)((5*dBm+20)/3);
	} else if(dBm < 13) {
		return (uint8_t)(3*dBm-4);
	} else if(dBm < 18) {
		return (uint8_t)((92*dBm-1021)/5);
 8008538:	235c      	movs	r3, #92	; 0x5c
 800853a:	fb03 f000 	mul.w	r0, r3, r0
 800853e:	4a07      	ldr	r2, [pc, #28]	; (800855c <dBm2powerLvl+0x8c>)
 8008540:	f46f 737f 	mvn.w	r3, #1020	; 0x3fc
 8008544:	18c3      	adds	r3, r0, r3
 8008546:	fb82 2003 	smull	r2, r0, r2, r3
 800854a:	17db      	asrs	r3, r3, #31
 800854c:	ebc3 0060 	rsb	r0, r3, r0, asr #1
 8008550:	b2c0      	uxtb	r0, r0
 8008552:	4770      	bx	lr
 8008554:	88888889 	.word	0x88888889
 8008558:	55555556 	.word	0x55555556
 800855c:	66666667 	.word	0x66666667

08008560 <radioShutdown>:
void stopTx(void) {
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(change_state_command, 2);
}

void radioShutdown(void) {
 8008560:	b538      	push	{r3, r4, r5, lr}
	RADIO_SDN_SET(true);	// Power down chip
 8008562:	4c0f      	ldr	r4, [pc, #60]	; (80085a0 <radioShutdown+0x40>)
	RF_GPIO1_SET(false);	// Set GPIO1 low
	initialized = false;
 8008564:	4b0f      	ldr	r3, [pc, #60]	; (80085a4 <radioShutdown+0x44>)
 8008566:	2500      	movs	r5, #0
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(change_state_command, 2);
}

void radioShutdown(void) {
	RADIO_SDN_SET(true);	// Power down chip
 8008568:	f44f 5180 	mov.w	r1, #4096	; 0x1000
	RF_GPIO1_SET(false);	// Set GPIO1 low
 800856c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
	uint8_t change_state_command[] = {0x34, 0x03};
	Si4464_write(change_state_command, 2);
}

void radioShutdown(void) {
	RADIO_SDN_SET(true);	// Power down chip
 8008570:	61a1      	str	r1, [r4, #24]
	RF_GPIO1_SET(false);	// Set GPIO1 low
	initialized = false;

	// Deinit pins
	palSetPadMode(PORT(RADIO_CS), PIN(RADIO_CS), PAL_MODE_INPUT);		// RADIO CS
 8008572:	4620      	mov	r0, r4
	Si4464_write(change_state_command, 2);
}

void radioShutdown(void) {
	RADIO_SDN_SET(true);	// Power down chip
	RF_GPIO1_SET(false);	// Set GPIO1 low
 8008574:	61a2      	str	r2, [r4, #24]
	initialized = false;

	// Deinit pins
	palSetPadMode(PORT(RADIO_CS), PIN(RADIO_CS), PAL_MODE_INPUT);		// RADIO CS
 8008576:	f44f 7100 	mov.w	r1, #512	; 0x200
 800857a:	462a      	mov	r2, r5
}

void radioShutdown(void) {
	RADIO_SDN_SET(true);	// Power down chip
	RF_GPIO1_SET(false);	// Set GPIO1 low
	initialized = false;
 800857c:	701d      	strb	r5, [r3, #0]

	// Deinit pins
	palSetPadMode(PORT(RADIO_CS), PIN(RADIO_CS), PAL_MODE_INPUT);		// RADIO CS
 800857e:	f001 fdd7 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(RADIO_GPIO0), PIN(RADIO_GPIO0), PAL_MODE_INPUT);	// RADIO GPIO0
 8008582:	462a      	mov	r2, r5
 8008584:	4620      	mov	r0, r4
 8008586:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800858a:	f001 fdd1 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(RADIO_GPIO1), PIN(RADIO_GPIO1), PAL_MODE_INPUT);	// RADIO GPIO1
 800858e:	462a      	mov	r2, r5
 8008590:	4620      	mov	r0, r4
 8008592:	f44f 7180 	mov.w	r1, #256	; 0x100
}
 8008596:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	initialized = false;

	// Deinit pins
	palSetPadMode(PORT(RADIO_CS), PIN(RADIO_CS), PAL_MODE_INPUT);		// RADIO CS
	palSetPadMode(PORT(RADIO_GPIO0), PIN(RADIO_GPIO0), PAL_MODE_INPUT);	// RADIO GPIO0
	palSetPadMode(PORT(RADIO_GPIO1), PIN(RADIO_GPIO1), PAL_MODE_INPUT);	// RADIO GPIO1
 800859a:	f001 bdc9 	b.w	800a130 <_pal_lld_setgroupmode>
 800859e:	bf00      	nop
 80085a0:	40020c00 	.word	0x40020c00
 80085a4:	2001b754 	.word	0x2001b754
	...

080085b0 <Si4464_write>:
	// Temperature readout
	TRACE_INFO("SI   > Transmitter temperature %d degC", Si4464_getTemperature());
	initialized = true;
}

void Si4464_write(uint8_t* txData, uint32_t len) {
 80085b0:	b5f0      	push	{r4, r5, r6, r7, lr}
	// Transmit data by SPI
	uint8_t rxData[len];
 80085b2:	1dcb      	adds	r3, r1, #7
 80085b4:	f023 0307 	bic.w	r3, r3, #7
	// Temperature readout
	TRACE_INFO("SI   > Transmitter temperature %d degC", Si4464_getTemperature());
	initialized = true;
}

void Si4464_write(uint8_t* txData, uint32_t len) {
 80085b8:	b083      	sub	sp, #12
 80085ba:	460c      	mov	r4, r1
 80085bc:	4605      	mov	r5, r0
 80085be:	af00      	add	r7, sp, #0
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80085c0:	481a      	ldr	r0, [pc, #104]	; (800862c <Si4464_write+0x7c>)
	// Transmit data by SPI
	uint8_t rxData[len];
 80085c2:	ebad 0d03 	sub.w	sp, sp, r3
 80085c6:	f003 fdeb 	bl	800c1a0 <chMtxLock>
	
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver());
 80085ca:	f002 fad1 	bl	800ab70 <spiStart.constprop.53>
	spiSelect(&SPID2);
 80085ce:	f002 fb57 	bl	800ac80 <spiSelect.constprop.51>
	spiExchange(&SPID2, len, txData, rxData);
 80085d2:	4629      	mov	r1, r5
 80085d4:	4620      	mov	r0, r4
 80085d6:	466a      	mov	r2, sp
 80085d8:	f002 fa62 	bl	800aaa0 <spiExchange.constprop.47>
	spiUnselect(&SPID2);
 80085dc:	f002 fb80 	bl	800ace0 <spiUnselect.constprop.49>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80085e0:	4812      	ldr	r0, [pc, #72]	; (800862c <Si4464_write+0x7c>)
 80085e2:	f000 ffcd 	bl	8009580 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
 80085e6:	2300      	movs	r3, #0
 80085e8:	f88d 3001 	strb.w	r3, [sp, #1]
	initialized = true;
}

void Si4464_write(uint8_t* txData, uint32_t len) {
	// Transmit data by SPI
	uint8_t rxData[len];
 80085ec:	466d      	mov	r5, sp
	spiUnselect(&SPID2);
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
 80085ee:	f240 74cf 	movw	r4, #1999	; 0x7cf
	while(rxData[1] != 0xFF && ++counter < 2000) {

		// Request ACK by Si4464
		uint8_t rx_ready[] = {0x44};
 80085f2:	2644      	movs	r6, #68	; 0x44
 80085f4:	e001      	b.n	80085fa <Si4464_write+0x4a>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 80085f6:	3c01      	subs	r4, #1
 80085f8:	d014      	beq.n	8008624 <Si4464_write+0x74>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80085fa:	480c      	ldr	r0, [pc, #48]	; (800862c <Si4464_write+0x7c>)

		// Request ACK by Si4464
		uint8_t rx_ready[] = {0x44};
 80085fc:	713e      	strb	r6, [r7, #4]
 80085fe:	f003 fdcf 	bl	800c1a0 <chMtxLock>

		// SPI transfer
		spiAcquireBus(&SPID2);
		spiStart(&SPID2, getSPIDriver());
 8008602:	f002 fab5 	bl	800ab70 <spiStart.constprop.53>
		spiSelect(&SPID2);
 8008606:	f002 fb3b 	bl	800ac80 <spiSelect.constprop.51>
		spiExchange(&SPID2, 3, rx_ready, rxData);
 800860a:	462a      	mov	r2, r5
 800860c:	1d39      	adds	r1, r7, #4
 800860e:	2003      	movs	r0, #3
 8008610:	f002 fa46 	bl	800aaa0 <spiExchange.constprop.47>
		spiUnselect(&SPID2);
 8008614:	f002 fb64 	bl	800ace0 <spiUnselect.constprop.49>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8008618:	4804      	ldr	r0, [pc, #16]	; (800862c <Si4464_write+0x7c>)
 800861a:	f000 ffb1 	bl	8009580 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 800861e:	786b      	ldrb	r3, [r5, #1]
 8008620:	2bff      	cmp	r3, #255	; 0xff
 8008622:	d1e8      	bne.n	80085f6 <Si4464_write+0x46>
		spiSelect(&SPID2);
		spiExchange(&SPID2, 3, rx_ready, rxData);
		spiUnselect(&SPID2);
		spiReleaseBus(&SPID2);
	}
}
 8008624:	370c      	adds	r7, #12
 8008626:	46bd      	mov	sp, r7
 8008628:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800862a:	bf00      	nop
 800862c:	2001b59c 	.word	0x2001b59c

08008630 <Si4464_Init>:
/**
 * Initializes Si4464 transceiver chip. Adjustes the frequency which is shifted by variable
 * oscillator voltage.
 * @param mv Oscillator voltage in mv
 */
void Si4464_Init(mod_t modulation) {
 8008630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008634:	b097      	sub	sp, #92	; 0x5c
 8008636:	4605      	mov	r5, r0
 8008638:	af00      	add	r7, sp, #0
	// Initialize SPI
	palSetPadMode(PORT(SPI_SCK), PIN(SPI_SCK), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// SCK
 800863a:	f240 229a 	movw	r2, #666	; 0x29a
 800863e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8008642:	48bb      	ldr	r0, [pc, #748]	; (8008930 <Si4464_Init+0x300>)
	palSetPadMode(PORT(SPI_MISO), PIN(SPI_MISO), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MISO
	palSetPadMode(PORT(SPI_MOSI), PIN(SPI_MOSI), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MOSI
	palSetPadMode(PORT(RADIO_CS), PIN(RADIO_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO CS
 8008644:	4cbb      	ldr	r4, [pc, #748]	; (8008934 <Si4464_Init+0x304>)
 * oscillator voltage.
 * @param mv Oscillator voltage in mv
 */
void Si4464_Init(mod_t modulation) {
	// Initialize SPI
	palSetPadMode(PORT(SPI_SCK), PIN(SPI_SCK), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// SCK
 8008646:	f001 fd73 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(SPI_MISO), PIN(SPI_MISO), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MISO
 800864a:	f240 229a 	movw	r2, #666	; 0x29a
 800864e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8008652:	48b7      	ldr	r0, [pc, #732]	; (8008930 <Si4464_Init+0x300>)
 8008654:	f001 fd6c 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(SPI_MOSI), PIN(SPI_MOSI), PAL_MODE_ALTERNATE(5) | PAL_STM32_OSPEED_HIGHEST);			// MOSI
 8008658:	f240 229a 	movw	r2, #666	; 0x29a
 800865c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8008660:	48b3      	ldr	r0, [pc, #716]	; (8008930 <Si4464_Init+0x300>)
 8008662:	f001 fd65 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(RADIO_CS), PIN(RADIO_CS), PAL_MODE_OUTPUT_PUSHPULL | PAL_STM32_OSPEED_HIGHEST);	// RADIO CS
 8008666:	4620      	mov	r0, r4
 8008668:	2219      	movs	r2, #25
 800866a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800866e:	f001 fd5f 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPad(PORT(RADIO_CS), PIN(RADIO_CS));
 8008672:	f44f 7300 	mov.w	r3, #512	; 0x200
 8008676:	8323      	strh	r3, [r4, #24]

	// Configure pins
	palSetPadMode(PORT(RADIO_SDN), PIN(RADIO_SDN), PAL_MODE_OUTPUT_PUSHPULL);		// RADIO SDN
 8008678:	4620      	mov	r0, r4
 800867a:	2201      	movs	r2, #1
 800867c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008680:	f001 fd56 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(RADIO_GPIO0), PIN(RADIO_GPIO0), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO GPIO0
 8008684:	4620      	mov	r0, r4
 8008686:	2201      	movs	r2, #1
 8008688:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800868c:	f001 fd50 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(RADIO_GPIO1), PIN(RADIO_GPIO1), PAL_MODE_OUTPUT_PUSHPULL);	// RADIO GPIO1
 8008690:	4620      	mov	r0, r4
 8008692:	2201      	movs	r2, #1
 8008694:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008698:	f001 fd4a 	bl	800a130 <_pal_lld_setgroupmode>

	// Power up transmitter
	RADIO_SDN_SET(false);	// Radio SDN low (power up transmitter)
 800869c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80086a0:	61a3      	str	r3, [r4, #24]
	chThdSleepMilliseconds(5);		// Wait for transmitter to power up
 80086a2:	2032      	movs	r0, #50	; 0x32
 80086a4:	f003 fe4c 	bl	800c340 <chThdSleep>
	// Power up (transmits oscillator type)
	uint8_t x3 = (OSC_FREQ >> 24) & 0x0FF;
	uint8_t x2 = (OSC_FREQ >> 16) & 0x0FF;
	uint8_t x1 = (OSC_FREQ >>  8) & 0x0FF;
	uint8_t x0 = (OSC_FREQ >>  0) & 0x0FF;
	uint8_t init_command[] = {0x02, 0x01, 0x01, x3, x2, x1, x0};
 80086a8:	268c      	movs	r6, #140	; 0x8c
 80086aa:	2301      	movs	r3, #1
 80086ac:	2274      	movs	r2, #116	; 0x74
	Si4464_write(init_command, 7);
 80086ae:	2107      	movs	r1, #7
 80086b0:	f107 0028 	add.w	r0, r7, #40	; 0x28
	// Power up (transmits oscillator type)
	uint8_t x3 = (OSC_FREQ >> 24) & 0x0FF;
	uint8_t x2 = (OSC_FREQ >> 16) & 0x0FF;
	uint8_t x1 = (OSC_FREQ >>  8) & 0x0FF;
	uint8_t x0 = (OSC_FREQ >>  0) & 0x0FF;
	uint8_t init_command[] = {0x02, 0x01, 0x01, x3, x2, x1, x0};
 80086b4:	f04f 0e02 	mov.w	lr, #2
 80086b8:	24bc      	movs	r4, #188	; 0xbc
 80086ba:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
 80086be:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
 80086c2:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
 80086c6:	f887 e028 	strb.w	lr, [r7, #40]	; 0x28
 80086ca:	f887 602c 	strb.w	r6, [r7, #44]	; 0x2c
 80086ce:	f887 402d 	strb.w	r4, [r7, #45]	; 0x2d
 80086d2:	f887 202e 	strb.w	r2, [r7, #46]	; 0x2e
	Si4464_write(init_command, 7);
 80086d6:	f7ff ff6b 	bl	80085b0 <Si4464_write>

	// Set transmitter GPIOs
	uint8_t gpio_pin_cfg_command[] = {
 80086da:	4b97      	ldr	r3, [pc, #604]	; (8008938 <Si4464_Init+0x308>)
 80086dc:	6818      	ldr	r0, [r3, #0]
 80086de:	6859      	ldr	r1, [r3, #4]
 80086e0:	f107 0338 	add.w	r3, r7, #56	; 0x38
 80086e4:	c303      	stmia	r3!, {r0, r1}
		0x00,	// GPIO3        0 - PULL_CTL[1bit] - GPIO_MODE[6bit]
		0x00,	// NIRQ
		0x00,	// SDO
		0x00	// GEN_CONFIG
	};
	Si4464_write(gpio_pin_cfg_command, 8);
 80086e6:	2108      	movs	r1, #8
 80086e8:	f107 0038 	add.w	r0, r7, #56	; 0x38
 80086ec:	f7ff ff60 	bl	80085b0 <Si4464_write>

	// Set modem
	switch(modulation)
 80086f0:	2d04      	cmp	r5, #4
 80086f2:	f200 81ce 	bhi.w	8008a92 <Si4464_Init+0x462>
 80086f6:	e8df f015 	tbh	[pc, r5, lsl #1]
 80086fa:	0082      	.short	0x0082
 80086fc:	01430193 	.word	0x01430193
 8008700:	00050195 	.word	0x00050195
	Si4464_write(set_modem_freq_dev_command, 7);
}

void setModemAFSK(void) {
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
 8008704:	4c8d      	ldr	r4, [pc, #564]	; (800893c <Si4464_Init+0x30c>)
 8008706:	6820      	ldr	r0, [r4, #0]
 8008708:	7923      	ldrb	r3, [r4, #4]
 800870a:	60b8      	str	r0, [r7, #8]
	Si4464_write(disable_preamble, 5);
 800870c:	2105      	movs	r1, #5
 800870e:	f107 0008 	add.w	r0, r7, #8
	Si4464_write(set_modem_freq_dev_command, 7);
}

void setModemAFSK(void) {
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
 8008712:	733b      	strb	r3, [r7, #12]
	Si4464_write(disable_preamble, 5);
 8008714:	f7ff ff4c 	bl	80085b0 <Si4464_write>

	// Do not transmit sync word
	uint8_t no_sync_word[] = {0x11, 0x11, 0x01, 0x00, (0x01 << 7)};
 8008718:	4623      	mov	r3, r4
	Si4464_write(no_sync_word, 5);
 800871a:	2105      	movs	r1, #5
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
	Si4464_write(disable_preamble, 5);

	// Do not transmit sync word
	uint8_t no_sync_word[] = {0x11, 0x11, 0x01, 0x00, (0x01 << 7)};
 800871c:	f853 0f08 	ldr.w	r0, [r3, #8]!
 8008720:	6138      	str	r0, [r7, #16]
 8008722:	791b      	ldrb	r3, [r3, #4]
 8008724:	753b      	strb	r3, [r7, #20]
	Si4464_write(no_sync_word, 5);
 8008726:	f107 0010 	add.w	r0, r7, #16
 800872a:	f7ff ff41 	bl	80085b0 <Si4464_write>
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
	Si4464_write(setup_oversampling, 8);
 800872e:	f107 0640 	add.w	r6, r7, #64	; 0x40
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 8008732:	2304      	movs	r3, #4
 8008734:	2106      	movs	r1, #6
 8008736:	f04f 0e00 	mov.w	lr, #0
 800873a:	f04f 0920 	mov.w	r9, #32
 800873e:	22ac      	movs	r2, #172	; 0xac
	Si4464_write(setup_oversampling, 8);
 8008740:	4630      	mov	r0, r6
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 8008742:	2527      	movs	r5, #39	; 0x27
 8008744:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
 8008748:	f887 1043 	strb.w	r1, [r7, #67]	; 0x43
 800874c:	2372      	movs	r3, #114	; 0x72
	Si4464_write(setup_oversampling, 8);
 800874e:	2108      	movs	r1, #8
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 8008750:	f04f 0a11 	mov.w	sl, #17
 8008754:	f887 e044 	strb.w	lr, [r7, #68]	; 0x44
 8008758:	f887 9041 	strb.w	r9, [r7, #65]	; 0x41
 800875c:	f887 5045 	strb.w	r5, [r7, #69]	; 0x45
 8008760:	f887 2046 	strb.w	r2, [r7, #70]	; 0x46
 8008764:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 8008768:	f887 a040 	strb.w	sl, [r7, #64]	; 0x40
	Si4464_write(setup_oversampling, 8);
 800876c:	f7ff ff20 	bl	80085b0 <Si4464_write>

	// Setup the NCO data rate for APRS
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x11, 0x30};
 8008770:	4623      	mov	r3, r4
 8008772:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8008776:	f853 0f10 	ldr.w	r0, [r3, #16]!
 800877a:	607a      	str	r2, [r7, #4]
 800877c:	4611      	mov	r1, r2
 800877e:	6338      	str	r0, [r7, #48]	; 0x30
 8008780:	889a      	ldrh	r2, [r3, #4]
 8008782:	808a      	strh	r2, [r1, #4]
 8008784:	4608      	mov	r0, r1
 8008786:	799b      	ldrb	r3, [r3, #6]
 8008788:	7183      	strb	r3, [r0, #6]
	Si4464_write(setup_data_rate, 7);
 800878a:	2107      	movs	r1, #7
 800878c:	f7ff ff10 	bl	80085b0 <Si4464_write>

	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
 8008790:	4623      	mov	r3, r4
	Si4464_write(use_2gfsk, 5);
 8008792:	2105      	movs	r1, #5
	// Setup the NCO data rate for APRS
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x11, 0x30};
	Si4464_write(setup_data_rate, 7);

	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
 8008794:	f853 0f18 	ldr.w	r0, [r3, #24]!
 8008798:	61b8      	str	r0, [r7, #24]
 800879a:	791b      	ldrb	r3, [r3, #4]
 800879c:	773b      	strb	r3, [r7, #28]
	Si4464_write(use_2gfsk, 5);
 800879e:	f107 0018 	add.w	r0, r7, #24
 80087a2:	f7ff ff05 	bl	80085b0 <Si4464_write>

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
 80087a6:	f854 0f20 	ldr.w	r0, [r4, #32]!
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
 80087aa:	f8c7 9000 	str.w	r9, [r7]
	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
	Si4464_write(use_2gfsk, 5);

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
 80087ae:	6861      	ldr	r1, [r4, #4]
 80087b0:	7a22      	ldrb	r2, [r4, #8]
 80087b2:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80087b6:	c303      	stmia	r3!, {r0, r1}
 80087b8:	f107 0548 	add.w	r5, r7, #72	; 0x48
 80087bc:	701a      	strb	r2, [r3, #0]
 80087be:	46a9      	mov	r9, r5
 80087c0:	f04f 0817 	mov.w	r8, #23
 80087c4:	f107 0420 	add.w	r4, r7, #32
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
 80087c8:	f04f 0b01 	mov.w	fp, #1
 80087cc:	f887 8023 	strb.w	r8, [r7, #35]	; 0x23
 80087d0:	f108 38ff 	add.w	r8, r8, #4294967295
 80087d4:	f819 2b01 	ldrb.w	r2, [r9], #1
 80087d8:	783b      	ldrb	r3, [r7, #0]
 80087da:	f887 a020 	strb.w	sl, [r7, #32]
		Si4464_write(msg, 5);
 80087de:	2105      	movs	r1, #5
 80087e0:	4620      	mov	r0, r4
 80087e2:	fa5f f888 	uxtb.w	r8, r8

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
		uint8_t msg[] = {0x11, 0x20, 0x01, 0x17-i, coeff[i]};
 80087e6:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
 80087ea:	f887 b022 	strb.w	fp, [r7, #34]	; 0x22
 80087ee:	f887 2024 	strb.w	r2, [r7, #36]	; 0x24
		Si4464_write(msg, 5);
 80087f2:	f7ff fedd 	bl	80085b0 <Si4464_write>
	Si4464_write(use_2gfsk, 5);

	// Set AFSK filter
	uint8_t coeff[] = {0x81, 0x9f, 0xc4, 0xee, 0x18, 0x3e, 0x5c, 0x70, 0x76};
	uint8_t i;
	for(i=0; i<sizeof(coeff); i++) {
 80087f6:	f1b8 0f0e 	cmp.w	r8, #14
 80087fa:	d1e7      	bne.n	80087cc <Si4464_Init+0x19c>
 80087fc:	e011      	b.n	8008822 <Si4464_Init+0x1f2>
	}
}

void setModemOOK(void) {
	// Use OOK from async GPIO0
	uint8_t use_ook[] = {0x11, 0x20, 0x01, 0x00, 0x89};
 80087fe:	4b50      	ldr	r3, [pc, #320]	; (8008940 <Si4464_Init+0x310>)
	Si4464_write(use_ook, 5);
}

void setModem2FSK(void) {
	// use 2FSK from async GPIO0
	uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x8A};
 8008800:	6818      	ldr	r0, [r3, #0]
 8008802:	791b      	ldrb	r3, [r3, #4]
 8008804:	64b8      	str	r0, [r7, #72]	; 0x48
 8008806:	f107 0548 	add.w	r5, r7, #72	; 0x48
	Si4464_write(use_2fsk, 5);
 800880a:	4628      	mov	r0, r5
	Si4464_write(use_ook, 5);
}

void setModem2FSK(void) {
	// use 2FSK from async GPIO0
	uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x8A};
 800880c:	712b      	strb	r3, [r5, #4]
	Si4464_write(use_2fsk, 5);
 800880e:	2105      	movs	r1, #5
 8008810:	f7ff fece 	bl	80085b0 <Si4464_write>
 8008814:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008818:	f107 0640 	add.w	r6, r7, #64	; 0x40
 800881c:	607b      	str	r3, [r7, #4]
 800881e:	f107 0420 	add.w	r4, r7, #32
		case MOD_DOMINOEX16:
			TRACE_WARN("SI   > Unimplemented modulation %s", VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI   > Transmitter temperature %d degC", Si4464_getTemperature());
 8008822:	4848      	ldr	r0, [pc, #288]	; (8008944 <Si4464_Init+0x314>)
 8008824:	f003 fcbc 	bl	800c1a0 <chMtxLock>
 8008828:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800882c:	f8df e14c 	ldr.w	lr, [pc, #332]	; 800897c <Si4464_Init+0x34c>
 8008830:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008832:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8008834:	4b44      	ldr	r3, [pc, #272]	; (8008948 <Si4464_Init+0x318>)
 8008836:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800883a:	fb00 f101 	mul.w	r1, r0, r1
 800883e:	fbae c101 	umull	ip, r1, lr, r1
 8008842:	0b49      	lsrs	r1, r1, #13
 8008844:	fba3 c301 	umull	ip, r3, r3, r1
 8008848:	fbae e202 	umull	lr, r2, lr, r2
 800884c:	099b      	lsrs	r3, r3, #6
 800884e:	fb00 1313 	mls	r3, r0, r3, r1
 8008852:	0b52      	lsrs	r2, r2, #13
 8008854:	493d      	ldr	r1, [pc, #244]	; (800894c <Si4464_Init+0x31c>)
 8008856:	483e      	ldr	r0, [pc, #248]	; (8008950 <Si4464_Init+0x320>)
 8008858:	f001 ff1a 	bl	800a690 <chprintf.constprop.26>
 800885c:	4a3d      	ldr	r2, [pc, #244]	; (8008954 <Si4464_Init+0x324>)
 800885e:	493e      	ldr	r1, [pc, #248]	; (8008958 <Si4464_Init+0x328>)
 8008860:	483b      	ldr	r0, [pc, #236]	; (8008950 <Si4464_Init+0x320>)
 8008862:	f001 ff15 	bl	800a690 <chprintf.constprop.26>
 8008866:	4a3d      	ldr	r2, [pc, #244]	; (800895c <Si4464_Init+0x32c>)
 8008868:	493d      	ldr	r1, [pc, #244]	; (8008960 <Si4464_Init+0x330>)
 800886a:	4839      	ldr	r0, [pc, #228]	; (8008950 <Si4464_Init+0x320>)
 800886c:	2358      	movs	r3, #88	; 0x58
 800886e:	f001 ff0f 	bl	800a690 <chprintf.constprop.26>
 8008872:	493c      	ldr	r1, [pc, #240]	; (8008964 <Si4464_Init+0x334>)
 8008874:	4836      	ldr	r0, [pc, #216]	; (8008950 <Si4464_Init+0x320>)
 8008876:	f001 ff0b 	bl	800a690 <chprintf.constprop.26>
	Si4464_read(fifo_info, 1, rxData, 4);
	return rxData[2];
}

int8_t Si4464_getTemperature(void) {
	uint8_t txData[2] = {0x14, 0x10};
 800887a:	4b3b      	ldr	r3, [pc, #236]	; (8008968 <Si4464_Init+0x338>)
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800887c:	483b      	ldr	r0, [pc, #236]	; (800896c <Si4464_Init+0x33c>)
 800887e:	881b      	ldrh	r3, [r3, #0]
 8008880:	843b      	strh	r3, [r7, #32]
 8008882:	f003 fc8d 	bl	800c1a0 <chMtxLock>
void Si4464_read(uint8_t* txData, uint32_t txlen, uint8_t* rxData, uint32_t rxlen) {
	// Transmit data by SPI
	uint8_t null_spi[txlen];
	// SPI transfer
	spiAcquireBus(&SPID2);
	spiStart(&SPID2, getSPIDriver());
 8008886:	f002 f973 	bl	800ab70 <spiStart.constprop.53>
	spiSelect(&SPID2);
 800888a:	f002 f9f9 	bl	800ac80 <spiSelect.constprop.51>
	spiExchange(&SPID2, txlen, txData, null_spi);
 800888e:	4621      	mov	r1, r4
 8008890:	687a      	ldr	r2, [r7, #4]
 8008892:	2002      	movs	r0, #2
 8008894:	f002 f904 	bl	800aaa0 <spiExchange.constprop.47>
	spiUnselect(&SPID2);
 8008898:	f002 fa22 	bl	800ace0 <spiUnselect.constprop.49>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800889c:	4833      	ldr	r0, [pc, #204]	; (800896c <Si4464_Init+0x33c>)
 800889e:	f000 fe6f 	bl	8009580 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
 80088a2:	2300      	movs	r3, #0
 80088a4:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
}

/**
 * Read register from Si4464. First Register CTS is included.
 */
void Si4464_read(uint8_t* txData, uint32_t txlen, uint8_t* rxData, uint32_t rxlen) {
 80088a8:	46e9      	mov	r9, sp
	spiUnselect(&SPID2);
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
 80088aa:	f240 74cf 	movw	r4, #1999	; 0x7cf
	while(rxData[1] != 0xFF && ++counter < 2000) {

		// Request ACK by Si4464
		uint16_t rx_ready[rxlen];
		rx_ready[0] = 0x44;
 80088ae:	f04f 0844 	mov.w	r8, #68	; 0x44
 80088b2:	e001      	b.n	80088b8 <Si4464_Init+0x288>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 80088b4:	3c01      	subs	r4, #1
 80088b6:	d016      	beq.n	80088e6 <Si4464_Init+0x2b6>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80088b8:	482c      	ldr	r0, [pc, #176]	; (800896c <Si4464_Init+0x33c>)

		// Request ACK by Si4464
		uint16_t rx_ready[rxlen];
		rx_ready[0] = 0x44;
 80088ba:	f8a7 8048 	strh.w	r8, [r7, #72]	; 0x48
 80088be:	f003 fc6f 	bl	800c1a0 <chMtxLock>

		// SPI transfer
		spiAcquireBus(&SPID2);
		spiStart(&SPID2, getSPIDriver());
 80088c2:	f002 f955 	bl	800ab70 <spiStart.constprop.53>
		spiSelect(&SPID2);
 80088c6:	f002 f9db 	bl	800ac80 <spiSelect.constprop.51>
		spiExchange(&SPID2, rxlen, rx_ready, rxData);
 80088ca:	4632      	mov	r2, r6
 80088cc:	4629      	mov	r1, r5
 80088ce:	2008      	movs	r0, #8
 80088d0:	f002 f8e6 	bl	800aaa0 <spiExchange.constprop.47>
		spiUnselect(&SPID2);
 80088d4:	f002 fa04 	bl	800ace0 <spiUnselect.constprop.49>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80088d8:	4824      	ldr	r0, [pc, #144]	; (800896c <Si4464_Init+0x33c>)
 80088da:	f000 fe51 	bl	8009580 <chMtxUnlock>
	spiReleaseBus(&SPID2);

	// Reqest ACK by Si4464
	uint32_t counter = 0; // FIXME: Sometimes CTS is not returned by Si4464 correctly
	rxData[1] = 0x00;
	while(rxData[1] != 0xFF && ++counter < 2000) {
 80088de:	f897 3041 	ldrb.w	r3, [r7, #65]	; 0x41
 80088e2:	2bff      	cmp	r3, #255	; 0xff
 80088e4:	d1e6      	bne.n	80088b4 <Si4464_Init+0x284>

int8_t Si4464_getTemperature(void) {
	uint8_t txData[2] = {0x14, 0x10};
	uint8_t rxData[8];
	Si4464_read(txData, 2, rxData, 8);
	uint16_t adc = rxData[7] | ((rxData[6] & 0x7) << 8);
 80088e6:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 80088ea:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
		case MOD_DOMINOEX16:
			TRACE_WARN("SI   > Unimplemented modulation %s", VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI   > Transmitter temperature %d degC", Si4464_getTemperature());
 80088ee:	4920      	ldr	r1, [pc, #128]	; (8008970 <Si4464_Init+0x340>)
 80088f0:	4817      	ldr	r0, [pc, #92]	; (8008950 <Si4464_Init+0x320>)

int8_t Si4464_getTemperature(void) {
	uint8_t txData[2] = {0x14, 0x10};
	uint8_t rxData[8];
	Si4464_read(txData, 2, rxData, 8);
	uint16_t adc = rxData[7] | ((rxData[6] & 0x7) << 8);
 80088f2:	021b      	lsls	r3, r3, #8
 80088f4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80088f8:	4313      	orrs	r3, r2
		case MOD_DOMINOEX16:
			TRACE_WARN("SI   > Unimplemented modulation %s", VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI   > Transmitter temperature %d degC", Si4464_getTemperature());
 80088fa:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 80088fe:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8008902:	ebc3 1343 	rsb	r3, r3, r3, lsl #5
 8008906:	131a      	asrs	r2, r3, #12
 8008908:	3a25      	subs	r2, #37	; 0x25
 800890a:	46cd      	mov	sp, r9
 800890c:	b252      	sxtb	r2, r2
 800890e:	f001 febf 	bl	800a690 <chprintf.constprop.26>
 8008912:	4918      	ldr	r1, [pc, #96]	; (8008974 <Si4464_Init+0x344>)
 8008914:	480e      	ldr	r0, [pc, #56]	; (8008950 <Si4464_Init+0x320>)
 8008916:	f001 febb 	bl	800a690 <chprintf.constprop.26>
 800891a:	480a      	ldr	r0, [pc, #40]	; (8008944 <Si4464_Init+0x314>)
 800891c:	f000 fe30 	bl	8009580 <chMtxUnlock>
	initialized = true;
 8008920:	4b15      	ldr	r3, [pc, #84]	; (8008978 <Si4464_Init+0x348>)
 8008922:	2201      	movs	r2, #1
}
 8008924:	375c      	adds	r7, #92	; 0x5c
			TRACE_WARN("SI   > Unimplemented modulation %s", VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
	}

	// Temperature readout
	TRACE_INFO("SI   > Transmitter temperature %d degC", Si4464_getTemperature());
	initialized = true;
 8008926:	701a      	strb	r2, [r3, #0]
}
 8008928:	46bd      	mov	sp, r7
 800892a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800892e:	bf00      	nop
 8008930:	40020400 	.word	0x40020400
 8008934:	40020c00 	.word	0x40020c00
 8008938:	0800e7dc 	.word	0x0800e7dc
 800893c:	0800e7e4 	.word	0x0800e7e4
 8008940:	0800e810 	.word	0x0800e810
 8008944:	2001b720 	.word	0x2001b720
 8008948:	10624dd3 	.word	0x10624dd3
 800894c:	0800ea50 	.word	0x0800ea50
 8008950:	2001ac28 	.word	0x2001ac28
 8008954:	0800f1dc 	.word	0x0800f1dc
 8008958:	0800ea64 	.word	0x0800ea64
 800895c:	0800fe2c 	.word	0x0800fe2c
 8008960:	0800ea7c 	.word	0x0800ea7c
 8008964:	0800f1e0 	.word	0x0800f1e0
 8008968:	0800e828 	.word	0x0800e828
 800896c:	2001b59c 	.word	0x2001b59c
 8008970:	0800fe68 	.word	0x0800fe68
 8008974:	0800eaa8 	.word	0x0800eaa8
 8008978:	2001b754 	.word	0x2001b754
 800897c:	d1b71759 	.word	0xd1b71759
	Si4464_write(use_2fsk, 5);
}

void setModem2GFSK(void) {
	// Disable preamble
	uint8_t disable_preamble[] = {0x11, 0x10, 0x01, 0x00, 0x00};
 8008980:	4b49      	ldr	r3, [pc, #292]	; (8008aa8 <Si4464_Init+0x478>)
 8008982:	6818      	ldr	r0, [r3, #0]
 8008984:	61b8      	str	r0, [r7, #24]
 8008986:	791b      	ldrb	r3, [r3, #4]
 8008988:	773b      	strb	r3, [r7, #28]
	Si4464_write(disable_preamble, 5);
 800898a:	f107 0018 	add.w	r0, r7, #24
 800898e:	2105      	movs	r1, #5
 8008990:	f7ff fe0e 	bl	80085b0 <Si4464_write>

	// Do not transmit sync word
	uint8_t no_sync_word[] = {0x11, 0x11, 0x01, 0x00, (0x01 << 7)};
 8008994:	4b44      	ldr	r3, [pc, #272]	; (8008aa8 <Si4464_Init+0x478>)
 8008996:	f853 0f08 	ldr.w	r0, [r3, #8]!
 800899a:	6238      	str	r0, [r7, #32]
 800899c:	f107 0420 	add.w	r4, r7, #32
 80089a0:	791b      	ldrb	r3, [r3, #4]
 80089a2:	7123      	strb	r3, [r4, #4]
	Si4464_write(no_sync_word, 5);
 80089a4:	4620      	mov	r0, r4
 80089a6:	2105      	movs	r1, #5
 80089a8:	f7ff fe02 	bl	80085b0 <Si4464_write>
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 80089ac:	2111      	movs	r1, #17
 80089ae:	f887 1048 	strb.w	r1, [r7, #72]	; 0x48
	Si4464_write(setup_oversampling, 8);
 80089b2:	f107 0548 	add.w	r5, r7, #72	; 0x48
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 80089b6:	2620      	movs	r6, #32
 80089b8:	2204      	movs	r2, #4
 80089ba:	2306      	movs	r3, #6
 80089bc:	2100      	movs	r1, #0
	Si4464_write(setup_oversampling, 8);
 80089be:	4628      	mov	r0, r5
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 80089c0:	f887 6049 	strb.w	r6, [r7, #73]	; 0x49
 80089c4:	f887 204a 	strb.w	r2, [r7, #74]	; 0x4a
 80089c8:	2627      	movs	r6, #39	; 0x27
 80089ca:	22ac      	movs	r2, #172	; 0xac
 80089cc:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
 80089d0:	f887 104c 	strb.w	r1, [r7, #76]	; 0x4c
 80089d4:	2372      	movs	r3, #114	; 0x72
	Si4464_write(setup_oversampling, 8);
 80089d6:	2108      	movs	r1, #8
	uint32_t s = OSC_FREQ / 10;
	uint8_t f3 = (s >> 24) & 0xFF;
	uint8_t f2 = (s >> 16) & 0xFF;
	uint8_t f1 = (s >>  8) & 0xFF;
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
 80089d8:	f887 604d 	strb.w	r6, [r7, #77]	; 0x4d
 80089dc:	f887 204e 	strb.w	r2, [r7, #78]	; 0x4e
 80089e0:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
	Si4464_write(setup_oversampling, 8);
 80089e4:	f7ff fde4 	bl	80085b0 <Si4464_write>

	// Setup the NCO data rate for 2GFSK
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x25, 0x80};
 80089e8:	4b2f      	ldr	r3, [pc, #188]	; (8008aa8 <Si4464_Init+0x478>)
 80089ea:	f853 0f3c 	ldr.w	r0, [r3, #60]!
 80089ee:	6438      	str	r0, [r7, #64]	; 0x40
 80089f0:	f107 0640 	add.w	r6, r7, #64	; 0x40
 80089f4:	889a      	ldrh	r2, [r3, #4]
 80089f6:	799b      	ldrb	r3, [r3, #6]
 80089f8:	80b2      	strh	r2, [r6, #4]
	Si4464_write(setup_data_rate, 7);
 80089fa:	4630      	mov	r0, r6
 80089fc:	2107      	movs	r1, #7
	uint8_t f0 = (s >>  0) & 0xFF;
	uint8_t setup_oversampling[] = {0x11, 0x20, 0x04, 0x06, f3, f2, f1, f0};
	Si4464_write(setup_oversampling, 8);

	// Setup the NCO data rate for 2GFSK
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x25, 0x80};
 80089fe:	71b3      	strb	r3, [r6, #6]
	Si4464_write(setup_data_rate, 7);
 8008a00:	f7ff fdd6 	bl	80085b0 <Si4464_write>

	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
 8008a04:	4b28      	ldr	r3, [pc, #160]	; (8008aa8 <Si4464_Init+0x478>)
 8008a06:	f853 0f18 	ldr.w	r0, [r3, #24]!
 8008a0a:	6338      	str	r0, [r7, #48]	; 0x30
 8008a0c:	f107 0230 	add.w	r2, r7, #48	; 0x30
 8008a10:	791b      	ldrb	r3, [r3, #4]
 8008a12:	607a      	str	r2, [r7, #4]
	Si4464_write(use_2gfsk, 5);
 8008a14:	4610      	mov	r0, r2
 8008a16:	2105      	movs	r1, #5
	// Setup the NCO data rate for 2GFSK
	uint8_t setup_data_rate[] = {0x11, 0x20, 0x03, 0x03, 0x00, 0x25, 0x80};
	Si4464_write(setup_data_rate, 7);

	// Use 2GFSK from async GPIO0
	uint8_t use_2gfsk[] = {0x11, 0x20, 0x01, 0x00, 0x0B};
 8008a18:	7113      	strb	r3, [r2, #4]
	Si4464_write(use_2gfsk, 5);
 8008a1a:	f7ff fdc9 	bl	80085b0 <Si4464_write>
 8008a1e:	e700      	b.n	8008822 <Si4464_Init+0x1f2>
	Si4464_write(use_ook, 5);
}

void setModem2FSK(void) {
	// use 2FSK from async GPIO0
	uint8_t use_2fsk[] = {0x11, 0x20, 0x01, 0x00, 0x8A};
 8008a20:	4b22      	ldr	r3, [pc, #136]	; (8008aac <Si4464_Init+0x47c>)
 8008a22:	e6ed      	b.n	8008800 <Si4464_Init+0x1d0>
			break;
		case MOD_2GFSK:
			setModem2GFSK();
			break;
		case MOD_DOMINOEX16:
			TRACE_WARN("SI   > Unimplemented modulation %s", VAL2MOULATION(modulation)); // TODO: Implement DominoEX16
 8008a24:	4822      	ldr	r0, [pc, #136]	; (8008ab0 <Si4464_Init+0x480>)
 8008a26:	4e23      	ldr	r6, [pc, #140]	; (8008ab4 <Si4464_Init+0x484>)
 8008a28:	f003 fbba 	bl	800c1a0 <chMtxLock>
 8008a2c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008a30:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 8008a34:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008a36:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8008a38:	4b1f      	ldr	r3, [pc, #124]	; (8008ab8 <Si4464_Init+0x488>)
 8008a3a:	4920      	ldr	r1, [pc, #128]	; (8008abc <Si4464_Init+0x48c>)
 8008a3c:	4820      	ldr	r0, [pc, #128]	; (8008ac0 <Si4464_Init+0x490>)
 8008a3e:	fb05 f404 	mul.w	r4, r5, r4
 8008a42:	fba6 e404 	umull	lr, r4, r6, r4
 8008a46:	0b64      	lsrs	r4, r4, #13
 8008a48:	fba3 e304 	umull	lr, r3, r3, r4
 8008a4c:	fba6 6202 	umull	r6, r2, r6, r2
 8008a50:	099b      	lsrs	r3, r3, #6
 8008a52:	fb05 4313 	mls	r3, r5, r3, r4
 8008a56:	0b52      	lsrs	r2, r2, #13
 8008a58:	f001 fe1a 	bl	800a690 <chprintf.constprop.26>
 8008a5c:	4a19      	ldr	r2, [pc, #100]	; (8008ac4 <Si4464_Init+0x494>)
 8008a5e:	491a      	ldr	r1, [pc, #104]	; (8008ac8 <Si4464_Init+0x498>)
 8008a60:	4817      	ldr	r0, [pc, #92]	; (8008ac0 <Si4464_Init+0x490>)
 8008a62:	f001 fe15 	bl	800a690 <chprintf.constprop.26>
 8008a66:	2354      	movs	r3, #84	; 0x54
 8008a68:	4a18      	ldr	r2, [pc, #96]	; (8008acc <Si4464_Init+0x49c>)
 8008a6a:	4919      	ldr	r1, [pc, #100]	; (8008ad0 <Si4464_Init+0x4a0>)
 8008a6c:	4814      	ldr	r0, [pc, #80]	; (8008ac0 <Si4464_Init+0x490>)
 8008a6e:	f001 fe0f 	bl	800a690 <chprintf.constprop.26>
 8008a72:	4918      	ldr	r1, [pc, #96]	; (8008ad4 <Si4464_Init+0x4a4>)
 8008a74:	4812      	ldr	r0, [pc, #72]	; (8008ac0 <Si4464_Init+0x490>)
 8008a76:	f001 fe0b 	bl	800a690 <chprintf.constprop.26>
 8008a7a:	4a17      	ldr	r2, [pc, #92]	; (8008ad8 <Si4464_Init+0x4a8>)
 8008a7c:	4917      	ldr	r1, [pc, #92]	; (8008adc <Si4464_Init+0x4ac>)
 8008a7e:	4810      	ldr	r0, [pc, #64]	; (8008ac0 <Si4464_Init+0x490>)
 8008a80:	f001 fe06 	bl	800a690 <chprintf.constprop.26>
 8008a84:	4916      	ldr	r1, [pc, #88]	; (8008ae0 <Si4464_Init+0x4b0>)
 8008a86:	480e      	ldr	r0, [pc, #56]	; (8008ac0 <Si4464_Init+0x490>)
 8008a88:	f001 fe02 	bl	800a690 <chprintf.constprop.26>
 8008a8c:	4808      	ldr	r0, [pc, #32]	; (8008ab0 <Si4464_Init+0x480>)
 8008a8e:	f000 fd77 	bl	8009580 <chMtxUnlock>
 8008a92:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008a96:	f107 0640 	add.w	r6, r7, #64	; 0x40
 8008a9a:	607b      	str	r3, [r7, #4]
 8008a9c:	f107 0548 	add.w	r5, r7, #72	; 0x48
 8008aa0:	f107 0420 	add.w	r4, r7, #32
 8008aa4:	e6bd      	b.n	8008822 <Si4464_Init+0x1f2>
 8008aa6:	bf00      	nop
 8008aa8:	0800e7e4 	.word	0x0800e7e4
 8008aac:	0800e818 	.word	0x0800e818
 8008ab0:	2001b720 	.word	0x2001b720
 8008ab4:	d1b71759 	.word	0xd1b71759
 8008ab8:	10624dd3 	.word	0x10624dd3
 8008abc:	0800ea50 	.word	0x0800ea50
 8008ac0:	2001ac28 	.word	0x2001ac28
 8008ac4:	0800f190 	.word	0x0800f190
 8008ac8:	0800ea64 	.word	0x0800ea64
 8008acc:	0800fe2c 	.word	0x0800fe2c
 8008ad0:	0800ea7c 	.word	0x0800ea7c
 8008ad4:	0800f1e0 	.word	0x0800f1e0
 8008ad8:	0800fe38 	.word	0x0800fe38
 8008adc:	0800fe44 	.word	0x0800fe44
 8008ae0:	0800eaa8 	.word	0x0800eaa8
	...

08008af0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8008af0:	f3ef 8309 	mrs	r3, PSP
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8008af4:	3320      	adds	r3, #32
 8008af6:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8008afa:	2300      	movs	r3, #0
 8008afc:	f383 8811 	msr	BASEPRI, r3
 8008b00:	4770      	bx	lr
 8008b02:	bf00      	nop
	...

08008b10 <_usb_ep0setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8008b10:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8008b14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008b16:	68cb      	ldr	r3, [r1, #12]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8008b18:	2200      	movs	r2, #0
 8008b1a:	6a1b      	ldr	r3, [r3, #32]
 8008b1c:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
 8008b20:	6819      	ldr	r1, [r3, #0]
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8008b22:	6842      	ldr	r2, [r0, #4]
 8008b24:	685b      	ldr	r3, [r3, #4]
 8008b26:	6483      	str	r3, [r0, #72]	; 0x48
 8008b28:	6441      	str	r1, [r0, #68]	; 0x44
 8008b2a:	6893      	ldr	r3, [r2, #8]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8008b2c:	4604      	mov	r4, r0
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8008b2e:	b333      	cbz	r3, 8008b7e <_usb_ep0setup+0x6e>
      !(usbp->config->requests_hook_cb(usbp))) {
 8008b30:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8008b32:	b320      	cbz	r0, 8008b7e <_usb_ep0setup+0x6e>
 8008b34:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8008b36:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8008b3a:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 8008b3e:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
 8008b42:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8008b46:	429a      	cmp	r2, r3
    usbp->ep0n = max;
 8008b48:	bf3c      	itt	cc
 8008b4a:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 8008b4c:	4613      	movcc	r3, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8008b4e:	0602      	lsls	r2, r0, #24
 8008b50:	f100 808d 	bmi.w	8008c6e <_usb_ep0setup+0x15e>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8008b54:	2b00      	cmp	r3, #0
 8008b56:	d152      	bne.n	8008bfe <_usb_ep0setup+0xee>
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8008b58:	2305      	movs	r3, #5
 8008b5a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008b5e:	2320      	movs	r3, #32
 8008b60:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8008b64:	f003 faac 	bl	800c0c0 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 8008b68:	2200      	movs	r2, #0
 8008b6a:	4620      	mov	r0, r4
 8008b6c:	4611      	mov	r1, r2
 8008b6e:	f001 fca7 	bl	800a4c0 <usbStartTransmitI.constprop.43>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8008b72:	f003 fa8d 	bl	800c090 <_dbg_check_unlock_from_isr>
 8008b76:	2300      	movs	r3, #0
 8008b78:	f383 8811 	msr	BASEPRI, r3
 8008b7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8008b7e:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 8008b82:	f010 0560 	ands.w	r5, r0, #96	; 0x60
 8008b86:	4602      	mov	r2, r0
 8008b88:	d016      	beq.n	8008bb8 <_usb_ep0setup+0xa8>
 8008b8a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8008b8c:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8008b90:	6861      	ldr	r1, [r4, #4]
 8008b92:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8008b96:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8008b9a:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8008b9e:	680d      	ldr	r5, [r1, #0]
 8008ba0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8008ba4:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8008ba8:	b115      	cbz	r5, 8008bb0 <_usb_ep0setup+0xa0>
 8008baa:	2106      	movs	r1, #6
 8008bac:	4620      	mov	r0, r4
 8008bae:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 8008bb0:	2306      	movs	r3, #6
 8008bb2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008bb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 8008bb8:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8008bbc:	f000 037f 	and.w	r3, r0, #127	; 0x7f
 8008bc0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8008bc4:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8008bc8:	f000 811c 	beq.w	8008e04 <_usb_ep0setup+0x2f4>
 8008bcc:	d92a      	bls.n	8008c24 <_usb_ep0setup+0x114>
 8008bce:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 8008bd2:	f000 80fe 	beq.w	8008dd2 <_usb_ep0setup+0x2c2>
 8008bd6:	d95e      	bls.n	8008c96 <_usb_ep0setup+0x186>
 8008bd8:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 8008bdc:	f000 8083 	beq.w	8008ce6 <_usb_ep0setup+0x1d6>
 8008be0:	f640 4202 	movw	r2, #3074	; 0xc02
 8008be4:	4293      	cmp	r3, r2
 8008be6:	f000 80d6 	beq.w	8008d96 <_usb_ep0setup+0x286>
 8008bea:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8008bee:	d1cc      	bne.n	8008b8a <_usb_ep0setup+0x7a>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8008bf0:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 8008bf4:	2301      	movs	r3, #1
 8008bf6:	6425      	str	r5, [r4, #64]	; 0x40
 8008bf8:	63a2      	str	r2, [r4, #56]	; 0x38
 8008bfa:	63e3      	str	r3, [r4, #60]	; 0x3c
 8008bfc:	e79d      	b.n	8008b3a <_usb_ep0setup+0x2a>
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8008bfe:	2304      	movs	r3, #4
 8008c00:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008c04:	2320      	movs	r3, #32
 8008c06:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8008c0a:	f003 fa59 	bl	800c0c0 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8008c0e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8008c10:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8008c12:	4620      	mov	r0, r4
 8008c14:	f001 fc34 	bl	800a480 <usbStartReceiveI.constprop.44>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8008c18:	f003 fa3a 	bl	800c090 <_dbg_check_unlock_from_isr>
 8008c1c:	2300      	movs	r3, #0
 8008c1e:	f383 8811 	msr	BASEPRI, r3
 8008c22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8008c24:	2b02      	cmp	r3, #2
 8008c26:	f000 80bd 	beq.w	8008da4 <_usb_ep0setup+0x294>
 8008c2a:	f240 80a8 	bls.w	8008d7e <_usb_ep0setup+0x26e>
 8008c2e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008c32:	f000 8087 	beq.w	8008d44 <_usb_ep0setup+0x234>
 8008c36:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8008c3a:	d1a6      	bne.n	8008b8a <_usb_ep0setup+0x7a>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8008c3c:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008c40:	2b00      	cmp	r3, #0
 8008c42:	d1a2      	bne.n	8008b8a <_usb_ep0setup+0x7a>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8008c44:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 8008c48:	f013 010f 	ands.w	r1, r3, #15
 8008c4c:	d031      	beq.n	8008cb2 <_usb_ep0setup+0x1a2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8008c4e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008c52:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8008c54:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 8008c58:	f040 80fd 	bne.w	8008e56 <_usb_ep0setup+0x346>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8008c5c:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8008c60:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8008c64:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8008c68:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8008c6c:	e021      	b.n	8008cb2 <_usb_ep0setup+0x1a2>
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8008c6e:	b33b      	cbz	r3, 8008cc0 <_usb_ep0setup+0x1b0>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8008c70:	2301      	movs	r3, #1
 8008c72:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008c76:	2320      	movs	r3, #32
 8008c78:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8008c7c:	f003 fa20 	bl	800c0c0 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 8008c80:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8008c82:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8008c84:	4620      	mov	r0, r4
 8008c86:	f001 fc1b 	bl	800a4c0 <usbStartTransmitI.constprop.43>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8008c8a:	f003 fa01 	bl	800c090 <_dbg_check_unlock_from_isr>
 8008c8e:	2300      	movs	r3, #0
 8008c90:	f383 8811 	msr	BASEPRI, r3
 8008c94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8008c96:	f240 3102 	movw	r1, #770	; 0x302
 8008c9a:	428b      	cmp	r3, r1
 8008c9c:	d038      	beq.n	8008d10 <_usb_ep0setup+0x200>
 8008c9e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8008ca2:	f47f af72 	bne.w	8008b8a <_usb_ep0setup+0x7a>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8008ca6:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
 8008caa:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8008cae:	f000 80ba 	beq.w	8008e26 <_usb_ep0setup+0x316>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8008cb2:	2300      	movs	r3, #0
 8008cb4:	63a3      	str	r3, [r4, #56]	; 0x38
 8008cb6:	63e3      	str	r3, [r4, #60]	; 0x3c
 8008cb8:	6423      	str	r3, [r4, #64]	; 0x40
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8008cba:	0613      	lsls	r3, r2, #24
 8008cbc:	f57f af4c 	bpl.w	8008b58 <_usb_ep0setup+0x48>
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8008cc0:	2303      	movs	r3, #3
 8008cc2:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8008cc6:	2320      	movs	r3, #32
 8008cc8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8008ccc:	f003 f9f8 	bl	800c0c0 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
 8008cd0:	2200      	movs	r2, #0
 8008cd2:	4620      	mov	r0, r4
 8008cd4:	4611      	mov	r1, r2
 8008cd6:	f001 fbd3 	bl	800a480 <usbStartReceiveI.constprop.44>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8008cda:	f003 f9d9 	bl	800c090 <_dbg_check_unlock_from_isr>
 8008cde:	2300      	movs	r3, #0
 8008ce0:	f383 8811 	msr	BASEPRI, r3
 8008ce4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 8008ce6:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008cea:	f894 104f 	ldrb.w	r1, [r4, #79]	; 0x4f
 8008cee:	4299      	cmp	r1, r3
 8008cf0:	d0df      	beq.n	8008cb2 <_usb_ep0setup+0x1a2>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8008cf2:	7822      	ldrb	r2, [r4, #0]
 8008cf4:	2a04      	cmp	r2, #4
 8008cf6:	d034      	beq.n	8008d62 <_usb_ep0setup+0x252>
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
 8008cf8:	b30b      	cbz	r3, 8008d3e <_usb_ep0setup+0x22e>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8008cfa:	6862      	ldr	r2, [r4, #4]
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8008cfc:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8008d00:	6813      	ldr	r3, [r2, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
 8008d02:	2204      	movs	r2, #4
 8008d04:	7022      	strb	r2, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8008d06:	b1d3      	cbz	r3, 8008d3e <_usb_ep0setup+0x22e>
 8008d08:	2102      	movs	r1, #2
 8008d0a:	4620      	mov	r0, r4
 8008d0c:	4798      	blx	r3
 8008d0e:	e016      	b.n	8008d3e <_usb_ep0setup+0x22e>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8008d10:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008d14:	2b00      	cmp	r3, #0
 8008d16:	f47f af38 	bne.w	8008b8a <_usb_ep0setup+0x7a>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8008d1a:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 8008d1e:	f013 010f 	ands.w	r1, r3, #15
 8008d22:	d0c6      	beq.n	8008cb2 <_usb_ep0setup+0x1a2>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8008d24:	f013 0f80 	tst.w	r3, #128	; 0x80
 8008d28:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8008d2a:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 8008d2e:	f040 809b 	bne.w	8008e68 <_usb_ep0setup+0x358>
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8008d32:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8008d36:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008d3a:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8008d3e:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8008d42:	e7b6      	b.n	8008cb2 <_usb_ep0setup+0x1a2>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8008d44:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008d48:	2b01      	cmp	r3, #1
 8008d4a:	f47f af1e 	bne.w	8008b8a <_usb_ep0setup+0x7a>
      usbp->status &= ~2U;
 8008d4e:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8008d52:	63a5      	str	r5, [r4, #56]	; 0x38
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8008d54:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8008d58:	63e5      	str	r5, [r4, #60]	; 0x3c
 8008d5a:	6425      	str	r5, [r4, #64]	; 0x40
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8008d5c:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 8008d60:	e7ab      	b.n	8008cba <_usb_ep0setup+0x1aa>
 8008d62:	2320      	movs	r3, #32
 8008d64:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8008d68:	f003 f9aa 	bl	800c0c0 <_dbg_check_lock_from_isr>
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
  unsigned i;

  osalDbgCheckClassI();
 8008d6c:	f002 ff60 	bl	800bc30 <chDbgCheckClassI>
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 8008d70:	7823      	ldrb	r3, [r4, #0]
 8008d72:	2b04      	cmp	r3, #4
 8008d74:	f000 8081 	beq.w	8008e7a <_usb_ep0setup+0x36a>
 8008d78:	485d      	ldr	r0, [pc, #372]	; (8008ef0 <_usb_ep0setup+0x3e0>)
 8008d7a:	f002 fef9 	bl	800bb70 <chSysHalt>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8008d7e:	b93b      	cbnz	r3, 8008d90 <_usb_ep0setup+0x280>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8008d80:	2202      	movs	r2, #2
 8008d82:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 8008d86:	6423      	str	r3, [r4, #64]	; 0x40
 8008d88:	63a1      	str	r1, [r4, #56]	; 0x38
 8008d8a:	63e2      	str	r2, [r4, #60]	; 0x3c
 8008d8c:	4613      	mov	r3, r2
 8008d8e:	e6d4      	b.n	8008b3a <_usb_ep0setup+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8008d90:	2b01      	cmp	r3, #1
 8008d92:	f47f aefa 	bne.w	8008b8a <_usb_ep0setup+0x7a>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8008d96:	4b57      	ldr	r3, [pc, #348]	; (8008ef4 <_usb_ep0setup+0x3e4>)
 8008d98:	63a3      	str	r3, [r4, #56]	; 0x38
 8008d9a:	2200      	movs	r2, #0
 8008d9c:	2302      	movs	r3, #2
 8008d9e:	63e3      	str	r3, [r4, #60]	; 0x3c
 8008da0:	6422      	str	r2, [r4, #64]	; 0x40
 8008da2:	e6ca      	b.n	8008b3a <_usb_ep0setup+0x2a>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8008da4:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8008da8:	f002 010f 	and.w	r1, r2, #15
 8008dac:	0616      	lsls	r6, r2, #24
 8008dae:	bf4c      	ite	mi
 8008db0:	3148      	addmi	r1, #72	; 0x48
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8008db2:	3158      	addpl	r1, #88	; 0x58
 8008db4:	0149      	lsls	r1, r1, #5
 8008db6:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8008db8:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8008dba:	040d      	lsls	r5, r1, #16
 8008dbc:	f57f aee6 	bpl.w	8008b8c <_usb_ep0setup+0x7c>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 8008dc0:	0289      	lsls	r1, r1, #10
 8008dc2:	d42e      	bmi.n	8008e22 <_usb_ep0setup+0x312>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8008dc4:	4a4c      	ldr	r2, [pc, #304]	; (8008ef8 <_usb_ep0setup+0x3e8>)
 8008dc6:	63a2      	str	r2, [r4, #56]	; 0x38
 8008dc8:	2102      	movs	r1, #2
 8008dca:	2200      	movs	r2, #0
 8008dcc:	63e1      	str	r1, [r4, #60]	; 0x3c
 8008dce:	6422      	str	r2, [r4, #64]	; 0x40
 8008dd0:	e6b3      	b.n	8008b3a <_usb_ep0setup+0x2a>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8008dd2:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 8008dd6:	6861      	ldr	r1, [r4, #4]
 8008dd8:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 8008ddc:	684e      	ldr	r6, [r1, #4]
 8008dde:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8008de2:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 8008de6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8008dea:	4620      	mov	r0, r4
 8008dec:	47b0      	blx	r6
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8008dee:	2800      	cmp	r0, #0
 8008df0:	f43f aecb 	beq.w	8008b8a <_usb_ep0setup+0x7a>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8008df4:	6842      	ldr	r2, [r0, #4]
 8008df6:	6803      	ldr	r3, [r0, #0]
 8008df8:	63e3      	str	r3, [r4, #60]	; 0x3c
 8008dfa:	63a2      	str	r2, [r4, #56]	; 0x38
 8008dfc:	6425      	str	r5, [r4, #64]	; 0x40
 8008dfe:	f894 0044 	ldrb.w	r0, [r4, #68]	; 0x44
 8008e02:	e69a      	b.n	8008b3a <_usb_ep0setup+0x2a>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8008e04:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008e08:	2b01      	cmp	r3, #1
 8008e0a:	f47f aebe 	bne.w	8008b8a <_usb_ep0setup+0x7a>
      usbp->status |= 2U;
 8008e0e:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8008e12:	63a5      	str	r5, [r4, #56]	; 0x38
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8008e14:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8008e18:	63e5      	str	r5, [r4, #60]	; 0x3c
 8008e1a:	6425      	str	r5, [r4, #64]	; 0x40
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8008e1c:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 8008e20:	e74b      	b.n	8008cba <_usb_ep0setup+0x1aa>
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8008e22:	4a36      	ldr	r2, [pc, #216]	; (8008efc <_usb_ep0setup+0x3ec>)
 8008e24:	e7cf      	b.n	8008dc6 <_usb_ep0setup+0x2b6>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 8008e26:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8008e2a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8008e2c:	f884 104e 	strb.w	r1, [r4, #78]	; 0x4e

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8008e30:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8008e34:	6860      	ldr	r0, [r4, #4]
 8008e36:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8008e3a:	6805      	ldr	r5, [r0, #0]
 8008e3c:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 8008e40:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 8008e44:	b115      	cbz	r5, 8008e4c <_usb_ep0setup+0x33c>
 8008e46:	2101      	movs	r1, #1
 8008e48:	4620      	mov	r0, r4
 8008e4a:	47a8      	blx	r5
  usbp->state = USB_SELECTED;
 8008e4c:	2303      	movs	r3, #3
 8008e4e:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8008e52:	7023      	strb	r3, [r4, #0]
 8008e54:	e72d      	b.n	8008cb2 <_usb_ep0setup+0x1a2>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8008e56:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8008e5a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8008e5e:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8008e62:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8008e66:	e724      	b.n	8008cb2 <_usb_ep0setup+0x1a2>
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8008e68:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8008e6c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8008e70:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8008e74:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8008e78:	e71b      	b.n	8008cb2 <_usb_ep0setup+0x1a2>
 8008e7a:	6da0      	ldr	r0, [r4, #88]	; 0x58

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8008e7c:	8921      	ldrh	r1, [r4, #8]
  usbp->receiving    &= 1U;
 8008e7e:	8963      	ldrh	r3, [r4, #10]
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8008e80:	6802      	ldr	r2, [r0, #0]
 8008e82:	65e2      	str	r2, [r4, #92]	; 0x5c

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8008e84:	f001 0101 	and.w	r1, r1, #1
  usbp->receiving    &= 1U;
 8008e88:	f003 0301 	and.w	r3, r3, #1
 8008e8c:	6d66      	ldr	r6, [r4, #84]	; 0x54

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008e8e:	6887      	ldr	r7, [r0, #8]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8008e90:	8121      	strh	r1, [r4, #8]
 8008e92:	462a      	mov	r2, r5
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8008e94:	6125      	str	r5, [r4, #16]
 8008e96:	6165      	str	r5, [r4, #20]
 8008e98:	61a5      	str	r5, [r4, #24]
  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;
 8008e9a:	8163      	strh	r3, [r4, #10]
    otgp->ie[i].DIEPCTL = 0;
 8008e9c:	4629      	mov	r1, r5
    otgp->ie[i].DIEPTSIZ = 0;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8008e9e:	f04f 30ff 	mov.w	r0, #4294967295
 8008ea2:	eb06 1342 	add.w	r3, r6, r2, lsl #5

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008ea6:	3201      	adds	r2, #1
 8008ea8:	42ba      	cmp	r2, r7
    otgp->ie[i].DIEPCTL = 0;
 8008eaa:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 8008eae:	f04f 0500 	mov.w	r5, #0
    otgp->ie[i].DIEPTSIZ = 0;
 8008eb2:	f8c3 1910 	str.w	r1, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8008eb6:	f8c3 0908 	str.w	r0, [r3, #2312]	; 0x908

    otgp->oe[i].DOEPCTL = 0;
 8008eba:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 8008ebe:	f8c3 1b10 	str.w	r1, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8008ec2:	f8c3 0b08 	str.w	r0, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008ec6:	d9ec      	bls.n	8008ea2 <_usb_ep0setup+0x392>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8008ec8:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8008ecc:	f8c6 381c 	str.w	r3, [r6, #2076]	; 0x81c
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8008ed0:	f003 f8de 	bl	800c090 <_dbg_check_unlock_from_isr>
 8008ed4:	f385 8811 	msr	BASEPRI, r5
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8008ed8:	6863      	ldr	r3, [r4, #4]
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
 8008eda:	f884 504f 	strb.w	r5, [r4, #79]	; 0x4f
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8008ede:	681b      	ldr	r3, [r3, #0]
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
 8008ee0:	2103      	movs	r1, #3
 8008ee2:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8008ee4:	b10b      	cbz	r3, 8008eea <_usb_ep0setup+0x3da>
 8008ee6:	4620      	mov	r0, r4
 8008ee8:	4798      	blx	r3
 8008eea:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 8008eee:	e703      	b.n	8008cf8 <_usb_ep0setup+0x1e8>
 8008ef0:	0800fef0 	.word	0x0800fef0
 8008ef4:	0800ff5c 	.word	0x0800ff5c
 8008ef8:	0800ff60 	.word	0x0800ff60
 8008efc:	0800ffb4 	.word	0x0800ffb4

08008f00 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8008f00:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8008f02:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8008f06:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8008f08:	0792      	lsls	r2, r2, #30
 8008f0a:	d501      	bpl.n	8008f10 <stSetAlarm+0x10>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8008f0c:	6358      	str	r0, [r3, #52]	; 0x34
 8008f0e:	bd08      	pop	{r3, pc}
 8008f10:	4801      	ldr	r0, [pc, #4]	; (8008f18 <stSetAlarm+0x18>)
 8008f12:	f002 fe2d 	bl	800bb70 <chSysHalt>
 8008f16:	bf00      	nop
 8008f18:	0800ff50 	.word	0x0800ff50
 8008f1c:	00000000 	.word	0x00000000

08008f20 <_port_irq_epilogue>:
 8008f20:	2320      	movs	r3, #32
 8008f22:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8008f26:	4b0f      	ldr	r3, [pc, #60]	; (8008f64 <_port_irq_epilogue+0x44>)
 8008f28:	685b      	ldr	r3, [r3, #4]
 8008f2a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8008f2e:	d102      	bne.n	8008f36 <_port_irq_epilogue+0x16>
 8008f30:	f383 8811 	msr	BASEPRI, r3
 8008f34:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8008f36:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8008f3a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8008f3e:	f843 2c04 	str.w	r2, [r3, #-4]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8008f42:	f1a3 0220 	sub.w	r2, r3, #32
 8008f46:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8008f4a:	4a07      	ldr	r2, [pc, #28]	; (8008f68 <_port_irq_epilogue+0x48>)
 8008f4c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 8008f4e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8008f50:	6889      	ldr	r1, [r1, #8]
 8008f52:	6892      	ldr	r2, [r2, #8]
 8008f54:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8008f56:	bf8c      	ite	hi
 8008f58:	4a04      	ldrhi	r2, [pc, #16]	; (8008f6c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8008f5a:	4a05      	ldrls	r2, [pc, #20]	; (8008f70 <_port_irq_epilogue+0x50>)
 8008f5c:	f843 2c08 	str.w	r2, [r3, #-8]
 8008f60:	4770      	bx	lr
 8008f62:	bf00      	nop
 8008f64:	e000ed00 	.word	0xe000ed00
 8008f68:	2001acdc 	.word	0x2001acdc
 8008f6c:	080002b9 	.word	0x080002b9
 8008f70:	080002c4 	.word	0x080002c4
	...

08008f80 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8008f80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008f84:	4606      	mov	r6, r0
 8008f86:	4688      	mov	r8, r1
  event_listener_t *elp;

  chDbgCheckClassI();
 8008f88:	f002 fe52 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 8008f8c:	2e00      	cmp	r6, #0
 8008f8e:	d039      	beq.n	8009004 <chEvtBroadcastFlagsI+0x84>

  elp = esp->next;
 8008f90:	6834      	ldr	r4, [r6, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8008f92:	42a6      	cmp	r6, r4
 8008f94:	d029      	beq.n	8008fea <chEvtBroadcastFlagsI+0x6a>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8008f96:	2700      	movs	r7, #0
 8008f98:	e002      	b.n	8008fa0 <chEvtBroadcastFlagsI+0x20>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8008f9a:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8008f9c:	42a6      	cmp	r6, r4
 8008f9e:	d024      	beq.n	8008fea <chEvtBroadcastFlagsI+0x6a>
  /*lint -restore*/
    elp->flags |= flags;
 8008fa0:	68e3      	ldr	r3, [r4, #12]
 8008fa2:	ea48 0303 	orr.w	r3, r8, r3
 8008fa6:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8008fa8:	f1b8 0f00 	cmp.w	r8, #0
 8008fac:	d002      	beq.n	8008fb4 <chEvtBroadcastFlagsI+0x34>
 8008fae:	6922      	ldr	r2, [r4, #16]
 8008fb0:	4213      	tst	r3, r2
 8008fb2:	d0f2      	beq.n	8008f9a <chEvtBroadcastFlagsI+0x1a>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8008fb4:	6865      	ldr	r5, [r4, #4]
 8008fb6:	f8d4 9008 	ldr.w	r9, [r4, #8]
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 8008fba:	f002 fe39 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8008fbe:	b1f5      	cbz	r5, 8008ffe <chEvtBroadcastFlagsI+0x7e>

  tp->epending |= events;
 8008fc0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8008fc2:	f895 2020 	ldrb.w	r2, [r5, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8008fc6:	ea49 0303 	orr.w	r3, r9, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8008fca:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8008fcc:	636b      	str	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8008fce:	d00e      	beq.n	8008fee <chEvtBroadcastFlagsI+0x6e>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8008fd0:	2a0b      	cmp	r2, #11
 8008fd2:	d1e2      	bne.n	8008f9a <chEvtBroadcastFlagsI+0x1a>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8008fd4:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8008fd6:	ea32 0303 	bics.w	r3, r2, r3
 8008fda:	d1de      	bne.n	8008f9a <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8008fdc:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8008fde:	4628      	mov	r0, r5
 8008fe0:	f002 feee 	bl	800bdc0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8008fe4:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8008fe6:	42a6      	cmp	r6, r4
 8008fe8:	d1da      	bne.n	8008fa0 <chEvtBroadcastFlagsI+0x20>
 8008fea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8008fee:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8008ff0:	4213      	tst	r3, r2
 8008ff2:	d0d2      	beq.n	8008f9a <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8008ff4:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8008ff6:	4628      	mov	r0, r5
 8008ff8:	f002 fee2 	bl	800bdc0 <chSchReadyI>
 8008ffc:	e7f2      	b.n	8008fe4 <chEvtBroadcastFlagsI+0x64>
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8008ffe:	4803      	ldr	r0, [pc, #12]	; (800900c <chEvtBroadcastFlagsI+0x8c>)
 8009000:	f002 fdb6 	bl	800bb70 <chSysHalt>
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);
 8009004:	4802      	ldr	r0, [pc, #8]	; (8009010 <chEvtBroadcastFlagsI+0x90>)
 8009006:	f002 fdb3 	bl	800bb70 <chSysHalt>
 800900a:	bf00      	nop
 800900c:	0800ff98 	.word	0x0800ff98
 8009010:	0800ff64 	.word	0x0800ff64
	...

08009020 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8009020:	b570      	push	{r4, r5, r6, lr}

  osalDbgCheck(sdp != NULL);
 8009022:	b150      	cbz	r0, 800903a <sdStart+0x1a>
 8009024:	460d      	mov	r5, r1
 8009026:	4604      	mov	r4, r0
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8009028:	2320      	movs	r3, #32
 800902a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800902e:	f003 f8a7 	bl	800c180 <_dbg_check_lock>

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8009032:	7a23      	ldrb	r3, [r4, #8]
 8009034:	1e5a      	subs	r2, r3, #1
 8009036:	2a01      	cmp	r2, #1
 8009038:	d902      	bls.n	8009040 <sdStart+0x20>
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {

  osalDbgCheck(sdp != NULL);
 800903a:	4831      	ldr	r0, [pc, #196]	; (8009100 <sdStart+0xe0>)
 800903c:	f002 fd98 	bl	800bb70 <chSysHalt>
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 8009040:	4a30      	ldr	r2, [pc, #192]	; (8009104 <sdStart+0xe4>)
 8009042:	2d00      	cmp	r5, #0
 8009044:	bf08      	it	eq
 8009046:	4615      	moveq	r5, r2

  if (sdp->state == SD_STOP) {
 8009048:	2b01      	cmp	r3, #1
 800904a:	d036      	beq.n	80090ba <sdStart+0x9a>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 800904c:	6f63      	ldr	r3, [r4, #116]	; 0x74
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 800904e:	6829      	ldr	r1, [r5, #0]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8009050:	88a8      	ldrh	r0, [r5, #4]
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 8009052:	4a2d      	ldr	r2, [pc, #180]	; (8009108 <sdStart+0xe8>)
 8009054:	fbb2 f2f1 	udiv	r2, r2, r1

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8009058:	88e9      	ldrh	r1, [r5, #6]
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 800905a:	609a      	str	r2, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800905c:	892a      	ldrh	r2, [r5, #8]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800905e:	f041 0140 	orr.w	r1, r1, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8009062:	f440 5504 	orr.w	r5, r0, #8448	; 0x2100
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8009066:	f042 0201 	orr.w	r2, r2, #1
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800906a:	b289      	uxth	r1, r1
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800906c:	b292      	uxth	r2, r2
  (void)u->SR;  /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 800906e:	f400 50a0 	and.w	r0, r0, #5120	; 0x1400
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8009072:	f045 052c 	orr.w	r5, r5, #44	; 0x2c
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8009076:	2600      	movs	r6, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8009078:	6119      	str	r1, [r3, #16]
  (void)u->SR;  /* SR reset step 1.*/
  (void)u->DR;  /* SR reset step 2.*/

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 800907a:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800907e:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8009080:	60dd      	str	r5, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8009082:	601e      	str	r6, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8009084:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8009086:	685b      	ldr	r3, [r3, #4]

  /* Deciding mask to be applied on the data register on receive, this is
     required in order to mask out the parity bit.*/
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
    sdp->rxmask = 0x7F;
 8009088:	bf0c      	ite	eq
 800908a:	237f      	moveq	r3, #127	; 0x7f
  }
  else {
    sdp->rxmask = 0xFF;
 800908c:	23ff      	movne	r3, #255	; 0xff
 800908e:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8009092:	2302      	movs	r3, #2
 8009094:	7223      	strb	r3, [r4, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8009096:	f003 f863 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800909a:	4b1c      	ldr	r3, [pc, #112]	; (800910c <sdStart+0xec>)
 800909c:	681a      	ldr	r2, [r3, #0]
 800909e:	429a      	cmp	r2, r3
 80090a0:	d004      	beq.n	80090ac <sdStart+0x8c>
 80090a2:	6999      	ldr	r1, [r3, #24]
 80090a4:	6893      	ldr	r3, [r2, #8]
 80090a6:	688a      	ldr	r2, [r1, #8]
 80090a8:	429a      	cmp	r2, r3
 80090aa:	d303      	bcc.n	80090b4 <sdStart+0x94>
 80090ac:	2300      	movs	r3, #0
 80090ae:	f383 8811 	msr	BASEPRI, r3
 80090b2:	bd70      	pop	{r4, r5, r6, pc}
 80090b4:	4816      	ldr	r0, [pc, #88]	; (8009110 <sdStart+0xf0>)
 80090b6:	f002 fd5b 	bl	800bb70 <chSysHalt>
      rccEnableUSART2(FALSE);
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
 80090ba:	4b16      	ldr	r3, [pc, #88]	; (8009114 <sdStart+0xf4>)
 80090bc:	429c      	cmp	r4, r3
 80090be:	d011      	beq.n	80090e4 <sdStart+0xc4>
      rccEnableUART4(FALSE);
      nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 80090c0:	4b15      	ldr	r3, [pc, #84]	; (8009118 <sdStart+0xf8>)
 80090c2:	429c      	cmp	r4, r3
 80090c4:	d1c2      	bne.n	800904c <sdStart+0x2c>
      rccEnableUART5(FALSE);
 80090c6:	4815      	ldr	r0, [pc, #84]	; (800911c <sdStart+0xfc>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80090c8:	4b15      	ldr	r3, [pc, #84]	; (8009120 <sdStart+0x100>)
 80090ca:	6c02      	ldr	r2, [r0, #64]	; 0x40
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80090cc:	f44f 1100 	mov.w	r1, #2097152	; 0x200000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80090d0:	26c0      	movs	r6, #192	; 0xc0
 80090d2:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 80090d6:	6402      	str	r2, [r0, #64]	; 0x40
 80090d8:	f883 6335 	strb.w	r6, [r3, #821]	; 0x335
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80090dc:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80090e0:	6059      	str	r1, [r3, #4]
 80090e2:	e7b3      	b.n	800904c <sdStart+0x2c>
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
      rccEnableUSART3(FALSE);
 80090e4:	480d      	ldr	r0, [pc, #52]	; (800911c <sdStart+0xfc>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80090e6:	4b0e      	ldr	r3, [pc, #56]	; (8009120 <sdStart+0x100>)
 80090e8:	6c02      	ldr	r2, [r0, #64]	; 0x40
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80090ea:	2180      	movs	r1, #128	; 0x80

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80090ec:	26c0      	movs	r6, #192	; 0xc0
 80090ee:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 80090f2:	6402      	str	r2, [r0, #64]	; 0x40
 80090f4:	f883 6327 	strb.w	r6, [r3, #807]	; 0x327
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80090f8:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80090fc:	6059      	str	r1, [r3, #4]
 80090fe:	e7df      	b.n	80090c0 <sdStart+0xa0>
 8009100:	0800ffb8 	.word	0x0800ffb8
 8009104:	0800fee4 	.word	0x0800fee4
 8009108:	018cba80 	.word	0x018cba80
 800910c:	2001acdc 	.word	0x2001acdc
 8009110:	0800ff14 	.word	0x0800ff14
 8009114:	2001ac28 	.word	0x2001ac28
 8009118:	2001b6a4 	.word	0x2001b6a4
 800911c:	40023800 	.word	0x40023800
 8009120:	e000e100 	.word	0xe000e100
	...

08009130 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8009130:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009134:	b083      	sub	sp, #12
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);
 8009136:	2a00      	cmp	r2, #0
 8009138:	d074      	beq.n	8009224 <oqWriteTimeout+0xf4>
 800913a:	4604      	mov	r4, r0
 800913c:	4688      	mov	r8, r1
 800913e:	461e      	mov	r6, r3
 8009140:	4615      	mov	r5, r2
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8009142:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 8009146:	f04f 0b20 	mov.w	fp, #32
 800914a:	f38b 8811 	msr	BASEPRI, fp
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800914e:	f003 f817 	bl	800c180 <_dbg_check_lock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8009152:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009156:	4f35      	ldr	r7, [pc, #212]	; (800922c <oqWriteTimeout+0xfc>)
 8009158:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800915a:	f8cd b004 	str.w	fp, [sp, #4]
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800915e:	18f3      	adds	r3, r6, r3
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;
 8009160:	f04f 0900 	mov.w	r9, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8009164:	9300      	str	r3, [sp, #0]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009166:	46bb      	mov	fp, r7

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8009168:	68a3      	ldr	r3, [r4, #8]
 800916a:	2b00      	cmp	r3, #0
 800916c:	d02f      	beq.n	80091ce <oqWriteTimeout+0x9e>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 800916e:	6962      	ldr	r2, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8009170:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8009172:	1c51      	adds	r1, r2, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8009174:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8009176:	6161      	str	r1, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8009178:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800917a:	f898 3000 	ldrb.w	r3, [r8]
 800917e:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8009180:	6923      	ldr	r3, [r4, #16]
 8009182:	6962      	ldr	r2, [r4, #20]
 8009184:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8009186:	bf24      	itt	cs
 8009188:	68e3      	ldrcs	r3, [r4, #12]
 800918a:	6163      	strcs	r3, [r4, #20]
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 800918c:	f1ba 0f00 	cmp.w	sl, #0
 8009190:	d001      	beq.n	8009196 <oqWriteTimeout+0x66>
      nfy(oqp);
 8009192:	4620      	mov	r0, r4
 8009194:	47d0      	blx	sl
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8009196:	f002 ffe3 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800919a:	683b      	ldr	r3, [r7, #0]
 800919c:	42bb      	cmp	r3, r7
 800919e:	d005      	beq.n	80091ac <oqWriteTimeout+0x7c>
 80091a0:	f8db 2018 	ldr.w	r2, [fp, #24]
 80091a4:	689b      	ldr	r3, [r3, #8]
 80091a6:	6892      	ldr	r2, [r2, #8]
 80091a8:	429a      	cmp	r2, r3
 80091aa:	d331      	bcc.n	8009210 <oqWriteTimeout+0xe0>
 80091ac:	2300      	movs	r3, #0
 80091ae:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 80091b2:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 80091b4:	f109 0901 	add.w	r9, r9, #1
    if (--n == 0U) {
 80091b8:	d026      	beq.n	8009208 <oqWriteTimeout+0xd8>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80091ba:	f108 0801 	add.w	r8, r8, #1
 80091be:	9b01      	ldr	r3, [sp, #4]
 80091c0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80091c4:	f002 ffdc 	bl	800c180 <_dbg_check_lock>
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 80091c8:	68a3      	ldr	r3, [r4, #8]
 80091ca:	2b00      	cmp	r3, #0
 80091cc:	d1cf      	bne.n	800916e <oqWriteTimeout+0x3e>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80091ce:	1e73      	subs	r3, r6, #1
 80091d0:	3303      	adds	r3, #3
 80091d2:	d820      	bhi.n	8009216 <oqWriteTimeout+0xe6>
 80091d4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80091d8:	6a59      	ldr	r1, [r3, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80091da:	9b00      	ldr	r3, [sp, #0]
 80091dc:	1a59      	subs	r1, r3, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80091de:	428e      	cmp	r6, r1
 80091e0:	d304      	bcc.n	80091ec <oqWriteTimeout+0xbc>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 80091e2:	4620      	mov	r0, r4
 80091e4:	f002 ff0c 	bl	800c000 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80091e8:	2800      	cmp	r0, #0
 80091ea:	d0bd      	beq.n	8009168 <oqWriteTimeout+0x38>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80091ec:	f002 ffb8 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80091f0:	683b      	ldr	r3, [r7, #0]
 80091f2:	4a0e      	ldr	r2, [pc, #56]	; (800922c <oqWriteTimeout+0xfc>)
 80091f4:	42bb      	cmp	r3, r7
 80091f6:	d004      	beq.n	8009202 <oqWriteTimeout+0xd2>
 80091f8:	6992      	ldr	r2, [r2, #24]
 80091fa:	689b      	ldr	r3, [r3, #8]
 80091fc:	6892      	ldr	r2, [r2, #8]
 80091fe:	429a      	cmp	r2, r3
 8009200:	d306      	bcc.n	8009210 <oqWriteTimeout+0xe0>
 8009202:	2300      	movs	r3, #0
 8009204:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
 8009208:	4648      	mov	r0, r9
 800920a:	b003      	add	sp, #12
 800920c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009210:	4807      	ldr	r0, [pc, #28]	; (8009230 <oqWriteTimeout+0x100>)
 8009212:	f002 fcad 	bl	800bb70 <chSysHalt>
 8009216:	4631      	mov	r1, r6
 8009218:	4620      	mov	r0, r4
 800921a:	f002 fef1 	bl	800c000 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800921e:	2800      	cmp	r0, #0
 8009220:	d0a2      	beq.n	8009168 <oqWriteTimeout+0x38>
 8009222:	e7e3      	b.n	80091ec <oqWriteTimeout+0xbc>
                      size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
  size_t w = 0;

  osalDbgCheck(n > 0U);
 8009224:	4803      	ldr	r0, [pc, #12]	; (8009234 <oqWriteTimeout+0x104>)
 8009226:	f002 fca3 	bl	800bb70 <chSysHalt>
 800922a:	bf00      	nop
 800922c:	2001acdc 	.word	0x2001acdc
 8009230:	0800ff08 	.word	0x0800ff08
 8009234:	0800ff40 	.word	0x0800ff40
	...

08009240 <_writet.lto_priv.117>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8009240:	3030      	adds	r0, #48	; 0x30
 8009242:	f7ff bf75 	b.w	8009130 <oqWriteTimeout>
 8009246:	bf00      	nop
	...

08009250 <_write.lto_priv.111>:
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8009250:	3030      	adds	r0, #48	; 0x30
 8009252:	f04f 33ff 	mov.w	r3, #4294967295
 8009256:	f7ff bf6b 	b.w	8009130 <oqWriteTimeout>
 800925a:	bf00      	nop
 800925c:	0000      	movs	r0, r0
	...

08009260 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8009260:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009262:	4604      	mov	r4, r0
 8009264:	460f      	mov	r7, r1
 8009266:	4616      	mov	r6, r2
 8009268:	2320      	movs	r3, #32
 800926a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800926e:	f002 ff87 	bl	800c180 <_dbg_check_lock>
 8009272:	e005      	b.n	8009280 <oqPutTimeout+0x20>
 8009274:	4631      	mov	r1, r6
 8009276:	4620      	mov	r0, r4
 8009278:	f002 fec2 	bl	800c000 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 800927c:	1e05      	subs	r5, r0, #0
 800927e:	db23      	blt.n	80092c8 <oqPutTimeout+0x68>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8009280:	68a3      	ldr	r3, [r4, #8]
 8009282:	2b00      	cmp	r3, #0
 8009284:	d0f6      	beq.n	8009274 <oqPutTimeout+0x14>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8009286:	6962      	ldr	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8009288:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800928a:	1c51      	adds	r1, r2, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 800928c:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800928e:	6161      	str	r1, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8009290:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8009292:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8009294:	6923      	ldr	r3, [r4, #16]
 8009296:	6962      	ldr	r2, [r4, #20]
 8009298:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 800929a:	bf24      	itt	cs
 800929c:	68e3      	ldrcs	r3, [r4, #12]
 800929e:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 80092a0:	69e3      	ldr	r3, [r4, #28]
 80092a2:	b10b      	cbz	r3, 80092a8 <oqPutTimeout+0x48>
    oqp->q_notify(oqp);
 80092a4:	4620      	mov	r0, r4
 80092a6:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80092a8:	f002 ff5a 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80092ac:	4b10      	ldr	r3, [pc, #64]	; (80092f0 <oqPutTimeout+0x90>)
 80092ae:	681a      	ldr	r2, [r3, #0]
 80092b0:	429a      	cmp	r2, r3
 80092b2:	d004      	beq.n	80092be <oqPutTimeout+0x5e>
 80092b4:	6999      	ldr	r1, [r3, #24]
 80092b6:	6893      	ldr	r3, [r2, #8]
 80092b8:	688a      	ldr	r2, [r1, #8]
 80092ba:	429a      	cmp	r2, r3
 80092bc:	d314      	bcc.n	80092e8 <oqPutTimeout+0x88>
 80092be:	2500      	movs	r5, #0
 80092c0:	f385 8811 	msr	BASEPRI, r5
  }

  osalSysUnlock();

  return MSG_OK;
}
 80092c4:	4628      	mov	r0, r5
 80092c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80092c8:	f002 ff4a 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80092cc:	4b08      	ldr	r3, [pc, #32]	; (80092f0 <oqPutTimeout+0x90>)
 80092ce:	681a      	ldr	r2, [r3, #0]
 80092d0:	429a      	cmp	r2, r3
 80092d2:	d004      	beq.n	80092de <oqPutTimeout+0x7e>
 80092d4:	6999      	ldr	r1, [r3, #24]
 80092d6:	6893      	ldr	r3, [r2, #8]
 80092d8:	688a      	ldr	r2, [r1, #8]
 80092da:	429a      	cmp	r2, r3
 80092dc:	d304      	bcc.n	80092e8 <oqPutTimeout+0x88>
 80092de:	2300      	movs	r3, #0
 80092e0:	f383 8811 	msr	BASEPRI, r3
 80092e4:	4628      	mov	r0, r5
 80092e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80092e8:	4802      	ldr	r0, [pc, #8]	; (80092f4 <oqPutTimeout+0x94>)
 80092ea:	f002 fc41 	bl	800bb70 <chSysHalt>
 80092ee:	bf00      	nop
 80092f0:	2001acdc 	.word	0x2001acdc
 80092f4:	0800ff08 	.word	0x0800ff08
	...

08009300 <_putt.lto_priv.115>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8009300:	3030      	adds	r0, #48	; 0x30
 8009302:	f7ff bfad 	b.w	8009260 <oqPutTimeout>
 8009306:	bf00      	nop
	...

08009310 <_put.lto_priv.113>:
                       n, TIME_INFINITE);
}

static msg_t _put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8009310:	3030      	adds	r0, #48	; 0x30
 8009312:	f04f 32ff 	mov.w	r2, #4294967295
 8009316:	f7ff bfa3 	b.w	8009260 <oqPutTimeout>
 800931a:	bf00      	nop
 800931c:	0000      	movs	r0, r0
	...

08009320 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8009320:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009324:	b083      	sub	sp, #12
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  osalDbgCheck(n > 0U);
 8009326:	2a00      	cmp	r2, #0
 8009328:	d074      	beq.n	8009414 <iqReadTimeout+0xf4>
 800932a:	4604      	mov	r4, r0
 800932c:	4688      	mov	r8, r1
 800932e:	461e      	mov	r6, r3
 8009330:	4615      	mov	r5, r2
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 8009332:	f8d0 a01c 	ldr.w	sl, [r0, #28]
 8009336:	f04f 0b20 	mov.w	fp, #32
 800933a:	f38b 8811 	msr	BASEPRI, fp
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800933e:	f002 ff1f 	bl	800c180 <_dbg_check_lock>
 8009342:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009346:	4f35      	ldr	r7, [pc, #212]	; (800941c <iqReadTimeout+0xfc>)
 8009348:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800934a:	f8cd b004 	str.w	fp, [sp, #4]
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800934e:	18f3      	adds	r3, r6, r3
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;
 8009350:	f04f 0900 	mov.w	r9, #0
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8009354:	9300      	str	r3, [sp, #0]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009356:	46bb      	mov	fp, r7

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8009358:	68a3      	ldr	r3, [r4, #8]
 800935a:	2b00      	cmp	r3, #0
 800935c:	d02f      	beq.n	80093be <iqReadTimeout+0x9e>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 800935e:	69a2      	ldr	r2, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8009360:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8009362:	1c51      	adds	r1, r2, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8009364:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8009366:	61a1      	str	r1, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8009368:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 800936a:	7813      	ldrb	r3, [r2, #0]
 800936c:	f888 3000 	strb.w	r3, [r8]
    if (iqp->q_rdptr >= iqp->q_top) {
 8009370:	6923      	ldr	r3, [r4, #16]
 8009372:	69a2      	ldr	r2, [r4, #24]
 8009374:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8009376:	bf24      	itt	cs
 8009378:	68e3      	ldrcs	r3, [r4, #12]
 800937a:	61a3      	strcs	r3, [r4, #24]
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 800937c:	f1ba 0f00 	cmp.w	sl, #0
 8009380:	d001      	beq.n	8009386 <iqReadTimeout+0x66>
      nfy(iqp);
 8009382:	4620      	mov	r0, r4
 8009384:	47d0      	blx	sl
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8009386:	f002 feeb 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800938a:	683b      	ldr	r3, [r7, #0]
 800938c:	42bb      	cmp	r3, r7
 800938e:	d005      	beq.n	800939c <iqReadTimeout+0x7c>
 8009390:	f8db 2018 	ldr.w	r2, [fp, #24]
 8009394:	689b      	ldr	r3, [r3, #8]
 8009396:	6892      	ldr	r2, [r2, #8]
 8009398:	429a      	cmp	r2, r3
 800939a:	d331      	bcc.n	8009400 <iqReadTimeout+0xe0>
 800939c:	2300      	movs	r3, #0
 800939e:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 80093a2:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 80093a4:	f109 0901 	add.w	r9, r9, #1
    if (--n == 0U) {
 80093a8:	d026      	beq.n	80093f8 <iqReadTimeout+0xd8>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80093aa:	f108 0801 	add.w	r8, r8, #1
 80093ae:	9b01      	ldr	r3, [sp, #4]
 80093b0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80093b4:	f002 fee4 	bl	800c180 <_dbg_check_lock>
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 80093b8:	68a3      	ldr	r3, [r4, #8]
 80093ba:	2b00      	cmp	r3, #0
 80093bc:	d1cf      	bne.n	800935e <iqReadTimeout+0x3e>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80093be:	1e73      	subs	r3, r6, #1
 80093c0:	3303      	adds	r3, #3
 80093c2:	d820      	bhi.n	8009406 <iqReadTimeout+0xe6>
 80093c4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80093c8:	6a59      	ldr	r1, [r3, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80093ca:	9b00      	ldr	r3, [sp, #0]
 80093cc:	1a59      	subs	r1, r3, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80093ce:	428e      	cmp	r6, r1
 80093d0:	d304      	bcc.n	80093dc <iqReadTimeout+0xbc>
 80093d2:	4620      	mov	r0, r4
 80093d4:	f002 fe14 	bl	800c000 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 80093d8:	2800      	cmp	r0, #0
 80093da:	d0bd      	beq.n	8009358 <iqReadTimeout+0x38>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80093dc:	f002 fec0 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80093e0:	683b      	ldr	r3, [r7, #0]
 80093e2:	4a0e      	ldr	r2, [pc, #56]	; (800941c <iqReadTimeout+0xfc>)
 80093e4:	42bb      	cmp	r3, r7
 80093e6:	d004      	beq.n	80093f2 <iqReadTimeout+0xd2>
 80093e8:	6992      	ldr	r2, [r2, #24]
 80093ea:	689b      	ldr	r3, [r3, #8]
 80093ec:	6892      	ldr	r2, [r2, #8]
 80093ee:	429a      	cmp	r2, r3
 80093f0:	d306      	bcc.n	8009400 <iqReadTimeout+0xe0>
 80093f2:	2300      	movs	r3, #0
 80093f4:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
 80093f8:	4648      	mov	r0, r9
 80093fa:	b003      	add	sp, #12
 80093fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009400:	4807      	ldr	r0, [pc, #28]	; (8009420 <iqReadTimeout+0x100>)
 8009402:	f002 fbb5 	bl	800bb70 <chSysHalt>
 8009406:	4631      	mov	r1, r6
 8009408:	4620      	mov	r0, r4
 800940a:	f002 fdf9 	bl	800c000 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800940e:	2800      	cmp	r0, #0
 8009410:	d0a2      	beq.n	8009358 <iqReadTimeout+0x38>
 8009412:	e7e3      	b.n	80093dc <iqReadTimeout+0xbc>
                     size_t n, systime_t timeout) {
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
  size_t r = 0;

  osalDbgCheck(n > 0U);
 8009414:	4803      	ldr	r0, [pc, #12]	; (8009424 <iqReadTimeout+0x104>)
 8009416:	f002 fbab 	bl	800bb70 <chSysHalt>
 800941a:	bf00      	nop
 800941c:	2001acdc 	.word	0x2001acdc
 8009420:	0800ff08 	.word	0x0800ff08
 8009424:	0800ff88 	.word	0x0800ff88
	...

08009430 <_readt.lto_priv.118>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8009430:	300c      	adds	r0, #12
 8009432:	f7ff bf75 	b.w	8009320 <iqReadTimeout>
 8009436:	bf00      	nop
	...

08009440 <_read.lto_priv.112>:
                        n, TIME_INFINITE);
}

static size_t _read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8009440:	300c      	adds	r0, #12
 8009442:	f04f 33ff 	mov.w	r3, #4294967295
 8009446:	f7ff bf6b 	b.w	8009320 <iqReadTimeout>
 800944a:	bf00      	nop
 800944c:	0000      	movs	r0, r0
	...

08009450 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8009450:	b570      	push	{r4, r5, r6, lr}
 8009452:	2320      	movs	r3, #32
 8009454:	4604      	mov	r4, r0
 8009456:	460e      	mov	r6, r1
 8009458:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800945c:	f002 fe90 	bl	800c180 <_dbg_check_lock>
 8009460:	e005      	b.n	800946e <iqGetTimeout+0x1e>
 8009462:	4631      	mov	r1, r6
 8009464:	4620      	mov	r0, r4
 8009466:	f002 fdcb 	bl	800c000 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 800946a:	1e05      	subs	r5, r0, #0
 800946c:	db13      	blt.n	8009496 <iqGetTimeout+0x46>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 800946e:	68a3      	ldr	r3, [r4, #8]
 8009470:	2b00      	cmp	r3, #0
 8009472:	d0f6      	beq.n	8009462 <iqGetTimeout+0x12>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8009474:	69a1      	ldr	r1, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8009476:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8009478:	6920      	ldr	r0, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800947a:	1c4a      	adds	r2, r1, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 800947c:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800947e:	4282      	cmp	r2, r0
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8009480:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8009482:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8009484:	bf28      	it	cs
 8009486:	68e3      	ldrcs	r3, [r4, #12]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8009488:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800948a:	bf28      	it	cs
 800948c:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 800948e:	69e3      	ldr	r3, [r4, #28]
 8009490:	b10b      	cbz	r3, 8009496 <iqGetTimeout+0x46>
    iqp->q_notify(iqp);
 8009492:	4620      	mov	r0, r4
 8009494:	4798      	blx	r3
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8009496:	f002 fe63 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800949a:	4b08      	ldr	r3, [pc, #32]	; (80094bc <iqGetTimeout+0x6c>)
 800949c:	681a      	ldr	r2, [r3, #0]
 800949e:	429a      	cmp	r2, r3
 80094a0:	d004      	beq.n	80094ac <iqGetTimeout+0x5c>
 80094a2:	6999      	ldr	r1, [r3, #24]
 80094a4:	6893      	ldr	r3, [r2, #8]
 80094a6:	688a      	ldr	r2, [r1, #8]
 80094a8:	429a      	cmp	r2, r3
 80094aa:	d304      	bcc.n	80094b6 <iqGetTimeout+0x66>
 80094ac:	2300      	movs	r3, #0
 80094ae:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
}
 80094b2:	4628      	mov	r0, r5
 80094b4:	bd70      	pop	{r4, r5, r6, pc}
 80094b6:	4802      	ldr	r0, [pc, #8]	; (80094c0 <iqGetTimeout+0x70>)
 80094b8:	f002 fb5a 	bl	800bb70 <chSysHalt>
 80094bc:	2001acdc 	.word	0x2001acdc
 80094c0:	0800ff08 	.word	0x0800ff08
	...

080094d0 <_gett.lto_priv.116>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t _gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80094d0:	300c      	adds	r0, #12
 80094d2:	f7ff bfbd 	b.w	8009450 <iqGetTimeout>
 80094d6:	bf00      	nop
	...

080094e0 <_get.lto_priv.114>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80094e0:	300c      	adds	r0, #12
 80094e2:	f04f 31ff 	mov.w	r1, #4294967295
 80094e6:	f7ff bfb3 	b.w	8009450 <iqGetTimeout>
 80094ea:	bf00      	nop
 80094ec:	0000      	movs	r0, r0
	...

080094f0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80094f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80094f2:	4605      	mov	r5, r0
 80094f4:	460c      	mov	r4, r1
 80094f6:	2320      	movs	r3, #32
 80094f8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80094fc:	f002 fe40 	bl	800c180 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
 8009500:	f002 fb96 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8009504:	b32c      	cbz	r4, 8009552 <chCoreAllocAligned+0x62>
 8009506:	1e62      	subs	r2, r4, #1
 8009508:	ea14 0702 	ands.w	r7, r4, r2
 800950c:	d121      	bne.n	8009552 <chCoreAllocAligned+0x62>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800950e:	4e14      	ldr	r6, [pc, #80]	; (8009560 <chCoreAllocAligned+0x70>)

  if (((size_t)endmem - (size_t)p) < size) {
 8009510:	4914      	ldr	r1, [pc, #80]	; (8009564 <chCoreAllocAligned+0x74>)

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8009512:	6833      	ldr	r3, [r6, #0]

  if (((size_t)endmem - (size_t)p) < size) {
 8009514:	6809      	ldr	r1, [r1, #0]

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8009516:	3b01      	subs	r3, #1
 8009518:	4423      	add	r3, r4
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800951a:	4264      	negs	r4, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800951c:	ea03 0004 	and.w	r0, r3, r4
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8009520:	442a      	add	r2, r5
 8009522:	4014      	ands	r4, r2
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8009524:	1a0b      	subs	r3, r1, r0
 8009526:	429c      	cmp	r4, r3
    return NULL;
  }
  nextmem = p + size;
 8009528:	bf9b      	ittet	ls
 800952a:	1824      	addls	r4, r4, r0
 800952c:	6034      	strls	r4, [r6, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 800952e:	463c      	movhi	r4, r7
  }
  nextmem = p + size;

  return p;
 8009530:	4604      	movls	r4, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8009532:	f002 fe15 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009536:	4b0c      	ldr	r3, [pc, #48]	; (8009568 <chCoreAllocAligned+0x78>)
 8009538:	681a      	ldr	r2, [r3, #0]
 800953a:	429a      	cmp	r2, r3
 800953c:	d004      	beq.n	8009548 <chCoreAllocAligned+0x58>
 800953e:	6999      	ldr	r1, [r3, #24]
 8009540:	6893      	ldr	r3, [r2, #8]
 8009542:	688a      	ldr	r2, [r1, #8]
 8009544:	429a      	cmp	r2, r3
 8009546:	d307      	bcc.n	8009558 <chCoreAllocAligned+0x68>
 8009548:	2300      	movs	r3, #0
 800954a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 800954e:	4620      	mov	r0, r4
 8009550:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8009552:	4806      	ldr	r0, [pc, #24]	; (800956c <chCoreAllocAligned+0x7c>)
 8009554:	f002 fb0c 	bl	800bb70 <chSysHalt>
 8009558:	4805      	ldr	r0, [pc, #20]	; (8009570 <chCoreAllocAligned+0x80>)
 800955a:	f002 fb09 	bl	800bb70 <chSysHalt>
 800955e:	bf00      	nop
 8009560:	2001a9d4 	.word	0x2001a9d4
 8009564:	20019978 	.word	0x20019978
 8009568:	2001acdc 	.word	0x2001acdc
 800956c:	0800ff20 	.word	0x0800ff20
 8009570:	0800ff34 	.word	0x0800ff34
	...

08009580 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8009580:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  thread_t *ctp = currp;
 8009584:	4f28      	ldr	r7, [pc, #160]	; (8009628 <chMtxUnlock+0xa8>)
 8009586:	69bd      	ldr	r5, [r7, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8009588:	b150      	cbz	r0, 80095a0 <chMtxUnlock+0x20>
 800958a:	4606      	mov	r6, r0
 800958c:	2320      	movs	r3, #32
 800958e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8009592:	f002 fdf5 	bl	800c180 <_dbg_check_lock>

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8009596:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8009598:	b113      	cbz	r3, 80095a0 <chMtxUnlock+0x20>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800959a:	689a      	ldr	r2, [r3, #8]
 800959c:	4295      	cmp	r5, r2
 800959e:	d002      	beq.n	80095a6 <chMtxUnlock+0x26>
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 80095a0:	4822      	ldr	r0, [pc, #136]	; (800962c <chMtxUnlock+0xac>)
 80095a2:	f002 fae5 	bl	800bb70 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 80095a6:	429e      	cmp	r6, r3
 80095a8:	d1fa      	bne.n	80095a0 <chMtxUnlock+0x20>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80095aa:	68f4      	ldr	r4, [r6, #12]
 80095ac:	63ac      	str	r4, [r5, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 80095ae:	f002 faff 	bl	800bbb0 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80095b2:	f8d6 9000 	ldr.w	r9, [r6]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80095b6:	454e      	cmp	r6, r9
 80095b8:	d033      	beq.n	8009622 <chMtxUnlock+0xa2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80095ba:	f8d5 803c 	ldr.w	r8, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80095be:	b15c      	cbz	r4, 80095d8 <chMtxUnlock+0x58>
 80095c0:	f002 faf6 	bl	800bbb0 <chDbgCheckClassS>
 80095c4:	6823      	ldr	r3, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80095c6:	429c      	cmp	r4, r3
 80095c8:	d003      	beq.n	80095d2 <chMtxUnlock+0x52>
            (lmp->queue.next->prio > newprio)) {
 80095ca:	689b      	ldr	r3, [r3, #8]
 80095cc:	4598      	cmp	r8, r3
 80095ce:	bf38      	it	cc
 80095d0:	4698      	movcc	r8, r3
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 80095d2:	68e4      	ldr	r4, [r4, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80095d4:	2c00      	cmp	r4, #0
 80095d6:	d1f3      	bne.n	80095c0 <chMtxUnlock+0x40>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80095d8:	f8d9 3000 	ldr.w	r3, [r9]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80095dc:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80095e0:	f8c5 8008 	str.w	r8, [r5, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80095e4:	4648      	mov	r0, r9
 80095e6:	6033      	str	r3, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80095e8:	605e      	str	r6, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80095ea:	60f2      	str	r2, [r6, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 80095ec:	f8c6 9008 	str.w	r9, [r6, #8]
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
 80095f0:	f8c9 6038 	str.w	r6, [r9, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80095f4:	f002 fbe4 	bl	800bdc0 <chSchReadyI>
      chSchRescheduleS();
 80095f8:	f002 fbca 	bl	800bd90 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80095fc:	f002 fdb0 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8009600:	683b      	ldr	r3, [r7, #0]
 8009602:	4a09      	ldr	r2, [pc, #36]	; (8009628 <chMtxUnlock+0xa8>)
 8009604:	42bb      	cmp	r3, r7
 8009606:	d004      	beq.n	8009612 <chMtxUnlock+0x92>
 8009608:	6992      	ldr	r2, [r2, #24]
 800960a:	689b      	ldr	r3, [r3, #8]
 800960c:	6892      	ldr	r2, [r2, #8]
 800960e:	429a      	cmp	r2, r3
 8009610:	d304      	bcc.n	800961c <chMtxUnlock+0x9c>
 8009612:	2300      	movs	r3, #0
 8009614:	f383 8811 	msr	BASEPRI, r3
 8009618:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800961c:	4804      	ldr	r0, [pc, #16]	; (8009630 <chMtxUnlock+0xb0>)
 800961e:	f002 faa7 	bl	800bb70 <chSysHalt>
    }
    else {
      mp->owner = NULL;
 8009622:	2300      	movs	r3, #0
 8009624:	60b3      	str	r3, [r6, #8]
 8009626:	e7e9      	b.n	80095fc <chMtxUnlock+0x7c>
 8009628:	2001acdc 	.word	0x2001acdc
 800962c:	0800ff7c 	.word	0x0800ff7c
 8009630:	0800ffa8 	.word	0x0800ffa8
	...

08009640 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8009640:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009642:	480d      	ldr	r0, [pc, #52]	; (8009678 <Vector158+0x38>)
 8009644:	f002 fa74 	bl	800bb30 <_trace_isr_enter>
 8009648:	f002 fd0a 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800964c:	4b0b      	ldr	r3, [pc, #44]	; (800967c <Vector158+0x3c>)
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 800964e:	480c      	ldr	r0, [pc, #48]	; (8009680 <Vector158+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009650:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 8009652:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8009654:	0d89      	lsrs	r1, r1, #22
 8009656:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 800965a:	058c      	lsls	r4, r1, #22
 800965c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 800965e:	b10a      	cbz	r2, 8009664 <Vector158+0x24>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8009660:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8009662:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009664:	f002 fce4 	bl	800c030 <_dbg_check_leave_isr>
 8009668:	4803      	ldr	r0, [pc, #12]	; (8009678 <Vector158+0x38>)
 800966a:	f002 fa41 	bl	800baf0 <_trace_isr_leave>
}
 800966e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009672:	f7ff bc55 	b.w	8008f20 <_port_irq_epilogue>
 8009676:	bf00      	nop
 8009678:	0801004c 	.word	0x0801004c
 800967c:	40026400 	.word	0x40026400
 8009680:	200198d0 	.word	0x200198d0
	...

08009690 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8009690:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009692:	480d      	ldr	r0, [pc, #52]	; (80096c8 <Vector154+0x38>)
 8009694:	f002 fa4c 	bl	800bb30 <_trace_isr_enter>
 8009698:	f002 fce2 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800969c:	4b0b      	ldr	r3, [pc, #44]	; (80096cc <Vector154+0x3c>)
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 800969e:	480c      	ldr	r0, [pc, #48]	; (80096d0 <Vector154+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80096a0:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 80096a2:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80096a4:	0c09      	lsrs	r1, r1, #16
 80096a6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 80096aa:	040c      	lsls	r4, r1, #16
 80096ac:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 80096ae:	b10a      	cbz	r2, 80096b4 <Vector154+0x24>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 80096b0:	6f40      	ldr	r0, [r0, #116]	; 0x74
 80096b2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80096b4:	f002 fcbc 	bl	800c030 <_dbg_check_leave_isr>
 80096b8:	4803      	ldr	r0, [pc, #12]	; (80096c8 <Vector154+0x38>)
 80096ba:	f002 fa19 	bl	800baf0 <_trace_isr_leave>
}
 80096be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80096c2:	f7ff bc2d 	b.w	8008f20 <_port_irq_epilogue>
 80096c6:	bf00      	nop
 80096c8:	080100c0 	.word	0x080100c0
 80096cc:	40026400 	.word	0x40026400
 80096d0:	200198d0 	.word	0x200198d0
	...

080096e0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 80096e0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80096e2:	480d      	ldr	r0, [pc, #52]	; (8009718 <Vector150+0x38>)
 80096e4:	f002 fa24 	bl	800bb30 <_trace_isr_enter>
 80096e8:	f002 fcba 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80096ec:	4b0b      	ldr	r3, [pc, #44]	; (800971c <Vector150+0x3c>)
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 80096ee:	480c      	ldr	r0, [pc, #48]	; (8009720 <Vector150+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80096f0:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 80096f2:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80096f4:	0989      	lsrs	r1, r1, #6
 80096f6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 80096fa:	018c      	lsls	r4, r1, #6
 80096fc:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 80096fe:	b10a      	cbz	r2, 8009704 <Vector150+0x24>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8009700:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8009702:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009704:	f002 fc94 	bl	800c030 <_dbg_check_leave_isr>
 8009708:	4803      	ldr	r0, [pc, #12]	; (8009718 <Vector150+0x38>)
 800970a:	f002 f9f1 	bl	800baf0 <_trace_isr_leave>
}
 800970e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009712:	f7ff bc05 	b.w	8008f20 <_port_irq_epilogue>
 8009716:	bf00      	nop
 8009718:	0801001c 	.word	0x0801001c
 800971c:	40026400 	.word	0x40026400
 8009720:	200198d0 	.word	0x200198d0
	...

08009730 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8009730:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009732:	480c      	ldr	r0, [pc, #48]	; (8009764 <Vector130+0x34>)
 8009734:	f002 f9fc 	bl	800bb30 <_trace_isr_enter>
 8009738:	f002 fc92 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800973c:	4b0a      	ldr	r3, [pc, #40]	; (8009768 <Vector130+0x38>)
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 800973e:	480b      	ldr	r0, [pc, #44]	; (800976c <Vector130+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009740:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 8009742:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8009744:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8009748:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 800974a:	b10a      	cbz	r2, 8009750 <Vector130+0x20>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 800974c:	6e40      	ldr	r0, [r0, #100]	; 0x64
 800974e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009750:	f002 fc6e 	bl	800c030 <_dbg_check_leave_isr>
 8009754:	4803      	ldr	r0, [pc, #12]	; (8009764 <Vector130+0x34>)
 8009756:	f002 f9cb 	bl	800baf0 <_trace_isr_leave>
}
 800975a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800975e:	f7ff bbdf 	b.w	8008f20 <_port_irq_epilogue>
 8009762:	bf00      	nop
 8009764:	0801007c 	.word	0x0801007c
 8009768:	40026400 	.word	0x40026400
 800976c:	200198d0 	.word	0x200198d0

08009770 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8009770:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009772:	480d      	ldr	r0, [pc, #52]	; (80097a8 <Vector12C+0x38>)
 8009774:	f002 f9dc 	bl	800bb30 <_trace_isr_enter>
 8009778:	f002 fc72 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800977c:	4b0b      	ldr	r3, [pc, #44]	; (80097ac <Vector12C+0x3c>)
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 800977e:	480c      	ldr	r0, [pc, #48]	; (80097b0 <Vector12C+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009780:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 8009782:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8009784:	0d89      	lsrs	r1, r1, #22
 8009786:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 800978a:	058c      	lsls	r4, r1, #22
 800978c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 800978e:	b10a      	cbz	r2, 8009794 <Vector12C+0x24>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8009790:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8009792:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009794:	f002 fc4c 	bl	800c030 <_dbg_check_leave_isr>
 8009798:	4803      	ldr	r0, [pc, #12]	; (80097a8 <Vector12C+0x38>)
 800979a:	f002 f9a9 	bl	800baf0 <_trace_isr_leave>
}
 800979e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80097a2:	f7ff bbbd 	b.w	8008f20 <_port_irq_epilogue>
 80097a6:	bf00      	nop
 80097a8:	0800ffec 	.word	0x0800ffec
 80097ac:	40026400 	.word	0x40026400
 80097b0:	200198d0 	.word	0x200198d0
	...

080097c0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80097c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80097c2:	480d      	ldr	r0, [pc, #52]	; (80097f8 <Vector128+0x38>)
 80097c4:	f002 f9b4 	bl	800bb30 <_trace_isr_enter>
 80097c8:	f002 fc4a 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80097cc:	4b0b      	ldr	r3, [pc, #44]	; (80097fc <Vector128+0x3c>)
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 80097ce:	480c      	ldr	r0, [pc, #48]	; (8009800 <Vector128+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80097d0:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 80097d2:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80097d4:	0c09      	lsrs	r1, r1, #16
 80097d6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 80097da:	040c      	lsls	r4, r1, #16
 80097dc:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 80097de:	b10a      	cbz	r2, 80097e4 <Vector128+0x24>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 80097e0:	6d40      	ldr	r0, [r0, #84]	; 0x54
 80097e2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80097e4:	f002 fc24 	bl	800c030 <_dbg_check_leave_isr>
 80097e8:	4803      	ldr	r0, [pc, #12]	; (80097f8 <Vector128+0x38>)
 80097ea:	f002 f981 	bl	800baf0 <_trace_isr_leave>
}
 80097ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80097f2:	f7ff bb95 	b.w	8008f20 <_port_irq_epilogue>
 80097f6:	bf00      	nop
 80097f8:	080100cc 	.word	0x080100cc
 80097fc:	40026400 	.word	0x40026400
 8009800:	200198d0 	.word	0x200198d0
	...

08009810 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8009810:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009812:	480d      	ldr	r0, [pc, #52]	; (8009848 <Vector124+0x38>)
 8009814:	f002 f98c 	bl	800bb30 <_trace_isr_enter>
 8009818:	f002 fc22 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800981c:	4b0b      	ldr	r3, [pc, #44]	; (800984c <Vector124+0x3c>)
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 800981e:	480c      	ldr	r0, [pc, #48]	; (8009850 <Vector124+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009820:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 8009822:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009824:	0989      	lsrs	r1, r1, #6
 8009826:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 800982a:	018c      	lsls	r4, r1, #6
 800982c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 800982e:	b10a      	cbz	r2, 8009834 <Vector124+0x24>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8009830:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8009832:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009834:	f002 fbfc 	bl	800c030 <_dbg_check_leave_isr>
 8009838:	4803      	ldr	r0, [pc, #12]	; (8009848 <Vector124+0x38>)
 800983a:	f002 f959 	bl	800baf0 <_trace_isr_leave>
}
 800983e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009842:	f7ff bb6d 	b.w	8008f20 <_port_irq_epilogue>
 8009846:	bf00      	nop
 8009848:	080100d8 	.word	0x080100d8
 800984c:	40026400 	.word	0x40026400
 8009850:	200198d0 	.word	0x200198d0
	...

08009860 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8009860:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009862:	480c      	ldr	r0, [pc, #48]	; (8009894 <Vector120+0x34>)
 8009864:	f002 f964 	bl	800bb30 <_trace_isr_enter>
 8009868:	f002 fbfa 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800986c:	4b0a      	ldr	r3, [pc, #40]	; (8009898 <Vector120+0x38>)
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 800986e:	480b      	ldr	r0, [pc, #44]	; (800989c <Vector120+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009870:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 8009872:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009874:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8009878:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 800987a:	b10a      	cbz	r2, 8009880 <Vector120+0x20>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 800987c:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800987e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009880:	f002 fbd6 	bl	800c030 <_dbg_check_leave_isr>
 8009884:	4803      	ldr	r0, [pc, #12]	; (8009894 <Vector120+0x34>)
 8009886:	f002 f933 	bl	800baf0 <_trace_isr_leave>
}
 800988a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800988e:	f7ff bb47 	b.w	8008f20 <_port_irq_epilogue>
 8009892:	bf00      	nop
 8009894:	08010058 	.word	0x08010058
 8009898:	40026400 	.word	0x40026400
 800989c:	200198d0 	.word	0x200198d0

080098a0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80098a0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80098a2:	480d      	ldr	r0, [pc, #52]	; (80098d8 <VectorFC+0x38>)
 80098a4:	f002 f944 	bl	800bb30 <_trace_isr_enter>
 80098a8:	f002 fbda 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80098ac:	4b0b      	ldr	r3, [pc, #44]	; (80098dc <VectorFC+0x3c>)
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 80098ae:	480c      	ldr	r0, [pc, #48]	; (80098e0 <VectorFC+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80098b0:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 80098b2:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80098b4:	0d89      	lsrs	r1, r1, #22
 80098b6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 80098ba:	058c      	lsls	r4, r1, #22
 80098bc:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 80098be:	b10a      	cbz	r2, 80098c4 <VectorFC+0x24>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 80098c0:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 80098c2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80098c4:	f002 fbb4 	bl	800c030 <_dbg_check_leave_isr>
 80098c8:	4803      	ldr	r0, [pc, #12]	; (80098d8 <VectorFC+0x38>)
 80098ca:	f002 f911 	bl	800baf0 <_trace_isr_leave>
}
 80098ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80098d2:	f7ff bb25 	b.w	8008f20 <_port_irq_epilogue>
 80098d6:	bf00      	nop
 80098d8:	080100b4 	.word	0x080100b4
 80098dc:	40026000 	.word	0x40026000
 80098e0:	200198d0 	.word	0x200198d0
	...

080098f0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80098f0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80098f2:	480d      	ldr	r0, [pc, #52]	; (8009928 <Vector84+0x38>)
 80098f4:	f002 f91c 	bl	800bb30 <_trace_isr_enter>
 80098f8:	f002 fbb2 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80098fc:	4b0b      	ldr	r3, [pc, #44]	; (800992c <Vector84+0x3c>)
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 80098fe:	480c      	ldr	r0, [pc, #48]	; (8009930 <Vector84+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009900:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 8009902:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8009904:	0c09      	lsrs	r1, r1, #16
 8009906:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 800990a:	040c      	lsls	r4, r1, #16
 800990c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 800990e:	b10a      	cbz	r2, 8009914 <Vector84+0x24>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8009910:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8009912:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009914:	f002 fb8c 	bl	800c030 <_dbg_check_leave_isr>
 8009918:	4803      	ldr	r0, [pc, #12]	; (8009928 <Vector84+0x38>)
 800991a:	f002 f8e9 	bl	800baf0 <_trace_isr_leave>
}
 800991e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009922:	f7ff bafd 	b.w	8008f20 <_port_irq_epilogue>
 8009926:	bf00      	nop
 8009928:	0800ffd4 	.word	0x0800ffd4
 800992c:	40026000 	.word	0x40026000
 8009930:	200198d0 	.word	0x200198d0
	...

08009940 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8009940:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009942:	480d      	ldr	r0, [pc, #52]	; (8009978 <Vector80+0x38>)
 8009944:	f002 f8f4 	bl	800bb30 <_trace_isr_enter>
 8009948:	f002 fb8a 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800994c:	4b0b      	ldr	r3, [pc, #44]	; (800997c <Vector80+0x3c>)
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 800994e:	480c      	ldr	r0, [pc, #48]	; (8009980 <Vector80+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009950:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 8009952:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8009954:	0989      	lsrs	r1, r1, #6
 8009956:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 800995a:	018c      	lsls	r4, r1, #6
 800995c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 800995e:	b10a      	cbz	r2, 8009964 <Vector80+0x24>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8009960:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8009962:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009964:	f002 fb64 	bl	800c030 <_dbg_check_leave_isr>
 8009968:	4803      	ldr	r0, [pc, #12]	; (8009978 <Vector80+0x38>)
 800996a:	f002 f8c1 	bl	800baf0 <_trace_isr_leave>
}
 800996e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009972:	f7ff bad5 	b.w	8008f20 <_port_irq_epilogue>
 8009976:	bf00      	nop
 8009978:	08010088 	.word	0x08010088
 800997c:	40026000 	.word	0x40026000
 8009980:	200198d0 	.word	0x200198d0
	...

08009990 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8009990:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009992:	480c      	ldr	r0, [pc, #48]	; (80099c4 <Vector7C+0x34>)
 8009994:	f002 f8cc 	bl	800bb30 <_trace_isr_enter>
 8009998:	f002 fb62 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800999c:	4b0a      	ldr	r3, [pc, #40]	; (80099c8 <Vector7C+0x38>)
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 800999e:	480b      	ldr	r0, [pc, #44]	; (80099cc <Vector7C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80099a0:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 80099a2:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80099a4:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 80099a8:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 80099aa:	b10a      	cbz	r2, 80099b0 <Vector7C+0x20>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 80099ac:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80099ae:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80099b0:	f002 fb3e 	bl	800c030 <_dbg_check_leave_isr>
 80099b4:	4803      	ldr	r0, [pc, #12]	; (80099c4 <Vector7C+0x34>)
 80099b6:	f002 f89b 	bl	800baf0 <_trace_isr_leave>
}
 80099ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80099be:	f7ff baaf 	b.w	8008f20 <_port_irq_epilogue>
 80099c2:	bf00      	nop
 80099c4:	08010064 	.word	0x08010064
 80099c8:	40026000 	.word	0x40026000
 80099cc:	200198d0 	.word	0x200198d0

080099d0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80099d0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80099d2:	480d      	ldr	r0, [pc, #52]	; (8009a08 <Vector78+0x38>)
 80099d4:	f002 f8ac 	bl	800bb30 <_trace_isr_enter>
 80099d8:	f002 fb42 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80099dc:	4b0b      	ldr	r3, [pc, #44]	; (8009a0c <Vector78+0x3c>)
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 80099de:	480c      	ldr	r0, [pc, #48]	; (8009a10 <Vector78+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80099e0:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 80099e2:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80099e4:	0d89      	lsrs	r1, r1, #22
 80099e6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 80099ea:	058c      	lsls	r4, r1, #22
 80099ec:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 80099ee:	b10a      	cbz	r2, 80099f4 <Vector78+0x24>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 80099f0:	69c0      	ldr	r0, [r0, #28]
 80099f2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80099f4:	f002 fb1c 	bl	800c030 <_dbg_check_leave_isr>
 80099f8:	4803      	ldr	r0, [pc, #12]	; (8009a08 <Vector78+0x38>)
 80099fa:	f002 f879 	bl	800baf0 <_trace_isr_leave>
}
 80099fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009a02:	f7ff ba8d 	b.w	8008f20 <_port_irq_epilogue>
 8009a06:	bf00      	nop
 8009a08:	08010004 	.word	0x08010004
 8009a0c:	40026000 	.word	0x40026000
 8009a10:	200198d0 	.word	0x200198d0
	...

08009a20 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8009a20:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009a22:	480d      	ldr	r0, [pc, #52]	; (8009a58 <Vector74+0x38>)
 8009a24:	f002 f884 	bl	800bb30 <_trace_isr_enter>
 8009a28:	f002 fb1a 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009a2c:	4b0b      	ldr	r3, [pc, #44]	; (8009a5c <Vector74+0x3c>)
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 8009a2e:	480c      	ldr	r0, [pc, #48]	; (8009a60 <Vector74+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009a30:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 8009a32:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8009a34:	0c09      	lsrs	r1, r1, #16
 8009a36:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 8009a3a:	040c      	lsls	r4, r1, #16
 8009a3c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 8009a3e:	b10a      	cbz	r2, 8009a44 <Vector74+0x24>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8009a40:	6940      	ldr	r0, [r0, #20]
 8009a42:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009a44:	f002 faf4 	bl	800c030 <_dbg_check_leave_isr>
 8009a48:	4803      	ldr	r0, [pc, #12]	; (8009a58 <Vector74+0x38>)
 8009a4a:	f002 f851 	bl	800baf0 <_trace_isr_leave>
}
 8009a4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009a52:	f7ff ba65 	b.w	8008f20 <_port_irq_epilogue>
 8009a56:	bf00      	nop
 8009a58:	0800ffe0 	.word	0x0800ffe0
 8009a5c:	40026000 	.word	0x40026000
 8009a60:	200198d0 	.word	0x200198d0
	...

08009a70 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8009a70:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009a72:	480d      	ldr	r0, [pc, #52]	; (8009aa8 <Vector70+0x38>)
 8009a74:	f002 f85c 	bl	800bb30 <_trace_isr_enter>
 8009a78:	f002 faf2 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009a7c:	4b0b      	ldr	r3, [pc, #44]	; (8009aac <Vector70+0x3c>)
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 8009a7e:	480c      	ldr	r0, [pc, #48]	; (8009ab0 <Vector70+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009a80:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 8009a82:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8009a84:	0989      	lsrs	r1, r1, #6
 8009a86:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 8009a8a:	018c      	lsls	r4, r1, #6
 8009a8c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 8009a8e:	b10a      	cbz	r2, 8009a94 <Vector70+0x24>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8009a90:	68c0      	ldr	r0, [r0, #12]
 8009a92:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8009a94:	f002 facc 	bl	800c030 <_dbg_check_leave_isr>
 8009a98:	4803      	ldr	r0, [pc, #12]	; (8009aa8 <Vector70+0x38>)
 8009a9a:	f002 f829 	bl	800baf0 <_trace_isr_leave>
}
 8009a9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009aa2:	f7ff ba3d 	b.w	8008f20 <_port_irq_epilogue>
 8009aa6:	bf00      	nop
 8009aa8:	08010028 	.word	0x08010028
 8009aac:	40026000 	.word	0x40026000
 8009ab0:	200198d0 	.word	0x200198d0
	...

08009ac0 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8009ac0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8009ac2:	480c      	ldr	r0, [pc, #48]	; (8009af4 <Vector6C+0x34>)
 8009ac4:	f002 f834 	bl	800bb30 <_trace_isr_enter>
 8009ac8:	f002 faca 	bl	800c060 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009acc:	4b0a      	ldr	r3, [pc, #40]	; (8009af8 <Vector6C+0x38>)
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
 8009ace:	4a0b      	ldr	r2, [pc, #44]	; (8009afc <Vector6C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8009ad0:	6819      	ldr	r1, [r3, #0]
 8009ad2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 8009ad6:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 8009ad8:	6813      	ldr	r3, [r2, #0]
 8009ada:	b10b      	cbz	r3, 8009ae0 <Vector6C+0x20>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8009adc:	6850      	ldr	r0, [r2, #4]
 8009ade:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8009ae0:	f002 faa6 	bl	800c030 <_dbg_check_leave_isr>
 8009ae4:	4803      	ldr	r0, [pc, #12]	; (8009af4 <Vector6C+0x34>)
 8009ae6:	f002 f803 	bl	800baf0 <_trace_isr_leave>
}
 8009aea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8009aee:	f7ff ba17 	b.w	8008f20 <_port_irq_epilogue>
 8009af2:	bf00      	nop
 8009af4:	08010034 	.word	0x08010034
 8009af8:	40026000 	.word	0x40026000
 8009afc:	200198d0 	.word	0x200198d0

08009b00 <VectorC0>:
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8009b00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 8009b02:	4c39      	ldr	r4, [pc, #228]	; (8009be8 <VectorC0+0xe8>)

  OSAL_IRQ_PROLOGUE();
 8009b04:	4839      	ldr	r0, [pc, #228]	; (8009bec <VectorC0+0xec>)

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 8009b06:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8009b08:	695e      	ldr	r6, [r3, #20]

  OSAL_IRQ_PROLOGUE();
 8009b0a:	f002 f811 	bl	800bb30 <_trace_isr_enter>

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 8009b0e:	b2b5      	uxth	r5, r6

  OSAL_IRQ_PROLOGUE();
 8009b10:	f002 faa6 	bl	800c060 <_dbg_check_enter_isr>
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8009b14:	6b27      	ldr	r7, [r4, #48]	; 0x30
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8009b16:	6b61      	ldr	r1, [r4, #52]	; 0x34
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8009b18:	683a      	ldr	r2, [r7, #0]
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8009b1a:	f405 435f 	and.w	r3, r5, #57088	; 0xdf00
 8009b1e:	43db      	mvns	r3, r3
 8009b20:	614b      	str	r3, [r1, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8009b22:	6813      	ldr	r3, [r2, #0]
 8009b24:	f023 031f 	bic.w	r3, r3, #31
 8009b28:	6013      	str	r3, [r2, #0]
 8009b2a:	6813      	ldr	r3, [r2, #0]
 8009b2c:	07d8      	lsls	r0, r3, #31
 8009b2e:	d4fc      	bmi.n	8009b2a <VectorC0+0x2a>
 8009b30:	7a3a      	ldrb	r2, [r7, #8]
  dmaStreamDisable(i2cp->dmarx);
 8009b32:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8009b34:	687f      	ldr	r7, [r7, #4]
 8009b36:	233d      	movs	r3, #61	; 0x3d
 8009b38:	4093      	lsls	r3, r2
  dmaStreamDisable(i2cp->dmarx);
 8009b3a:	6802      	ldr	r2, [r0, #0]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8009b3c:	603b      	str	r3, [r7, #0]
  dmaStreamDisable(i2cp->dmarx);
 8009b3e:	6813      	ldr	r3, [r2, #0]
 8009b40:	f023 031f 	bic.w	r3, r3, #31
 8009b44:	6013      	str	r3, [r2, #0]
 8009b46:	6813      	ldr	r3, [r2, #0]
 8009b48:	f013 0301 	ands.w	r3, r3, #1
 8009b4c:	d1fb      	bne.n	8009b46 <VectorC0+0x46>
 8009b4e:	7a07      	ldrb	r7, [r0, #8]
 8009b50:	6840      	ldr	r0, [r0, #4]
 8009b52:	223d      	movs	r2, #61	; 0x3d
 8009b54:	40ba      	lsls	r2, r7
 8009b56:	6002      	str	r2, [r0, #0]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8009b58:	05ea      	lsls	r2, r5, #23
    i2cp->errors |= I2C_BUS_ERROR;
 8009b5a:	bf48      	it	mi
 8009b5c:	2301      	movmi	r3, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8009b5e:	05af      	lsls	r7, r5, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8009b60:	60a3      	str	r3, [r4, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8009b62:	bf44      	itt	mi
 8009b64:	f043 0302 	orrmi.w	r3, r3, #2
 8009b68:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8009b6a:	0568      	lsls	r0, r5, #21
 8009b6c:	d50a      	bpl.n	8009b84 <VectorC0+0x84>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8009b6e:	684a      	ldr	r2, [r1, #4]
 8009b70:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8009b74:	604a      	str	r2, [r1, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8009b76:	680a      	ldr	r2, [r1, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8009b78:	f043 0304 	orr.w	r3, r3, #4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8009b7c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8009b80:	600a      	str	r2, [r1, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8009b82:	60a3      	str	r3, [r4, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8009b84:	052a      	lsls	r2, r5, #20
    i2cp->errors |= I2C_OVERRUN;
 8009b86:	bf44      	itt	mi
 8009b88:	f043 0308 	orrmi.w	r3, r3, #8
 8009b8c:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8009b8e:	046f      	lsls	r7, r5, #17
    i2cp->errors |= I2C_TIMEOUT;
 8009b90:	bf44      	itt	mi
 8009b92:	f043 0320 	orrmi.w	r3, r3, #32
 8009b96:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8009b98:	04e8      	lsls	r0, r5, #19
 8009b9a:	d51c      	bpl.n	8009bd6 <VectorC0+0xd6>
    i2cp->errors |= I2C_PEC_ERROR;
 8009b9c:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8009ba0:	0431      	lsls	r1, r6, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 8009ba2:	60a3      	str	r3, [r4, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8009ba4:	d41c      	bmi.n	8009be0 <VectorC0+0xe0>
 8009ba6:	2320      	movs	r3, #32
 8009ba8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009bac:	f002 fa88 	bl	800c0c0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8009bb0:	f06f 0101 	mvn.w	r1, #1
 8009bb4:	480e      	ldr	r0, [pc, #56]	; (8009bf0 <VectorC0+0xf0>)
 8009bb6:	f002 f92b 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8009bba:	f002 fa69 	bl	800c090 <_dbg_check_unlock_from_isr>
 8009bbe:	2300      	movs	r3, #0
 8009bc0:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8009bc4:	f002 fa34 	bl	800c030 <_dbg_check_leave_isr>
 8009bc8:	4808      	ldr	r0, [pc, #32]	; (8009bec <VectorC0+0xec>)
 8009bca:	f001 ff91 	bl	800baf0 <_trace_isr_leave>
}
 8009bce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8009bd2:	f7ff b9a5 	b.w	8008f20 <_port_irq_epilogue>
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8009bd6:	0432      	lsls	r2, r6, #16
 8009bd8:	d402      	bmi.n	8009be0 <VectorC0+0xe0>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8009bda:	2b00      	cmp	r3, #0
 8009bdc:	d0f2      	beq.n	8009bc4 <VectorC0+0xc4>
 8009bde:	e7e2      	b.n	8009ba6 <VectorC0+0xa6>

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 8009be0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009be4:	60a3      	str	r3, [r4, #8]
 8009be6:	e7de      	b.n	8009ba6 <VectorC0+0xa6>
 8009be8:	2001aca4 	.word	0x2001aca4
 8009bec:	08010010 	.word	0x08010010
 8009bf0:	2001acc0 	.word	0x2001acc0
	...

08009c00 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8009c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8009c02:	4d40      	ldr	r5, [pc, #256]	; (8009d04 <VectorBC+0x104>)
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8009c04:	4840      	ldr	r0, [pc, #256]	; (8009d08 <VectorBC+0x108>)
 8009c06:	f001 ff93 	bl	800bb30 <_trace_isr_enter>
 8009c0a:	f002 fa29 	bl	800c060 <_dbg_check_enter_isr>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8009c0e:	6b6c      	ldr	r4, [r5, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8009c10:	4a3e      	ldr	r2, [pc, #248]	; (8009d0c <VectorBC+0x10c>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 8009c12:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 8009c14:	6966      	ldr	r6, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8009c16:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 8009c1a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8009c1e:	4293      	cmp	r3, r2
 8009c20:	d04e      	beq.n	8009cc0 <VectorBC+0xc0>
 8009c22:	d823      	bhi.n	8009c6c <VectorBC+0x6c>
 8009c24:	3a07      	subs	r2, #7
 8009c26:	4293      	cmp	r3, r2
 8009c28:	d03e      	beq.n	8009ca8 <VectorBC+0xa8>
 8009c2a:	3201      	adds	r2, #1
 8009c2c:	4293      	cmp	r3, r2
 8009c2e:	d110      	bne.n	8009c52 <VectorBC+0x52>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8009c30:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8009c32:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8009c34:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 8009c38:	681b      	ldr	r3, [r3, #0]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8009c3a:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8009c3c:	681a      	ldr	r2, [r3, #0]
 8009c3e:	f042 0201 	orr.w	r2, r2, #1
 8009c42:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8009c44:	6862      	ldr	r2, [r4, #4]
 8009c46:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009c4a:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8009c4c:	685b      	ldr	r3, [r3, #4]
 8009c4e:	2b01      	cmp	r3, #1
 8009c50:	d952      	bls.n	8009cf8 <VectorBC+0xf8>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8009c52:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 8009c56:	bf18      	it	ne
 8009c58:	69a3      	ldrne	r3, [r4, #24]

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8009c5a:	f002 f9e9 	bl	800c030 <_dbg_check_leave_isr>
 8009c5e:	482a      	ldr	r0, [pc, #168]	; (8009d08 <VectorBC+0x108>)
 8009c60:	f001 ff46 	bl	800baf0 <_trace_isr_leave>
}
 8009c64:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8009c68:	f7ff b95a 	b.w	8008f20 <_port_irq_epilogue>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8009c6c:	4a28      	ldr	r2, [pc, #160]	; (8009d10 <VectorBC+0x110>)
 8009c6e:	4293      	cmp	r3, r2
 8009c70:	d00f      	beq.n	8009c92 <VectorBC+0x92>
 8009c72:	3202      	adds	r2, #2
 8009c74:	4293      	cmp	r3, r2
 8009c76:	d1ec      	bne.n	8009c52 <VectorBC+0x52>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8009c78:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009c7a:	681b      	ldr	r3, [r3, #0]
 8009c7c:	685f      	ldr	r7, [r3, #4]
 8009c7e:	b327      	cbz	r7, 8009cca <VectorBC+0xca>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8009c80:	8c2a      	ldrh	r2, [r5, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8009c82:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8009c84:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8009c88:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8009c8c:	842a      	strh	r2, [r5, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8009c8e:	6023      	str	r3, [r4, #0]
 8009c90:	e7e3      	b.n	8009c5a <VectorBC+0x5a>
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8009c92:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8009c94:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8009c96:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8009c9a:	6812      	ldr	r2, [r2, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8009c9c:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8009c9e:	6813      	ldr	r3, [r2, #0]
 8009ca0:	f043 0301 	orr.w	r3, r3, #1
 8009ca4:	6013      	str	r3, [r2, #0]
 8009ca6:	e7d4      	b.n	8009c52 <VectorBC+0x52>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 8009ca8:	8c2b      	ldrh	r3, [r5, #32]
 8009caa:	0a1a      	lsrs	r2, r3, #8
 8009cac:	d00b      	beq.n	8009cc6 <VectorBC+0xc6>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 8009cae:	f003 0301 	and.w	r3, r3, #1
 8009cb2:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8009cb6:	f002 0206 	and.w	r2, r2, #6
 8009cba:	4313      	orrs	r3, r2
 8009cbc:	6123      	str	r3, [r4, #16]
 8009cbe:	e7c8      	b.n	8009c52 <VectorBC+0x52>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8009cc0:	8c2b      	ldrh	r3, [r5, #32]
 8009cc2:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8009cc6:	6123      	str	r3, [r4, #16]
 8009cc8:	e7c3      	b.n	8009c52 <VectorBC+0x52>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8009cca:	6863      	ldr	r3, [r4, #4]
 8009ccc:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8009cd0:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 8009cd2:	6823      	ldr	r3, [r4, #0]
 8009cd4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8009cd8:	6023      	str	r3, [r4, #0]
 8009cda:	2320      	movs	r3, #32
 8009cdc:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009ce0:	f002 f9ee 	bl	800c0c0 <_dbg_check_lock_from_isr>
 8009ce4:	4639      	mov	r1, r7
 8009ce6:	f105 001c 	add.w	r0, r5, #28
 8009cea:	f002 f891 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8009cee:	f002 f9cf 	bl	800c090 <_dbg_check_unlock_from_isr>
 8009cf2:	f387 8811 	msr	BASEPRI, r7
 8009cf6:	e7ac      	b.n	8009c52 <VectorBC+0x52>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 8009cf8:	6823      	ldr	r3, [r4, #0]
 8009cfa:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009cfe:	6023      	str	r3, [r4, #0]
 8009d00:	e7a7      	b.n	8009c52 <VectorBC+0x52>
 8009d02:	bf00      	nop
 8009d04:	2001aca4 	.word	0x2001aca4
 8009d08:	08010094 	.word	0x08010094
 8009d0c:	00030008 	.word	0x00030008
 8009d10:	00070082 	.word	0x00070082
	...

08009d20 <Vector88>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC_HANDLER) {
 8009d20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();
 8009d22:	4828      	ldr	r0, [pc, #160]	; (8009dc4 <Vector88+0xa4>)
 8009d24:	f001 ff04 	bl	800bb30 <_trace_isr_enter>
 8009d28:	f002 f99a 	bl	800c060 <_dbg_check_enter_isr>

#if STM32_ADC_USE_ADC1
  sr = ADC1->SR;
 8009d2c:	4b26      	ldr	r3, [pc, #152]	; (8009dc8 <Vector88+0xa8>)
 8009d2e:	681a      	ldr	r2, [r3, #0]
  ADC1->SR = 0;
 8009d30:	2100      	movs	r1, #0
 8009d32:	6019      	str	r1, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 8009d34:	0693      	lsls	r3, r2, #26
 8009d36:	d538      	bpl.n	8009daa <Vector88+0x8a>
 8009d38:	4c24      	ldr	r4, [pc, #144]	; (8009dcc <Vector88+0xac>)
 8009d3a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8009d3c:	680a      	ldr	r2, [r1, #0]
 8009d3e:	6853      	ldr	r3, [r2, #4]
 8009d40:	2b00      	cmp	r3, #0
 8009d42:	d032      	beq.n	8009daa <Vector88+0x8a>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 8009d44:	6925      	ldr	r5, [r4, #16]
 8009d46:	2d00      	cmp	r5, #0
 8009d48:	d02f      	beq.n	8009daa <Vector88+0x8a>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009d4a:	6813      	ldr	r3, [r2, #0]
 8009d4c:	f023 031f 	bic.w	r3, r3, #31
 8009d50:	6013      	str	r3, [r2, #0]
 8009d52:	6813      	ldr	r3, [r2, #0]
 8009d54:	f013 0301 	ands.w	r3, r3, #1
 8009d58:	d1fb      	bne.n	8009d52 <Vector88+0x32>
 8009d5a:	7a08      	ldrb	r0, [r1, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8009d5c:	68ae      	ldr	r6, [r5, #8]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009d5e:	684f      	ldr	r7, [r1, #4]
  adcp->adc->CR1 = 0;
 8009d60:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8009d62:	4d1a      	ldr	r5, [pc, #104]	; (8009dcc <Vector88+0xac>)
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009d64:	213d      	movs	r1, #61	; 0x3d
 8009d66:	fa01 f000 	lsl.w	r0, r1, r0
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8009d6a:	2101      	movs	r1, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009d6c:	6038      	str	r0, [r7, #0]
  adcp->adc->CR1 = 0;
 8009d6e:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
 8009d70:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8009d72:	6091      	str	r1, [r2, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8009d74:	b316      	cbz	r6, 8009dbc <Vector88+0x9c>
 8009d76:	2305      	movs	r3, #5
 8009d78:	702b      	strb	r3, [r5, #0]
 8009d7a:	4628      	mov	r0, r5
 8009d7c:	47b0      	blx	r6
 8009d7e:	782b      	ldrb	r3, [r5, #0]
 8009d80:	2b05      	cmp	r3, #5
 8009d82:	bf04      	itt	eq
 8009d84:	2302      	moveq	r3, #2
 8009d86:	702b      	strbeq	r3, [r5, #0]
 8009d88:	2300      	movs	r3, #0
 8009d8a:	6123      	str	r3, [r4, #16]
 8009d8c:	2320      	movs	r3, #32
 8009d8e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009d92:	f002 f995 	bl	800c0c0 <_dbg_check_lock_from_isr>
 8009d96:	f04f 31ff 	mov.w	r1, #4294967295
 8009d9a:	480d      	ldr	r0, [pc, #52]	; (8009dd0 <Vector88+0xb0>)
 8009d9c:	f002 f838 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8009da0:	f002 f976 	bl	800c090 <_dbg_check_unlock_from_isr>
 8009da4:	2300      	movs	r3, #0
 8009da6:	f383 8811 	msr	BASEPRI, r3
#if defined(STM32_ADC_ADC3_IRQ_HOOK)
  STM32_ADC_ADC3_IRQ_HOOK
#endif
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 8009daa:	f002 f941 	bl	800c030 <_dbg_check_leave_isr>
 8009dae:	4805      	ldr	r0, [pc, #20]	; (8009dc4 <Vector88+0xa4>)
 8009db0:	f001 fe9e 	bl	800baf0 <_trace_isr_leave>
}
 8009db4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#if defined(STM32_ADC_ADC3_IRQ_HOOK)
  STM32_ADC_ADC3_IRQ_HOOK
#endif
#endif /* STM32_ADC_USE_ADC3 */

  OSAL_IRQ_EPILOGUE();
 8009db8:	f7ff b8b2 	b.w	8008f20 <_port_irq_epilogue>
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8009dbc:	2302      	movs	r3, #2
 8009dbe:	612e      	str	r6, [r5, #16]
 8009dc0:	702b      	strb	r3, [r5, #0]
 8009dc2:	e7e3      	b.n	8009d8c <Vector88+0x6c>
 8009dc4:	08010040 	.word	0x08010040
 8009dc8:	40012000 	.word	0x40012000
 8009dcc:	2001a9e8 	.word	0x2001a9e8
 8009dd0:	2001a9fc 	.word	0x2001a9fc
	...

08009de0 <adc_lld_serve_rx_interrupt.lto_priv.136>:
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8009de0:	f011 0f0c 	tst.w	r1, #12
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 8009de4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009de8:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8009dea:	d034      	beq.n	8009e56 <adc_lld_serve_rx_interrupt.lto_priv.136+0x76>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009dec:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8009dee:	6803      	ldr	r3, [r0, #0]
 8009df0:	681a      	ldr	r2, [r3, #0]
 8009df2:	f022 021f 	bic.w	r2, r2, #31
 8009df6:	601a      	str	r2, [r3, #0]
 8009df8:	6819      	ldr	r1, [r3, #0]
 8009dfa:	f011 0101 	ands.w	r1, r1, #1
 8009dfe:	d1fb      	bne.n	8009df8 <adc_lld_serve_rx_interrupt.lto_priv.136+0x18>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8009e00:	6922      	ldr	r2, [r4, #16]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009e02:	7a07      	ldrb	r7, [r0, #8]
 8009e04:	6846      	ldr	r6, [r0, #4]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8009e06:	6895      	ldr	r5, [r2, #8]
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 8009e08:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009e0a:	223d      	movs	r2, #61	; 0x3d
 8009e0c:	40ba      	lsls	r2, r7
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8009e0e:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009e10:	6032      	str	r2, [r6, #0]
  adcp->adc->CR1 = 0;
 8009e12:	6059      	str	r1, [r3, #4]
  adcp->adc->CR2 = 0;
 8009e14:	6099      	str	r1, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8009e16:	6098      	str	r0, [r3, #8]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8009e18:	2d00      	cmp	r5, #0
 8009e1a:	d035      	beq.n	8009e88 <adc_lld_serve_rx_interrupt.lto_priv.136+0xa8>
 8009e1c:	2305      	movs	r3, #5
 8009e1e:	7023      	strb	r3, [r4, #0]
 8009e20:	4620      	mov	r0, r4
 8009e22:	47a8      	blx	r5
 8009e24:	7823      	ldrb	r3, [r4, #0]
 8009e26:	2b05      	cmp	r3, #5
 8009e28:	bf04      	itt	eq
 8009e2a:	2302      	moveq	r3, #2
 8009e2c:	7023      	strbeq	r3, [r4, #0]
 8009e2e:	2300      	movs	r3, #0
 8009e30:	6123      	str	r3, [r4, #16]
 8009e32:	2320      	movs	r3, #32
 8009e34:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009e38:	f002 f942 	bl	800c0c0 <_dbg_check_lock_from_isr>
 8009e3c:	f104 0014 	add.w	r0, r4, #20
 8009e40:	f04f 31ff 	mov.w	r1, #4294967295
 8009e44:	f001 ffe4 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8009e48:	f002 f922 	bl	800c090 <_dbg_check_unlock_from_isr>
 8009e4c:	2300      	movs	r3, #0
 8009e4e:	f383 8811 	msr	BASEPRI, r3
 8009e52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 8009e56:	6905      	ldr	r5, [r0, #16]
 8009e58:	b1a5      	cbz	r5, 8009e84 <adc_lld_serve_rx_interrupt.lto_priv.136+0xa4>

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8009e5a:	068a      	lsls	r2, r1, #26
 8009e5c:	d510      	bpl.n	8009e80 <adc_lld_serve_rx_interrupt.lto_priv.136+0xa0>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8009e5e:	782b      	ldrb	r3, [r5, #0]
 8009e60:	b1fb      	cbz	r3, 8009ea2 <adc_lld_serve_rx_interrupt.lto_priv.136+0xc2>
 8009e62:	686b      	ldr	r3, [r5, #4]
 8009e64:	b173      	cbz	r3, 8009e84 <adc_lld_serve_rx_interrupt.lto_priv.136+0xa4>
 8009e66:	68c2      	ldr	r2, [r0, #12]
 8009e68:	2a01      	cmp	r2, #1
 8009e6a:	d94f      	bls.n	8009f0c <adc_lld_serve_rx_interrupt.lto_priv.136+0x12c>
 8009e6c:	8869      	ldrh	r1, [r5, #2]
 8009e6e:	6884      	ldr	r4, [r0, #8]
 8009e70:	0852      	lsrs	r2, r2, #1
 8009e72:	fb02 f101 	mul.w	r1, r2, r1
 8009e76:	eb04 0141 	add.w	r1, r4, r1, lsl #1
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8009e7a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8009e7e:	4718      	bx	r3
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8009e80:	06cb      	lsls	r3, r1, #27
 8009e82:	d405      	bmi.n	8009e90 <adc_lld_serve_rx_interrupt.lto_priv.136+0xb0>
 8009e84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8009e88:	2302      	movs	r3, #2
 8009e8a:	6125      	str	r5, [r4, #16]
 8009e8c:	7023      	strb	r3, [r4, #0]
 8009e8e:	e7d0      	b.n	8009e32 <adc_lld_serve_rx_interrupt.lto_priv.136+0x52>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8009e90:	686b      	ldr	r3, [r5, #4]
 8009e92:	2b00      	cmp	r3, #0
 8009e94:	d0f6      	beq.n	8009e84 <adc_lld_serve_rx_interrupt.lto_priv.136+0xa4>
 8009e96:	68c2      	ldr	r2, [r0, #12]
 8009e98:	6881      	ldr	r1, [r0, #8]
 8009e9a:	0852      	lsrs	r2, r2, #1
      }
    }
  }
}
 8009e9c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8009ea0:	4718      	bx	r3
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009ea2:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8009ea4:	6802      	ldr	r2, [r0, #0]
 8009ea6:	6813      	ldr	r3, [r2, #0]
 8009ea8:	f023 031f 	bic.w	r3, r3, #31
 8009eac:	6013      	str	r3, [r2, #0]
 8009eae:	6813      	ldr	r3, [r2, #0]
 8009eb0:	f013 0301 	ands.w	r3, r3, #1
 8009eb4:	d1fb      	bne.n	8009eae <adc_lld_serve_rx_interrupt.lto_priv.136+0xce>
 8009eb6:	7a07      	ldrb	r7, [r0, #8]
 8009eb8:	6846      	ldr	r6, [r0, #4]
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8009eba:	686d      	ldr	r5, [r5, #4]
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 8009ebc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009ebe:	213d      	movs	r1, #61	; 0x3d
 8009ec0:	40b9      	lsls	r1, r7
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8009ec2:	2001      	movs	r0, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8009ec4:	6031      	str	r1, [r6, #0]
  adcp->adc->CR1 = 0;
 8009ec6:	6053      	str	r3, [r2, #4]
  adcp->adc->CR2 = 0;
 8009ec8:	6093      	str	r3, [r2, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8009eca:	6090      	str	r0, [r2, #8]
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8009ecc:	b1cd      	cbz	r5, 8009f02 <adc_lld_serve_rx_interrupt.lto_priv.136+0x122>
 8009ece:	2304      	movs	r3, #4
 8009ed0:	7023      	strb	r3, [r4, #0]
 8009ed2:	68e2      	ldr	r2, [r4, #12]
 8009ed4:	68a1      	ldr	r1, [r4, #8]
 8009ed6:	4620      	mov	r0, r4
 8009ed8:	47a8      	blx	r5
 8009eda:	7823      	ldrb	r3, [r4, #0]
 8009edc:	2b04      	cmp	r3, #4
 8009ede:	d010      	beq.n	8009f02 <adc_lld_serve_rx_interrupt.lto_priv.136+0x122>
 8009ee0:	2320      	movs	r3, #32
 8009ee2:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009ee6:	f002 f8eb 	bl	800c0c0 <_dbg_check_lock_from_isr>
 8009eea:	f104 0014 	add.w	r0, r4, #20
 8009eee:	2100      	movs	r1, #0
 8009ef0:	f001 ff8e 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8009ef4:	f002 f8cc 	bl	800c090 <_dbg_check_unlock_from_isr>
 8009ef8:	2300      	movs	r3, #0
 8009efa:	f383 8811 	msr	BASEPRI, r3
 8009efe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009f02:	2202      	movs	r2, #2
 8009f04:	2300      	movs	r3, #0
 8009f06:	7022      	strb	r2, [r4, #0]
 8009f08:	6123      	str	r3, [r4, #16]
 8009f0a:	e7e9      	b.n	8009ee0 <adc_lld_serve_rx_interrupt.lto_priv.136+0x100>
 8009f0c:	6881      	ldr	r1, [r0, #8]
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8009f0e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {

      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8009f12:	4718      	bx	r3
	...

08009f20 <i2c_lld_serve_tx_end_irq.lto_priv.108>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8009f20:	f011 0f0c 	tst.w	r1, #12
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8009f24:	b510      	push	{r4, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8009f26:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8009f28:	d112      	bne.n	8009f50 <i2c_lld_serve_tx_end_irq.lto_priv.108+0x30>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 8009f2a:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8009f2c:	680a      	ldr	r2, [r1, #0]
 8009f2e:	6813      	ldr	r3, [r2, #0]
 8009f30:	f023 031f 	bic.w	r3, r3, #31
 8009f34:	6013      	str	r3, [r2, #0]
 8009f36:	6813      	ldr	r3, [r2, #0]
 8009f38:	07db      	lsls	r3, r3, #31
 8009f3a:	d4fc      	bmi.n	8009f36 <i2c_lld_serve_tx_end_irq.lto_priv.108+0x16>
 8009f3c:	7a08      	ldrb	r0, [r1, #8]
 8009f3e:	684a      	ldr	r2, [r1, #4]
 8009f40:	233d      	movs	r3, #61	; 0x3d
 8009f42:	4083      	lsls	r3, r0
 8009f44:	6013      	str	r3, [r2, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8009f46:	6863      	ldr	r3, [r4, #4]
 8009f48:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8009f4c:	6063      	str	r3, [r4, #4]
 8009f4e:	bd10      	pop	{r4, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8009f50:	4801      	ldr	r0, [pc, #4]	; (8009f58 <i2c_lld_serve_tx_end_irq.lto_priv.108+0x38>)
 8009f52:	f001 fe0d 	bl	800bb70 <chSysHalt>
 8009f56:	bf00      	nop
 8009f58:	0800fb48 	.word	0x0800fb48
 8009f5c:	00000000 	.word	0x00000000

08009f60 <i2c_lld_serve_rx_end_irq.lto_priv.107>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8009f60:	f011 0f0c 	tst.w	r1, #12
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8009f64:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8009f66:	6b42      	ldr	r2, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8009f68:	d12a      	bne.n	8009fc0 <i2c_lld_serve_rx_end_irq.lto_priv.107+0x60>
 8009f6a:	4605      	mov	r5, r0
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 8009f6c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8009f6e:	6803      	ldr	r3, [r0, #0]
 8009f70:	6819      	ldr	r1, [r3, #0]
 8009f72:	f021 011f 	bic.w	r1, r1, #31
 8009f76:	6019      	str	r1, [r3, #0]
 8009f78:	6819      	ldr	r1, [r3, #0]
 8009f7a:	f011 0401 	ands.w	r4, r1, #1
 8009f7e:	d1fb      	bne.n	8009f78 <i2c_lld_serve_rx_end_irq.lto_priv.107+0x18>
 8009f80:	7a06      	ldrb	r6, [r0, #8]
 8009f82:	6841      	ldr	r1, [r0, #4]
 8009f84:	233d      	movs	r3, #61	; 0x3d
 8009f86:	40b3      	lsls	r3, r6
 8009f88:	600b      	str	r3, [r1, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 8009f8a:	6853      	ldr	r3, [r2, #4]
 8009f8c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8009f90:	6053      	str	r3, [r2, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8009f92:	6813      	ldr	r3, [r2, #0]
 8009f94:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009f98:	6013      	str	r3, [r2, #0]
  dp->CR1 |= I2C_CR1_STOP;
 8009f9a:	6813      	ldr	r3, [r2, #0]
 8009f9c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8009fa0:	6013      	str	r3, [r2, #0]
 8009fa2:	2320      	movs	r3, #32
 8009fa4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009fa8:	f002 f88a 	bl	800c0c0 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8009fac:	4621      	mov	r1, r4
 8009fae:	f105 001c 	add.w	r0, r5, #28
 8009fb2:	f001 ff2d 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8009fb6:	f002 f86b 	bl	800c090 <_dbg_check_unlock_from_isr>
 8009fba:	f384 8811 	msr	BASEPRI, r4
 8009fbe:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8009fc0:	4801      	ldr	r0, [pc, #4]	; (8009fc8 <i2c_lld_serve_rx_end_irq.lto_priv.107+0x68>)
 8009fc2:	f001 fdd5 	bl	800bb70 <chSysHalt>
 8009fc6:	bf00      	nop
 8009fc8:	0800fb48 	.word	0x0800fb48
 8009fcc:	00000000 	.word	0x00000000

08009fd0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8009fd0:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8009fd2:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8009fd6:	4604      	mov	r4, r0

  (void)ep;
  switch (usbp->ep0state) {
 8009fd8:	2b06      	cmp	r3, #6
 8009fda:	d805      	bhi.n	8009fe8 <_usb_ep0out+0x18>
 8009fdc:	e8df f003 	tbb	[pc, r3]
 8009fe0:	1a040404 	.word	0x1a040404
 8009fe4:	0407      	.short	0x0407
 8009fe6:	25          	.byte	0x25
 8009fe7:	00          	.byte	0x00
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8009fe8:	481b      	ldr	r0, [pc, #108]	; (800a058 <_usb_ep0out+0x88>)
 8009fea:	f001 fdc1 	bl	800bb70 <chSysHalt>

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 8009fee:	2305      	movs	r3, #5
 8009ff0:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
 8009ff4:	2320      	movs	r3, #32
 8009ff6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8009ffa:	f002 f861 	bl	800c0c0 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 8009ffe:	2200      	movs	r2, #0
 800a000:	4620      	mov	r0, r4
 800a002:	4611      	mov	r1, r2
 800a004:	f000 fa5c 	bl	800a4c0 <usbStartTransmitI.constprop.43>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800a008:	f002 f842 	bl	800c090 <_dbg_check_unlock_from_isr>
 800a00c:	2300      	movs	r3, #0
 800a00e:	f383 8811 	msr	BASEPRI, r3
 800a012:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 800a014:	68c3      	ldr	r3, [r0, #12]
 800a016:	699b      	ldr	r3, [r3, #24]
 800a018:	685b      	ldr	r3, [r3, #4]
 800a01a:	b9e3      	cbnz	r3, 800a056 <_usb_ep0out+0x86>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800a01c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a01e:	b103      	cbz	r3, 800a022 <_usb_ep0out+0x52>
      usbp->ep0endcb(usbp);
 800a020:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800a022:	2300      	movs	r3, #0
 800a024:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a028:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800a02a:	6d43      	ldr	r3, [r0, #84]	; 0x54
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800a02c:	6841      	ldr	r1, [r0, #4]
 800a02e:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800a032:	680d      	ldr	r5, [r1, #0]
 800a034:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800a038:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800a03c:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800a040:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800a044:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800a048:	b10d      	cbz	r5, 800a04e <_usb_ep0out+0x7e>
 800a04a:	2106      	movs	r1, #6
 800a04c:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 800a04e:	2306      	movs	r3, #6
 800a050:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a054:	bd38      	pop	{r3, r4, r5, pc}
 800a056:	bd38      	pop	{r3, r4, r5, pc}
 800a058:	08010070 	.word	0x08010070
 800a05c:	00000000 	.word	0x00000000

0800a060 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800a060:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800a062:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 800a066:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800a068:	2b06      	cmp	r3, #6
 800a06a:	d805      	bhi.n	800a078 <_usb_ep0in+0x18>
 800a06c:	e8df f003 	tbb	[pc, r3]
 800a070:	04170704 	.word	0x04170704
 800a074:	2a04      	.short	0x2a04
 800a076:	31          	.byte	0x31
 800a077:	00          	.byte	0x00
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 800a078:	482a      	ldr	r0, [pc, #168]	; (800a124 <_usb_ep0in+0xc4>)
 800a07a:	f001 fd79 	bl	800bb70 <chSysHalt>
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800a07e:	f890 104b 	ldrb.w	r1, [r0, #75]	; 0x4b
 800a082:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
 800a086:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 800a088:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800a08c:	4293      	cmp	r3, r2
 800a08e:	d906      	bls.n	800a09e <_usb_ep0in+0x3e>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 800a090:	68c3      	ldr	r3, [r0, #12]
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800a092:	8a1d      	ldrh	r5, [r3, #16]
 800a094:	fbb2 f3f5 	udiv	r3, r2, r5
 800a098:	fb05 2513 	mls	r5, r5, r3, r2
 800a09c:	b37d      	cbz	r5, 800a0fe <_usb_ep0in+0x9e>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 800a09e:	2303      	movs	r3, #3
 800a0a0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a0a4:	2320      	movs	r3, #32
 800a0a6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800a0aa:	f002 f809 	bl	800c0c0 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0, NULL, 0);
 800a0ae:	2200      	movs	r2, #0
 800a0b0:	4620      	mov	r0, r4
 800a0b2:	4611      	mov	r1, r2
 800a0b4:	f000 f9e4 	bl	800a480 <usbStartReceiveI.constprop.44>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800a0b8:	f001 ffea 	bl	800c090 <_dbg_check_unlock_from_isr>
 800a0bc:	2300      	movs	r3, #0
 800a0be:	f383 8811 	msr	BASEPRI, r3
 800a0c2:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 800a0c4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a0c6:	b103      	cbz	r3, 800a0ca <_usb_ep0in+0x6a>
      usbp->ep0endcb(usbp);
 800a0c8:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800a0ca:	2300      	movs	r3, #0
 800a0cc:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a0d0:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800a0d2:	6d43      	ldr	r3, [r0, #84]	; 0x54
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800a0d4:	6841      	ldr	r1, [r0, #4]
 800a0d6:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800a0da:	680d      	ldr	r5, [r1, #0]
 800a0dc:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800a0e0:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800a0e4:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800a0e8:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800a0ec:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800a0f0:	b10d      	cbz	r5, 800a0f6 <_usb_ep0in+0x96>
 800a0f2:	2106      	movs	r1, #6
 800a0f4:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 800a0f6:	2306      	movs	r3, #6
 800a0f8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a0fc:	bd38      	pop	{r3, r4, r5, pc}
 800a0fe:	2320      	movs	r3, #32
 800a100:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800a104:	f001 ffdc 	bl	800c0c0 <_dbg_check_lock_from_isr>
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 800a108:	462a      	mov	r2, r5
 800a10a:	4629      	mov	r1, r5
 800a10c:	4620      	mov	r0, r4
 800a10e:	f000 f9d7 	bl	800a4c0 <usbStartTransmitI.constprop.43>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800a112:	f001 ffbd 	bl	800c090 <_dbg_check_unlock_from_isr>
 800a116:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 800a11a:	2302      	movs	r3, #2
 800a11c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800a120:	bd38      	pop	{r3, r4, r5, pc}
 800a122:	bf00      	nop
 800a124:	0800fff8 	.word	0x0800fff8
	...

0800a130 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 800a130:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800a134:	f002 0a03 	and.w	sl, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800a138:	f3c2 0880 	ubfx	r8, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800a13c:	f3c2 0cc1 	ubfx	ip, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 800a140:	f3c2 1e41 	ubfx	lr, r2, #5, #2
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 800a144:	46d1      	mov	r9, sl
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800a146:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  uint32_t bit     = 0;
 800a14a:	2700      	movs	r7, #0
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800a14c:	f04f 0b0f 	mov.w	fp, #15
 800a150:	e00f      	b.n	800a172 <_pal_lld_setgroupmode+0x42>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800a152:	6a04      	ldr	r4, [r0, #32]
 800a154:	ea24 0303 	bic.w	r3, r4, r3
 800a158:	431d      	orrs	r5, r3
 800a15a:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 800a15c:	0849      	lsrs	r1, r1, #1
 800a15e:	d039      	beq.n	800a1d4 <_pal_lld_setgroupmode+0xa4>
      return;
    otyper <<= 1;
 800a160:	ea4f 0848 	mov.w	r8, r8, lsl #1
    ospeedr <<= 2;
 800a164:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    pupdr <<= 2;
 800a168:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
    moder <<= 2;
 800a16c:	ea4f 0989 	mov.w	r9, r9, lsl #2
    bit++;
 800a170:	3701      	adds	r7, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800a172:	07cb      	lsls	r3, r1, #31
 800a174:	d5f2      	bpl.n	800a15c <_pal_lld_setgroupmode+0x2c>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800a176:	6843      	ldr	r3, [r0, #4]
 800a178:	2401      	movs	r4, #1
 800a17a:	40bc      	lsls	r4, r7
 800a17c:	ea23 0304 	bic.w	r3, r3, r4
 800a180:	ea43 0308 	orr.w	r3, r3, r8
 800a184:	6043      	str	r3, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800a186:	2503      	movs	r5, #3
 800a188:	007c      	lsls	r4, r7, #1
 800a18a:	6883      	ldr	r3, [r0, #8]
 800a18c:	fa05 f404 	lsl.w	r4, r5, r4
 800a190:	43e4      	mvns	r4, r4
 800a192:	4023      	ands	r3, r4
 800a194:	ea43 030c 	orr.w	r3, r3, ip
 800a198:	6083      	str	r3, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800a19a:	68c5      	ldr	r5, [r0, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800a19c:	f007 0307 	and.w	r3, r7, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800a1a0:	4025      	ands	r5, r4
 800a1a2:	ea45 050e 	orr.w	r5, r5, lr
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800a1a6:	009b      	lsls	r3, r3, #2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800a1a8:	f1ba 0f02 	cmp.w	sl, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800a1ac:	60c5      	str	r5, [r0, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800a1ae:	fa02 f503 	lsl.w	r5, r2, r3
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800a1b2:	fa0b f303 	lsl.w	r3, fp, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 800a1b6:	d00f      	beq.n	800a1d8 <_pal_lld_setgroupmode+0xa8>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800a1b8:	6806      	ldr	r6, [r0, #0]
 800a1ba:	4034      	ands	r4, r6
 800a1bc:	ea44 0409 	orr.w	r4, r4, r9
        if (bit < 8)
 800a1c0:	2f07      	cmp	r7, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800a1c2:	6004      	str	r4, [r0, #0]
        if (bit < 8)
 800a1c4:	d9c5      	bls.n	800a152 <_pal_lld_setgroupmode+0x22>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800a1c6:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800a1c8:	ea24 0303 	bic.w	r3, r4, r3
 800a1cc:	431d      	orrs	r5, r3
      }
    }
    mask >>= 1;
    if (!mask)
 800a1ce:	0849      	lsrs	r1, r1, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800a1d0:	6245      	str	r5, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 800a1d2:	d1c5      	bne.n	800a160 <_pal_lld_setgroupmode+0x30>
 800a1d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800a1d8:	2f07      	cmp	r7, #7
 800a1da:	d80a      	bhi.n	800a1f2 <_pal_lld_setgroupmode+0xc2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800a1dc:	6a06      	ldr	r6, [r0, #32]
 800a1de:	ea26 0303 	bic.w	r3, r6, r3
 800a1e2:	431d      	orrs	r5, r3
 800a1e4:	6205      	str	r5, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 800a1e6:	6803      	ldr	r3, [r0, #0]
 800a1e8:	401c      	ands	r4, r3
 800a1ea:	ea44 0409 	orr.w	r4, r4, r9
 800a1ee:	6004      	str	r4, [r0, #0]
 800a1f0:	e7b4      	b.n	800a15c <_pal_lld_setgroupmode+0x2c>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800a1f2:	6a46      	ldr	r6, [r0, #36]	; 0x24
 800a1f4:	ea26 0303 	bic.w	r3, r6, r3
 800a1f8:	431d      	orrs	r5, r3
 800a1fa:	6245      	str	r5, [r0, #36]	; 0x24
 800a1fc:	e7f3      	b.n	800a1e6 <_pal_lld_setgroupmode+0xb6>
 800a1fe:	bf00      	nop

0800a200 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 800a200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);
 800a202:	b378      	cbz	r0, 800a264 <dmaStreamRelease+0x64>

  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1U << dmastp->selfindex)) != 0U,
 800a204:	4e19      	ldr	r6, [pc, #100]	; (800a26c <dmaStreamRelease+0x6c>)
 800a206:	7a43      	ldrb	r3, [r0, #9]
 800a208:	6832      	ldr	r2, [r6, #0]
 800a20a:	2101      	movs	r1, #1
 800a20c:	fa01 f303 	lsl.w	r3, r1, r3
 800a210:	4213      	tst	r3, r2
 800a212:	d027      	beq.n	800a264 <dmaStreamRelease+0x64>
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 800a214:	7a83      	ldrb	r3, [r0, #10]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800a216:	4f16      	ldr	r7, [pc, #88]	; (800a270 <dmaStreamRelease+0x70>)
 800a218:	095c      	lsrs	r4, r3, #5
 800a21a:	3420      	adds	r4, #32
 800a21c:	f003 051f 	and.w	r5, r3, #31
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800a220:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800a224:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800a228:	fa01 f505 	lsl.w	r5, r1, r5
 800a22c:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800a230:	2400      	movs	r4, #0
 800a232:	f883 4300 	strb.w	r4, [r3, #768]	; 0x300

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 800a236:	7a43      	ldrb	r3, [r0, #9]
 800a238:	fa01 f303 	lsl.w	r3, r1, r3
 800a23c:	ea22 0303 	bic.w	r3, r2, r3

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 800a240:	f013 0fff 	tst.w	r3, #255	; 0xff

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 800a244:	6033      	str	r3, [r6, #0]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 800a246:	d104      	bne.n	800a252 <dmaStreamRelease+0x52>
    rccDisableDMA1(false);
 800a248:	490a      	ldr	r1, [pc, #40]	; (800a274 <dmaStreamRelease+0x74>)
 800a24a:	6b0a      	ldr	r2, [r1, #48]	; 0x30
 800a24c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800a250:	630a      	str	r2, [r1, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 800a252:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
 800a256:	d104      	bne.n	800a262 <dmaStreamRelease+0x62>
    rccDisableDMA2(false);
 800a258:	4a06      	ldr	r2, [pc, #24]	; (800a274 <dmaStreamRelease+0x74>)
 800a25a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800a25c:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 800a260:	6313      	str	r3, [r2, #48]	; 0x30
 800a262:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {

  osalDbgCheck(dmastp != NULL);
 800a264:	4804      	ldr	r0, [pc, #16]	; (800a278 <dmaStreamRelease+0x78>)
 800a266:	f001 fc83 	bl	800bb70 <chSysHalt>
 800a26a:	bf00      	nop
 800a26c:	20019974 	.word	0x20019974
 800a270:	e000e100 	.word	0xe000e100
 800a274:	40023800 	.word	0x40023800
 800a278:	0800ffc0 	.word	0x0800ffc0
 800a27c:	00000000 	.word	0x00000000

0800a280 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 800a280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);
 800a282:	2800      	cmp	r0, #0
 800a284:	d051      	beq.n	800a32a <dmaStreamAllocate+0xaa>

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 800a286:	4f2a      	ldr	r7, [pc, #168]	; (800a330 <dmaStreamAllocate+0xb0>)
 800a288:	7a46      	ldrb	r6, [r0, #9]
 800a28a:	683d      	ldr	r5, [r7, #0]
 800a28c:	2401      	movs	r4, #1
 800a28e:	fa04 fe06 	lsl.w	lr, r4, r6
 800a292:	ea1e 0f05 	tst.w	lr, r5
 800a296:	d144      	bne.n	800a322 <dmaStreamAllocate+0xa2>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800a298:	4c26      	ldr	r4, [pc, #152]	; (800a334 <dmaStreamAllocate+0xb4>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 800a29a:	ea4e 0505 	orr.w	r5, lr, r5
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800a29e:	eb04 0ec6 	add.w	lr, r4, r6, lsl #3
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 800a2a2:	f015 0fff 	tst.w	r5, #255	; 0xff
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 800a2a6:	603d      	str	r5, [r7, #0]
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800a2a8:	f844 2036 	str.w	r2, [r4, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800a2ac:	f8ce 3004 	str.w	r3, [lr, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 800a2b0:	d004      	beq.n	800a2bc <dmaStreamAllocate+0x3c>
    rccEnableDMA1(false);
 800a2b2:	4c21      	ldr	r4, [pc, #132]	; (800a338 <dmaStreamAllocate+0xb8>)
 800a2b4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a2b6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800a2ba:	6323      	str	r3, [r4, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 800a2bc:	f415 4f7f 	tst.w	r5, #65280	; 0xff00
 800a2c0:	d129      	bne.n	800a316 <dmaStreamAllocate+0x96>
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800a2c2:	6805      	ldr	r5, [r0, #0]
 800a2c4:	682b      	ldr	r3, [r5, #0]
 800a2c6:	f023 031f 	bic.w	r3, r3, #31
 800a2ca:	602b      	str	r3, [r5, #0]
 800a2cc:	682b      	ldr	r3, [r5, #0]
 800a2ce:	f013 0301 	ands.w	r3, r3, #1
 800a2d2:	d1fb      	bne.n	800a2cc <dmaStreamAllocate+0x4c>
 800a2d4:	7a07      	ldrb	r7, [r0, #8]
 800a2d6:	6846      	ldr	r6, [r0, #4]
 800a2d8:	243d      	movs	r4, #61	; 0x3d
 800a2da:	40bc      	lsls	r4, r7
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800a2dc:	2721      	movs	r7, #33	; 0x21
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800a2de:	6034      	str	r4, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 800a2e0:	602b      	str	r3, [r5, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800a2e2:	616f      	str	r7, [r5, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 800a2e4:	b1fa      	cbz	r2, 800a326 <dmaStreamAllocate+0xa6>
    nvicEnableVector(dmastp->vector, priority);
 800a2e6:	7a80      	ldrb	r0, [r0, #10]
 800a2e8:	0942      	lsrs	r2, r0, #5
 800a2ea:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a2ec:	f100 4560 	add.w	r5, r0, #3758096384	; 0xe0000000
 800a2f0:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 800a2f4:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 800a2f8:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a2fc:	f000 001f 	and.w	r0, r0, #31

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a300:	0109      	lsls	r1, r1, #4
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a302:	2401      	movs	r4, #1
 800a304:	4084      	lsls	r4, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a306:	b2c9      	uxtb	r1, r1
 800a308:	f885 1300 	strb.w	r1, [r5, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a30c:	f8c2 4180 	str.w	r4, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a310:	6014      	str	r4, [r2, #0]
 800a312:	4618      	mov	r0, r3
 800a314:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
    rccEnableDMA1(false);
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
 800a316:	4c08      	ldr	r4, [pc, #32]	; (800a338 <dmaStreamAllocate+0xb8>)
 800a318:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800a31a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800a31e:	6323      	str	r3, [r4, #48]	; 0x30
 800a320:	e7cf      	b.n	800a2c2 <dmaStreamAllocate+0x42>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 800a322:	4620      	mov	r0, r4
 800a324:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dmaStreamDisable(dmastp);
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 800a326:	4610      	mov	r0, r2
    nvicEnableVector(dmastp->vector, priority);
  }

  return false;
}
 800a328:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {

  osalDbgCheck(dmastp != NULL);
 800a32a:	4804      	ldr	r0, [pc, #16]	; (800a33c <dmaStreamAllocate+0xbc>)
 800a32c:	f001 fc20 	bl	800bb70 <chSysHalt>
 800a330:	20019974 	.word	0x20019974
 800a334:	200198d0 	.word	0x200198d0
 800a338:	40023800 	.word	0x40023800
 800a33c:	080100a0 	.word	0x080100a0

0800a340 <chSchWakeupS.constprop.96>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800a340:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 800a342:	4c1a      	ldr	r4, [pc, #104]	; (800a3ac <chSchWakeupS.constprop.96+0x6c>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 800a344:	4605      	mov	r5, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 800a346:	f001 fc33 	bl	800bbb0 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a34a:	6823      	ldr	r3, [r4, #0]
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 800a34c:	69a0      	ldr	r0, [r4, #24]

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a34e:	42a3      	cmp	r3, r4
 800a350:	d003      	beq.n	800a35a <chSchWakeupS.constprop.96+0x1a>
 800a352:	689b      	ldr	r3, [r3, #8]
 800a354:	6882      	ldr	r2, [r0, #8]
 800a356:	429a      	cmp	r2, r3
 800a358:	d322      	bcc.n	800a3a0 <chSchWakeupS.constprop.96+0x60>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800a35a:	2300      	movs	r3, #0
 800a35c:	626b      	str	r3, [r5, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800a35e:	6883      	ldr	r3, [r0, #8]
 800a360:	68aa      	ldr	r2, [r5, #8]
 800a362:	429a      	cmp	r2, r3
 800a364:	d917      	bls.n	800a396 <chSchWakeupS.constprop.96+0x56>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 800a366:	f001 fd2b 	bl	800bdc0 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 800a36a:	2301      	movs	r3, #1
 800a36c:	f885 3020 	strb.w	r3, [r5, #32]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800a370:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 800a372:	61a5      	str	r5, [r4, #24]
 800a374:	07db      	lsls	r3, r3, #31
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 800a376:	4606      	mov	r6, r0
 800a378:	d401      	bmi.n	800a37e <chSchWakeupS.constprop.96+0x3e>
 800a37a:	f001 fba1 	bl	800bac0 <_trace_switch.part.0.lto_priv.119>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800a37e:	f3ef 8309 	mrs	r3, PSP
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800a382:	69f2      	ldr	r2, [r6, #28]
 800a384:	3b24      	subs	r3, #36	; 0x24
 800a386:	429a      	cmp	r2, r3
 800a388:	d80d      	bhi.n	800a3a6 <chSchWakeupS.constprop.96+0x66>
 800a38a:	4631      	mov	r1, r6
 800a38c:	4628      	mov	r0, r5
  }
}
 800a38e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800a392:	f7f5 bf7f 	b.w	8000294 <_port_switch>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 800a396:	4628      	mov	r0, r5
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 800a398:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 800a39c:	f001 bd10 	b.w	800bdc0 <chSchReadyI>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a3a0:	4803      	ldr	r0, [pc, #12]	; (800a3b0 <chSchWakeupS.constprop.96+0x70>)
 800a3a2:	f001 fbe5 	bl	800bb70 <chSysHalt>
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800a3a6:	4803      	ldr	r0, [pc, #12]	; (800a3b4 <chSchWakeupS.constprop.96+0x74>)
 800a3a8:	f001 fbe2 	bl	800bb70 <chSysHalt>
 800a3ac:	2001acdc 	.word	0x2001acdc
 800a3b0:	080101fc 	.word	0x080101fc
 800a3b4:	08010250 	.word	0x08010250
	...

0800a3c0 <chTMStartMeasurementX.constprop.93>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 800a3c0:	4b01      	ldr	r3, [pc, #4]	; (800a3c8 <chTMStartMeasurementX.constprop.93+0x8>)
 800a3c2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 800a3c4:	6083      	str	r3, [r0, #8]
 800a3c6:	4770      	bx	lr
 800a3c8:	e0001000 	.word	0xe0001000
 800a3cc:	00000000 	.word	0x00000000

0800a3d0 <chSysPolledDelayX.constprop.92>:
 800a3d0:	4a03      	ldr	r2, [pc, #12]	; (800a3e0 <chSysPolledDelayX.constprop.92+0x10>)
 800a3d2:	6851      	ldr	r1, [r2, #4]
 800a3d4:	6853      	ldr	r3, [r2, #4]
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 800a3d6:	1a5b      	subs	r3, r3, r1
 800a3d8:	2b11      	cmp	r3, #17
 800a3da:	d9fb      	bls.n	800a3d4 <chSysPolledDelayX.constprop.92+0x4>
  }
}
 800a3dc:	4770      	bx	lr
 800a3de:	bf00      	nop
 800a3e0:	e0001000 	.word	0xe0001000
	...

0800a3f0 <chThdDequeueNextI.constprop.88>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 800a3f0:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800a3f2:	6803      	ldr	r3, [r0, #0]

  if (queue_notempty(tqp)) {
 800a3f4:	4298      	cmp	r0, r3
 800a3f6:	d009      	beq.n	800a40c <chThdDequeueNextI.constprop.88+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800a3f8:	681a      	ldr	r2, [r3, #0]
 800a3fa:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800a3fc:	6050      	str	r0, [r2, #4]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800a3fe:	f893 2020 	ldrb.w	r2, [r3, #32]
 800a402:	2a04      	cmp	r2, #4
 800a404:	d003      	beq.n	800a40e <chThdDequeueNextI.constprop.88+0x1e>
 800a406:	4805      	ldr	r0, [pc, #20]	; (800a41c <chThdDequeueNextI.constprop.88+0x2c>)
 800a408:	f001 fbb2 	bl	800bb70 <chSysHalt>
 800a40c:	bd08      	pop	{r3, pc}

  tp->u.rdymsg = msg;
 800a40e:	2200      	movs	r2, #0
 800a410:	625a      	str	r2, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800a412:	4618      	mov	r0, r3
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800a414:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800a418:	f001 bcd2 	b.w	800bdc0 <chSchReadyI>
 800a41c:	080101c4 	.word	0x080101c4

0800a420 <sdObjectInit.constprop.80>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 800a420:	b5f0      	push	{r4, r5, r6, r7, lr}

  sdp->vmt = &vmt;
 800a422:	4603      	mov	r3, r0
 800a424:	4a13      	ldr	r2, [pc, #76]	; (800a474 <sdObjectInit.constprop.80+0x54>)
 800a426:	f843 2b04 	str.w	r2, [r3], #4
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800a42a:	2500      	movs	r5, #0
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 800a42c:	f100 0254 	add.w	r2, r0, #84	; 0x54
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
 800a430:	f100 040c 	add.w	r4, r0, #12
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800a434:	f04f 0e01 	mov.w	lr, #1
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800a438:	2710      	movs	r7, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800a43a:	f100 0674 	add.w	r6, r0, #116	; 0x74
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 800a43e:	6043      	str	r3, [r0, #4]
  oqp->q_notify  = onfy;
 800a440:	64c1      	str	r1, [r0, #76]	; 0x4c
  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800a442:	f100 0364 	add.w	r3, r0, #100	; 0x64
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
 800a446:	f100 0130 	add.w	r1, r0, #48	; 0x30
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800a44a:	6145      	str	r5, [r0, #20]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 800a44c:	62c0      	str	r0, [r0, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 800a44e:	6500      	str	r0, [r0, #80]	; 0x50
 800a450:	f880 e008 	strb.w	lr, [r0, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 800a454:	6285      	str	r5, [r0, #40]	; 0x28
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800a456:	6387      	str	r7, [r0, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800a458:	6406      	str	r6, [r0, #64]	; 0x40
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800a45a:	6182      	str	r2, [r0, #24]
  iqp->q_rdptr   = bp;
 800a45c:	6242      	str	r2, [r0, #36]	; 0x24
  iqp->q_wrptr   = bp;
 800a45e:	6202      	str	r2, [r0, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800a460:	60c4      	str	r4, [r0, #12]
  tqp->prev = (thread_t *)tqp;
 800a462:	6104      	str	r4, [r0, #16]
  iqp->q_top     = bp + size;
 800a464:	61c3      	str	r3, [r0, #28]
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 800a466:	63c3      	str	r3, [r0, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 800a468:	6483      	str	r3, [r0, #72]	; 0x48
  oqp->q_wrptr   = bp;
 800a46a:	6443      	str	r3, [r0, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800a46c:	6301      	str	r1, [r0, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 800a46e:	6341      	str	r1, [r0, #52]	; 0x34
 800a470:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800a472:	bf00      	nop
 800a474:	08010154 	.word	0x08010154
	...

0800a480 <usbStartReceiveI.constprop.44>:
 * @param[in] n         transaction size. It is recommended a multiple of
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
 800a480:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a482:	4604      	mov	r4, r0
 800a484:	460f      	mov	r7, r1
 800a486:	4616      	mov	r6, r2
                      uint8_t *buf, size_t n) {
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 800a488:	f001 fbd2 	bl	800bc30 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800a48c:	b18c      	cbz	r4, 800a4b2 <usbStartReceiveI.constprop.44+0x32>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 800a48e:	8963      	ldrh	r3, [r4, #10]
 800a490:	f013 0501 	ands.w	r5, r3, #1
 800a494:	d10d      	bne.n	800a4b2 <usbStartReceiveI.constprop.44+0x32>
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 800a496:	68e2      	ldr	r2, [r4, #12]
 800a498:	6990      	ldr	r0, [r2, #24]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800a49a:	f043 0301 	orr.w	r3, r3, #1
 800a49e:	8163      	strh	r3, [r4, #10]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 800a4a0:	4629      	mov	r1, r5

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
 800a4a2:	6087      	str	r7, [r0, #8]
  osp->rxsize = n;
 800a4a4:	6006      	str	r6, [r0, #0]
  osp->rxcnt  = 0;
 800a4a6:	6045      	str	r5, [r0, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 800a4a8:	4620      	mov	r0, r4
}
 800a4aa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 800a4ae:	f7fd bab7 	b.w	8007a20 <usb_lld_start_out>
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800a4b2:	4801      	ldr	r0, [pc, #4]	; (800a4b8 <usbStartReceiveI.constprop.44+0x38>)
 800a4b4:	f001 fb5c 	bl	800bb70 <chSysHalt>
 800a4b8:	080100fc 	.word	0x080100fc
 800a4bc:	00000000 	.word	0x00000000

0800a4c0 <usbStartTransmitI.constprop.43>:
 * @param[in] buf       buffer where to fetch the data to be transmitted
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
 800a4c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800a4c2:	4604      	mov	r4, r0
 800a4c4:	460f      	mov	r7, r1
 800a4c6:	4616      	mov	r6, r2
                       const uint8_t *buf, size_t n) {
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 800a4c8:	f001 fbb2 	bl	800bc30 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800a4cc:	b18c      	cbz	r4, 800a4f2 <usbStartTransmitI.constprop.43+0x32>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 800a4ce:	8923      	ldrh	r3, [r4, #8]
 800a4d0:	f013 0501 	ands.w	r5, r3, #1
 800a4d4:	d10d      	bne.n	800a4f2 <usbStartTransmitI.constprop.43+0x32>
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 800a4d6:	68e2      	ldr	r2, [r4, #12]
 800a4d8:	6950      	ldr	r0, [r2, #20]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800a4da:	f043 0301 	orr.w	r3, r3, #1
 800a4de:	8123      	strh	r3, [r4, #8]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800a4e0:	4629      	mov	r1, r5

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 800a4e2:	6087      	str	r7, [r0, #8]
  isp->txsize = n;
 800a4e4:	6006      	str	r6, [r0, #0]
  isp->txcnt  = 0;
 800a4e6:	6045      	str	r5, [r0, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800a4e8:	4620      	mov	r0, r4
}
 800a4ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 800a4ee:	f7fd ba3f 	b.w	8007970 <usb_lld_start_in>
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
  USBInEndpointState *isp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 800a4f2:	4801      	ldr	r0, [pc, #4]	; (800a4f8 <usbStartTransmitI.constprop.43+0x38>)
 800a4f4:	f001 fb3c 	bl	800bb70 <chSysHalt>
 800a4f8:	08010110 	.word	0x08010110
 800a4fc:	00000000 	.word	0x00000000

0800a500 <otg_epout_handler.constprop.30>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800a500:	b5f0      	push	{r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 800a502:	4e2b      	ldr	r6, [pc, #172]	; (800a5b0 <otg_epout_handler.constprop.30+0xb0>)
 800a504:	6d77      	ldr	r7, [r6, #84]	; 0x54
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800a506:	eb07 1340 	add.w	r3, r7, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800a50a:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800a50c:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 800a510:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 800a514:	0720      	lsls	r0, r4, #28
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800a516:	b083      	sub	sp, #12
  uint32_t epint = otgp->oe[ep].DOEPINT;

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 800a518:	d503      	bpl.n	800a522 <otg_epout_handler.constprop.30+0x22>
 800a51a:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800a51e:	0719      	lsls	r1, r3, #28
 800a520:	d43e      	bmi.n	800a5a0 <otg_epout_handler.constprop.30+0xa0>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 800a522:	07e2      	lsls	r2, r4, #31
 800a524:	d527      	bpl.n	800a576 <otg_epout_handler.constprop.30+0x76>
 800a526:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800a52a:	07db      	lsls	r3, r3, #31
 800a52c:	d523      	bpl.n	800a576 <otg_epout_handler.constprop.30+0x76>
    USBOutEndpointState *osp;

    /* Receive transfer complete, checking if it is a SETUP transfer on EP0,
       than it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
 800a52e:	bb25      	cbnz	r5, 800a57a <otg_epout_handler.constprop.30+0x7a>
 800a530:	f896 3034 	ldrb.w	r3, [r6, #52]	; 0x34
 800a534:	b1fb      	cbz	r3, 800a576 <otg_epout_handler.constprop.30+0x76>
      return;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 800a536:	481f      	ldr	r0, [pc, #124]	; (800a5b4 <otg_epout_handler.constprop.30+0xb4>)
 800a538:	6841      	ldr	r1, [r0, #4]
 800a53a:	698c      	ldr	r4, [r1, #24]

    /* A short packet always terminates a transaction.*/
    if ((ep == 0) &&
 800a53c:	8a4b      	ldrh	r3, [r1, #18]
 800a53e:	6867      	ldr	r7, [r4, #4]
 800a540:	fbb7 f2f3 	udiv	r2, r7, r3
 800a544:	fb03 7312 	mls	r3, r3, r2, r7
 800a548:	b9d3      	cbnz	r3, 800a580 <otg_epout_handler.constprop.30+0x80>
        ((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
        (osp->rxsize < osp->totsize)) {
 800a54a:	6822      	ldr	r2, [r4, #0]
 800a54c:	68e3      	ldr	r3, [r4, #12]
    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if ((ep == 0) &&
        ((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 800a54e:	429a      	cmp	r2, r3
 800a550:	d216      	bcs.n	800a580 <otg_epout_handler.constprop.30+0x80>
        (osp->rxsize < osp->totsize)) {
      /* For EP 0 only, in case the transaction covered only part of the total
         transfer then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 800a552:	1a9b      	subs	r3, r3, r2
      osp->rxcnt  = 0;
 800a554:	e884 0028 	stmia.w	r4, {r3, r5}
 800a558:	9001      	str	r0, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800a55a:	2320      	movs	r3, #32
 800a55c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800a560:	f001 fdae 	bl	800c0c0 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usb_lld_start_out(usbp, ep);
 800a564:	9801      	ldr	r0, [sp, #4]
 800a566:	4629      	mov	r1, r5
 800a568:	3808      	subs	r0, #8
 800a56a:	f7fd fa59 	bl	8007a20 <usb_lld_start_out>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800a56e:	f001 fd8f 	bl	800c090 <_dbg_check_unlock_from_isr>
 800a572:	f385 8811 	msr	BASEPRI, r5
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 800a576:	b003      	add	sp, #12
 800a578:	bdf0      	pop	{r4, r5, r6, r7, pc}
       than it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
      return;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 800a57a:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 800a57e:	68d9      	ldr	r1, [r3, #12]
      usb_lld_start_out(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800a580:	8972      	ldrh	r2, [r6, #10]
 800a582:	68cc      	ldr	r4, [r1, #12]
 800a584:	2301      	movs	r3, #1
 800a586:	40ab      	lsls	r3, r5
 800a588:	ea22 0303 	bic.w	r3, r2, r3
 800a58c:	8173      	strh	r3, [r6, #10]
 800a58e:	2c00      	cmp	r4, #0
 800a590:	d0f1      	beq.n	800a576 <otg_epout_handler.constprop.30+0x76>
 800a592:	4807      	ldr	r0, [pc, #28]	; (800a5b0 <otg_epout_handler.constprop.30+0xb0>)
 800a594:	4629      	mov	r1, r5
 800a596:	4623      	mov	r3, r4
    }
  }
}
 800a598:	b003      	add	sp, #12
 800a59a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
      usb_lld_start_out(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 800a59e:	4718      	bx	r3
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 800a5a0:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 800a5a4:	4629      	mov	r1, r5
 800a5a6:	68db      	ldr	r3, [r3, #12]
 800a5a8:	4630      	mov	r0, r6
 800a5aa:	685b      	ldr	r3, [r3, #4]
 800a5ac:	4798      	blx	r3
 800a5ae:	e7b8      	b.n	800a522 <otg_epout_handler.constprop.30+0x22>
 800a5b0:	2001aa70 	.word	0x2001aa70
 800a5b4:	2001aa78 	.word	0x2001aa78
	...

0800a5c0 <otg_epin_handler.constprop.29>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800a5c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 800a5c4:	4e2e      	ldr	r6, [pc, #184]	; (800a680 <otg_epin_handler.constprop.29+0xc0>)
 800a5c6:	6d75      	ldr	r5, [r6, #84]	; 0x54
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800a5c8:	eb05 1340 	add.w	r3, r5, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800a5cc:	4607      	mov	r7, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800a5ce:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 800a5d2:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 800a5d6:	07e1      	lsls	r1, r4, #31
 800a5d8:	d503      	bpl.n	800a5e2 <otg_epin_handler.constprop.29+0x22>
 800a5da:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 800a5de:	07da      	lsls	r2, r3, #31
 800a5e0:	d40a      	bmi.n	800a5f8 <otg_epin_handler.constprop.29+0x38>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800a5e2:	0623      	lsls	r3, r4, #24
 800a5e4:	d506      	bpl.n	800a5f4 <otg_epin_handler.constprop.29+0x34>
 800a5e6:	2301      	movs	r3, #1
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800a5e8:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800a5ec:	fa03 f407 	lsl.w	r4, r3, r7
 800a5f0:	4214      	tst	r4, r2
 800a5f2:	d118      	bne.n	800a626 <otg_epin_handler.constprop.29+0x66>
 800a5f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800a5f8:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 800a5fc:	68d9      	ldr	r1, [r3, #12]
 800a5fe:	694b      	ldr	r3, [r1, #20]

    if (isp->txsize < isp->totsize) {
 800a600:	6818      	ldr	r0, [r3, #0]
 800a602:	68da      	ldr	r2, [r3, #12]
 800a604:	4290      	cmp	r0, r2
 800a606:	d327      	bcc.n	800a658 <otg_epin_handler.constprop.29+0x98>
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800a608:	8932      	ldrh	r2, [r6, #8]
 800a60a:	f8d1 8008 	ldr.w	r8, [r1, #8]
 800a60e:	2301      	movs	r3, #1
 800a610:	40bb      	lsls	r3, r7
 800a612:	ea22 0303 	bic.w	r3, r2, r3
 800a616:	8133      	strh	r3, [r6, #8]
 800a618:	f1b8 0f00 	cmp.w	r8, #0
 800a61c:	d0e1      	beq.n	800a5e2 <otg_epin_handler.constprop.29+0x22>
 800a61e:	4639      	mov	r1, r7
 800a620:	4630      	mov	r0, r6
 800a622:	47c0      	blx	r8
 800a624:	e7dd      	b.n	800a5e2 <otg_epin_handler.constprop.29+0x22>
 800a626:	2320      	movs	r3, #32
 800a628:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800a62c:	f001 fd48 	bl	800c0c0 <_dbg_check_lock_from_isr>
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800a630:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 800a634:	6e32      	ldr	r2, [r6, #96]	; 0x60
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800a636:	4813      	ldr	r0, [pc, #76]	; (800a684 <otg_epin_handler.constprop.29+0xc4>)
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800a638:	ea23 0304 	bic.w	r3, r3, r4
 800a63c:	f8c5 3834 	str.w	r3, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 800a640:	4314      	orrs	r4, r2
 800a642:	2100      	movs	r1, #0
 800a644:	6634      	str	r4, [r6, #96]	; 0x60
 800a646:	f001 fbe3 	bl	800be10 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800a64a:	f001 fd21 	bl	800c090 <_dbg_check_unlock_from_isr>
 800a64e:	2300      	movs	r3, #0
 800a650:	f383 8811 	msr	BASEPRI, r3
 800a654:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800a658:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 800a65a:	f04f 0800 	mov.w	r8, #0
 800a65e:	e883 0104 	stmia.w	r3, {r2, r8}
 800a662:	2320      	movs	r3, #32
 800a664:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800a668:	f001 fd2a 	bl	800c0c0 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usb_lld_start_in(usbp, ep);
 800a66c:	4639      	mov	r1, r7
 800a66e:	4630      	mov	r0, r6
 800a670:	f7fd f97e 	bl	8007970 <usb_lld_start_in>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800a674:	f001 fd0c 	bl	800c090 <_dbg_check_unlock_from_isr>
 800a678:	f388 8811 	msr	BASEPRI, r8
 800a67c:	e7b1      	b.n	800a5e2 <otg_epin_handler.constprop.29+0x22>
 800a67e:	bf00      	nop
 800a680:	2001aa70 	.word	0x2001aa70
 800a684:	2001aad4 	.word	0x2001aad4
	...

0800a690 <chprintf.constprop.26>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800a690:	b40e      	push	{r1, r2, r3}
 800a692:	b500      	push	{lr}
 800a694:	b082      	sub	sp, #8
 800a696:	aa03      	add	r2, sp, #12
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
 800a698:	4805      	ldr	r0, [pc, #20]	; (800a6b0 <chprintf.constprop.26+0x20>)
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800a69a:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800a69e:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800a6a0:	f7fc ff2e 	bl	8007500 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 800a6a4:	b002      	add	sp, #8
 800a6a6:	f85d eb04 	ldr.w	lr, [sp], #4
 800a6aa:	b003      	add	sp, #12
 800a6ac:	4770      	bx	lr
 800a6ae:	bf00      	nop
 800a6b0:	2001ac28 	.word	0x2001ac28
	...

0800a6c0 <chThdCreateFromHeap.constprop.86>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 800a6c0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a6c4:	b087      	sub	sp, #28
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
  heap_header_t *qp, *hp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 800a6c6:	2800      	cmp	r0, #0
 800a6c8:	d072      	beq.n	800a7b0 <chThdCreateFromHeap.constprop.86+0xf0>
 800a6ca:	f100 0807 	add.w	r8, r0, #7
 800a6ce:	4607      	mov	r7, r0

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800a6d0:	4855      	ldr	r0, [pc, #340]	; (800a828 <chThdCreateFromHeap.constprop.86+0x168>)
 800a6d2:	4615      	mov	r5, r2
 800a6d4:	460e      	mov	r6, r1
 800a6d6:	461c      	mov	r4, r3
 800a6d8:	f001 fd62 	bl	800c1a0 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 800a6dc:	f8df e15c 	ldr.w	lr, [pc, #348]	; 800a83c <chThdCreateFromHeap.constprop.86+0x17c>
  while (H_NEXT(qp) != NULL) {
 800a6e0:	f8de 2000 	ldr.w	r2, [lr]
 800a6e4:	ea4f 08d8 	mov.w	r8, r8, lsr #3
 800a6e8:	b1ca      	cbz	r2, 800a71e <chThdCreateFromHeap.constprop.86+0x5e>
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800a6ea:	f8d2 c004 	ldr.w	ip, [r2, #4]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800a6ee:	f102 030f 	add.w	r3, r2, #15

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800a6f2:	f10c 0101 	add.w	r1, ip, #1
 800a6f6:	00c9      	lsls	r1, r1, #3

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800a6f8:	f023 0307 	bic.w	r3, r3, #7

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800a6fc:	1850      	adds	r0, r2, r1

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800a6fe:	3b08      	subs	r3, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800a700:	4283      	cmp	r3, r0

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800a702:	f102 0908 	add.w	r9, r2, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800a706:	d205      	bcs.n	800a714 <chThdCreateFromHeap.constprop.86+0x54>
 800a708:	3908      	subs	r1, #8
 800a70a:	1ad0      	subs	r0, r2, r3
 800a70c:	4408      	add	r0, r1
 800a70e:	10c0      	asrs	r0, r0, #3
 800a710:	4540      	cmp	r0, r8
 800a712:	d253      	bcs.n	800a7bc <chThdCreateFromHeap.constprop.86+0xfc>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 800a714:	4696      	mov	lr, r2
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800a716:	f8de 2000 	ldr.w	r2, [lr]
 800a71a:	2a00      	cmp	r2, #0
 800a71c:	d1e5      	bne.n	800a6ea <chThdCreateFromHeap.constprop.86+0x2a>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800a71e:	f8df 9118 	ldr.w	r9, [pc, #280]	; 800a838 <chThdCreateFromHeap.constprop.86+0x178>
 800a722:	f109 0010 	add.w	r0, r9, #16
 800a726:	f7fe ff2b 	bl	8009580 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 800a72a:	f8d9 3000 	ldr.w	r3, [r9]
 800a72e:	2b00      	cmp	r3, #0
 800a730:	d078      	beq.n	800a824 <chThdCreateFromHeap.constprop.86+0x164>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
 800a732:	f108 0001 	add.w	r0, r8, #1
 800a736:	00c0      	lsls	r0, r0, #3
 800a738:	2108      	movs	r1, #8
 800a73a:	4798      	blx	r3
    if (hp != NULL) {
 800a73c:	2800      	cmp	r0, #0
 800a73e:	d071      	beq.n	800a824 <chThdCreateFromHeap.constprop.86+0x164>
      H_HEAP(hp) = heapp;
 800a740:	f8c0 9000 	str.w	r9, [r0]
      H_SIZE(hp) = size;
 800a744:	6047      	str	r7, [r0, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 800a746:	f100 0808 	add.w	r8, r0, #8
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
 800a74a:	f1b8 0f00 	cmp.w	r8, #0
 800a74e:	d069      	beq.n	800a824 <chThdCreateFromHeap.constprop.86+0x164>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 800a750:	4447      	add	r7, r8
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 800a752:	2380      	movs	r3, #128	; 0x80
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800a754:	4547      	cmp	r7, r8
 800a756:	9303      	str	r3, [sp, #12]
 800a758:	9702      	str	r7, [sp, #8]
 800a75a:	e88d 0140 	stmia.w	sp, {r6, r8}
 800a75e:	9504      	str	r5, [sp, #16]
 800a760:	9405      	str	r4, [sp, #20]
    *startp++ = v;
 800a762:	bf88      	it	hi
 800a764:	2355      	movhi	r3, #85	; 0x55
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800a766:	d903      	bls.n	800a770 <chThdCreateFromHeap.constprop.86+0xb0>
    *startp++ = v;
 800a768:	f808 3b01 	strb.w	r3, [r8], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800a76c:	4547      	cmp	r7, r8
 800a76e:	d1fb      	bne.n	800a768 <chThdCreateFromHeap.constprop.86+0xa8>
 800a770:	2320      	movs	r3, #32
 800a772:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a776:	f001 fd03 	bl	800c180 <_dbg_check_lock>
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800a77a:	4668      	mov	r0, sp
 800a77c:	f001 fa68 	bl	800bc50 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 800a780:	2301      	movs	r3, #1
 800a782:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800a786:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 800a788:	f7ff fdda 	bl	800a340 <chSchWakeupS.constprop.96>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800a78c:	f001 fce8 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a790:	4b26      	ldr	r3, [pc, #152]	; (800a82c <chThdCreateFromHeap.constprop.86+0x16c>)
 800a792:	681a      	ldr	r2, [r3, #0]
 800a794:	429a      	cmp	r2, r3
 800a796:	d004      	beq.n	800a7a2 <chThdCreateFromHeap.constprop.86+0xe2>
 800a798:	6999      	ldr	r1, [r3, #24]
 800a79a:	6893      	ldr	r3, [r2, #8]
 800a79c:	688a      	ldr	r2, [r1, #8]
 800a79e:	429a      	cmp	r2, r3
 800a7a0:	d309      	bcc.n	800a7b6 <chThdCreateFromHeap.constprop.86+0xf6>
 800a7a2:	2300      	movs	r3, #0
 800a7a4:	f383 8811 	msr	BASEPRI, r3
 800a7a8:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
 800a7aa:	b007      	add	sp, #28
 800a7ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
  heap_header_t *qp, *hp;
  size_t pages;

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));
 800a7b0:	481f      	ldr	r0, [pc, #124]	; (800a830 <chThdCreateFromHeap.constprop.86+0x170>)
 800a7b2:	f001 f9dd 	bl	800bb70 <chSysHalt>
 800a7b6:	481f      	ldr	r0, [pc, #124]	; (800a834 <chThdCreateFromHeap.constprop.86+0x174>)
 800a7b8:	f001 f9da 	bl	800bb70 <chSysHalt>

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 800a7bc:	429a      	cmp	r2, r3
 800a7be:	d21b      	bcs.n	800a7f8 <chThdCreateFromHeap.constprop.86+0x138>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 800a7c0:	ebc9 0103 	rsb	r1, r9, r3
 800a7c4:	10c9      	asrs	r1, r1, #3
        if (bpages > pages) {
 800a7c6:	4540      	cmp	r0, r8
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 800a7c8:	6051      	str	r1, [r2, #4]
        if (bpages > pages) {
 800a7ca:	d90b      	bls.n	800a7e4 <chThdCreateFromHeap.constprop.86+0x124>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 800a7cc:	f108 0e01 	add.w	lr, r8, #1
 800a7d0:	eb03 01ce 	add.w	r1, r3, lr, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 800a7d4:	ea6f 0808 	mvn.w	r8, r8
 800a7d8:	4440      	add	r0, r8
 800a7da:	6048      	str	r0, [r1, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 800a7dc:	6810      	ldr	r0, [r2, #0]
 800a7de:	f843 003e 	str.w	r0, [r3, lr, lsl #3]
          H_NEXT(hp) = fp;
 800a7e2:	6011      	str	r1, [r2, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;
 800a7e4:	4a14      	ldr	r2, [pc, #80]	; (800a838 <chThdCreateFromHeap.constprop.86+0x178>)
          H_NEXT(qp) = fp;
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 800a7e6:	605f      	str	r7, [r3, #4]
      H_HEAP(hp) = heapp;
 800a7e8:	4698      	mov	r8, r3

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 800a7ea:	f102 0010 	add.w	r0, r2, #16
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;
 800a7ee:	f848 2b08 	str.w	r2, [r8], #8

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 800a7f2:	f7fe fec5 	bl	8009580 <chMtxUnlock>
 800a7f6:	e7a8      	b.n	800a74a <chThdCreateFromHeap.constprop.86+0x8a>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 800a7f8:	45c4      	cmp	ip, r8
 800a7fa:	d00e      	beq.n	800a81a <chThdCreateFromHeap.constprop.86+0x15a>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 800a7fc:	f108 0801 	add.w	r8, r8, #1
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 800a800:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
 800a804:	eba1 01c8 	sub.w	r1, r1, r8, lsl #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
 800a808:	6813      	ldr	r3, [r2, #0]
 800a80a:	f842 3038 	str.w	r3, [r2, r8, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 800a80e:	10c9      	asrs	r1, r1, #3
 800a810:	6041      	str	r1, [r0, #4]
          H_NEXT(qp) = fp;
 800a812:	4613      	mov	r3, r2
 800a814:	f8ce 0000 	str.w	r0, [lr]
 800a818:	e7e4      	b.n	800a7e4 <chThdCreateFromHeap.constprop.86+0x124>
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 800a81a:	6813      	ldr	r3, [r2, #0]
 800a81c:	f8ce 3000 	str.w	r3, [lr]
 800a820:	4613      	mov	r3, r2
 800a822:	e7df      	b.n	800a7e4 <chThdCreateFromHeap.constprop.86+0x124>
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
 800a824:	2000      	movs	r0, #0
 800a826:	e7c0      	b.n	800a7aa <chThdCreateFromHeap.constprop.86+0xea>
 800a828:	2001b580 	.word	0x2001b580
 800a82c:	2001acdc 	.word	0x2001acdc
 800a830:	080101d8 	.word	0x080101d8
 800a834:	0801020c 	.word	0x0801020c
 800a838:	2001b570 	.word	0x2001b570
 800a83c:	2001b578 	.word	0x2001b578

0800a840 <i2cStart.constprop.66>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] config    pointer to the @p I2CConfig object
 *
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {
 800a840:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 800a844:	4c85      	ldr	r4, [pc, #532]	; (800aa5c <i2cStart.constprop.66+0x21c>)
 800a846:	7823      	ldrb	r3, [r4, #0]
 800a848:	1e5a      	subs	r2, r3, #1
 800a84a:	2a01      	cmp	r2, #1
 800a84c:	d904      	bls.n	800a858 <i2cStart.constprop.66+0x18>
 800a84e:	2b05      	cmp	r3, #5
 800a850:	d002      	beq.n	800a858 <i2cStart.constprop.66+0x18>
 800a852:	4883      	ldr	r0, [pc, #524]	; (800aa60 <i2cStart.constprop.66+0x220>)
 800a854:	f001 f98c 	bl	800bb70 <chSysHalt>
 800a858:	2320      	movs	r3, #32
 800a85a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800a85e:	f001 fc8f 	bl	800c180 <_dbg_check_lock>
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800a862:	7827      	ldrb	r7, [r4, #0]
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800a864:	4b7f      	ldr	r3, [pc, #508]	; (800aa64 <i2cStart.constprop.66+0x224>)
 800a866:	6063      	str	r3, [r4, #4]
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800a868:	f240 4156 	movw	r1, #1110	; 0x456
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800a86c:	f240 4216 	movw	r2, #1046	; 0x416
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800a870:	2f01      	cmp	r7, #1
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800a872:	62a1      	str	r1, [r4, #40]	; 0x28
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800a874:	6262      	str	r2, [r4, #36]	; 0x24
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800a876:	6b65      	ldr	r5, [r4, #52]	; 0x34
 800a878:	4e78      	ldr	r6, [pc, #480]	; (800aa5c <i2cStart.constprop.66+0x21c>)
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800a87a:	d05e      	beq.n	800a93a <i2cStart.constprop.66+0xfa>
 800a87c:	4619      	mov	r1, r3
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800a87e:	4628      	mov	r0, r5
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800a880:	f24c 374f 	movw	r7, #49999	; 0xc34f
 800a884:	f04f 0c01 	mov.w	ip, #1
 800a888:	f24c 3250 	movw	r2, #50000	; 0xc350
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800a88c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800a88e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800a890:	f8d6 8000 	ldr.w	r8, [r6]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800a894:	f8d3 e000 	ldr.w	lr, [r3]
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 800a898:	4e73      	ldr	r6, [pc, #460]	; (800aa68 <i2cStart.constprop.66+0x228>)
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 800a89a:	f105 0310 	add.w	r3, r5, #16
 800a89e:	f8c8 3008 	str.w	r3, [r8, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 800a8a2:	f8ce 3008 	str.w	r3, [lr, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800a8a6:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
 800a8aa:	f8c5 e000 	str.w	lr, [r5]
  dp->CR1 = 0;
 800a8ae:	2300      	movs	r3, #0
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 800a8b0:	f44f 6e10 	mov.w	lr, #2304	; 0x900
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 800a8b4:	42b7      	cmp	r7, r6
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 800a8b6:	602b      	str	r3, [r5, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 800a8b8:	f8c5 e004 	str.w	lr, [r5, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 800a8bc:	d811      	bhi.n	800a8e2 <i2cStart.constprop.66+0xa2>
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 800a8be:	f8d0 e004 	ldr.w	lr, [r0, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 800a8c2:	4f6a      	ldr	r7, [pc, #424]	; (800aa6c <i2cStart.constprop.66+0x22c>)
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 800a8c4:	f64f 76c0 	movw	r6, #65472	; 0xffc0
 800a8c8:	ea0e 0606 	and.w	r6, lr, r6
 800a8cc:	6046      	str	r6, [r0, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 800a8ce:	6846      	ldr	r6, [r0, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 800a8d0:	42ba      	cmp	r2, r7
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 800a8d2:	f046 061a 	orr.w	r6, r6, #26
 800a8d6:	6046      	str	r6, [r0, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 800a8d8:	dc06      	bgt.n	800a8e8 <i2cStart.constprop.66+0xa8>
    /* Configure clock_div in standard mode.*/
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");
 800a8da:	f1bc 0f01 	cmp.w	ip, #1
 800a8de:	f000 808f 	beq.w	800aa00 <i2cStart.constprop.66+0x1c0>
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 800a8e2:	4863      	ldr	r0, [pc, #396]	; (800aa70 <i2cStart.constprop.66+0x230>)
 800a8e4:	f001 f944 	bl	800bb70 <chSysHalt>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 800a8e8:	4e62      	ldr	r6, [pc, #392]	; (800aa74 <i2cStart.constprop.66+0x234>)
 800a8ea:	42b2      	cmp	r2, r6
 800a8ec:	dd68      	ble.n	800a9c0 <i2cStart.constprop.66+0x180>
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 800a8ee:	61c3      	str	r3, [r0, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 800a8f0:	780a      	ldrb	r2, [r1, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 800a8f2:	6803      	ldr	r3, [r0, #0]
  switch (opmode) {
 800a8f4:	2a02      	cmp	r2, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 800a8f6:	b29b      	uxth	r3, r3
  switch (opmode) {
 800a8f8:	f000 809d 	beq.w	800aa36 <i2cStart.constprop.66+0x1f6>
 800a8fc:	2a03      	cmp	r2, #3
 800a8fe:	f000 8097 	beq.w	800aa30 <i2cStart.constprop.66+0x1f0>
 800a902:	2a01      	cmp	r2, #1
 800a904:	d102      	bne.n	800a90c <i2cStart.constprop.66+0xcc>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800a906:	f023 030a 	bic.w	r3, r3, #10
 800a90a:	b29b      	uxth	r3, r3
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 800a90c:	6003      	str	r3, [r0, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 800a90e:	682b      	ldr	r3, [r5, #0]
 800a910:	f043 0301 	orr.w	r3, r3, #1
 800a914:	602b      	str	r3, [r5, #0]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 800a916:	2302      	movs	r3, #2
 800a918:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800a91a:	f001 fc21 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800a91e:	4b56      	ldr	r3, [pc, #344]	; (800aa78 <i2cStart.constprop.66+0x238>)
 800a920:	681a      	ldr	r2, [r3, #0]
 800a922:	429a      	cmp	r2, r3
 800a924:	d004      	beq.n	800a930 <i2cStart.constprop.66+0xf0>
 800a926:	6999      	ldr	r1, [r3, #24]
 800a928:	6893      	ldr	r3, [r2, #8]
 800a92a:	688a      	ldr	r2, [r1, #8]
 800a92c:	429a      	cmp	r2, r3
 800a92e:	d37c      	bcc.n	800aa2a <i2cStart.constprop.66+0x1ea>
 800a930:	2300      	movs	r3, #0
 800a932:	f383 8811 	msr	BASEPRI, r3
 800a936:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 800a93a:	f8df 8158 	ldr.w	r8, [pc, #344]	; 800aa94 <i2cStart.constprop.66+0x254>
      b = dmaStreamAllocate(i2cp->dmarx,
 800a93e:	6af0      	ldr	r0, [r6, #44]	; 0x2c

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 800a940:	f8d8 3020 	ldr.w	r3, [r8, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 800a944:	4a4d      	ldr	r2, [pc, #308]	; (800aa7c <i2cStart.constprop.66+0x23c>)

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 800a946:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800a94a:	2100      	movs	r1, #0
 800a94c:	f8c8 3020 	str.w	r3, [r8, #32]
 800a950:	f8c8 1020 	str.w	r1, [r8, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 800a954:	4633      	mov	r3, r6
 800a956:	2105      	movs	r1, #5
 800a958:	f7ff fc92 	bl	800a280 <dmaStreamAllocate>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 800a95c:	bb68      	cbnz	r0, 800a9ba <i2cStart.constprop.66+0x17a>
      b = dmaStreamAllocate(i2cp->dmatx,
 800a95e:	4633      	mov	r3, r6
 800a960:	4a47      	ldr	r2, [pc, #284]	; (800aa80 <i2cStart.constprop.66+0x240>)
 800a962:	6b30      	ldr	r0, [r6, #48]	; 0x30
 800a964:	2105      	movs	r1, #5
 800a966:	f7ff fc8b 	bl	800a280 <dmaStreamAllocate>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 800a96a:	bb30      	cbnz	r0, 800a9ba <i2cStart.constprop.66+0x17a>
      rccEnableI2C1(FALSE);
 800a96c:	f8d8 3040 	ldr.w	r3, [r8, #64]	; 0x40

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a970:	4a44      	ldr	r2, [pc, #272]	; (800aa84 <i2cStart.constprop.66+0x244>)
 800a972:	6871      	ldr	r1, [r6, #4]
 800a974:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800a978:	f8c8 3040 	str.w	r3, [r8, #64]	; 0x40
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a97c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a980:	2350      	movs	r3, #80	; 0x50
 800a982:	f882 331f 	strb.w	r3, [r2, #799]	; 0x31f
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a986:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a98a:	6010      	str	r0, [r2, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800a98c:	f882 3320 	strb.w	r3, [r2, #800]	; 0x320
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800a990:	6ab3      	ldr	r3, [r6, #40]	; 0x28
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800a992:	f8c2 7184 	str.w	r7, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800a996:	6057      	str	r7, [r2, #4]
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800a998:	6a70      	ldr	r0, [r6, #36]	; 0x24
 800a99a:	684a      	ldr	r2, [r1, #4]
 800a99c:	f891 c008 	ldrb.w	ip, [r1, #8]
 800a9a0:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800a9a4:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800a9a8:	f440 3040 	orr.w	r0, r0, #196608	; 0x30000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800a9ac:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800a9b0:	6270      	str	r0, [r6, #36]	; 0x24
 800a9b2:	1e57      	subs	r7, r2, #1
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800a9b4:	62b3      	str	r3, [r6, #40]	; 0x28
 800a9b6:	6b70      	ldr	r0, [r6, #52]	; 0x34
 800a9b8:	e768      	b.n	800a88c <i2cStart.constprop.66+0x4c>
      rccResetI2C1();
      b = dmaStreamAllocate(i2cp->dmarx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 800a9ba:	4833      	ldr	r0, [pc, #204]	; (800aa88 <i2cStart.constprop.66+0x248>)
 800a9bc:	f001 f8d8 	bl	800bb70 <chSysHalt>
    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
 800a9c0:	f1ac 0302 	sub.w	r3, ip, #2
 800a9c4:	2b01      	cmp	r3, #1
 800a9c6:	d88c      	bhi.n	800a8e2 <i2cStart.constprop.66+0xa2>
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 800a9c8:	f1bc 0f02 	cmp.w	ip, #2
 800a9cc:	d039      	beq.n	800aa42 <i2cStart.constprop.66+0x202>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
 800a9ce:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800a9d2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800a9d6:	4e2d      	ldr	r6, [pc, #180]	; (800aa8c <i2cStart.constprop.66+0x24c>)
 800a9d8:	fbb6 f3f2 	udiv	r3, r6, r2
 800a9dc:	fb02 f203 	mul.w	r2, r2, r3
 800a9e0:	1ab6      	subs	r6, r6, r2
 800a9e2:	2e00      	cmp	r6, #0
 800a9e4:	f47f af7d 	bne.w	800a8e2 <i2cStart.constprop.66+0xa2>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 800a9e8:	b29b      	uxth	r3, r3
      regCCR |= I2C_CCR_DUTY;
 800a9ea:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    }

    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 800a9ee:	4313      	orrs	r3, r2
 800a9f0:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800a9f4:	ea6f 4353 	mvn.w	r3, r3, lsr #17

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 800a9f8:	2208      	movs	r2, #8
 800a9fa:	b29b      	uxth	r3, r3
 800a9fc:	6202      	str	r2, [r0, #32]
 800a9fe:	e776      	b.n	800a8ee <i2cStart.constprop.66+0xae>
  if (clock_speed <= 100000) {
    /* Configure clock_div in standard mode.*/
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
 800aa00:	0052      	lsls	r2, r2, #1
 800aa02:	4e22      	ldr	r6, [pc, #136]	; (800aa8c <i2cStart.constprop.66+0x24c>)
 800aa04:	fbb6 f3f2 	udiv	r3, r6, r2
 800aa08:	fb02 f203 	mul.w	r2, r2, r3
 800aa0c:	1ab6      	subs	r6, r6, r2
 800aa0e:	2e00      	cmp	r6, #0
 800aa10:	f47f af67 	bne.w	800a8e2 <i2cStart.constprop.66+0xa2>
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 800aa14:	b29b      	uxth	r3, r3

    osalDbgAssert(clock_div >= 0x04,
 800aa16:	2b03      	cmp	r3, #3
 800aa18:	f67f af63 	bls.w	800a8e2 <i2cStart.constprop.66+0xa2>
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 800aa1c:	221b      	movs	r2, #27

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 800aa1e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 800aa22:	6202      	str	r2, [r0, #32]

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 800aa24:	f4bf af5d 	bcs.w	800a8e2 <i2cStart.constprop.66+0xa2>
 800aa28:	e761      	b.n	800a8ee <i2cStart.constprop.66+0xae>
 800aa2a:	4819      	ldr	r0, [pc, #100]	; (800aa90 <i2cStart.constprop.66+0x250>)
 800aa2c:	f001 f8a0 	bl	800bb70 <chSysHalt>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800aa30:	f043 030a 	orr.w	r3, r3, #10
 800aa34:	e76a      	b.n	800a90c <i2cStart.constprop.66+0xcc>
 800aa36:	f023 0308 	bic.w	r3, r3, #8
 800aa3a:	b29b      	uxth	r3, r3
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 800aa3c:	f043 0302 	orr.w	r3, r3, #2
 800aa40:	e764      	b.n	800a90c <i2cStart.constprop.66+0xcc>
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
 800aa42:	eb02 0642 	add.w	r6, r2, r2, lsl #1
 800aa46:	4a11      	ldr	r2, [pc, #68]	; (800aa8c <i2cStart.constprop.66+0x24c>)
 800aa48:	fbb2 f3f6 	udiv	r3, r2, r6
 800aa4c:	fb06 f603 	mul.w	r6, r6, r3
 800aa50:	1b92      	subs	r2, r2, r6
 800aa52:	2a00      	cmp	r2, #0
 800aa54:	f47f af45 	bne.w	800a8e2 <i2cStart.constprop.66+0xa2>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 800aa58:	b29b      	uxth	r3, r3
 800aa5a:	e7c8      	b.n	800a9ee <i2cStart.constprop.66+0x1ae>
 800aa5c:	2001aca4 	.word	0x2001aca4
 800aa60:	08010174 	.word	0x08010174
 800aa64:	080100f0 	.word	0x080100f0
 800aa68:	003d08ff 	.word	0x003d08ff
 800aa6c:	000186a0 	.word	0x000186a0
 800aa70:	08010218 	.word	0x08010218
 800aa74:	00061a80 	.word	0x00061a80
 800aa78:	2001acdc 	.word	0x2001acdc
 800aa7c:	08009f61 	.word	0x08009f61
 800aa80:	08009f21 	.word	0x08009f21
 800aa84:	e000e100 	.word	0xe000e100
 800aa88:	08010198 	.word	0x08010198
 800aa8c:	018cba80 	.word	0x018cba80
 800aa90:	080101a8 	.word	0x080101a8
 800aa94:	40023800 	.word	0x40023800
	...

0800aaa0 <spiExchange.constprop.47>:
 * @param[in] txbuf     the pointer to the transmit buffer
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
 800aaa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                 const void *txbuf, void *rxbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) &&
 800aaa2:	b168      	cbz	r0, 800aac0 <spiExchange.constprop.47+0x20>
 800aaa4:	4615      	mov	r5, r2
 800aaa6:	b15a      	cbz	r2, 800aac0 <spiExchange.constprop.47+0x20>
 800aaa8:	460e      	mov	r6, r1
 800aaaa:	b149      	cbz	r1, 800aac0 <spiExchange.constprop.47+0x20>
 800aaac:	4604      	mov	r4, r0
 800aaae:	2320      	movs	r3, #32
 800aab0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800aab4:	f001 fb64 	bl	800c180 <_dbg_check_lock>
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800aab8:	4b24      	ldr	r3, [pc, #144]	; (800ab4c <spiExchange.constprop.47+0xac>)
 800aaba:	781a      	ldrb	r2, [r3, #0]
 800aabc:	2a02      	cmp	r2, #2
 800aabe:	d002      	beq.n	800aac6 <spiExchange.constprop.47+0x26>
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {

  osalDbgCheck((spip != NULL) && (n > 0U) &&
 800aac0:	4823      	ldr	r0, [pc, #140]	; (800ab50 <spiExchange.constprop.47+0xb0>)
 800aac2:	f001 f855 	bl	800bb70 <chSysHalt>
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
 800aac6:	685a      	ldr	r2, [r3, #4]
 800aac8:	6812      	ldr	r2, [r2, #0]
 800aaca:	2a00      	cmp	r2, #0
 800aacc:	d1f8      	bne.n	800aac0 <spiExchange.constprop.47+0x20>
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 800aace:	2003      	movs	r0, #3
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
 800aad0:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
 800aad4:	7018      	strb	r0, [r3, #0]
 800aad6:	d21e      	bcs.n	800ab16 <spiExchange.constprop.47+0x76>

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 800aad8:	f103 0120 	add.w	r1, r3, #32
 800aadc:	e891 4006 	ldmia.w	r1, {r1, r2, lr}

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800aae0:	6adf      	ldr	r7, [r3, #44]	; 0x2c
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800aae2:	6809      	ldr	r1, [r1, #0]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800aae4:	6812      	ldr	r2, [r2, #0]
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800aae6:	60cd      	str	r5, [r1, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 800aae8:	f44e 6e80 	orr.w	lr, lr, #1024	; 0x400

  dmaStreamSetMemory0(spip->dmatx, txbuf);
  dmaStreamSetTransactionSize(spip->dmatx, n);
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800aaec:	f447 6580 	orr.w	r5, r7, #1024	; 0x400
                      const void *txbuf, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800aaf0:	604c      	str	r4, [r1, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode| STM32_DMA_CR_MINC);
 800aaf2:	f8c1 e000 	str.w	lr, [r1]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800aaf6:	60d6      	str	r6, [r2, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800aaf8:	6054      	str	r4, [r2, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800aafa:	6015      	str	r5, [r2, #0]

  dmaStreamEnable(spip->dmarx);
 800aafc:	680c      	ldr	r4, [r1, #0]
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 800aafe:	689d      	ldr	r5, [r3, #8]
 800ab00:	f044 0401 	orr.w	r4, r4, #1
 800ab04:	600c      	str	r4, [r1, #0]
  dmaStreamEnable(spip->dmatx);
 800ab06:	6811      	ldr	r1, [r2, #0]
 800ab08:	f041 0101 	orr.w	r1, r1, #1
 800ab0c:	6011      	str	r1, [r2, #0]
 800ab0e:	b12d      	cbz	r5, 800ab1c <spiExchange.constprop.47+0x7c>
 800ab10:	4810      	ldr	r0, [pc, #64]	; (800ab54 <spiExchange.constprop.47+0xb4>)
 800ab12:	f001 f82d 	bl	800bb70 <chSysHalt>
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {

  osalDbgAssert(n < 65536, "unsupported DMA transfer size");
 800ab16:	4810      	ldr	r0, [pc, #64]	; (800ab58 <spiExchange.constprop.47+0xb8>)
 800ab18:	f001 f82a 	bl	800bb70 <chSysHalt>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800ab1c:	4c0f      	ldr	r4, [pc, #60]	; (800ab5c <spiExchange.constprop.47+0xbc>)
 800ab1e:	69a2      	ldr	r2, [r4, #24]

  *trp = tp;
 800ab20:	f843 2f08 	str.w	r2, [r3, #8]!
  tp->u.wttrp = trp;
 800ab24:	6253      	str	r3, [r2, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800ab26:	f001 f853 	bl	800bbd0 <chSchGoSleepS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800ab2a:	f001 fb19 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ab2e:	6823      	ldr	r3, [r4, #0]
 800ab30:	42a3      	cmp	r3, r4
 800ab32:	d004      	beq.n	800ab3e <spiExchange.constprop.47+0x9e>
 800ab34:	69a2      	ldr	r2, [r4, #24]
 800ab36:	689b      	ldr	r3, [r3, #8]
 800ab38:	6892      	ldr	r2, [r2, #8]
 800ab3a:	429a      	cmp	r2, r3
 800ab3c:	d303      	bcc.n	800ab46 <spiExchange.constprop.47+0xa6>
 800ab3e:	2300      	movs	r3, #0
 800ab40:	f383 8811 	msr	BASEPRI, r3
 800ab44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ab46:	4806      	ldr	r0, [pc, #24]	; (800ab60 <spiExchange.constprop.47+0xc0>)
 800ab48:	f001 f812 	bl	800bb70 <chSysHalt>
 800ab4c:	2001b590 	.word	0x2001b590
 800ab50:	08010244 	.word	0x08010244
 800ab54:	080101b4 	.word	0x080101b4
 800ab58:	08010130 	.word	0x08010130
 800ab5c:	2001acdc 	.word	0x2001acdc
 800ab60:	0801022c 	.word	0x0801022c
	...

0800ab70 <spiStart.constprop.53>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 800ab70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ab72:	2320      	movs	r3, #32
 800ab74:	f383 8811 	msr	BASEPRI, r3

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
 800ab78:	4c35      	ldr	r4, [pc, #212]	; (800ac50 <spiStart.constprop.53+0xe0>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ab7a:	f001 fb01 	bl	800c180 <_dbg_check_lock>
 800ab7e:	7823      	ldrb	r3, [r4, #0]
 800ab80:	1e5a      	subs	r2, r3, #1
 800ab82:	2a01      	cmp	r2, #1
 800ab84:	d902      	bls.n	800ab8c <spiStart.constprop.53+0x1c>
 800ab86:	4833      	ldr	r0, [pc, #204]	; (800ac54 <spiStart.constprop.53+0xe4>)
 800ab88:	f000 fff2 	bl	800bb70 <chSysHalt>
                "invalid state");
  spip->config = config;
 800ab8c:	4a32      	ldr	r2, [pc, #200]	; (800ac58 <spiStart.constprop.53+0xe8>)
 800ab8e:	6062      	str	r2, [r4, #4]
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800ab90:	2b01      	cmp	r3, #1
 800ab92:	d02b      	beq.n	800abec <spiStart.constprop.53+0x7c>
 800ab94:	4611      	mov	r1, r2
 800ab96:	f44f 7041 	mov.w	r0, #772	; 0x304
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ab9a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ab9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ab9e:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800aba2:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800aba6:	62a2      	str	r2, [r4, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800aba8:	62e3      	str	r3, [r4, #44]	; 0x2c
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800abaa:	898a      	ldrh	r2, [r1, #12]
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 800abac:	69e3      	ldr	r3, [r4, #28]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800abae:	f042 0207 	orr.w	r2, r2, #7
 800abb2:	b292      	uxth	r2, r2
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }
  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 800abb4:	2100      	movs	r1, #0
 800abb6:	6019      	str	r1, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR | SPI_CR1_SSM |
 800abb8:	6018      	str	r0, [r3, #0]
                    SPI_CR1_SSI;
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_SSOE | SPI_CR2_RXDMAEN |
 800abba:	605a      	str	r2, [r3, #4]
                    SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 800abbc:	681a      	ldr	r2, [r3, #0]
 800abbe:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800abc2:	601a      	str	r2, [r3, #0]
  spi_lld_start(spip);
  spip->state = SPI_READY;
 800abc4:	2302      	movs	r3, #2
 800abc6:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800abc8:	f001 faca 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800abcc:	4b23      	ldr	r3, [pc, #140]	; (800ac5c <spiStart.constprop.53+0xec>)
 800abce:	681a      	ldr	r2, [r3, #0]
 800abd0:	429a      	cmp	r2, r3
 800abd2:	d004      	beq.n	800abde <spiStart.constprop.53+0x6e>
 800abd4:	6999      	ldr	r1, [r3, #24]
 800abd6:	6893      	ldr	r3, [r2, #8]
 800abd8:	688a      	ldr	r2, [r1, #8]
 800abda:	429a      	cmp	r2, r3
 800abdc:	d303      	bcc.n	800abe6 <spiStart.constprop.53+0x76>
 800abde:	2300      	movs	r3, #0
 800abe0:	f383 8811 	msr	BASEPRI, r3
 800abe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800abe6:	481e      	ldr	r0, [pc, #120]	; (800ac60 <spiStart.constprop.53+0xf0>)
 800abe8:	f000 ffc2 	bl	800bb70 <chSysHalt>
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800abec:	4623      	mov	r3, r4
 800abee:	4a1d      	ldr	r2, [pc, #116]	; (800ac64 <spiStart.constprop.53+0xf4>)
 800abf0:	6a20      	ldr	r0, [r4, #32]
 800abf2:	210a      	movs	r1, #10
 800abf4:	f7ff fb44 	bl	800a280 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800abf8:	bb30      	cbnz	r0, 800ac48 <spiStart.constprop.53+0xd8>
      b = dmaStreamAllocate(spip->dmatx,
 800abfa:	4623      	mov	r3, r4
 800abfc:	4a1a      	ldr	r2, [pc, #104]	; (800ac68 <spiStart.constprop.53+0xf8>)
 800abfe:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800ac00:	210a      	movs	r1, #10
 800ac02:	f7ff fb3d 	bl	800a280 <dmaStreamAllocate>
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800ac06:	b9f8      	cbnz	r0, 800ac48 <spiStart.constprop.53+0xd8>
      rccEnableSPI2(FALSE);
 800ac08:	4818      	ldr	r0, [pc, #96]	; (800ac6c <spiStart.constprop.53+0xfc>)
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800ac0a:	6a26      	ldr	r6, [r4, #32]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800ac0c:	6a65      	ldr	r5, [r4, #36]	; 0x24
 800ac0e:	6861      	ldr	r1, [r4, #4]
      b = dmaStreamAllocate(spip->dmatx,
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 800ac10:	6c02      	ldr	r2, [r0, #64]	; 0x40
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800ac12:	69e3      	ldr	r3, [r4, #28]
 800ac14:	6837      	ldr	r7, [r6, #0]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800ac16:	682e      	ldr	r6, [r5, #0]
 800ac18:	894d      	ldrh	r5, [r1, #10]
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800ac1a:	330c      	adds	r3, #12
      b = dmaStreamAllocate(spip->dmatx,
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 800ac1c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800ac20:	6402      	str	r2, [r0, #64]	; 0x40
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800ac22:	60bb      	str	r3, [r7, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800ac24:	60b3      	str	r3, [r6, #8]
  }

  /* Configuration-specific DMA setup.*/
  if ((spip->config->cr1 & SPI_CR1_DFF) == 0) {
 800ac26:	052b      	lsls	r3, r5, #20
 800ac28:	f445 7041 	orr.w	r0, r5, #772	; 0x304
 800ac2c:	d5b5      	bpl.n	800ab9a <spiStart.constprop.53+0x2a>
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac2e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac30:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac32:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac36:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac3a:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac3e:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac42:	62a2      	str	r2, [r4, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800ac44:	62e3      	str	r3, [r4, #44]	; 0x2c
 800ac46:	e7b0      	b.n	800abaa <spiStart.constprop.53+0x3a>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
 800ac48:	4809      	ldr	r0, [pc, #36]	; (800ac70 <spiStart.constprop.53+0x100>)
 800ac4a:	f000 ff91 	bl	800bb70 <chSysHalt>
 800ac4e:	bf00      	nop
 800ac50:	2001b590 	.word	0x2001b590
 800ac54:	08010180 	.word	0x08010180
 800ac58:	080101ec 	.word	0x080101ec
 800ac5c:	2001acdc 	.word	0x2001acdc
 800ac60:	0801022c 	.word	0x0801022c
 800ac64:	080070d1 	.word	0x080070d1
 800ac68:	08006db1 	.word	0x08006db1
 800ac6c:	40023800 	.word	0x40023800
 800ac70:	08010144 	.word	0x08010144
	...

0800ac80 <spiSelect.constprop.51>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 800ac80:	b508      	push	{r3, lr}
 800ac82:	2320      	movs	r3, #32
 800ac84:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ac88:	f001 fa7a 	bl	800c180 <_dbg_check_lock>

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800ac8c:	4b0f      	ldr	r3, [pc, #60]	; (800accc <spiSelect.constprop.51+0x4c>)
 800ac8e:	781a      	ldrb	r2, [r3, #0]
 800ac90:	2a02      	cmp	r2, #2
 800ac92:	d002      	beq.n	800ac9a <spiSelect.constprop.51+0x1a>
 800ac94:	480e      	ldr	r0, [pc, #56]	; (800acd0 <spiSelect.constprop.51+0x50>)
 800ac96:	f000 ff6b 	bl	800bb70 <chSysHalt>
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {

  palClearPad(spip->config->ssport, spip->config->sspad);
 800ac9a:	685a      	ldr	r2, [r3, #4]
 800ac9c:	8911      	ldrh	r1, [r2, #8]
 800ac9e:	6852      	ldr	r2, [r2, #4]
 800aca0:	2301      	movs	r3, #1
 800aca2:	408b      	lsls	r3, r1
 800aca4:	b29b      	uxth	r3, r3
 800aca6:	8353      	strh	r3, [r2, #26]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800aca8:	f001 fa5a 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800acac:	4b09      	ldr	r3, [pc, #36]	; (800acd4 <spiSelect.constprop.51+0x54>)
 800acae:	681a      	ldr	r2, [r3, #0]
 800acb0:	429a      	cmp	r2, r3
 800acb2:	d004      	beq.n	800acbe <spiSelect.constprop.51+0x3e>
 800acb4:	6999      	ldr	r1, [r3, #24]
 800acb6:	6893      	ldr	r3, [r2, #8]
 800acb8:	688a      	ldr	r2, [r1, #8]
 800acba:	429a      	cmp	r2, r3
 800acbc:	d303      	bcc.n	800acc6 <spiSelect.constprop.51+0x46>
 800acbe:	2300      	movs	r3, #0
 800acc0:	f383 8811 	msr	BASEPRI, r3
 800acc4:	bd08      	pop	{r3, pc}
 800acc6:	4804      	ldr	r0, [pc, #16]	; (800acd8 <spiSelect.constprop.51+0x58>)
 800acc8:	f000 ff52 	bl	800bb70 <chSysHalt>
 800accc:	2001b590 	.word	0x2001b590
 800acd0:	080100e4 	.word	0x080100e4
 800acd4:	2001acdc 	.word	0x2001acdc
 800acd8:	0801022c 	.word	0x0801022c
 800acdc:	00000000 	.word	0x00000000

0800ace0 <spiUnselect.constprop.49>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 800ace0:	b508      	push	{r3, lr}
 800ace2:	2320      	movs	r3, #32
 800ace4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ace8:	f001 fa4a 	bl	800c180 <_dbg_check_lock>

  osalDbgCheck(spip != NULL);

  osalSysLock();
  osalDbgAssert(spip->state == SPI_READY, "not ready");
 800acec:	4b0f      	ldr	r3, [pc, #60]	; (800ad2c <spiUnselect.constprop.49+0x4c>)
 800acee:	781a      	ldrb	r2, [r3, #0]
 800acf0:	2a02      	cmp	r2, #2
 800acf2:	d002      	beq.n	800acfa <spiUnselect.constprop.49+0x1a>
 800acf4:	480e      	ldr	r0, [pc, #56]	; (800ad30 <spiUnselect.constprop.49+0x50>)
 800acf6:	f000 ff3b 	bl	800bb70 <chSysHalt>
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {

  palSetPad(spip->config->ssport, spip->config->sspad);
 800acfa:	685a      	ldr	r2, [r3, #4]
 800acfc:	8911      	ldrh	r1, [r2, #8]
 800acfe:	6852      	ldr	r2, [r2, #4]
 800ad00:	2301      	movs	r3, #1
 800ad02:	408b      	lsls	r3, r1
 800ad04:	b29b      	uxth	r3, r3
 800ad06:	8313      	strh	r3, [r2, #24]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800ad08:	f001 fa2a 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ad0c:	4b09      	ldr	r3, [pc, #36]	; (800ad34 <spiUnselect.constprop.49+0x54>)
 800ad0e:	681a      	ldr	r2, [r3, #0]
 800ad10:	429a      	cmp	r2, r3
 800ad12:	d004      	beq.n	800ad1e <spiUnselect.constprop.49+0x3e>
 800ad14:	6999      	ldr	r1, [r3, #24]
 800ad16:	6893      	ldr	r3, [r2, #8]
 800ad18:	688a      	ldr	r2, [r1, #8]
 800ad1a:	429a      	cmp	r2, r3
 800ad1c:	d303      	bcc.n	800ad26 <spiUnselect.constprop.49+0x46>
 800ad1e:	2300      	movs	r3, #0
 800ad20:	f383 8811 	msr	BASEPRI, r3
 800ad24:	bd08      	pop	{r3, pc}
 800ad26:	4804      	ldr	r0, [pc, #16]	; (800ad38 <spiUnselect.constprop.49+0x58>)
 800ad28:	f000 ff22 	bl	800bb70 <chSysHalt>
 800ad2c:	2001b590 	.word	0x2001b590
 800ad30:	08010124 	.word	0x08010124
 800ad34:	2001acdc 	.word	0x2001acdc
 800ad38:	0801022c 	.word	0x0801022c
 800ad3c:	00000000 	.word	0x00000000

0800ad40 <wdgReset.constprop.35>:
 *
 * @param[in] wdgp      pointer to the @p WDGDriver object
 *
 * @api
 */
void wdgReset(WDGDriver *wdgp) {
 800ad40:	b508      	push	{r3, lr}
 800ad42:	2320      	movs	r3, #32
 800ad44:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ad48:	f001 fa1a 	bl	800c180 <_dbg_check_lock>

  osalDbgCheck(wdgp != NULL);

  osalSysLock();
  osalDbgAssert(wdgp->state == WDG_READY, "not ready");
 800ad4c:	4b0e      	ldr	r3, [pc, #56]	; (800ad88 <wdgReset.constprop.35+0x48>)
 800ad4e:	781a      	ldrb	r2, [r3, #0]
 800ad50:	2a02      	cmp	r2, #2
 800ad52:	d002      	beq.n	800ad5a <wdgReset.constprop.35+0x1a>
 800ad54:	480d      	ldr	r0, [pc, #52]	; (800ad8c <wdgReset.constprop.35+0x4c>)
 800ad56:	f000 ff0b 	bl	800bb70 <chSysHalt>
 *
 * @notapi
 */
void wdg_lld_reset(WDGDriver * wdgp) {

  wdgp->wdg->KR = KR_KEY_RELOAD;
 800ad5a:	689b      	ldr	r3, [r3, #8]
 800ad5c:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 800ad60:	601a      	str	r2, [r3, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800ad62:	f001 f9fd 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ad66:	4b0a      	ldr	r3, [pc, #40]	; (800ad90 <wdgReset.constprop.35+0x50>)
 800ad68:	681a      	ldr	r2, [r3, #0]
 800ad6a:	429a      	cmp	r2, r3
 800ad6c:	d004      	beq.n	800ad78 <wdgReset.constprop.35+0x38>
 800ad6e:	6999      	ldr	r1, [r3, #24]
 800ad70:	6893      	ldr	r3, [r2, #8]
 800ad72:	688a      	ldr	r2, [r1, #8]
 800ad74:	429a      	cmp	r2, r3
 800ad76:	d303      	bcc.n	800ad80 <wdgReset.constprop.35+0x40>
 800ad78:	2300      	movs	r3, #0
 800ad7a:	f383 8811 	msr	BASEPRI, r3
 800ad7e:	bd08      	pop	{r3, pc}
 800ad80:	4804      	ldr	r0, [pc, #16]	; (800ad94 <wdgReset.constprop.35+0x54>)
 800ad82:	f000 fef5 	bl	800bb70 <chSysHalt>
 800ad86:	bf00      	nop
 800ad88:	2001b564 	.word	0x2001b564
 800ad8c:	0801018c 	.word	0x0801018c
 800ad90:	2001acdc 	.word	0x2001acdc
 800ad94:	08010238 	.word	0x08010238
	...

0800ada0 <moduleIMG>:
	}

	TRACE_INFO("SSDV > %i packets", i);
}

THD_FUNCTION(moduleIMG, arg) {
 800ada0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 800ada4:	6b42      	ldr	r2, [r0, #52]	; 0x34
	}

	TRACE_INFO("SSDV > %i packets", i);
}

THD_FUNCTION(moduleIMG, arg) {
 800ada6:	b087      	sub	sp, #28
 800ada8:	4605      	mov	r5, r0
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
 800adaa:	2a00      	cmp	r2, #0
 800adac:	f040 860a 	bne.w	800b9c4 <moduleIMG+0xc24>
 800adb0:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
		chThdSleepMilliseconds(config->init_delay);

	// Print initialization message
	TRACE_INFO("IMG  > Startup module %s", config->name);
 800adb4:	4840      	ldr	r0, [pc, #256]	; (800aeb8 <moduleIMG+0x118>)
 800adb6:	4c41      	ldr	r4, [pc, #260]	; (800aebc <moduleIMG+0x11c>)
 800adb8:	4e41      	ldr	r6, [pc, #260]	; (800aec0 <moduleIMG+0x120>)
 800adba:	f001 f9f1 	bl	800c1a0 <chMtxLock>
 800adbe:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800adc0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800adc2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800adc6:	fb00 f101 	mul.w	r1, r0, r1
 800adca:	fba4 3101 	umull	r3, r1, r4, r1
 800adce:	0b49      	lsrs	r1, r1, #13
 800add0:	fba6 e301 	umull	lr, r3, r6, r1
 800add4:	fba4 e202 	umull	lr, r2, r4, r2
 800add8:	099b      	lsrs	r3, r3, #6
 800adda:	fb00 1313 	mls	r3, r0, r3, r1
 800adde:	0b52      	lsrs	r2, r2, #13
 800ade0:	4938      	ldr	r1, [pc, #224]	; (800aec4 <moduleIMG+0x124>)
 800ade2:	4839      	ldr	r0, [pc, #228]	; (800aec8 <moduleIMG+0x128>)
 800ade4:	f7ff fc54 	bl	800a690 <chprintf.constprop.26>
 800ade8:	4a38      	ldr	r2, [pc, #224]	; (800aecc <moduleIMG+0x12c>)
 800adea:	4939      	ldr	r1, [pc, #228]	; (800aed0 <moduleIMG+0x130>)
 800adec:	4836      	ldr	r0, [pc, #216]	; (800aec8 <moduleIMG+0x128>)
 800adee:	f7ff fc4f 	bl	800a690 <chprintf.constprop.26>
 800adf2:	2372      	movs	r3, #114	; 0x72
 800adf4:	4a37      	ldr	r2, [pc, #220]	; (800aed4 <moduleIMG+0x134>)
 800adf6:	4938      	ldr	r1, [pc, #224]	; (800aed8 <moduleIMG+0x138>)
 800adf8:	4833      	ldr	r0, [pc, #204]	; (800aec8 <moduleIMG+0x128>)
 800adfa:	f7ff fc49 	bl	800a690 <chprintf.constprop.26>
 800adfe:	4937      	ldr	r1, [pc, #220]	; (800aedc <moduleIMG+0x13c>)
 800ae00:	4831      	ldr	r0, [pc, #196]	; (800aec8 <moduleIMG+0x128>)
 800ae02:	f7ff fc45 	bl	800a690 <chprintf.constprop.26>
 800ae06:	462a      	mov	r2, r5
 800ae08:	4935      	ldr	r1, [pc, #212]	; (800aee0 <moduleIMG+0x140>)
 800ae0a:	482f      	ldr	r0, [pc, #188]	; (800aec8 <moduleIMG+0x128>)
 800ae0c:	f7ff fc40 	bl	800a690 <chprintf.constprop.26>
 800ae10:	4934      	ldr	r1, [pc, #208]	; (800aee4 <moduleIMG+0x144>)
 800ae12:	482d      	ldr	r0, [pc, #180]	; (800aec8 <moduleIMG+0x128>)
 800ae14:	f7ff fc3c 	bl	800a690 <chprintf.constprop.26>
 800ae18:	4827      	ldr	r0, [pc, #156]	; (800aeb8 <moduleIMG+0x118>)
 800ae1a:	f7fe fbb1 	bl	8009580 <chMtxUnlock>
 800ae1e:	f505 7386 	add.w	r3, r5, #268	; 0x10c
 800ae22:	f8d7 a024 	ldr.w	sl, [r7, #36]	; 0x24
 800ae26:	9301      	str	r3, [sp, #4]

	systime_t time = chVTGetSystemTimeX();
	while(true)
	{
		TRACE_INFO("IMG  > Do module IMAGE cycle");
 800ae28:	46b3      	mov	fp, r6
 800ae2a:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 800ae2e:	4822      	ldr	r0, [pc, #136]	; (800aeb8 <moduleIMG+0x118>)
 800ae30:	f001 f9b6 	bl	800c1a0 <chMtxLock>
 800ae34:	6a72      	ldr	r2, [r6, #36]	; 0x24
 800ae36:	6a70      	ldr	r0, [r6, #36]	; 0x24
 800ae38:	4922      	ldr	r1, [pc, #136]	; (800aec4 <moduleIMG+0x124>)
 800ae3a:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 800ae3e:	fb07 f000 	mul.w	r0, r7, r0
 800ae42:	fba4 3000 	umull	r3, r0, r4, r0
 800ae46:	0b40      	lsrs	r0, r0, #13
 800ae48:	fbab e300 	umull	lr, r3, fp, r0
 800ae4c:	fba4 e202 	umull	lr, r2, r4, r2
 800ae50:	099b      	lsrs	r3, r3, #6
 800ae52:	fb07 0313 	mls	r3, r7, r3, r0
 800ae56:	0b52      	lsrs	r2, r2, #13
 800ae58:	481b      	ldr	r0, [pc, #108]	; (800aec8 <moduleIMG+0x128>)
 800ae5a:	f7ff fc19 	bl	800a690 <chprintf.constprop.26>
 800ae5e:	4a1b      	ldr	r2, [pc, #108]	; (800aecc <moduleIMG+0x12c>)
 800ae60:	491b      	ldr	r1, [pc, #108]	; (800aed0 <moduleIMG+0x130>)
 800ae62:	4819      	ldr	r0, [pc, #100]	; (800aec8 <moduleIMG+0x128>)
 800ae64:	f7ff fc14 	bl	800a690 <chprintf.constprop.26>
 800ae68:	2377      	movs	r3, #119	; 0x77
 800ae6a:	4a1a      	ldr	r2, [pc, #104]	; (800aed4 <moduleIMG+0x134>)
 800ae6c:	491a      	ldr	r1, [pc, #104]	; (800aed8 <moduleIMG+0x138>)
 800ae6e:	4816      	ldr	r0, [pc, #88]	; (800aec8 <moduleIMG+0x128>)
 800ae70:	f7ff fc0e 	bl	800a690 <chprintf.constprop.26>
 800ae74:	4919      	ldr	r1, [pc, #100]	; (800aedc <moduleIMG+0x13c>)
 800ae76:	4814      	ldr	r0, [pc, #80]	; (800aec8 <moduleIMG+0x128>)
 800ae78:	f7ff fc0a 	bl	800a690 <chprintf.constprop.26>
 800ae7c:	491a      	ldr	r1, [pc, #104]	; (800aee8 <moduleIMG+0x148>)
 800ae7e:	4812      	ldr	r0, [pc, #72]	; (800aec8 <moduleIMG+0x128>)
 800ae80:	f7ff fc06 	bl	800a690 <chprintf.constprop.26>
 800ae84:	4917      	ldr	r1, [pc, #92]	; (800aee4 <moduleIMG+0x144>)
 800ae86:	4810      	ldr	r0, [pc, #64]	; (800aec8 <moduleIMG+0x128>)
 800ae88:	f7ff fc02 	bl	800a690 <chprintf.constprop.26>
 800ae8c:	480a      	ldr	r0, [pc, #40]	; (800aeb8 <moduleIMG+0x118>)
 800ae8e:	f7fe fb77 	bl	8009580 <chMtxUnlock>
/**
  * Sleeping method. Returns true if sleeping condition are given.
  */
bool p_sleep(const sleep_config_t *config)
{
	switch(config->type)
 800ae92:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
 800ae96:	6a72      	ldr	r2, [r6, #36]	; 0x24
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer
 800ae98:	f8c5 21b0 	str.w	r2, [r5, #432]	; 0x1b0
 800ae9c:	3b01      	subs	r3, #1
 800ae9e:	2b08      	cmp	r3, #8
 800aea0:	d858      	bhi.n	800af54 <moduleIMG+0x1b4>
 800aea2:	e8df f013 	tbh	[pc, r3, lsl #1]
 800aea6:	0228      	.short	0x0228
 800aea8:	020b021f 	.word	0x020b021f
 800aeac:	002301e3 	.word	0x002301e3
 800aeb0:	00230023 	.word	0x00230023
 800aeb4:	00230023 	.word	0x00230023
 800aeb8:	2001b720 	.word	0x2001b720
 800aebc:	d1b71759 	.word	0xd1b71759
 800aec0:	10624dd3 	.word	0x10624dd3
 800aec4:	0800ea50 	.word	0x0800ea50
 800aec8:	2001ac28 	.word	0x2001ac28
 800aecc:	0800f1dc 	.word	0x0800f1dc
 800aed0:	0800ea64 	.word	0x0800ea64
 800aed4:	0800ea74 	.word	0x0800ea74
 800aed8:	0800ea7c 	.word	0x0800ea7c
 800aedc:	0800f1e0 	.word	0x0800f1e0
 800aee0:	08010260 	.word	0x08010260
 800aee4:	0800eaa8 	.word	0x0800eaa8
 800aee8:	0801027c 	.word	0x0801027c
		case SLEEP_WHEN_DISCHARGING:
		case SLEEP_WHEN_CHARGING:
		case SLEEP_WHEN_INSIDE_ITU1:
		case SLEEP_WHEN_INSIDE_ITU2:
		case SLEEP_WHEN_INSIDE_ITU3:
			TRACE_WARN("Sleeping method not implemented");
 800aeec:	48c0      	ldr	r0, [pc, #768]	; (800b1f0 <moduleIMG+0x450>)
 800aeee:	f001 f957 	bl	800c1a0 <chMtxLock>
 800aef2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800aef6:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800aefa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800aefc:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800aefe:	49bd      	ldr	r1, [pc, #756]	; (800b1f4 <moduleIMG+0x454>)
 800af00:	fb06 f000 	mul.w	r0, r6, r0
 800af04:	fba4 3000 	umull	r3, r0, r4, r0
 800af08:	0b40      	lsrs	r0, r0, #13
 800af0a:	fbab 7300 	umull	r7, r3, fp, r0
 800af0e:	fba4 7202 	umull	r7, r2, r4, r2
 800af12:	099b      	lsrs	r3, r3, #6
 800af14:	fb06 0313 	mls	r3, r6, r3, r0
 800af18:	0b52      	lsrs	r2, r2, #13
 800af1a:	48b7      	ldr	r0, [pc, #732]	; (800b1f8 <moduleIMG+0x458>)
 800af1c:	f7ff fbb8 	bl	800a690 <chprintf.constprop.26>
 800af20:	4ab6      	ldr	r2, [pc, #728]	; (800b1fc <moduleIMG+0x45c>)
 800af22:	49b7      	ldr	r1, [pc, #732]	; (800b200 <moduleIMG+0x460>)
 800af24:	48b4      	ldr	r0, [pc, #720]	; (800b1f8 <moduleIMG+0x458>)
 800af26:	f7ff fbb3 	bl	800a690 <chprintf.constprop.26>
 800af2a:	2321      	movs	r3, #33	; 0x21
 800af2c:	4ab5      	ldr	r2, [pc, #724]	; (800b204 <moduleIMG+0x464>)
 800af2e:	49b6      	ldr	r1, [pc, #728]	; (800b208 <moduleIMG+0x468>)
 800af30:	48b1      	ldr	r0, [pc, #708]	; (800b1f8 <moduleIMG+0x458>)
 800af32:	f7ff fbad 	bl	800a690 <chprintf.constprop.26>
 800af36:	49b5      	ldr	r1, [pc, #724]	; (800b20c <moduleIMG+0x46c>)
 800af38:	48af      	ldr	r0, [pc, #700]	; (800b1f8 <moduleIMG+0x458>)
 800af3a:	f7ff fba9 	bl	800a690 <chprintf.constprop.26>
 800af3e:	49b4      	ldr	r1, [pc, #720]	; (800b210 <moduleIMG+0x470>)
 800af40:	48ad      	ldr	r0, [pc, #692]	; (800b1f8 <moduleIMG+0x458>)
 800af42:	f7ff fba5 	bl	800a690 <chprintf.constprop.26>
 800af46:	49b3      	ldr	r1, [pc, #716]	; (800b214 <moduleIMG+0x474>)
 800af48:	48ab      	ldr	r0, [pc, #684]	; (800b1f8 <moduleIMG+0x458>)
 800af4a:	f7ff fba1 	bl	800a690 <chprintf.constprop.26>
 800af4e:	48a8      	ldr	r0, [pc, #672]	; (800b1f0 <moduleIMG+0x450>)
 800af50:	f7fe fb16 	bl	8009580 <chMtxUnlock>
		{
			uint32_t image_len = 0;
			uint8_t *image;

			// Take photo if camera activated (if camera disabled, camera buffer is probably shared in config file)
			if(!config->ssdv_config.no_camera)
 800af54:	f895 3120 	ldrb.w	r3, [r5, #288]	; 0x120
 800af58:	9302      	str	r3, [sp, #8]
 800af5a:	2b00      	cmp	r3, #0
 800af5c:	f040 8486 	bne.w	800b86c <moduleIMG+0xacc>
 800af60:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
			{
				// Lock camera
				TRACE_INFO("IMG  > Lock camera");
 800af64:	48a2      	ldr	r0, [pc, #648]	; (800b1f0 <moduleIMG+0x450>)
bool OV2640_isAvailable(void)
{
	I2C_lock();

	// Configure pins
	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);			// CAM_EN
 800af66:	f8df 92d8 	ldr.w	r9, [pc, #728]	; 800b240 <moduleIMG+0x4a0>
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// CAM_RESET
 800af6a:	f8df 82d8 	ldr.w	r8, [pc, #728]	; 800b244 <moduleIMG+0x4a4>
 800af6e:	f001 f917 	bl	800c1a0 <chMtxLock>
 800af72:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800af74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800af76:	499f      	ldr	r1, [pc, #636]	; (800b1f4 <moduleIMG+0x454>)
 800af78:	489f      	ldr	r0, [pc, #636]	; (800b1f8 <moduleIMG+0x458>)
 800af7a:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800af7e:	fb06 f303 	mul.w	r3, r6, r3
 800af82:	fba4 e303 	umull	lr, r3, r4, r3
 800af86:	0b5b      	lsrs	r3, r3, #13
 800af88:	fbab ce03 	umull	ip, lr, fp, r3
 800af8c:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800af90:	fba4 c202 	umull	ip, r2, r4, r2
 800af94:	fb06 331e 	mls	r3, r6, lr, r3
 800af98:	0b52      	lsrs	r2, r2, #13
 800af9a:	f7ff fb79 	bl	800a690 <chprintf.constprop.26>
 800af9e:	4a9e      	ldr	r2, [pc, #632]	; (800b218 <moduleIMG+0x478>)
 800afa0:	4997      	ldr	r1, [pc, #604]	; (800b200 <moduleIMG+0x460>)
 800afa2:	4895      	ldr	r0, [pc, #596]	; (800b1f8 <moduleIMG+0x458>)
 800afa4:	f7ff fb74 	bl	800a690 <chprintf.constprop.26>
 800afa8:	2383      	movs	r3, #131	; 0x83
 800afaa:	4a9c      	ldr	r2, [pc, #624]	; (800b21c <moduleIMG+0x47c>)
 800afac:	4996      	ldr	r1, [pc, #600]	; (800b208 <moduleIMG+0x468>)
 800afae:	4892      	ldr	r0, [pc, #584]	; (800b1f8 <moduleIMG+0x458>)
 800afb0:	f7ff fb6e 	bl	800a690 <chprintf.constprop.26>
 800afb4:	4995      	ldr	r1, [pc, #596]	; (800b20c <moduleIMG+0x46c>)
 800afb6:	4890      	ldr	r0, [pc, #576]	; (800b1f8 <moduleIMG+0x458>)
 800afb8:	f7ff fb6a 	bl	800a690 <chprintf.constprop.26>
 800afbc:	4998      	ldr	r1, [pc, #608]	; (800b220 <moduleIMG+0x480>)
 800afbe:	488e      	ldr	r0, [pc, #568]	; (800b1f8 <moduleIMG+0x458>)
 800afc0:	f7ff fb66 	bl	800a690 <chprintf.constprop.26>
 800afc4:	4993      	ldr	r1, [pc, #588]	; (800b214 <moduleIMG+0x474>)
 800afc6:	488c      	ldr	r0, [pc, #560]	; (800b1f8 <moduleIMG+0x458>)
 800afc8:	f7ff fb62 	bl	800a690 <chprintf.constprop.26>
 800afcc:	4888      	ldr	r0, [pc, #544]	; (800b1f0 <moduleIMG+0x450>)
 800afce:	f7fe fad7 	bl	8009580 <chMtxUnlock>
				chMtxLock(&camera_mtx);
 800afd2:	4894      	ldr	r0, [pc, #592]	; (800b224 <moduleIMG+0x484>)
 800afd4:	f001 f8e4 	bl	800c1a0 <chMtxLock>
				TRACE_INFO("IMG  > Locked camera");
 800afd8:	4885      	ldr	r0, [pc, #532]	; (800b1f0 <moduleIMG+0x450>)
 800afda:	f001 f8e1 	bl	800c1a0 <chMtxLock>
 800afde:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800afe0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800afe2:	4984      	ldr	r1, [pc, #528]	; (800b1f4 <moduleIMG+0x454>)
 800afe4:	4884      	ldr	r0, [pc, #528]	; (800b1f8 <moduleIMG+0x458>)
 800afe6:	fb06 f303 	mul.w	r3, r6, r3
 800afea:	fba4 e303 	umull	lr, r3, r4, r3
 800afee:	0b5b      	lsrs	r3, r3, #13
 800aff0:	fbab ce03 	umull	ip, lr, fp, r3
 800aff4:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800aff8:	fba4 c202 	umull	ip, r2, r4, r2
 800affc:	fb06 331e 	mls	r3, r6, lr, r3
 800b000:	0b52      	lsrs	r2, r2, #13
 800b002:	f7ff fb45 	bl	800a690 <chprintf.constprop.26>
 800b006:	4a84      	ldr	r2, [pc, #528]	; (800b218 <moduleIMG+0x478>)
 800b008:	497d      	ldr	r1, [pc, #500]	; (800b200 <moduleIMG+0x460>)
 800b00a:	487b      	ldr	r0, [pc, #492]	; (800b1f8 <moduleIMG+0x458>)
 800b00c:	f7ff fb40 	bl	800a690 <chprintf.constprop.26>
 800b010:	2385      	movs	r3, #133	; 0x85
 800b012:	4a82      	ldr	r2, [pc, #520]	; (800b21c <moduleIMG+0x47c>)
 800b014:	497c      	ldr	r1, [pc, #496]	; (800b208 <moduleIMG+0x468>)
 800b016:	4878      	ldr	r0, [pc, #480]	; (800b1f8 <moduleIMG+0x458>)
 800b018:	f7ff fb3a 	bl	800a690 <chprintf.constprop.26>
 800b01c:	497b      	ldr	r1, [pc, #492]	; (800b20c <moduleIMG+0x46c>)
 800b01e:	4876      	ldr	r0, [pc, #472]	; (800b1f8 <moduleIMG+0x458>)
 800b020:	f7ff fb36 	bl	800a690 <chprintf.constprop.26>
 800b024:	4980      	ldr	r1, [pc, #512]	; (800b228 <moduleIMG+0x488>)
 800b026:	4874      	ldr	r0, [pc, #464]	; (800b1f8 <moduleIMG+0x458>)
 800b028:	f7ff fb32 	bl	800a690 <chprintf.constprop.26>
 800b02c:	4979      	ldr	r1, [pc, #484]	; (800b214 <moduleIMG+0x474>)
 800b02e:	4872      	ldr	r0, [pc, #456]	; (800b1f8 <moduleIMG+0x458>)
 800b030:	f7ff fb2e 	bl	800a690 <chprintf.constprop.26>
 800b034:	486e      	ldr	r0, [pc, #440]	; (800b1f0 <moduleIMG+0x450>)
 800b036:	f7fe faa3 	bl	8009580 <chMtxUnlock>

				// Lock RADIO from producing interferences
				TRACE_INFO("IMG  > Lock radio");
 800b03a:	486d      	ldr	r0, [pc, #436]	; (800b1f0 <moduleIMG+0x450>)
 800b03c:	f001 f8b0 	bl	800c1a0 <chMtxLock>
 800b040:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b042:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b044:	496b      	ldr	r1, [pc, #428]	; (800b1f4 <moduleIMG+0x454>)
 800b046:	486c      	ldr	r0, [pc, #432]	; (800b1f8 <moduleIMG+0x458>)
 800b048:	fb06 f303 	mul.w	r3, r6, r3
 800b04c:	fba4 e303 	umull	lr, r3, r4, r3
 800b050:	0b5b      	lsrs	r3, r3, #13
 800b052:	fbab ce03 	umull	ip, lr, fp, r3
 800b056:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b05a:	fba4 c202 	umull	ip, r2, r4, r2
 800b05e:	fb06 331e 	mls	r3, r6, lr, r3
 800b062:	0b52      	lsrs	r2, r2, #13
 800b064:	f7ff fb14 	bl	800a690 <chprintf.constprop.26>
 800b068:	4a6b      	ldr	r2, [pc, #428]	; (800b218 <moduleIMG+0x478>)
 800b06a:	4965      	ldr	r1, [pc, #404]	; (800b200 <moduleIMG+0x460>)
 800b06c:	4862      	ldr	r0, [pc, #392]	; (800b1f8 <moduleIMG+0x458>)
 800b06e:	f7ff fb0f 	bl	800a690 <chprintf.constprop.26>
 800b072:	2388      	movs	r3, #136	; 0x88
 800b074:	4a69      	ldr	r2, [pc, #420]	; (800b21c <moduleIMG+0x47c>)
 800b076:	4964      	ldr	r1, [pc, #400]	; (800b208 <moduleIMG+0x468>)
 800b078:	485f      	ldr	r0, [pc, #380]	; (800b1f8 <moduleIMG+0x458>)
 800b07a:	f7ff fb09 	bl	800a690 <chprintf.constprop.26>
 800b07e:	4963      	ldr	r1, [pc, #396]	; (800b20c <moduleIMG+0x46c>)
 800b080:	485d      	ldr	r0, [pc, #372]	; (800b1f8 <moduleIMG+0x458>)
 800b082:	f7ff fb05 	bl	800a690 <chprintf.constprop.26>
 800b086:	4969      	ldr	r1, [pc, #420]	; (800b22c <moduleIMG+0x48c>)
 800b088:	485b      	ldr	r0, [pc, #364]	; (800b1f8 <moduleIMG+0x458>)
 800b08a:	f7ff fb01 	bl	800a690 <chprintf.constprop.26>
 800b08e:	4961      	ldr	r1, [pc, #388]	; (800b214 <moduleIMG+0x474>)
 800b090:	4859      	ldr	r0, [pc, #356]	; (800b1f8 <moduleIMG+0x458>)
 800b092:	f7ff fafd 	bl	800a690 <chprintf.constprop.26>
 800b096:	4856      	ldr	r0, [pc, #344]	; (800b1f0 <moduleIMG+0x450>)
 800b098:	f7fe fa72 	bl	8009580 <chMtxUnlock>
				chMtxLock(&interference_mtx);
 800b09c:	4864      	ldr	r0, [pc, #400]	; (800b230 <moduleIMG+0x490>)
 800b09e:	f001 f87f 	bl	800c1a0 <chMtxLock>
				TRACE_INFO("IMG  > Locked radio");
 800b0a2:	4853      	ldr	r0, [pc, #332]	; (800b1f0 <moduleIMG+0x450>)
 800b0a4:	f001 f87c 	bl	800c1a0 <chMtxLock>
 800b0a8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b0aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b0ac:	4951      	ldr	r1, [pc, #324]	; (800b1f4 <moduleIMG+0x454>)
 800b0ae:	4852      	ldr	r0, [pc, #328]	; (800b1f8 <moduleIMG+0x458>)
 800b0b0:	fb06 f303 	mul.w	r3, r6, r3
 800b0b4:	fba4 e303 	umull	lr, r3, r4, r3
 800b0b8:	0b5b      	lsrs	r3, r3, #13
 800b0ba:	fbab ce03 	umull	ip, lr, fp, r3
 800b0be:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b0c2:	fba4 c202 	umull	ip, r2, r4, r2
 800b0c6:	fb06 331e 	mls	r3, r6, lr, r3
 800b0ca:	0b52      	lsrs	r2, r2, #13
 800b0cc:	f7ff fae0 	bl	800a690 <chprintf.constprop.26>
 800b0d0:	4a51      	ldr	r2, [pc, #324]	; (800b218 <moduleIMG+0x478>)
 800b0d2:	494b      	ldr	r1, [pc, #300]	; (800b200 <moduleIMG+0x460>)
 800b0d4:	4848      	ldr	r0, [pc, #288]	; (800b1f8 <moduleIMG+0x458>)
 800b0d6:	f7ff fadb 	bl	800a690 <chprintf.constprop.26>
 800b0da:	238a      	movs	r3, #138	; 0x8a
 800b0dc:	4a4f      	ldr	r2, [pc, #316]	; (800b21c <moduleIMG+0x47c>)
 800b0de:	494a      	ldr	r1, [pc, #296]	; (800b208 <moduleIMG+0x468>)
 800b0e0:	4845      	ldr	r0, [pc, #276]	; (800b1f8 <moduleIMG+0x458>)
 800b0e2:	f7ff fad5 	bl	800a690 <chprintf.constprop.26>
 800b0e6:	4949      	ldr	r1, [pc, #292]	; (800b20c <moduleIMG+0x46c>)
 800b0e8:	4843      	ldr	r0, [pc, #268]	; (800b1f8 <moduleIMG+0x458>)
 800b0ea:	f7ff fad1 	bl	800a690 <chprintf.constprop.26>
 800b0ee:	4951      	ldr	r1, [pc, #324]	; (800b234 <moduleIMG+0x494>)
 800b0f0:	4841      	ldr	r0, [pc, #260]	; (800b1f8 <moduleIMG+0x458>)
 800b0f2:	f7ff facd 	bl	800a690 <chprintf.constprop.26>
 800b0f6:	4947      	ldr	r1, [pc, #284]	; (800b214 <moduleIMG+0x474>)
 800b0f8:	483f      	ldr	r0, [pc, #252]	; (800b1f8 <moduleIMG+0x458>)
 800b0fa:	f7ff fac9 	bl	800a690 <chprintf.constprop.26>
 800b0fe:	483c      	ldr	r0, [pc, #240]	; (800b1f0 <moduleIMG+0x450>)
 800b100:	f7fe fa3e 	bl	8009580 <chMtxUnlock>

				// Shutdown radio (to avoid interference)
				radioShutdown();
 800b104:	f7fd fa2c 	bl	8008560 <radioShutdown>
 800b108:	484b      	ldr	r0, [pc, #300]	; (800b238 <moduleIMG+0x498>)
 800b10a:	f001 f849 	bl	800c1a0 <chMtxLock>
bool OV2640_isAvailable(void)
{
	I2C_lock();

	// Configure pins
	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);			// CAM_EN
 800b10e:	4648      	mov	r0, r9
 800b110:	2201      	movs	r2, #1
 800b112:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800b116:	f7ff f80b 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// CAM_RESET

	// Switch on camera
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
 800b11a:	f44f 6300 	mov.w	r3, #2048	; 0x800
{
	I2C_lock();

	// Configure pins
	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);			// CAM_EN
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// CAM_RESET
 800b11e:	2201      	movs	r2, #1
 800b120:	4640      	mov	r0, r8
 800b122:	2108      	movs	r1, #8

	// Switch on camera
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
 800b124:	9303      	str	r3, [sp, #12]
{
	I2C_lock();

	// Configure pins
	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);			// CAM_EN
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// CAM_RESET
 800b126:	f7ff f803 	bl	800a130 <_pal_lld_setgroupmode>

	// Switch on camera
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
 800b12a:	9b03      	ldr	r3, [sp, #12]
 800b12c:	f8a9 3018 	strh.w	r3, [r9, #24]
	palSetPad(PORT(CAM_RESET), PIN(CAM_RESET)); // Toggle reset
 800b130:	f04f 0108 	mov.w	r1, #8
	// Configure pins
	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);			// CAM_EN
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// CAM_RESET

	// Switch on camera
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
 800b134:	9303      	str	r3, [sp, #12]
	palSetPad(PORT(CAM_RESET), PIN(CAM_RESET)); // Toggle reset

	chThdSleepMilliseconds(100);
 800b136:	4630      	mov	r0, r6
	palSetPadMode(PORT(CAM_EN), PIN(CAM_EN), PAL_MODE_OUTPUT_PUSHPULL);			// CAM_EN
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_OUTPUT_PUSHPULL);	// CAM_RESET

	// Switch on camera
	palSetPad(PORT(CAM_EN), PIN(CAM_EN)); 		// Switch on camera
	palSetPad(PORT(CAM_RESET), PIN(CAM_RESET)); // Toggle reset
 800b138:	f8a8 1018 	strh.w	r1, [r8, #24]

	chThdSleepMilliseconds(100);
 800b13c:	f001 f900 	bl	800c340 <chThdSleep>

	uint16_t val;
	bool ret;
	if(I2C_read16_locked(OV2640_I2C_ADR, 0x0A, &val))
 800b140:	aa05      	add	r2, sp, #20
 800b142:	210a      	movs	r1, #10
 800b144:	2030      	movs	r0, #48	; 0x30
 800b146:	f001 fadb 	bl	800c700 <I2C_read16_locked>
 800b14a:	9b03      	ldr	r3, [sp, #12]
 800b14c:	4602      	mov	r2, r0
 800b14e:	2800      	cmp	r0, #0
 800b150:	f000 8325 	beq.w	800b79e <moduleIMG+0x9fe>
		ret = val == PID_OV2640;
	else
		ret = false;

	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_INPUT);	// CAM_RESET
 800b154:	9a02      	ldr	r2, [sp, #8]
 800b156:	4640      	mov	r0, r8
 800b158:	2108      	movs	r1, #8
	chThdSleepMilliseconds(100);

	uint16_t val;
	bool ret;
	if(I2C_read16_locked(OV2640_I2C_ADR, 0x0A, &val))
		ret = val == PID_OV2640;
 800b15a:	f8bd 8014 	ldrh.w	r8, [sp, #20]
	else
		ret = false;

	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 800b15e:	f8a9 301a 	strh.w	r3, [r9, #26]
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_INPUT);	// CAM_RESET
 800b162:	f7fe ffe5 	bl	800a130 <_pal_lld_setgroupmode>
/**
  * Unlocks all other I2C threads to access I2C
  */
void I2C_unlock(void)
{
	chMtxUnlock(&pi2c_mtx);
 800b166:	4834      	ldr	r0, [pc, #208]	; (800b238 <moduleIMG+0x498>)
 800b168:	f7fe fa0a 	bl	8009580 <chMtxUnlock>

				uint8_t tries;
				bool status = false;

				// Detect camera
				if(OV2640_isAvailable()) // OV2640 available
 800b16c:	f242 6326 	movw	r3, #9766	; 0x2626
 800b170:	4598      	cmp	r8, r3
 800b172:	f040 831d 	bne.w	800b7b0 <moduleIMG+0xa10>
				{
					TRACE_INFO("IMG  > OV2640 found");
 800b176:	481e      	ldr	r0, [pc, #120]	; (800b1f0 <moduleIMG+0x450>)
 800b178:	f001 f812 	bl	800c1a0 <chMtxLock>
 800b17c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b17e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b180:	491c      	ldr	r1, [pc, #112]	; (800b1f4 <moduleIMG+0x454>)
 800b182:	fb06 f303 	mul.w	r3, r6, r3
 800b186:	fba4 0303 	umull	r0, r3, r4, r3
 800b18a:	0b5b      	lsrs	r3, r3, #13
 800b18c:	fbab 7003 	umull	r7, r0, fp, r3
 800b190:	0980      	lsrs	r0, r0, #6
 800b192:	fba4 7202 	umull	r7, r2, r4, r2
 800b196:	fb06 3310 	mls	r3, r6, r0, r3
 800b19a:	0b52      	lsrs	r2, r2, #13
 800b19c:	4816      	ldr	r0, [pc, #88]	; (800b1f8 <moduleIMG+0x458>)
 800b19e:	f7ff fa77 	bl	800a690 <chprintf.constprop.26>
 800b1a2:	4a1d      	ldr	r2, [pc, #116]	; (800b218 <moduleIMG+0x478>)
 800b1a4:	4916      	ldr	r1, [pc, #88]	; (800b200 <moduleIMG+0x460>)
 800b1a6:	4814      	ldr	r0, [pc, #80]	; (800b1f8 <moduleIMG+0x458>)
 800b1a8:	f7ff fa72 	bl	800a690 <chprintf.constprop.26>
 800b1ac:	2395      	movs	r3, #149	; 0x95
 800b1ae:	4a1b      	ldr	r2, [pc, #108]	; (800b21c <moduleIMG+0x47c>)
 800b1b0:	4915      	ldr	r1, [pc, #84]	; (800b208 <moduleIMG+0x468>)
 800b1b2:	4811      	ldr	r0, [pc, #68]	; (800b1f8 <moduleIMG+0x458>)
 800b1b4:	f7ff fa6c 	bl	800a690 <chprintf.constprop.26>
 800b1b8:	4914      	ldr	r1, [pc, #80]	; (800b20c <moduleIMG+0x46c>)
 800b1ba:	480f      	ldr	r0, [pc, #60]	; (800b1f8 <moduleIMG+0x458>)
 800b1bc:	f7ff fa68 	bl	800a690 <chprintf.constprop.26>
 800b1c0:	491e      	ldr	r1, [pc, #120]	; (800b23c <moduleIMG+0x49c>)
 800b1c2:	480d      	ldr	r0, [pc, #52]	; (800b1f8 <moduleIMG+0x458>)
 800b1c4:	f7ff fa64 	bl	800a690 <chprintf.constprop.26>
 800b1c8:	4912      	ldr	r1, [pc, #72]	; (800b214 <moduleIMG+0x474>)
 800b1ca:	480b      	ldr	r0, [pc, #44]	; (800b1f8 <moduleIMG+0x458>)
 800b1cc:	f7ff fa60 	bl	800a690 <chprintf.constprop.26>
 800b1d0:	4807      	ldr	r0, [pc, #28]	; (800b1f0 <moduleIMG+0x450>)
 800b1d2:	f7fe f9d5 	bl	8009580 <chMtxUnlock>

					if(config->ssdv_config.res == RES_MAX) // Attempt maximum resolution (limited by memory)
 800b1d6:	f895 6114 	ldrb.w	r6, [r5, #276]	; 0x114
 800b1da:	2e05      	cmp	r6, #5
 800b1dc:	f040 8098 	bne.w	800b310 <moduleIMG+0x570>
					{
						config->ssdv_config.res = RES_UXGA; // Try maximum resolution
 800b1e0:	2304      	movs	r3, #4

						do {

							// Init camera
							OV2640_init(&config->ssdv_config);
 800b1e2:	9801      	ldr	r0, [sp, #4]
				{
					TRACE_INFO("IMG  > OV2640 found");

					if(config->ssdv_config.res == RES_MAX) // Attempt maximum resolution (limited by memory)
					{
						config->ssdv_config.res = RES_UXGA; // Try maximum resolution
 800b1e4:	f885 3114 	strb.w	r3, [r5, #276]	; 0x114

						do {

							// Init camera
							OV2640_init(&config->ssdv_config);
 800b1e8:	f7fc fcfa 	bl	8007be0 <OV2640_init>
 800b1ec:	4634      	mov	r4, r6
 800b1ee:	e02b      	b.n	800b248 <moduleIMG+0x4a8>
 800b1f0:	2001b720 	.word	0x2001b720
 800b1f4:	0800ea50 	.word	0x0800ea50
 800b1f8:	2001ac28 	.word	0x2001ac28
 800b1fc:	0800f190 	.word	0x0800f190
 800b200:	0800ea64 	.word	0x0800ea64
 800b204:	0801029c 	.word	0x0801029c
 800b208:	0800ea7c 	.word	0x0800ea7c
 800b20c:	0800f1e0 	.word	0x0800f1e0
 800b210:	080102a4 	.word	0x080102a4
 800b214:	0800eaa8 	.word	0x0800eaa8
 800b218:	0800f1dc 	.word	0x0800f1dc
 800b21c:	0800ea74 	.word	0x0800ea74
 800b220:	080102c4 	.word	0x080102c4
 800b224:	2001a9d8 	.word	0x2001a9d8
 800b228:	080102d8 	.word	0x080102d8
 800b22c:	080102f0 	.word	0x080102f0
 800b230:	2001aa1c 	.word	0x2001aa1c
 800b234:	08010304 	.word	0x08010304
 800b238:	2001aa30 	.word	0x2001aa30
 800b23c:	08010318 	.word	0x08010318
 800b240:	40020400 	.word	0x40020400
 800b244:	40020000 	.word	0x40020000

							// Sample data from DCMI through DMA into RAM
							tries = 5; // Try 5 times at maximum
							do { // Try capturing image until capture successful
								status = OV2640_Snapshot2RAM();
 800b248:	f7fc ffd2 	bl	80081f0 <OV2640_Snapshot2RAM>
							} while(!status && --tries);
 800b24c:	b918      	cbnz	r0, 800b256 <moduleIMG+0x4b6>
 800b24e:	1e63      	subs	r3, r4, #1
 800b250:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 800b254:	d1f8      	bne.n	800b248 <moduleIMG+0x4a8>
{
	return OV2640_getBuffer(NULL) > ov2640_config->ram_size-3;
}

uint32_t OV2640_getBuffer(uint8_t** buffer) {
	*buffer = ov2640_config->ram_buffer;
 800b256:	4a2c      	ldr	r2, [pc, #176]	; (800b308 <moduleIMG+0x568>)

							config->ssdv_config.res--; // Decrement resolution in next attempt (if status==false)
 800b258:	f895 3114 	ldrb.w	r3, [r5, #276]	; 0x114
 800b25c:	6811      	ldr	r1, [r2, #0]
 800b25e:	2200      	movs	r2, #0
 800b260:	68c9      	ldr	r1, [r1, #12]
 800b262:	3b01      	subs	r3, #1
 800b264:	f885 3114 	strb.w	r3, [r5, #276]	; 0x114
 800b268:	6011      	str	r1, [r2, #0]
 800b26a:	deff      	udf	#255	; 0xff

		case SLEEP_WHEN_VBAT_ABOVE_THRES:
			return getBatteryVoltageMV() > config->vbat_thres;

		case SLEEP_WHEN_VSOL_ABOVE_THRES:
			return getSolarVoltageMV() > config->vsol_thres;
 800b26c:	f001 fe30 	bl	800ced0 <getSolarVoltageMV>
 800b270:	f8b5 3040 	ldrh.w	r3, [r5, #64]	; 0x40
 800b274:	4283      	cmp	r3, r0
 800b276:	bf2c      	ite	cs
 800b278:	2000      	movcs	r0, #0
 800b27a:	2001      	movcc	r0, #1
	while(true)
	{
		TRACE_INFO("IMG  > Do module IMAGE cycle");
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		if(!p_sleep(&config->sleep_config))
 800b27c:	2800      	cmp	r0, #0
 800b27e:	f43f ae69 	beq.w	800af54 <moduleIMG+0x1b4>
	return false;
}

systime_t waitForTrigger(systime_t prev, trigger_config_t *config)
{
	switch(config->type)
 800b282:	f895 3044 	ldrb.w	r3, [r5, #68]	; 0x44
 800b286:	2b03      	cmp	r3, #3
 800b288:	d813      	bhi.n	800b2b2 <moduleIMG+0x512>
 800b28a:	e8df f003 	tbb	[pc, r3]
 800b28e:	022a      	.short	0x022a
 800b290:	121f      	.short	0x121f
	{
		case TRIG_EVENT: // Wait for new tracking point
			switch(config->event)
 800b292:	f895 304c 	ldrb.w	r3, [r5, #76]	; 0x4c
 800b296:	b31b      	cbz	r3, 800b2e0 <moduleIMG+0x540>
 800b298:	2b01      	cmp	r3, #1
 800b29a:	d117      	bne.n	800b2cc <moduleIMG+0x52c>
	}
}

void waitForNewTrackPoint(void)
{
	uint32_t old_id = getLastTrackPoint()->id;
 800b29c:	4e1b      	ldr	r6, [pc, #108]	; (800b30c <moduleIMG+0x56c>)
 800b29e:	6833      	ldr	r3, [r6, #0]
 800b2a0:	681f      	ldr	r7, [r3, #0]
	while(old_id == getLastTrackPoint()->id)
		chThdSleepMilliseconds(1000);
 800b2a2:	f242 7010 	movw	r0, #10000	; 0x2710
 800b2a6:	f001 f84b 	bl	800c340 <chThdSleep>
}

void waitForNewTrackPoint(void)
{
	uint32_t old_id = getLastTrackPoint()->id;
	while(old_id == getLastTrackPoint()->id)
 800b2aa:	6833      	ldr	r3, [r6, #0]
 800b2ac:	681b      	ldr	r3, [r3, #0]
 800b2ae:	429f      	cmp	r7, r3
 800b2b0:	d0f7      	beq.n	800b2a2 <moduleIMG+0x502>
 800b2b2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b2b6:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
 800b2ba:	e5b6      	b.n	800ae2a <moduleIMG+0x8a>

		case SLEEP_WHEN_VSOL_BELOW_THRES:
			return getSolarVoltageMV() < config->vsol_thres;

		case SLEEP_WHEN_VBAT_ABOVE_THRES:
			return getBatteryVoltageMV() > config->vbat_thres;
 800b2bc:	f001 fe20 	bl	800cf00 <getBatteryVoltageMV>
 800b2c0:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 800b2c2:	4283      	cmp	r3, r0
 800b2c4:	bf2c      	ite	cs
 800b2c6:	2000      	movcs	r0, #0
 800b2c8:	2001      	movcc	r0, #1
 800b2ca:	e7d7      	b.n	800b27c <moduleIMG+0x4dc>
				case NO_EVENT: // No event defined
					while(1); // Assert
			}
		
		case TRIG_TIMEOUT: // Wait for specified timeout
			return chThdSleepUntilWindowed(prev, prev + S2ST(config->timeout));
 800b2cc:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800b2ce:	f242 7110 	movw	r1, #10000	; 0x2710
 800b2d2:	fb01 a103 	mla	r1, r1, r3, sl
 800b2d6:	4650      	mov	r0, sl
 800b2d8:	f000 fffa 	bl	800c2d0 <chThdSleepUntilWindowed>
 800b2dc:	4682      	mov	sl, r0
 800b2de:	e5a4      	b.n	800ae2a <moduleIMG+0x8a>
 800b2e0:	e7fe      	b.n	800b2e0 <moduleIMG+0x540>
 800b2e2:	e7fe      	b.n	800b2e2 <moduleIMG+0x542>
	{
		case SLEEP_WHEN_VBAT_BELOW_THRES:
			return getBatteryVoltageMV() < config->vbat_thres;

		case SLEEP_WHEN_VSOL_BELOW_THRES:
			return getSolarVoltageMV() < config->vsol_thres;
 800b2e4:	f001 fdf4 	bl	800ced0 <getSolarVoltageMV>
 800b2e8:	f8b5 3040 	ldrh.w	r3, [r5, #64]	; 0x40
 800b2ec:	4283      	cmp	r3, r0
 800b2ee:	bf94      	ite	ls
 800b2f0:	2000      	movls	r0, #0
 800b2f2:	2001      	movhi	r0, #1
 800b2f4:	e7c2      	b.n	800b27c <moduleIMG+0x4dc>
bool p_sleep(const sleep_config_t *config)
{
	switch(config->type)
	{
		case SLEEP_WHEN_VBAT_BELOW_THRES:
			return getBatteryVoltageMV() < config->vbat_thres;
 800b2f6:	f001 fe03 	bl	800cf00 <getBatteryVoltageMV>
 800b2fa:	8feb      	ldrh	r3, [r5, #62]	; 0x3e
 800b2fc:	4283      	cmp	r3, r0
 800b2fe:	bf94      	ite	ls
 800b300:	2000      	movls	r0, #0
 800b302:	2001      	movhi	r0, #1
 800b304:	e7ba      	b.n	800b27c <moduleIMG+0x4dc>
 800b306:	bf00      	nop
 800b308:	2001aa5c 	.word	0x2001aa5c
 800b30c:	2001b730 	.word	0x2001b730
						config->ssdv_config.res = RES_MAX; // Revert register

					} else { // Static resolution

						// Init camera
						OV2640_init(&config->ssdv_config);
 800b310:	9801      	ldr	r0, [sp, #4]
 800b312:	f7fc fc65 	bl	8007be0 <OV2640_init>
 800b316:	2605      	movs	r6, #5

						// Sample data from DCMI through DMA into RAM
						tries = 5; // Try 5 times at maximum
						do { // Try capturing image until capture successful
							status = OV2640_Snapshot2RAM();
 800b318:	f7fc ff6a 	bl	80081f0 <OV2640_Snapshot2RAM>
						} while(!status && --tries);
 800b31c:	b918      	cbnz	r0, 800b326 <moduleIMG+0x586>
 800b31e:	3e01      	subs	r6, #1
 800b320:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 800b324:	d1f8      	bne.n	800b318 <moduleIMG+0x578>
 800b326:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 800b32a:	4681      	mov	r9, r0
	chThdSleepMilliseconds(3000);
}

void OV2640_deinit(void) {
	// DCMI Init
	TRACE_INFO("CAM  > Deinit DCMI");
 800b32c:	48ba      	ldr	r0, [pc, #744]	; (800b618 <moduleIMG+0x878>)
 800b32e:	f000 ff37 	bl	800c1a0 <chMtxLock>
 800b332:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b334:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b336:	49b9      	ldr	r1, [pc, #740]	; (800b61c <moduleIMG+0x87c>)
 800b338:	48b9      	ldr	r0, [pc, #740]	; (800b620 <moduleIMG+0x880>)
 800b33a:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800b33e:	fb06 f303 	mul.w	r3, r6, r3
 800b342:	fba4 e303 	umull	lr, r3, r4, r3
 800b346:	0b5b      	lsrs	r3, r3, #13
 800b348:	fbab ce03 	umull	ip, lr, fp, r3
 800b34c:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b350:	fba4 c202 	umull	ip, r2, r4, r2
 800b354:	fb06 331e 	mls	r3, r6, lr, r3
 800b358:	0b52      	lsrs	r2, r2, #13
 800b35a:	f7ff f999 	bl	800a690 <chprintf.constprop.26>
 800b35e:	4ab1      	ldr	r2, [pc, #708]	; (800b624 <moduleIMG+0x884>)
 800b360:	49b1      	ldr	r1, [pc, #708]	; (800b628 <moduleIMG+0x888>)
 800b362:	48af      	ldr	r0, [pc, #700]	; (800b620 <moduleIMG+0x880>)
 800b364:	f7ff f994 	bl	800a690 <chprintf.constprop.26>
 800b368:	f44f 7355 	mov.w	r3, #852	; 0x354
 800b36c:	4aaf      	ldr	r2, [pc, #700]	; (800b62c <moduleIMG+0x88c>)
 800b36e:	49b0      	ldr	r1, [pc, #704]	; (800b630 <moduleIMG+0x890>)
 800b370:	48ab      	ldr	r0, [pc, #684]	; (800b620 <moduleIMG+0x880>)
 800b372:	f7ff f98d 	bl	800a690 <chprintf.constprop.26>
 800b376:	49af      	ldr	r1, [pc, #700]	; (800b634 <moduleIMG+0x894>)
 800b378:	48a9      	ldr	r0, [pc, #676]	; (800b620 <moduleIMG+0x880>)
 800b37a:	f7ff f989 	bl	800a690 <chprintf.constprop.26>
 800b37e:	49ae      	ldr	r1, [pc, #696]	; (800b638 <moduleIMG+0x898>)
 800b380:	48a7      	ldr	r0, [pc, #668]	; (800b620 <moduleIMG+0x880>)
 800b382:	f7ff f985 	bl	800a690 <chprintf.constprop.26>
 800b386:	49ad      	ldr	r1, [pc, #692]	; (800b63c <moduleIMG+0x89c>)
 800b388:	48a5      	ldr	r0, [pc, #660]	; (800b620 <moduleIMG+0x880>)
 800b38a:	f7ff f981 	bl	800a690 <chprintf.constprop.26>
 800b38e:	48a2      	ldr	r0, [pc, #648]	; (800b618 <moduleIMG+0x878>)
 800b390:	f7fe f8f6 	bl	8009580 <chMtxUnlock>
}

void OV2640_DeinitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR &= ~RCC_AHB2Periph_DCMI;
 800b394:	49aa      	ldr	r1, [pc, #680]	; (800b640 <moduleIMG+0x8a0>)
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 800b396:	4aab      	ldr	r2, [pc, #684]	; (800b644 <moduleIMG+0x8a4>)
}

void OV2640_DeinitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR &= ~RCC_AHB2Periph_DCMI;
 800b398:	6b4b      	ldr	r3, [r1, #52]	; 0x34
	// DCMI Init
	TRACE_INFO("CAM  > Deinit DCMI");
	OV2640_DeinitDCMI();

	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
 800b39a:	489f      	ldr	r0, [pc, #636]	; (800b618 <moduleIMG+0x878>)
}

void OV2640_DeinitDCMI(void)
{
	// Clock enable
	RCC->AHB2ENR &= ~RCC_AHB2Periph_DCMI;
 800b39c:	f023 0301 	bic.w	r3, r3, #1
 800b3a0:	634b      	str	r3, [r1, #52]	; 0x34
	DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 800b3a2:	6813      	ldr	r3, [r2, #0]
 800b3a4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800b3a8:	f023 0301 	bic.w	r3, r3, #1
 800b3ac:	6013      	str	r3, [r2, #0]
	// DCMI Init
	TRACE_INFO("CAM  > Deinit DCMI");
	OV2640_DeinitDCMI();

	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
 800b3ae:	f000 fef7 	bl	800c1a0 <chMtxLock>
 800b3b2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b3b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b3b6:	4999      	ldr	r1, [pc, #612]	; (800b61c <moduleIMG+0x87c>)
 800b3b8:	4899      	ldr	r0, [pc, #612]	; (800b620 <moduleIMG+0x880>)
 800b3ba:	fb06 f303 	mul.w	r3, r6, r3
 800b3be:	fba4 7303 	umull	r7, r3, r4, r3
 800b3c2:	0b5b      	lsrs	r3, r3, #13
 800b3c4:	fbab e703 	umull	lr, r7, fp, r3
 800b3c8:	fba4 e202 	umull	lr, r2, r4, r2
 800b3cc:	09bf      	lsrs	r7, r7, #6
 800b3ce:	fb06 3317 	mls	r3, r6, r7, r3
 800b3d2:	0b52      	lsrs	r2, r2, #13
 800b3d4:	f7ff f95c 	bl	800a690 <chprintf.constprop.26>
 800b3d8:	4a92      	ldr	r2, [pc, #584]	; (800b624 <moduleIMG+0x884>)
 800b3da:	4993      	ldr	r1, [pc, #588]	; (800b628 <moduleIMG+0x888>)
 800b3dc:	4890      	ldr	r0, [pc, #576]	; (800b620 <moduleIMG+0x880>)
 800b3de:	f7ff f957 	bl	800a690 <chprintf.constprop.26>
 800b3e2:	f44f 7356 	mov.w	r3, #856	; 0x358
 800b3e6:	4a91      	ldr	r2, [pc, #580]	; (800b62c <moduleIMG+0x88c>)
 800b3e8:	4991      	ldr	r1, [pc, #580]	; (800b630 <moduleIMG+0x890>)
 800b3ea:	488d      	ldr	r0, [pc, #564]	; (800b620 <moduleIMG+0x880>)
 800b3ec:	f7ff f950 	bl	800a690 <chprintf.constprop.26>
 800b3f0:	4990      	ldr	r1, [pc, #576]	; (800b634 <moduleIMG+0x894>)
 800b3f2:	488b      	ldr	r0, [pc, #556]	; (800b620 <moduleIMG+0x880>)
 800b3f4:	f7ff f94c 	bl	800a690 <chprintf.constprop.26>
 800b3f8:	4993      	ldr	r1, [pc, #588]	; (800b648 <moduleIMG+0x8a8>)
 800b3fa:	4889      	ldr	r0, [pc, #548]	; (800b620 <moduleIMG+0x880>)
 800b3fc:	f7ff f948 	bl	800a690 <chprintf.constprop.26>
 800b400:	498e      	ldr	r1, [pc, #568]	; (800b63c <moduleIMG+0x89c>)
 800b402:	4887      	ldr	r0, [pc, #540]	; (800b620 <moduleIMG+0x880>)
 800b404:	f7ff f944 	bl	800a690 <chprintf.constprop.26>
 800b408:	4883      	ldr	r0, [pc, #524]	; (800b618 <moduleIMG+0x878>)
 800b40a:	f7fe f8b9 	bl	8009580 <chMtxUnlock>
}

void OV2640_DeinitDMA(void)
{
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamDisable(stream);
 800b40e:	4b8f      	ldr	r3, [pc, #572]	; (800b64c <moduleIMG+0x8ac>)
 800b410:	4a8e      	ldr	r2, [pc, #568]	; (800b64c <moduleIMG+0x8ac>)
 800b412:	681b      	ldr	r3, [r3, #0]
 800b414:	f023 031f 	bic.w	r3, r3, #31
 800b418:	6013      	str	r3, [r2, #0]
 800b41a:	4b8c      	ldr	r3, [pc, #560]	; (800b64c <moduleIMG+0x8ac>)
 800b41c:	681b      	ldr	r3, [r3, #0]
 800b41e:	f013 0801 	ands.w	r8, r3, #1
 800b422:	d1fa      	bne.n	800b41a <moduleIMG+0x67a>
 800b424:	4b8a      	ldr	r3, [pc, #552]	; (800b650 <moduleIMG+0x8b0>)
	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
	OV2640_DeinitDMA();

	// Power off OV2640
	TRACE_INFO("CAM  > Switch off");
 800b426:	487c      	ldr	r0, [pc, #496]	; (800b618 <moduleIMG+0x878>)
 800b428:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
}

void OV2640_DeinitDMA(void)
{
	const stm32_dma_stream_t *stream = STM32_DMA2_STREAM1;
	dmaStreamDisable(stream);
 800b42c:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 800b430:	601a      	str	r2, [r3, #0]
	// DCMI DMA
	TRACE_INFO("CAM  > Deinit DMA");
	OV2640_DeinitDMA();

	// Power off OV2640
	TRACE_INFO("CAM  > Switch off");
 800b432:	f000 feb5 	bl	800c1a0 <chMtxLock>
 800b436:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b438:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b43a:	4978      	ldr	r1, [pc, #480]	; (800b61c <moduleIMG+0x87c>)
 800b43c:	4878      	ldr	r0, [pc, #480]	; (800b620 <moduleIMG+0x880>)
 800b43e:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800b442:	fb06 f303 	mul.w	r3, r6, r3
 800b446:	fba4 e303 	umull	lr, r3, r4, r3
 800b44a:	0b5b      	lsrs	r3, r3, #13
 800b44c:	fbab ce03 	umull	ip, lr, fp, r3
 800b450:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b454:	fba4 c202 	umull	ip, r2, r4, r2
 800b458:	fb06 331e 	mls	r3, r6, lr, r3
 800b45c:	0b52      	lsrs	r2, r2, #13
 800b45e:	f7ff f917 	bl	800a690 <chprintf.constprop.26>
 800b462:	4a70      	ldr	r2, [pc, #448]	; (800b624 <moduleIMG+0x884>)
 800b464:	4970      	ldr	r1, [pc, #448]	; (800b628 <moduleIMG+0x888>)
 800b466:	486e      	ldr	r0, [pc, #440]	; (800b620 <moduleIMG+0x880>)
 800b468:	f7ff f912 	bl	800a690 <chprintf.constprop.26>
 800b46c:	f44f 7357 	mov.w	r3, #860	; 0x35c
 800b470:	4a6e      	ldr	r2, [pc, #440]	; (800b62c <moduleIMG+0x88c>)
 800b472:	496f      	ldr	r1, [pc, #444]	; (800b630 <moduleIMG+0x890>)
 800b474:	486a      	ldr	r0, [pc, #424]	; (800b620 <moduleIMG+0x880>)
 800b476:	f7ff f90b 	bl	800a690 <chprintf.constprop.26>
 800b47a:	496e      	ldr	r1, [pc, #440]	; (800b634 <moduleIMG+0x894>)
 800b47c:	4868      	ldr	r0, [pc, #416]	; (800b620 <moduleIMG+0x880>)
 800b47e:	f7ff f907 	bl	800a690 <chprintf.constprop.26>
 800b482:	4974      	ldr	r1, [pc, #464]	; (800b654 <moduleIMG+0x8b4>)
 800b484:	4866      	ldr	r0, [pc, #408]	; (800b620 <moduleIMG+0x880>)
 800b486:	f7ff f903 	bl	800a690 <chprintf.constprop.26>
 800b48a:	496c      	ldr	r1, [pc, #432]	; (800b63c <moduleIMG+0x89c>)
 800b48c:	4864      	ldr	r0, [pc, #400]	; (800b620 <moduleIMG+0x880>)
 800b48e:	f7ff f8ff 	bl	800a690 <chprintf.constprop.26>
 800b492:	4861      	ldr	r0, [pc, #388]	; (800b618 <moduleIMG+0x878>)
 800b494:	f7fe f874 	bl	8009580 <chMtxUnlock>
	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 800b498:	4b6f      	ldr	r3, [pc, #444]	; (800b658 <moduleIMG+0x8b8>)

	// Deinit pins
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_INPUT);	// CAM_RESET
 800b49a:	4870      	ldr	r0, [pc, #448]	; (800b65c <moduleIMG+0x8bc>)
	TRACE_INFO("CAM  > Deinit DMA");
	OV2640_DeinitDMA();

	// Power off OV2640
	TRACE_INFO("CAM  > Switch off");
	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 800b49c:	f44f 6100 	mov.w	r1, #2048	; 0x800

	// Deinit pins
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_INPUT);	// CAM_RESET
 800b4a0:	4642      	mov	r2, r8
	TRACE_INFO("CAM  > Deinit DMA");
	OV2640_DeinitDMA();

	// Power off OV2640
	TRACE_INFO("CAM  > Switch off");
	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 800b4a2:	8359      	strh	r1, [r3, #26]

	// Deinit pins
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_INPUT);	// CAM_RESET
 800b4a4:	2108      	movs	r1, #8
 800b4a6:	f7fe fe43 	bl	800a130 <_pal_lld_setgroupmode>
 800b4aa:	486d      	ldr	r0, [pc, #436]	; (800b660 <moduleIMG+0x8c0>)
 800b4ac:	f7fe f868 	bl	8009580 <chMtxUnlock>

					// Switch off camera
					OV2640_deinit();

					// Get image
					image_len = OV2640_getBuffer(&image);
 800b4b0:	a805      	add	r0, sp, #20
 800b4b2:	f7fc fe85 	bl	80081c0 <OV2640_getBuffer>
 800b4b6:	4680      	mov	r8, r0
					TRACE_INFO("IMG  > Image size: %d bytes", image_len);
 800b4b8:	4857      	ldr	r0, [pc, #348]	; (800b618 <moduleIMG+0x878>)
 800b4ba:	f000 fe71 	bl	800c1a0 <chMtxLock>
 800b4be:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b4c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b4c2:	4956      	ldr	r1, [pc, #344]	; (800b61c <moduleIMG+0x87c>)
 800b4c4:	4856      	ldr	r0, [pc, #344]	; (800b620 <moduleIMG+0x880>)
 800b4c6:	fb06 f303 	mul.w	r3, r6, r3
 800b4ca:	fba4 7303 	umull	r7, r3, r4, r3
 800b4ce:	0b5b      	lsrs	r3, r3, #13
 800b4d0:	fbab e703 	umull	lr, r7, fp, r3
 800b4d4:	fba4 e202 	umull	lr, r2, r4, r2
 800b4d8:	09bf      	lsrs	r7, r7, #6
 800b4da:	fb06 3317 	mls	r3, r6, r7, r3
 800b4de:	0b52      	lsrs	r2, r2, #13
 800b4e0:	f7ff f8d6 	bl	800a690 <chprintf.constprop.26>
 800b4e4:	4a4f      	ldr	r2, [pc, #316]	; (800b624 <moduleIMG+0x884>)
 800b4e6:	4950      	ldr	r1, [pc, #320]	; (800b628 <moduleIMG+0x888>)
 800b4e8:	484d      	ldr	r0, [pc, #308]	; (800b620 <moduleIMG+0x880>)
 800b4ea:	f7ff f8d1 	bl	800a690 <chprintf.constprop.26>
 800b4ee:	23be      	movs	r3, #190	; 0xbe
 800b4f0:	4a5c      	ldr	r2, [pc, #368]	; (800b664 <moduleIMG+0x8c4>)
 800b4f2:	494f      	ldr	r1, [pc, #316]	; (800b630 <moduleIMG+0x890>)
 800b4f4:	484a      	ldr	r0, [pc, #296]	; (800b620 <moduleIMG+0x880>)
 800b4f6:	f7ff f8cb 	bl	800a690 <chprintf.constprop.26>
 800b4fa:	494e      	ldr	r1, [pc, #312]	; (800b634 <moduleIMG+0x894>)
 800b4fc:	4848      	ldr	r0, [pc, #288]	; (800b620 <moduleIMG+0x880>)
 800b4fe:	f7ff f8c7 	bl	800a690 <chprintf.constprop.26>
 800b502:	4642      	mov	r2, r8
 800b504:	4958      	ldr	r1, [pc, #352]	; (800b668 <moduleIMG+0x8c8>)
 800b506:	4846      	ldr	r0, [pc, #280]	; (800b620 <moduleIMG+0x880>)
 800b508:	f7ff f8c2 	bl	800a690 <chprintf.constprop.26>
 800b50c:	494b      	ldr	r1, [pc, #300]	; (800b63c <moduleIMG+0x89c>)
 800b50e:	4844      	ldr	r0, [pc, #272]	; (800b620 <moduleIMG+0x880>)
 800b510:	f7ff f8be 	bl	800a690 <chprintf.constprop.26>
 800b514:	4840      	ldr	r0, [pc, #256]	; (800b618 <moduleIMG+0x878>)
 800b516:	f7fe f833 	bl	8009580 <chMtxUnlock>
 800b51a:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
					TRACE_ERROR("IMG  > No camera found");

				}

				// Unlock radio
				TRACE_INFO("IMG  > Unlock radio");
 800b51e:	483e      	ldr	r0, [pc, #248]	; (800b618 <moduleIMG+0x878>)
 800b520:	f000 fe3e 	bl	800c1a0 <chMtxLock>
 800b524:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b526:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b528:	493c      	ldr	r1, [pc, #240]	; (800b61c <moduleIMG+0x87c>)
 800b52a:	483d      	ldr	r0, [pc, #244]	; (800b620 <moduleIMG+0x880>)
 800b52c:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800b530:	fb06 f303 	mul.w	r3, r6, r3
 800b534:	fba4 e303 	umull	lr, r3, r4, r3
 800b538:	0b5b      	lsrs	r3, r3, #13
 800b53a:	fbab ce03 	umull	ip, lr, fp, r3
 800b53e:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b542:	fba4 c202 	umull	ip, r2, r4, r2
 800b546:	fb06 331e 	mls	r3, r6, lr, r3
 800b54a:	0b52      	lsrs	r2, r2, #13
 800b54c:	f7ff f8a0 	bl	800a690 <chprintf.constprop.26>
 800b550:	4a34      	ldr	r2, [pc, #208]	; (800b624 <moduleIMG+0x884>)
 800b552:	4935      	ldr	r1, [pc, #212]	; (800b628 <moduleIMG+0x888>)
 800b554:	4832      	ldr	r0, [pc, #200]	; (800b620 <moduleIMG+0x880>)
 800b556:	f7ff f89b 	bl	800a690 <chprintf.constprop.26>
 800b55a:	23c7      	movs	r3, #199	; 0xc7
 800b55c:	4a41      	ldr	r2, [pc, #260]	; (800b664 <moduleIMG+0x8c4>)
 800b55e:	4934      	ldr	r1, [pc, #208]	; (800b630 <moduleIMG+0x890>)
 800b560:	482f      	ldr	r0, [pc, #188]	; (800b620 <moduleIMG+0x880>)
 800b562:	f7ff f895 	bl	800a690 <chprintf.constprop.26>
 800b566:	4933      	ldr	r1, [pc, #204]	; (800b634 <moduleIMG+0x894>)
 800b568:	482d      	ldr	r0, [pc, #180]	; (800b620 <moduleIMG+0x880>)
 800b56a:	f7ff f891 	bl	800a690 <chprintf.constprop.26>
 800b56e:	493f      	ldr	r1, [pc, #252]	; (800b66c <moduleIMG+0x8cc>)
 800b570:	482b      	ldr	r0, [pc, #172]	; (800b620 <moduleIMG+0x880>)
 800b572:	f7ff f88d 	bl	800a690 <chprintf.constprop.26>
 800b576:	4931      	ldr	r1, [pc, #196]	; (800b63c <moduleIMG+0x89c>)
 800b578:	4829      	ldr	r0, [pc, #164]	; (800b620 <moduleIMG+0x880>)
 800b57a:	f7ff f889 	bl	800a690 <chprintf.constprop.26>
 800b57e:	4826      	ldr	r0, [pc, #152]	; (800b618 <moduleIMG+0x878>)
 800b580:	f7fd fffe 	bl	8009580 <chMtxUnlock>
				chMtxUnlock(&interference_mtx);
 800b584:	483a      	ldr	r0, [pc, #232]	; (800b670 <moduleIMG+0x8d0>)
 800b586:	f7fd fffb 	bl	8009580 <chMtxUnlock>
				TRACE_INFO("IMG  > Unlocked radio");
 800b58a:	4823      	ldr	r0, [pc, #140]	; (800b618 <moduleIMG+0x878>)
 800b58c:	f000 fe08 	bl	800c1a0 <chMtxLock>
 800b590:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b592:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b594:	4921      	ldr	r1, [pc, #132]	; (800b61c <moduleIMG+0x87c>)
 800b596:	4822      	ldr	r0, [pc, #136]	; (800b620 <moduleIMG+0x880>)
 800b598:	fb06 f303 	mul.w	r3, r6, r3
 800b59c:	fba4 e303 	umull	lr, r3, r4, r3
 800b5a0:	0b5b      	lsrs	r3, r3, #13
 800b5a2:	fbab ce03 	umull	ip, lr, fp, r3
 800b5a6:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b5aa:	fba4 c202 	umull	ip, r2, r4, r2
 800b5ae:	fb06 331e 	mls	r3, r6, lr, r3
 800b5b2:	0b52      	lsrs	r2, r2, #13
 800b5b4:	f7ff f86c 	bl	800a690 <chprintf.constprop.26>
 800b5b8:	4a1a      	ldr	r2, [pc, #104]	; (800b624 <moduleIMG+0x884>)
 800b5ba:	491b      	ldr	r1, [pc, #108]	; (800b628 <moduleIMG+0x888>)
 800b5bc:	4818      	ldr	r0, [pc, #96]	; (800b620 <moduleIMG+0x880>)
 800b5be:	f7ff f867 	bl	800a690 <chprintf.constprop.26>
 800b5c2:	23c9      	movs	r3, #201	; 0xc9
 800b5c4:	4a27      	ldr	r2, [pc, #156]	; (800b664 <moduleIMG+0x8c4>)
 800b5c6:	491a      	ldr	r1, [pc, #104]	; (800b630 <moduleIMG+0x890>)
 800b5c8:	4815      	ldr	r0, [pc, #84]	; (800b620 <moduleIMG+0x880>)
 800b5ca:	f7ff f861 	bl	800a690 <chprintf.constprop.26>
 800b5ce:	4919      	ldr	r1, [pc, #100]	; (800b634 <moduleIMG+0x894>)
 800b5d0:	4813      	ldr	r0, [pc, #76]	; (800b620 <moduleIMG+0x880>)
 800b5d2:	f7ff f85d 	bl	800a690 <chprintf.constprop.26>
 800b5d6:	4927      	ldr	r1, [pc, #156]	; (800b674 <moduleIMG+0x8d4>)
 800b5d8:	4811      	ldr	r0, [pc, #68]	; (800b620 <moduleIMG+0x880>)
 800b5da:	f7ff f859 	bl	800a690 <chprintf.constprop.26>
 800b5de:	4917      	ldr	r1, [pc, #92]	; (800b63c <moduleIMG+0x89c>)
 800b5e0:	480f      	ldr	r0, [pc, #60]	; (800b620 <moduleIMG+0x880>)
 800b5e2:	f7ff f855 	bl	800a690 <chprintf.constprop.26>
 800b5e6:	480c      	ldr	r0, [pc, #48]	; (800b618 <moduleIMG+0x878>)
 800b5e8:	f7fd ffca 	bl	8009580 <chMtxUnlock>

				// Unlock camera
				TRACE_INFO("IMG  > Unlock camera");
 800b5ec:	480a      	ldr	r0, [pc, #40]	; (800b618 <moduleIMG+0x878>)
 800b5ee:	f000 fdd7 	bl	800c1a0 <chMtxLock>
 800b5f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b5f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b5f6:	4909      	ldr	r1, [pc, #36]	; (800b61c <moduleIMG+0x87c>)
 800b5f8:	4809      	ldr	r0, [pc, #36]	; (800b620 <moduleIMG+0x880>)
 800b5fa:	fb06 f303 	mul.w	r3, r6, r3
 800b5fe:	fba4 e303 	umull	lr, r3, r4, r3
 800b602:	0b5b      	lsrs	r3, r3, #13
 800b604:	fbab ce03 	umull	ip, lr, fp, r3
 800b608:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b60c:	fba4 c202 	umull	ip, r2, r4, r2
 800b610:	fb06 331e 	mls	r3, r6, lr, r3
 800b614:	0b52      	lsrs	r2, r2, #13
 800b616:	e02f      	b.n	800b678 <moduleIMG+0x8d8>
 800b618:	2001b720 	.word	0x2001b720
 800b61c:	0800ea50 	.word	0x0800ea50
 800b620:	2001ac28 	.word	0x2001ac28
 800b624:	0800f1dc 	.word	0x0800f1dc
 800b628:	0800ea64 	.word	0x0800ea64
 800b62c:	0800fd60 	.word	0x0800fd60
 800b630:	0800ea7c 	.word	0x0800ea7c
 800b634:	0800f1e0 	.word	0x0800f1e0
 800b638:	0801032c 	.word	0x0801032c
 800b63c:	0800eaa8 	.word	0x0800eaa8
 800b640:	40023800 	.word	0x40023800
 800b644:	50050000 	.word	0x50050000
 800b648:	08010340 	.word	0x08010340
 800b64c:	40026428 	.word	0x40026428
 800b650:	40026408 	.word	0x40026408
 800b654:	08010354 	.word	0x08010354
 800b658:	40020400 	.word	0x40020400
 800b65c:	40020000 	.word	0x40020000
 800b660:	2001aa30 	.word	0x2001aa30
 800b664:	0800ea74 	.word	0x0800ea74
 800b668:	08010368 	.word	0x08010368
 800b66c:	0801039c 	.word	0x0801039c
 800b670:	2001aa1c 	.word	0x2001aa1c
 800b674:	080103b0 	.word	0x080103b0
 800b678:	f7ff f80a 	bl	800a690 <chprintf.constprop.26>
 800b67c:	4a6a      	ldr	r2, [pc, #424]	; (800b828 <moduleIMG+0xa88>)
 800b67e:	496b      	ldr	r1, [pc, #428]	; (800b82c <moduleIMG+0xa8c>)
 800b680:	486b      	ldr	r0, [pc, #428]	; (800b830 <moduleIMG+0xa90>)
 800b682:	f7ff f805 	bl	800a690 <chprintf.constprop.26>
 800b686:	23cc      	movs	r3, #204	; 0xcc
 800b688:	4a6a      	ldr	r2, [pc, #424]	; (800b834 <moduleIMG+0xa94>)
 800b68a:	496b      	ldr	r1, [pc, #428]	; (800b838 <moduleIMG+0xa98>)
 800b68c:	4868      	ldr	r0, [pc, #416]	; (800b830 <moduleIMG+0xa90>)
 800b68e:	f7fe ffff 	bl	800a690 <chprintf.constprop.26>
 800b692:	496a      	ldr	r1, [pc, #424]	; (800b83c <moduleIMG+0xa9c>)
 800b694:	4866      	ldr	r0, [pc, #408]	; (800b830 <moduleIMG+0xa90>)
 800b696:	f7fe fffb 	bl	800a690 <chprintf.constprop.26>
 800b69a:	4969      	ldr	r1, [pc, #420]	; (800b840 <moduleIMG+0xaa0>)
 800b69c:	4864      	ldr	r0, [pc, #400]	; (800b830 <moduleIMG+0xa90>)
 800b69e:	f7fe fff7 	bl	800a690 <chprintf.constprop.26>
 800b6a2:	4968      	ldr	r1, [pc, #416]	; (800b844 <moduleIMG+0xaa4>)
 800b6a4:	4862      	ldr	r0, [pc, #392]	; (800b830 <moduleIMG+0xa90>)
 800b6a6:	f7fe fff3 	bl	800a690 <chprintf.constprop.26>
 800b6aa:	4867      	ldr	r0, [pc, #412]	; (800b848 <moduleIMG+0xaa8>)
 800b6ac:	f7fd ff68 	bl	8009580 <chMtxUnlock>
				chMtxUnlock(&camera_mtx);
 800b6b0:	4866      	ldr	r0, [pc, #408]	; (800b84c <moduleIMG+0xaac>)
 800b6b2:	f7fd ff65 	bl	8009580 <chMtxUnlock>
				TRACE_INFO("IMG  > Unlocked camera");
 800b6b6:	4864      	ldr	r0, [pc, #400]	; (800b848 <moduleIMG+0xaa8>)
 800b6b8:	f000 fd72 	bl	800c1a0 <chMtxLock>
 800b6bc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b6be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b6c0:	4963      	ldr	r1, [pc, #396]	; (800b850 <moduleIMG+0xab0>)
 800b6c2:	485b      	ldr	r0, [pc, #364]	; (800b830 <moduleIMG+0xa90>)
 800b6c4:	fb06 f303 	mul.w	r3, r6, r3
 800b6c8:	fba4 e303 	umull	lr, r3, r4, r3
 800b6cc:	0b5b      	lsrs	r3, r3, #13
 800b6ce:	fbab ce03 	umull	ip, lr, fp, r3
 800b6d2:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b6d6:	fba4 c202 	umull	ip, r2, r4, r2
 800b6da:	fb06 331e 	mls	r3, r6, lr, r3
 800b6de:	0b52      	lsrs	r2, r2, #13
 800b6e0:	f7fe ffd6 	bl	800a690 <chprintf.constprop.26>
 800b6e4:	4a50      	ldr	r2, [pc, #320]	; (800b828 <moduleIMG+0xa88>)
 800b6e6:	4951      	ldr	r1, [pc, #324]	; (800b82c <moduleIMG+0xa8c>)
 800b6e8:	4851      	ldr	r0, [pc, #324]	; (800b830 <moduleIMG+0xa90>)
 800b6ea:	f7fe ffd1 	bl	800a690 <chprintf.constprop.26>
 800b6ee:	23ce      	movs	r3, #206	; 0xce
 800b6f0:	4a50      	ldr	r2, [pc, #320]	; (800b834 <moduleIMG+0xa94>)
 800b6f2:	4951      	ldr	r1, [pc, #324]	; (800b838 <moduleIMG+0xa98>)
 800b6f4:	484e      	ldr	r0, [pc, #312]	; (800b830 <moduleIMG+0xa90>)
 800b6f6:	f7fe ffcb 	bl	800a690 <chprintf.constprop.26>
 800b6fa:	4950      	ldr	r1, [pc, #320]	; (800b83c <moduleIMG+0xa9c>)
 800b6fc:	484c      	ldr	r0, [pc, #304]	; (800b830 <moduleIMG+0xa90>)
 800b6fe:	f7fe ffc7 	bl	800a690 <chprintf.constprop.26>
 800b702:	4954      	ldr	r1, [pc, #336]	; (800b854 <moduleIMG+0xab4>)
 800b704:	484a      	ldr	r0, [pc, #296]	; (800b830 <moduleIMG+0xa90>)
 800b706:	f7fe ffc3 	bl	800a690 <chprintf.constprop.26>
 800b70a:	494e      	ldr	r1, [pc, #312]	; (800b844 <moduleIMG+0xaa4>)
 800b70c:	4848      	ldr	r0, [pc, #288]	; (800b830 <moduleIMG+0xa90>)
 800b70e:	f7fe ffbf 	bl	800a690 <chprintf.constprop.26>
 800b712:	484d      	ldr	r0, [pc, #308]	; (800b848 <moduleIMG+0xaa8>)
 800b714:	f7fd ff34 	bl	8009580 <chMtxUnlock>

				// Encode/Transmit SSDV if image sampled successfully
				if(status)
 800b718:	f1b9 0f00 	cmp.w	r9, #0
 800b71c:	f43f adb1 	beq.w	800b282 <moduleIMG+0x4e2>
				{
					TRACE_INFO("IMG  > Encode/Transmit SSDV ID=%d", gimage_id++);
 800b720:	4849      	ldr	r0, [pc, #292]	; (800b848 <moduleIMG+0xaa8>)
 800b722:	f8df 9144 	ldr.w	r9, [pc, #324]	; 800b868 <moduleIMG+0xac8>
 800b726:	f000 fd3b 	bl	800c1a0 <chMtxLock>
 800b72a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b72c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b72e:	fb06 f303 	mul.w	r3, r6, r3
 800b732:	fba4 1303 	umull	r1, r3, r4, r3
 800b736:	0b5b      	lsrs	r3, r3, #13
 800b738:	fbab 0103 	umull	r0, r1, fp, r3
 800b73c:	fba4 0202 	umull	r0, r2, r4, r2
 800b740:	0989      	lsrs	r1, r1, #6
 800b742:	fb06 3311 	mls	r3, r6, r1, r3
 800b746:	0b52      	lsrs	r2, r2, #13
 800b748:	4941      	ldr	r1, [pc, #260]	; (800b850 <moduleIMG+0xab0>)
 800b74a:	4839      	ldr	r0, [pc, #228]	; (800b830 <moduleIMG+0xa90>)
 800b74c:	f7fe ffa0 	bl	800a690 <chprintf.constprop.26>
 800b750:	4a35      	ldr	r2, [pc, #212]	; (800b828 <moduleIMG+0xa88>)
 800b752:	4936      	ldr	r1, [pc, #216]	; (800b82c <moduleIMG+0xa8c>)
 800b754:	4836      	ldr	r0, [pc, #216]	; (800b830 <moduleIMG+0xa90>)
 800b756:	f7fe ff9b 	bl	800a690 <chprintf.constprop.26>
 800b75a:	23d3      	movs	r3, #211	; 0xd3
 800b75c:	4a35      	ldr	r2, [pc, #212]	; (800b834 <moduleIMG+0xa94>)
 800b75e:	4936      	ldr	r1, [pc, #216]	; (800b838 <moduleIMG+0xa98>)
 800b760:	4833      	ldr	r0, [pc, #204]	; (800b830 <moduleIMG+0xa90>)
 800b762:	f7fe ff95 	bl	800a690 <chprintf.constprop.26>
 800b766:	4935      	ldr	r1, [pc, #212]	; (800b83c <moduleIMG+0xa9c>)
 800b768:	4831      	ldr	r0, [pc, #196]	; (800b830 <moduleIMG+0xa90>)
 800b76a:	f7fe ff91 	bl	800a690 <chprintf.constprop.26>
 800b76e:	f8d9 2000 	ldr.w	r2, [r9]
 800b772:	4939      	ldr	r1, [pc, #228]	; (800b858 <moduleIMG+0xab8>)
 800b774:	482e      	ldr	r0, [pc, #184]	; (800b830 <moduleIMG+0xa90>)
 800b776:	1c53      	adds	r3, r2, #1
 800b778:	f8c9 3000 	str.w	r3, [r9]
 800b77c:	f7fe ff88 	bl	800a690 <chprintf.constprop.26>
 800b780:	4930      	ldr	r1, [pc, #192]	; (800b844 <moduleIMG+0xaa4>)
 800b782:	482b      	ldr	r0, [pc, #172]	; (800b830 <moduleIMG+0xa90>)
 800b784:	f7fe ff84 	bl	800a690 <chprintf.constprop.26>
 800b788:	482f      	ldr	r0, [pc, #188]	; (800b848 <moduleIMG+0xaa8>)
 800b78a:	f7fd fef9 	bl	8009580 <chMtxUnlock>
					encode_ssdv(image, image_len, config, gimage_id);
 800b78e:	f899 3000 	ldrb.w	r3, [r9]
 800b792:	9805      	ldr	r0, [sp, #20]
 800b794:	4641      	mov	r1, r8
 800b796:	462a      	mov	r2, r5
 800b798:	f7f6 f862 	bl	8001860 <encode_ssdv>
 800b79c:	e571      	b.n	800b282 <moduleIMG+0x4e2>
		ret = val == PID_OV2640;
	else
		ret = false;

	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_INPUT);	// CAM_RESET
 800b79e:	4640      	mov	r0, r8
	if(I2C_read16_locked(OV2640_I2C_ADR, 0x0A, &val))
		ret = val == PID_OV2640;
	else
		ret = false;

	palClearPad(PORT(CAM_EN), PIN(CAM_EN)); // Switch off camera
 800b7a0:	f8a9 301a 	strh.w	r3, [r9, #26]
	palSetPadMode(PORT(CAM_RESET), PIN(CAM_RESET), PAL_MODE_INPUT);	// CAM_RESET
 800b7a4:	2108      	movs	r1, #8
 800b7a6:	f7fe fcc3 	bl	800a130 <_pal_lld_setgroupmode>
 800b7aa:	482c      	ldr	r0, [pc, #176]	; (800b85c <moduleIMG+0xabc>)
 800b7ac:	f7fd fee8 	bl	8009580 <chMtxUnlock>
					image_len = OV2640_getBuffer(&image);
					TRACE_INFO("IMG  > Image size: %d bytes", image_len);

				} else { // Camera error

					TRACE_ERROR("IMG  > No camera found");
 800b7b0:	4825      	ldr	r0, [pc, #148]	; (800b848 <moduleIMG+0xaa8>)
 800b7b2:	f000 fcf5 	bl	800c1a0 <chMtxLock>
 800b7b6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800b7ba:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800b7be:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b7c0:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800b7c2:	4923      	ldr	r1, [pc, #140]	; (800b850 <moduleIMG+0xab0>)
 800b7c4:	fb06 f000 	mul.w	r0, r6, r0
 800b7c8:	fba4 3000 	umull	r3, r0, r4, r0
 800b7cc:	0b40      	lsrs	r0, r0, #13
 800b7ce:	fbab 7300 	umull	r7, r3, fp, r0
 800b7d2:	fba4 7202 	umull	r7, r2, r4, r2
 800b7d6:	099b      	lsrs	r3, r3, #6
 800b7d8:	fb06 0313 	mls	r3, r6, r3, r0
 800b7dc:	0b52      	lsrs	r2, r2, #13
 800b7de:	4814      	ldr	r0, [pc, #80]	; (800b830 <moduleIMG+0xa90>)
 800b7e0:	f7fe ff56 	bl	800a690 <chprintf.constprop.26>
 800b7e4:	4a1e      	ldr	r2, [pc, #120]	; (800b860 <moduleIMG+0xac0>)
 800b7e6:	4911      	ldr	r1, [pc, #68]	; (800b82c <moduleIMG+0xa8c>)
 800b7e8:	4811      	ldr	r0, [pc, #68]	; (800b830 <moduleIMG+0xa90>)
 800b7ea:	f7fe ff51 	bl	800a690 <chprintf.constprop.26>
 800b7ee:	23c2      	movs	r3, #194	; 0xc2
 800b7f0:	4a10      	ldr	r2, [pc, #64]	; (800b834 <moduleIMG+0xa94>)
 800b7f2:	4911      	ldr	r1, [pc, #68]	; (800b838 <moduleIMG+0xa98>)
 800b7f4:	480e      	ldr	r0, [pc, #56]	; (800b830 <moduleIMG+0xa90>)
 800b7f6:	f7fe ff4b 	bl	800a690 <chprintf.constprop.26>
 800b7fa:	4910      	ldr	r1, [pc, #64]	; (800b83c <moduleIMG+0xa9c>)
 800b7fc:	480c      	ldr	r0, [pc, #48]	; (800b830 <moduleIMG+0xa90>)
 800b7fe:	f7fe ff47 	bl	800a690 <chprintf.constprop.26>
 800b802:	4918      	ldr	r1, [pc, #96]	; (800b864 <moduleIMG+0xac4>)
 800b804:	480a      	ldr	r0, [pc, #40]	; (800b830 <moduleIMG+0xa90>)
 800b806:	f7fe ff43 	bl	800a690 <chprintf.constprop.26>
 800b80a:	490e      	ldr	r1, [pc, #56]	; (800b844 <moduleIMG+0xaa4>)
 800b80c:	4808      	ldr	r0, [pc, #32]	; (800b830 <moduleIMG+0xa90>)
 800b80e:	f7fe ff3f 	bl	800a690 <chprintf.constprop.26>
 800b812:	480d      	ldr	r0, [pc, #52]	; (800b848 <moduleIMG+0xaa8>)
 800b814:	f7fd feb4 	bl	8009580 <chMtxUnlock>

				// Shutdown radio (to avoid interference)
				radioShutdown();

				uint8_t tries;
				bool status = false;
 800b818:	f04f 0900 	mov.w	r9, #0
					image_len = OV2640_getBuffer(&image);
					TRACE_INFO("IMG  > Image size: %d bytes", image_len);

				} else { // Camera error

					TRACE_ERROR("IMG  > No camera found");
 800b81c:	21c2      	movs	r1, #194	; 0xc2
 800b81e:	4805      	ldr	r0, [pc, #20]	; (800b834 <moduleIMG+0xa94>)
 800b820:	f001 f8ae 	bl	800c980 <log_error>
		TRACE_INFO("IMG  > Do module IMAGE cycle");
		config->last_update = chVTGetSystemTimeX(); // Update Watchdog timer

		if(!p_sleep(&config->sleep_config))
		{
			uint32_t image_len = 0;
 800b824:	46c8      	mov	r8, r9
 800b826:	e678      	b.n	800b51a <moduleIMG+0x77a>
 800b828:	0800f1dc 	.word	0x0800f1dc
 800b82c:	0800ea64 	.word	0x0800ea64
 800b830:	2001ac28 	.word	0x2001ac28
 800b834:	0800ea74 	.word	0x0800ea74
 800b838:	0800ea7c 	.word	0x0800ea7c
 800b83c:	0800f1e0 	.word	0x0800f1e0
 800b840:	080103c8 	.word	0x080103c8
 800b844:	0800eaa8 	.word	0x0800eaa8
 800b848:	2001b720 	.word	0x2001b720
 800b84c:	2001a9d8 	.word	0x2001a9d8
 800b850:	0800ea50 	.word	0x0800ea50
 800b854:	080103e0 	.word	0x080103e0
 800b858:	080103f8 	.word	0x080103f8
 800b85c:	2001aa30 	.word	0x2001aa30
 800b860:	0800ea5c 	.word	0x0800ea5c
 800b864:	08010384 	.word	0x08010384
 800b868:	2001b5c0 	.word	0x2001b5c0
					encode_ssdv(image, image_len, config, gimage_id);
				}

			} else {

				image_len = OV2640_getBuffer(&image);
 800b86c:	a805      	add	r0, sp, #20
 800b86e:	f7fc fca7 	bl	80081c0 <OV2640_getBuffer>
 800b872:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
 800b876:	4607      	mov	r7, r0
				TRACE_INFO("IMG  > Image size: %d bytes", image_len);
 800b878:	4859      	ldr	r0, [pc, #356]	; (800b9e0 <moduleIMG+0xc40>)

				TRACE_INFO("IMG  > Camera disabled");
				TRACE_INFO("IMG  > Encode/Transmit SSDV ID=%d", gimage_id);
 800b87a:	f8df 8198 	ldr.w	r8, [pc, #408]	; 800ba14 <moduleIMG+0xc74>
				}

			} else {

				image_len = OV2640_getBuffer(&image);
				TRACE_INFO("IMG  > Image size: %d bytes", image_len);
 800b87e:	f000 fc8f 	bl	800c1a0 <chMtxLock>
 800b882:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800b886:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800b88a:	4956      	ldr	r1, [pc, #344]	; (800b9e4 <moduleIMG+0xc44>)
 800b88c:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800b890:	fb06 f303 	mul.w	r3, r6, r3
 800b894:	fba4 0303 	umull	r0, r3, r4, r3
 800b898:	0b5b      	lsrs	r3, r3, #13
 800b89a:	fbab e003 	umull	lr, r0, fp, r3
 800b89e:	fba4 e202 	umull	lr, r2, r4, r2
 800b8a2:	0980      	lsrs	r0, r0, #6
 800b8a4:	fb06 3310 	mls	r3, r6, r0, r3
 800b8a8:	0b52      	lsrs	r2, r2, #13
 800b8aa:	484f      	ldr	r0, [pc, #316]	; (800b9e8 <moduleIMG+0xc48>)
 800b8ac:	f7fe fef0 	bl	800a690 <chprintf.constprop.26>
 800b8b0:	4a4e      	ldr	r2, [pc, #312]	; (800b9ec <moduleIMG+0xc4c>)
 800b8b2:	494f      	ldr	r1, [pc, #316]	; (800b9f0 <moduleIMG+0xc50>)
 800b8b4:	484c      	ldr	r0, [pc, #304]	; (800b9e8 <moduleIMG+0xc48>)
 800b8b6:	f7fe feeb 	bl	800a690 <chprintf.constprop.26>
 800b8ba:	23da      	movs	r3, #218	; 0xda
 800b8bc:	4a4d      	ldr	r2, [pc, #308]	; (800b9f4 <moduleIMG+0xc54>)
 800b8be:	494e      	ldr	r1, [pc, #312]	; (800b9f8 <moduleIMG+0xc58>)
 800b8c0:	4849      	ldr	r0, [pc, #292]	; (800b9e8 <moduleIMG+0xc48>)
 800b8c2:	f7fe fee5 	bl	800a690 <chprintf.constprop.26>
 800b8c6:	494d      	ldr	r1, [pc, #308]	; (800b9fc <moduleIMG+0xc5c>)
 800b8c8:	4847      	ldr	r0, [pc, #284]	; (800b9e8 <moduleIMG+0xc48>)
 800b8ca:	f7fe fee1 	bl	800a690 <chprintf.constprop.26>
 800b8ce:	463a      	mov	r2, r7
 800b8d0:	494b      	ldr	r1, [pc, #300]	; (800ba00 <moduleIMG+0xc60>)
 800b8d2:	4845      	ldr	r0, [pc, #276]	; (800b9e8 <moduleIMG+0xc48>)
 800b8d4:	f7fe fedc 	bl	800a690 <chprintf.constprop.26>
 800b8d8:	494a      	ldr	r1, [pc, #296]	; (800ba04 <moduleIMG+0xc64>)
 800b8da:	4843      	ldr	r0, [pc, #268]	; (800b9e8 <moduleIMG+0xc48>)
 800b8dc:	f7fe fed8 	bl	800a690 <chprintf.constprop.26>
 800b8e0:	483f      	ldr	r0, [pc, #252]	; (800b9e0 <moduleIMG+0xc40>)
 800b8e2:	f7fd fe4d 	bl	8009580 <chMtxUnlock>

				TRACE_INFO("IMG  > Camera disabled");
 800b8e6:	483e      	ldr	r0, [pc, #248]	; (800b9e0 <moduleIMG+0xc40>)
 800b8e8:	f000 fc5a 	bl	800c1a0 <chMtxLock>
 800b8ec:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800b8f0:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800b8f4:	493b      	ldr	r1, [pc, #236]	; (800b9e4 <moduleIMG+0xc44>)
 800b8f6:	fb06 f303 	mul.w	r3, r6, r3
 800b8fa:	fba4 0303 	umull	r0, r3, r4, r3
 800b8fe:	0b5b      	lsrs	r3, r3, #13
 800b900:	fbab e003 	umull	lr, r0, fp, r3
 800b904:	fba4 e202 	umull	lr, r2, r4, r2
 800b908:	0980      	lsrs	r0, r0, #6
 800b90a:	fb06 3310 	mls	r3, r6, r0, r3
 800b90e:	0b52      	lsrs	r2, r2, #13
 800b910:	4835      	ldr	r0, [pc, #212]	; (800b9e8 <moduleIMG+0xc48>)
 800b912:	f7fe febd 	bl	800a690 <chprintf.constprop.26>
 800b916:	4a35      	ldr	r2, [pc, #212]	; (800b9ec <moduleIMG+0xc4c>)
 800b918:	4935      	ldr	r1, [pc, #212]	; (800b9f0 <moduleIMG+0xc50>)
 800b91a:	4833      	ldr	r0, [pc, #204]	; (800b9e8 <moduleIMG+0xc48>)
 800b91c:	f7fe feb8 	bl	800a690 <chprintf.constprop.26>
 800b920:	23dc      	movs	r3, #220	; 0xdc
 800b922:	4a34      	ldr	r2, [pc, #208]	; (800b9f4 <moduleIMG+0xc54>)
 800b924:	4934      	ldr	r1, [pc, #208]	; (800b9f8 <moduleIMG+0xc58>)
 800b926:	4830      	ldr	r0, [pc, #192]	; (800b9e8 <moduleIMG+0xc48>)
 800b928:	f7fe feb2 	bl	800a690 <chprintf.constprop.26>
 800b92c:	4933      	ldr	r1, [pc, #204]	; (800b9fc <moduleIMG+0xc5c>)
 800b92e:	482e      	ldr	r0, [pc, #184]	; (800b9e8 <moduleIMG+0xc48>)
 800b930:	f7fe feae 	bl	800a690 <chprintf.constprop.26>
 800b934:	4934      	ldr	r1, [pc, #208]	; (800ba08 <moduleIMG+0xc68>)
 800b936:	482c      	ldr	r0, [pc, #176]	; (800b9e8 <moduleIMG+0xc48>)
 800b938:	f7fe feaa 	bl	800a690 <chprintf.constprop.26>
 800b93c:	4931      	ldr	r1, [pc, #196]	; (800ba04 <moduleIMG+0xc64>)
 800b93e:	482a      	ldr	r0, [pc, #168]	; (800b9e8 <moduleIMG+0xc48>)
 800b940:	f7fe fea6 	bl	800a690 <chprintf.constprop.26>
 800b944:	4826      	ldr	r0, [pc, #152]	; (800b9e0 <moduleIMG+0xc40>)
 800b946:	f7fd fe1b 	bl	8009580 <chMtxUnlock>
				TRACE_INFO("IMG  > Encode/Transmit SSDV ID=%d", gimage_id);
 800b94a:	4825      	ldr	r0, [pc, #148]	; (800b9e0 <moduleIMG+0xc40>)
 800b94c:	f000 fc28 	bl	800c1a0 <chMtxLock>
 800b950:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800b954:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800b958:	4922      	ldr	r1, [pc, #136]	; (800b9e4 <moduleIMG+0xc44>)
 800b95a:	4823      	ldr	r0, [pc, #140]	; (800b9e8 <moduleIMG+0xc48>)
 800b95c:	fb06 f303 	mul.w	r3, r6, r3
 800b960:	fba4 e303 	umull	lr, r3, r4, r3
 800b964:	0b5b      	lsrs	r3, r3, #13
 800b966:	fbab ce03 	umull	ip, lr, fp, r3
 800b96a:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 800b96e:	fba4 c202 	umull	ip, r2, r4, r2
 800b972:	fb06 331e 	mls	r3, r6, lr, r3
 800b976:	0b52      	lsrs	r2, r2, #13
 800b978:	f7fe fe8a 	bl	800a690 <chprintf.constprop.26>
 800b97c:	4a1b      	ldr	r2, [pc, #108]	; (800b9ec <moduleIMG+0xc4c>)
 800b97e:	491c      	ldr	r1, [pc, #112]	; (800b9f0 <moduleIMG+0xc50>)
 800b980:	4819      	ldr	r0, [pc, #100]	; (800b9e8 <moduleIMG+0xc48>)
 800b982:	f7fe fe85 	bl	800a690 <chprintf.constprop.26>
 800b986:	23dd      	movs	r3, #221	; 0xdd
 800b988:	4a1a      	ldr	r2, [pc, #104]	; (800b9f4 <moduleIMG+0xc54>)
 800b98a:	491b      	ldr	r1, [pc, #108]	; (800b9f8 <moduleIMG+0xc58>)
 800b98c:	4816      	ldr	r0, [pc, #88]	; (800b9e8 <moduleIMG+0xc48>)
 800b98e:	f7fe fe7f 	bl	800a690 <chprintf.constprop.26>
 800b992:	491a      	ldr	r1, [pc, #104]	; (800b9fc <moduleIMG+0xc5c>)
 800b994:	4814      	ldr	r0, [pc, #80]	; (800b9e8 <moduleIMG+0xc48>)
 800b996:	f7fe fe7b 	bl	800a690 <chprintf.constprop.26>
 800b99a:	f8d8 2000 	ldr.w	r2, [r8]
 800b99e:	491b      	ldr	r1, [pc, #108]	; (800ba0c <moduleIMG+0xc6c>)
 800b9a0:	4811      	ldr	r0, [pc, #68]	; (800b9e8 <moduleIMG+0xc48>)
 800b9a2:	f7fe fe75 	bl	800a690 <chprintf.constprop.26>
 800b9a6:	4917      	ldr	r1, [pc, #92]	; (800ba04 <moduleIMG+0xc64>)
 800b9a8:	480f      	ldr	r0, [pc, #60]	; (800b9e8 <moduleIMG+0xc48>)
 800b9aa:	f7fe fe71 	bl	800a690 <chprintf.constprop.26>
 800b9ae:	480c      	ldr	r0, [pc, #48]	; (800b9e0 <moduleIMG+0xc40>)
 800b9b0:	f7fd fde6 	bl	8009580 <chMtxUnlock>
				encode_ssdv(image, image_len, config, gimage_id);
 800b9b4:	f898 3000 	ldrb.w	r3, [r8]
 800b9b8:	9805      	ldr	r0, [sp, #20]
 800b9ba:	4639      	mov	r1, r7
 800b9bc:	462a      	mov	r2, r5
 800b9be:	f7f5 ff4f 	bl	8001860 <encode_ssdv>
 800b9c2:	e45e      	b.n	800b282 <moduleIMG+0x4e2>
THD_FUNCTION(moduleIMG, arg) {
	module_conf_t* config = (module_conf_t*)arg;

	// Execute Initial delay
	if(config->init_delay)
		chThdSleepMilliseconds(config->init_delay);
 800b9c4:	f242 7310 	movw	r3, #10000	; 0x2710
 800b9c8:	fb03 f302 	mul.w	r3, r3, r2
 800b9cc:	4810      	ldr	r0, [pc, #64]	; (800ba10 <moduleIMG+0xc70>)
 800b9ce:	f203 33e7 	addw	r3, r3, #999	; 0x3e7
 800b9d2:	fba0 3003 	umull	r3, r0, r0, r3
 800b9d6:	0980      	lsrs	r0, r0, #6
 800b9d8:	f000 fcb2 	bl	800c340 <chThdSleep>
 800b9dc:	f7ff b9e8 	b.w	800adb0 <moduleIMG+0x10>
 800b9e0:	2001b720 	.word	0x2001b720
 800b9e4:	0800ea50 	.word	0x0800ea50
 800b9e8:	2001ac28 	.word	0x2001ac28
 800b9ec:	0800f1dc 	.word	0x0800f1dc
 800b9f0:	0800ea64 	.word	0x0800ea64
 800b9f4:	0800ea74 	.word	0x0800ea74
 800b9f8:	0800ea7c 	.word	0x0800ea7c
 800b9fc:	0800f1e0 	.word	0x0800f1e0
 800ba00:	08010368 	.word	0x08010368
 800ba04:	0800eaa8 	.word	0x0800eaa8
 800ba08:	0801041c 	.word	0x0801041c
 800ba0c:	080103f8 	.word	0x080103f8
 800ba10:	10624dd3 	.word	0x10624dd3
 800ba14:	2001b5c0 	.word	0x2001b5c0
	...

0800ba20 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 800ba20:	b410      	push	{r4}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 800ba22:	4a0b      	ldr	r2, [pc, #44]	; (800ba50 <trace_next+0x30>)
 800ba24:	480b      	ldr	r0, [pc, #44]	; (800ba54 <trace_next+0x34>)
 800ba26:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800ba28:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800ba2c:	6819      	ldr	r1, [r3, #0]
 800ba2e:	6a64      	ldr	r4, [r4, #36]	; 0x24
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 800ba30:	605c      	str	r4, [r3, #4]
 800ba32:	6840      	ldr	r0, [r0, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 800ba34:	f360 211f 	bfi	r1, r0, #8, #24
 800ba38:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800ba3c:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 800ba40:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 800ba42:	bf28      	it	cs
 800ba44:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 800ba48:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 800ba4a:	bc10      	pop	{r4}
 800ba4c:	4770      	bx	lr
 800ba4e:	bf00      	nop
 800ba50:	2001acdc 	.word	0x2001acdc
 800ba54:	e0001000 	.word	0xe0001000
	...

0800ba60 <_idle_thread.lto_priv.131>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 800ba60:	e7fe      	b.n	800ba60 <_idle_thread.lto_priv.131>
 800ba62:	bf00      	nop
	...

0800ba70 <chTMStopMeasurementX>:
 800ba70:	4b0f      	ldr	r3, [pc, #60]	; (800bab0 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800ba72:	4910      	ldr	r1, [pc, #64]	; (800bab4 <chTMStopMeasurementX+0x44>)
 800ba74:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800ba76:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800ba78:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800ba7a:	f8d1 7884 	ldr.w	r7, [r1, #2180]	; 0x884
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 800ba7e:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800ba80:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800ba82:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800ba86:	1ad3      	subs	r3, r2, r3
 800ba88:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 800ba8a:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 800ba8c:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800ba8e:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800ba90:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 800ba94:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800ba96:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 800ba9a:	bf88      	it	hi
 800ba9c:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 800ba9e:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800baa0:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800baa2:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 800baa6:	bf38      	it	cc
 800baa8:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 800baaa:	bcf0      	pop	{r4, r5, r6, r7}
 800baac:	4770      	bx	lr
 800baae:	bf00      	nop
 800bab0:	e0001000 	.word	0xe0001000
 800bab4:	2001acdc 	.word	0x2001acdc
	...

0800bac0 <_trace_switch.part.0.lto_priv.119>:
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800bac0:	4909      	ldr	r1, [pc, #36]	; (800bae8 <_trace_switch.part.0.lto_priv.119+0x28>)
 800bac2:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 800bac4:	7813      	ldrb	r3, [r2, #0]
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 800bac6:	b410      	push	{r4}

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800bac8:	2401      	movs	r4, #1
 800baca:	f364 0302 	bfi	r3, r4, #0, #3
 800bace:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800bad0:	f890 4020 	ldrb.w	r4, [r0, #32]
 800bad4:	f364 03c7 	bfi	r3, r4, #3, #5
 800bad8:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800bada:	698b      	ldr	r3, [r1, #24]
 800badc:	6093      	str	r3, [r2, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800bade:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800bae0:	60d3      	str	r3, [r2, #12]
    trace_next();
  }
}
 800bae2:	bc10      	pop	{r4}
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
    trace_next();
 800bae4:	f7ff bf9c 	b.w	800ba20 <trace_next>
 800bae8:	2001acdc 	.word	0x2001acdc
 800baec:	00000000 	.word	0x00000000

0800baf0 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800baf0:	4b0b      	ldr	r3, [pc, #44]	; (800bb20 <_trace_isr_leave+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 800baf2:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800baf4:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 800baf6:	f004 0402 	and.w	r4, r4, #2
 800bafa:	b2a4      	uxth	r4, r4
 800bafc:	b97c      	cbnz	r4, 800bb1e <_trace_isr_leave+0x2e>
 800bafe:	2220      	movs	r2, #32
 800bb00:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800bb04:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800bb06:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800bb08:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800bb0a:	2103      	movs	r1, #3
 800bb0c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800bb10:	f364 03c7 	bfi	r3, r4, #3, #5
 800bb14:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 800bb16:	f7ff ff83 	bl	800ba20 <trace_next>
 800bb1a:	f384 8811 	msr	BASEPRI, r4
 800bb1e:	bd10      	pop	{r4, pc}
 800bb20:	2001acdc 	.word	0x2001acdc
	...

0800bb30 <_trace_isr_enter>:
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800bb30:	4b0b      	ldr	r3, [pc, #44]	; (800bb60 <_trace_isr_enter+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 800bb32:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800bb34:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 800bb36:	f004 0402 	and.w	r4, r4, #2
 800bb3a:	b2a4      	uxth	r4, r4
 800bb3c:	b97c      	cbnz	r4, 800bb5e <_trace_isr_enter+0x2e>
 800bb3e:	2220      	movs	r2, #32
 800bb40:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800bb44:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800bb46:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800bb48:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800bb4a:	2102      	movs	r1, #2
 800bb4c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800bb50:	f364 03c7 	bfi	r3, r4, #3, #5
 800bb54:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 800bb56:	f7ff ff63 	bl	800ba20 <trace_next>
 800bb5a:	f384 8811 	msr	BASEPRI, r4
 800bb5e:	bd10      	pop	{r4, pc}
 800bb60:	2001acdc 	.word	0x2001acdc
	...

0800bb70 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 800bb70:	b508      	push	{r3, lr}
 800bb72:	4605      	mov	r5, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800bb74:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 800bb76:	4c0a      	ldr	r4, [pc, #40]	; (800bba0 <chSysHalt+0x30>)
 800bb78:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800bb7a:	f003 0304 	and.w	r3, r3, #4
 800bb7e:	b29b      	uxth	r3, r3
 800bb80:	b10b      	cbz	r3, 800bb86 <chSysHalt+0x16>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800bb82:	62e5      	str	r5, [r4, #44]	; 0x2c
 800bb84:	e7fe      	b.n	800bb84 <chSysHalt+0x14>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800bb86:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800bb88:	780a      	ldrb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 800bb8a:	6088      	str	r0, [r1, #8]
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800bb8c:	2004      	movs	r0, #4
 800bb8e:	f360 0202 	bfi	r2, r0, #0, #3
    ch.dbg.trace_buffer.ptr->state         = 0;
 800bb92:	f363 02c7 	bfi	r2, r3, #3, #5
 800bb96:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
    trace_next();
 800bb98:	f7ff ff42 	bl	800ba20 <trace_next>
 800bb9c:	e7f1      	b.n	800bb82 <chSysHalt+0x12>
 800bb9e:	bf00      	nop
 800bba0:	2001acdc 	.word	0x2001acdc
	...

0800bbb0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 800bbb0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800bbb2:	4b05      	ldr	r3, [pc, #20]	; (800bbc8 <chDbgCheckClassS+0x18>)
 800bbb4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bbb6:	b91a      	cbnz	r2, 800bbc0 <chDbgCheckClassS+0x10>
 800bbb8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bbba:	2b00      	cmp	r3, #0
 800bbbc:	dd00      	ble.n	800bbc0 <chDbgCheckClassS+0x10>
 800bbbe:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 800bbc0:	4802      	ldr	r0, [pc, #8]	; (800bbcc <chDbgCheckClassS+0x1c>)
 800bbc2:	f7ff ffd5 	bl	800bb70 <chSysHalt>
 800bbc6:	bf00      	nop
 800bbc8:	2001acdc 	.word	0x2001acdc
 800bbcc:	080104cc 	.word	0x080104cc

0800bbd0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800bbd0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 800bbd2:	4c12      	ldr	r4, [pc, #72]	; (800bc1c <chSchGoSleepS+0x4c>)
 800bbd4:	69a5      	ldr	r5, [r4, #24]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 800bbd6:	4606      	mov	r6, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 800bbd8:	f7ff ffea 	bl	800bbb0 <chDbgCheckClassS>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800bbdc:	6823      	ldr	r3, [r4, #0]

  /* New state.*/
  otp->state = newstate;
 800bbde:	f885 6020 	strb.w	r6, [r5, #32]

  tqp->next             = tp->queue.next;
 800bbe2:	681a      	ldr	r2, [r3, #0]
 800bbe4:	6022      	str	r2, [r4, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800bbe6:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800bbe8:	6054      	str	r4, [r2, #4]
 800bbea:	f883 1020 	strb.w	r1, [r3, #32]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800bbee:	8f22      	ldrh	r2, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800bbf0:	61a3      	str	r3, [r4, #24]
 800bbf2:	07d3      	lsls	r3, r2, #31
 800bbf4:	d402      	bmi.n	800bbfc <chSchGoSleepS+0x2c>
 800bbf6:	4628      	mov	r0, r5
 800bbf8:	f7ff ff62 	bl	800bac0 <_trace_switch.part.0.lto_priv.119>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800bbfc:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800bc00:	69ea      	ldr	r2, [r5, #28]
 800bc02:	3b24      	subs	r3, #36	; 0x24
 800bc04:	429a      	cmp	r2, r3
 800bc06:	d805      	bhi.n	800bc14 <chSchGoSleepS+0x44>
 800bc08:	4629      	mov	r1, r5
 800bc0a:	69a0      	ldr	r0, [r4, #24]
}
 800bc0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800bc10:	f7f4 bb40 	b.w	8000294 <_port_switch>
 800bc14:	4802      	ldr	r0, [pc, #8]	; (800bc20 <chSchGoSleepS+0x50>)
 800bc16:	f7ff ffab 	bl	800bb70 <chSysHalt>
 800bc1a:	bf00      	nop
 800bc1c:	2001acdc 	.word	0x2001acdc
 800bc20:	08010250 	.word	0x08010250
	...

0800bc30 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 800bc30:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800bc32:	4b05      	ldr	r3, [pc, #20]	; (800bc48 <chDbgCheckClassI+0x18>)
 800bc34:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800bc36:	2a00      	cmp	r2, #0
 800bc38:	db03      	blt.n	800bc42 <chDbgCheckClassI+0x12>
 800bc3a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bc3c:	2b00      	cmp	r3, #0
 800bc3e:	dd00      	ble.n	800bc42 <chDbgCheckClassI+0x12>
 800bc40:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 800bc42:	4802      	ldr	r0, [pc, #8]	; (800bc4c <chDbgCheckClassI+0x1c>)
 800bc44:	f7ff ff94 	bl	800bb70 <chSysHalt>
 800bc48:	2001acdc 	.word	0x2001acdc
 800bc4c:	080104d4 	.word	0x080104d4

0800bc50 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 800bc50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800bc52:	4604      	mov	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
 800bc54:	f7ff ffec 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800bc58:	b134      	cbz	r4, 800bc68 <chThdCreateSuspendedI+0x18>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 800bc5a:	6861      	ldr	r1, [r4, #4]
 800bc5c:	074b      	lsls	r3, r1, #29
 800bc5e:	d103      	bne.n	800bc68 <chThdCreateSuspendedI+0x18>
 800bc60:	68a3      	ldr	r3, [r4, #8]
 800bc62:	f013 0507 	ands.w	r5, r3, #7
 800bc66:	d002      	beq.n	800bc6e <chThdCreateSuspendedI+0x1e>
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
  chDbgCheck(tdp != NULL);
 800bc68:	4823      	ldr	r0, [pc, #140]	; (800bcf8 <chThdCreateSuspendedI+0xa8>)
 800bc6a:	f7ff ff81 	bl	800bb70 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 800bc6e:	4299      	cmp	r1, r3
 800bc70:	d2fa      	bcs.n	800bc68 <chThdCreateSuspendedI+0x18>
 800bc72:	1a5a      	subs	r2, r3, r1
 800bc74:	2ac7      	cmp	r2, #199	; 0xc7
 800bc76:	d9f7      	bls.n	800bc68 <chThdCreateSuspendedI+0x18>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 800bc78:	68e0      	ldr	r0, [r4, #12]
 800bc7a:	28ff      	cmp	r0, #255	; 0xff
 800bc7c:	d8f4      	bhi.n	800bc68 <chThdCreateSuspendedI+0x18>
 800bc7e:	6927      	ldr	r7, [r4, #16]
 800bc80:	2f00      	cmp	r7, #0
 800bc82:	d0f1      	beq.n	800bc68 <chThdCreateSuspendedI+0x18>
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800bc84:	4a1d      	ldr	r2, [pc, #116]	; (800bcfc <chThdCreateSuspendedI+0xac>)
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800bc86:	f843 1c2c 	str.w	r1, [r3, #-44]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800bc8a:	f04f 0e02 	mov.w	lr, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800bc8e:	2601      	movs	r6, #1
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800bc90:	6961      	ldr	r1, [r4, #20]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800bc92:	6824      	ldr	r4, [r4, #0]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 800bc94:	f803 ec28 	strb.w	lr, [r3, #-40]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800bc98:	f803 5c27 	strb.w	r5, [r3, #-39]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800bc9c:	f803 6c26 	strb.w	r6, [r3, #-38]
  tp->name      = name;
  REG_INSERT(tp);
 800bca0:	6956      	ldr	r6, [r2, #20]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800bca2:	f8df e05c 	ldr.w	lr, [pc, #92]	; 800bd00 <chThdCreateSuspendedI+0xb0>
 800bca6:	f843 7c6c 	str.w	r7, [r3, #-108]
 800bcaa:	f843 1c68 	str.w	r1, [r3, #-104]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800bcae:	f843 4c30 	str.w	r4, [r3, #-48]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 800bcb2:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 800bcb6:	f1a3 041c 	sub.w	r4, r3, #28
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800bcba:	f1a3 0c6c 	sub.w	ip, r3, #108	; 0x6c
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800bcbe:	f1a3 0720 	sub.w	r7, r3, #32
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800bcc2:	f843 0c40 	str.w	r0, [r3, #-64]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800bcc6:	f843 0c0c 	str.w	r0, [r3, #-12]
  tp->mtxlist   = NULL;
 800bcca:	f843 5c10 	str.w	r5, [r3, #-16]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800bcce:	f843 5c14 	str.w	r5, [r3, #-20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800bcd2:	f843 2c38 	str.w	r2, [r3, #-56]
 800bcd6:	f843 6c34 	str.w	r6, [r3, #-52]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800bcda:	f843 cc3c 	str.w	ip, [r3, #-60]
 800bcde:	f843 ec4c 	str.w	lr, [r3, #-76]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 800bce2:	4608      	mov	r0, r1
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800bce4:	6131      	str	r1, [r6, #16]
 800bce6:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800bce8:	f843 7c20 	str.w	r7, [r3, #-32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800bcec:	f843 4c1c 	str.w	r4, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 800bcf0:	f843 4c18 	str.w	r4, [r3, #-24]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 800bcf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800bcf6:	bf00      	nop
 800bcf8:	08010498 	.word	0x08010498
 800bcfc:	2001acdc 	.word	0x2001acdc
 800bd00:	080002a5 	.word	0x080002a5
	...

0800bd10 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 800bd10:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 800bd12:	4d1c      	ldr	r5, [pc, #112]	; (800bd84 <chSchDoReschedule+0x74>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800bd14:	682b      	ldr	r3, [r5, #0]
 800bd16:	69ae      	ldr	r6, [r5, #24]

  tqp->next             = tp->queue.next;
 800bd18:	681c      	ldr	r4, [r3, #0]
 800bd1a:	602c      	str	r4, [r5, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800bd1c:	2201      	movs	r2, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800bd1e:	6065      	str	r5, [r4, #4]
 800bd20:	f883 2020 	strb.w	r2, [r3, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800bd24:	61ab      	str	r3, [r5, #24]
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
 800bd26:	f7ff ff83 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800bd2a:	b326      	cbz	r6, 800bd76 <chSchDoReschedule+0x66>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800bd2c:	f896 3020 	ldrb.w	r3, [r6, #32]
 800bd30:	b30b      	cbz	r3, 800bd76 <chSchDoReschedule+0x66>
 800bd32:	2b0f      	cmp	r3, #15
 800bd34:	d01f      	beq.n	800bd76 <chSchDoReschedule+0x66>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800bd36:	2300      	movs	r3, #0
 800bd38:	68b2      	ldr	r2, [r6, #8]
 800bd3a:	f886 3020 	strb.w	r3, [r6, #32]
 800bd3e:	e000      	b.n	800bd42 <chSchDoReschedule+0x32>
 800bd40:	6824      	ldr	r4, [r4, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 800bd42:	68a3      	ldr	r3, [r4, #8]
 800bd44:	4293      	cmp	r3, r2
 800bd46:	d8fb      	bhi.n	800bd40 <chSchDoReschedule+0x30>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800bd48:	6863      	ldr	r3, [r4, #4]
 800bd4a:	8f2a      	ldrh	r2, [r5, #56]	; 0x38
 800bd4c:	6073      	str	r3, [r6, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800bd4e:	6034      	str	r4, [r6, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800bd50:	601e      	str	r6, [r3, #0]
 800bd52:	07d3      	lsls	r3, r2, #31
  cp->queue.prev             = tp;
 800bd54:	6066      	str	r6, [r4, #4]
 800bd56:	d402      	bmi.n	800bd5e <chSchDoReschedule+0x4e>
 800bd58:	4630      	mov	r0, r6
 800bd5a:	f7ff feb1 	bl	800bac0 <_trace_switch.part.0.lto_priv.119>
 800bd5e:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800bd62:	69f2      	ldr	r2, [r6, #28]
 800bd64:	3b24      	subs	r3, #36	; 0x24
 800bd66:	429a      	cmp	r2, r3
 800bd68:	d808      	bhi.n	800bd7c <chSchDoReschedule+0x6c>
 800bd6a:	4631      	mov	r1, r6
 800bd6c:	69a8      	ldr	r0, [r5, #24]
}
 800bd6e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800bd72:	f7f4 ba8f 	b.w	8000294 <_port_switch>
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 800bd76:	4804      	ldr	r0, [pc, #16]	; (800bd88 <chSchDoReschedule+0x78>)
 800bd78:	f7ff fefa 	bl	800bb70 <chSysHalt>

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800bd7c:	4803      	ldr	r0, [pc, #12]	; (800bd8c <chSchDoReschedule+0x7c>)
 800bd7e:	f7ff fef7 	bl	800bb70 <chSysHalt>
 800bd82:	bf00      	nop
 800bd84:	2001acdc 	.word	0x2001acdc
 800bd88:	08010478 	.word	0x08010478
 800bd8c:	08010250 	.word	0x08010250

0800bd90 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 800bd90:	b508      	push	{r3, lr}

  chDbgCheckClassS();
 800bd92:	f7ff ff0d 	bl	800bbb0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 800bd96:	f7ff ff4b 	bl	800bc30 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 800bd9a:	4b06      	ldr	r3, [pc, #24]	; (800bdb4 <chSchRescheduleS+0x24>)
 800bd9c:	681a      	ldr	r2, [r3, #0]
 800bd9e:	699b      	ldr	r3, [r3, #24]

  if (chSchIsRescRequiredI()) {
 800bda0:	6892      	ldr	r2, [r2, #8]
 800bda2:	689b      	ldr	r3, [r3, #8]
 800bda4:	429a      	cmp	r2, r3
 800bda6:	d800      	bhi.n	800bdaa <chSchRescheduleS+0x1a>
 800bda8:	bd08      	pop	{r3, pc}
    chSchDoRescheduleAhead();
  }
}
 800bdaa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
 800bdae:	f7ff bfaf 	b.w	800bd10 <chSchDoReschedule>
 800bdb2:	bf00      	nop
 800bdb4:	2001acdc 	.word	0x2001acdc
	...

0800bdc0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 800bdc0:	b510      	push	{r4, lr}
 800bdc2:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 800bdc4:	f7ff ff34 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800bdc8:	b1a4      	cbz	r4, 800bdf4 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800bdca:	f894 3020 	ldrb.w	r3, [r4, #32]
 800bdce:	b18b      	cbz	r3, 800bdf4 <chSchReadyI+0x34>
 800bdd0:	2b0f      	cmp	r3, #15
 800bdd2:	d00f      	beq.n	800bdf4 <chSchReadyI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800bdd4:	2200      	movs	r2, #0
 800bdd6:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 800bdd8:	4b08      	ldr	r3, [pc, #32]	; (800bdfc <chSchReadyI+0x3c>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800bdda:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800bdde:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800bde0:	689a      	ldr	r2, [r3, #8]
 800bde2:	428a      	cmp	r2, r1
 800bde4:	d2fb      	bcs.n	800bdde <chSchReadyI+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800bde6:	685a      	ldr	r2, [r3, #4]
 800bde8:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800bdea:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800bdec:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800bdee:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800bdf0:	605c      	str	r4, [r3, #4]

  return tp;
}
 800bdf2:	bd10      	pop	{r4, pc}
 */
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 800bdf4:	4802      	ldr	r0, [pc, #8]	; (800be00 <chSchReadyI+0x40>)
 800bdf6:	f7ff febb 	bl	800bb70 <chSysHalt>
 800bdfa:	bf00      	nop
 800bdfc:	2001acdc 	.word	0x2001acdc
 800be00:	0801046c 	.word	0x0801046c
	...

0800be10 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 800be10:	b508      	push	{r3, lr}

  if (*trp != NULL) {
 800be12:	6803      	ldr	r3, [r0, #0]
 800be14:	b173      	cbz	r3, 800be34 <chThdResumeI+0x24>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800be16:	f893 2020 	ldrb.w	r2, [r3, #32]
 800be1a:	2a03      	cmp	r2, #3
 800be1c:	d002      	beq.n	800be24 <chThdResumeI+0x14>
 800be1e:	4806      	ldr	r0, [pc, #24]	; (800be38 <chThdResumeI+0x28>)
 800be20:	f7ff fea6 	bl	800bb70 <chSysHalt>

    *trp = NULL;
 800be24:	2200      	movs	r2, #0
 800be26:	6002      	str	r2, [r0, #0]
    tp->u.rdymsg = msg;
 800be28:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800be2a:	4618      	mov	r0, r3
  }
}
 800be2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800be30:	f7ff bfc6 	b.w	800bdc0 <chSchReadyI>
 800be34:	bd08      	pop	{r3, pc}
 800be36:	bf00      	nop
 800be38:	08010434 	.word	0x08010434
 800be3c:	00000000 	.word	0x00000000

0800be40 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 800be40:	b510      	push	{r4, lr}
 800be42:	4604      	mov	r4, r0

  chDbgCheckClassI();
 800be44:	f7ff fef4 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 800be48:	2c00      	cmp	r4, #0
 800be4a:	d033      	beq.n	800beb4 <chVTDoResetI+0x74>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 800be4c:	68e3      	ldr	r3, [r4, #12]
 800be4e:	2b00      	cmp	r3, #0
 800be50:	d030      	beq.n	800beb4 <chVTDoResetI+0x74>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800be52:	4b1c      	ldr	r3, [pc, #112]	; (800bec4 <chVTDoResetI+0x84>)
 800be54:	69da      	ldr	r2, [r3, #28]
 800be56:	4294      	cmp	r4, r2
 800be58:	d00f      	beq.n	800be7a <chVTDoResetI+0x3a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800be5a:	6861      	ldr	r1, [r4, #4]
 800be5c:	6822      	ldr	r2, [r4, #0]
 800be5e:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 800be60:	6822      	ldr	r2, [r4, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800be62:	331c      	adds	r3, #28
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 800be64:	2000      	movs	r0, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800be66:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 800be68:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 800be6a:	60e0      	str	r0, [r4, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800be6c:	d004      	beq.n	800be78 <chVTDoResetI+0x38>
      vtp->next->delta += vtp->delta;
 800be6e:	68a3      	ldr	r3, [r4, #8]
 800be70:	6891      	ldr	r1, [r2, #8]
 800be72:	440b      	add	r3, r1
 800be74:	6093      	str	r3, [r2, #8]
 800be76:	bd10      	pop	{r4, pc}
 800be78:	bd10      	pop	{r4, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800be7a:	461a      	mov	r2, r3
 800be7c:	6821      	ldr	r1, [r4, #0]
 800be7e:	f842 1f1c 	str.w	r1, [r2, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 800be82:	2000      	movs	r0, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800be84:	4291      	cmp	r1, r2
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800be86:	604a      	str	r2, [r1, #4]
  vtp->func = NULL;
 800be88:	60e0      	str	r0, [r4, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800be8a:	d016      	beq.n	800beba <chVTDoResetI+0x7a>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800be8c:	68a2      	ldr	r2, [r4, #8]
 800be8e:	6888      	ldr	r0, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 800be90:	6a9c      	ldr	r4, [r3, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800be92:	1883      	adds	r3, r0, r2
 800be94:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800be98:	608b      	str	r3, [r1, #8]
 800be9a:	6a50      	ldr	r0, [r2, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 800be9c:	1b02      	subs	r2, r0, r4

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800be9e:	4293      	cmp	r3, r2
 800bea0:	d9ea      	bls.n	800be78 <chVTDoResetI+0x38>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 800bea2:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800bea4:	2b01      	cmp	r3, #1
 800bea6:	bf98      	it	ls
 800bea8:	2302      	movls	r3, #2
 800beaa:	4418      	add	r0, r3
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800beac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800beb0:	f7fd b826 	b.w	8008f00 <stSetAlarm>
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
  chDbgCheck(vtp != NULL);
 800beb4:	4804      	ldr	r0, [pc, #16]	; (800bec8 <chVTDoResetI+0x88>)
 800beb6:	f7ff fe5b 	bl	800bb70 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800beba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800bebe:	60d8      	str	r0, [r3, #12]
 800bec0:	bd10      	pop	{r4, pc}
 800bec2:	bf00      	nop
 800bec4:	2001acdc 	.word	0x2001acdc
 800bec8:	080104bc 	.word	0x080104bc
 800becc:	00000000 	.word	0x00000000

0800bed0 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 800bed0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bed4:	4607      	mov	r7, r0
 800bed6:	460d      	mov	r5, r1
 800bed8:	4614      	mov	r4, r2
 800beda:	461e      	mov	r6, r3
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 800bedc:	f7ff fea8 	bl	800bc30 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800bee0:	b377      	cbz	r7, 800bf40 <chVTDoSetI+0x70>
 800bee2:	b36c      	cbz	r4, 800bf40 <chVTDoSetI+0x70>
 800bee4:	b365      	cbz	r5, 800bf40 <chVTDoSetI+0x70>
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800bee6:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 800bf90 <chVTDoSetI+0xc0>
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800beea:	613e      	str	r6, [r7, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800beec:	4643      	mov	r3, r8
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800beee:	2d01      	cmp	r5, #1
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800bef0:	f853 6f1c 	ldr.w	r6, [r3, #28]!

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 800bef4:	60fc      	str	r4, [r7, #12]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800bef6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800befa:	bf98      	it	ls
 800befc:	2502      	movls	r5, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800befe:	429e      	cmp	r6, r3
 800bf00:	6a54      	ldr	r4, [r2, #36]	; 0x24
 800bf02:	d029      	beq.n	800bf58 <chVTDoSetI+0x88>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 800bf04:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28

    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800bf08:	68b3      	ldr	r3, [r6, #8]
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 800bf0a:	1a24      	subs	r4, r4, r0

    if (delta < now - ch.vtlist.lasttime) {
 800bf0c:	192c      	adds	r4, r5, r4
 800bf0e:	d21a      	bcs.n	800bf46 <chVTDoSetI+0x76>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 800bf10:	429c      	cmp	r4, r3
 800bf12:	d31c      	bcc.n	800bf4e <chVTDoSetI+0x7e>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 800bf14:	429c      	cmp	r4, r3
 800bf16:	d904      	bls.n	800bf22 <chVTDoSetI+0x52>
    delta -= p->delta;
    p = p->next;
 800bf18:	6836      	ldr	r6, [r6, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 800bf1a:	1ae4      	subs	r4, r4, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 800bf1c:	68b3      	ldr	r3, [r6, #8]
 800bf1e:	42a3      	cmp	r3, r4
 800bf20:	d3fa      	bcc.n	800bf18 <chVTDoSetI+0x48>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 800bf22:	6873      	ldr	r3, [r6, #4]
 800bf24:	607b      	str	r3, [r7, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800bf26:	603e      	str	r6, [r7, #0]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 800bf28:	601f      	str	r7, [r3, #0]
  p->prev = vtp;
 800bf2a:	6077      	str	r7, [r6, #4]
  vtp->delta = delta
 800bf2c:	60bc      	str	r4, [r7, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800bf2e:	68b1      	ldr	r1, [r6, #8]
  ch.vtlist.delta = (systime_t)-1;
 800bf30:	f04f 33ff 	mov.w	r3, #4294967295
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800bf34:	1b09      	subs	r1, r1, r4
 800bf36:	60b1      	str	r1, [r6, #8]
  ch.vtlist.delta = (systime_t)-1;
 800bf38:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
 800bf3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 800bf40:	4811      	ldr	r0, [pc, #68]	; (800bf88 <chVTDoSetI+0xb8>)
 800bf42:	f7ff fe15 	bl	800bb70 <chSysHalt>
    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
 800bf46:	6836      	ldr	r6, [r6, #0]

    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800bf48:	1ae4      	subs	r4, r4, r3
 800bf4a:	68b3      	ldr	r3, [r6, #8]
 800bf4c:	e7e2      	b.n	800bf14 <chVTDoSetI+0x44>
 800bf4e:	4420      	add	r0, r4
 800bf50:	f7fc ffd6 	bl	8008f00 <stSetAlarm>
 800bf54:	68b3      	ldr	r3, [r6, #8]
 800bf56:	e7dd      	b.n	800bf14 <chVTDoSetI+0x44>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800bf58:	f8c8 4028 	str.w	r4, [r8, #40]	; 0x28
      ch.vtlist.next = vtp;
 800bf5c:	f8c8 701c 	str.w	r7, [r8, #28]
      ch.vtlist.prev = vtp;
 800bf60:	f8c8 7020 	str.w	r7, [r8, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 800bf64:	60bd      	str	r5, [r7, #8]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800bf66:	68d3      	ldr	r3, [r2, #12]
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800bf68:	603e      	str	r6, [r7, #0]
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800bf6a:	f013 0302 	ands.w	r3, r3, #2
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800bf6e:	607e      	str	r6, [r7, #4]
 800bf70:	d106      	bne.n	800bf80 <chVTDoSetI+0xb0>
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 800bf72:	442c      	add	r4, r5
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800bf74:	2102      	movs	r1, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800bf76:	6354      	str	r4, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800bf78:	6113      	str	r3, [r2, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800bf7a:	60d1      	str	r1, [r2, #12]
 800bf7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bf80:	4802      	ldr	r0, [pc, #8]	; (800bf8c <chVTDoSetI+0xbc>)
 800bf82:	f7ff fdf5 	bl	800bb70 <chSysHalt>
 800bf86:	bf00      	nop
 800bf88:	08010450 	.word	0x08010450
 800bf8c:	0801045c 	.word	0x0801045c
 800bf90:	2001acdc 	.word	0x2001acdc
	...

0800bfa0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800bfa0:	b570      	push	{r4, r5, r6, lr}
 800bfa2:	460c      	mov	r4, r1
 800bfa4:	b086      	sub	sp, #24
 800bfa6:	4606      	mov	r6, r0

  chDbgCheckClassS();
 800bfa8:	f7ff fe02 	bl	800bbb0 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 800bfac:	1c63      	adds	r3, r4, #1
 800bfae:	d014      	beq.n	800bfda <chSchGoSleepTimeoutS+0x3a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800bfb0:	4d0e      	ldr	r5, [pc, #56]	; (800bfec <chSchGoSleepTimeoutS+0x4c>)
 800bfb2:	4a0f      	ldr	r2, [pc, #60]	; (800bff0 <chSchGoSleepTimeoutS+0x50>)
 800bfb4:	69ab      	ldr	r3, [r5, #24]
 800bfb6:	4621      	mov	r1, r4
 800bfb8:	a801      	add	r0, sp, #4
 800bfba:	f7ff ff89 	bl	800bed0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800bfbe:	4630      	mov	r0, r6
 800bfc0:	f7ff fe06 	bl	800bbd0 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800bfc4:	f7ff fe34 	bl	800bc30 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 800bfc8:	9b04      	ldr	r3, [sp, #16]
 800bfca:	b113      	cbz	r3, 800bfd2 <chSchGoSleepTimeoutS+0x32>
      chVTDoResetI(&vt);
 800bfcc:	a801      	add	r0, sp, #4
 800bfce:	f7ff ff37 	bl	800be40 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 800bfd2:	69ab      	ldr	r3, [r5, #24]
}
 800bfd4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800bfd6:	b006      	add	sp, #24
 800bfd8:	bd70      	pop	{r4, r5, r6, pc}
 800bfda:	4d04      	ldr	r5, [pc, #16]	; (800bfec <chSchGoSleepTimeoutS+0x4c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 800bfdc:	4630      	mov	r0, r6
 800bfde:	f7ff fdf7 	bl	800bbd0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800bfe2:	69ab      	ldr	r3, [r5, #24]
}
 800bfe4:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800bfe6:	b006      	add	sp, #24
 800bfe8:	bd70      	pop	{r4, r5, r6, pc}
 800bfea:	bf00      	nop
 800bfec:	2001acdc 	.word	0x2001acdc
 800bff0:	0800c0f1 	.word	0x0800c0f1
	...

0800c000 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 800c000:	b161      	cbz	r1, 800c01c <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800c002:	4b08      	ldr	r3, [pc, #32]	; (800c024 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 800c004:	b410      	push	{r4}
 800c006:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800c008:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800c00a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800c00c:	2004      	movs	r0, #4
 800c00e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 800c012:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 800c014:	6053      	str	r3, [r2, #4]
}
 800c016:	bc10      	pop	{r4}
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800c018:	f7ff bfc2 	b.w	800bfa0 <chSchGoSleepTimeoutS>
}
 800c01c:	f04f 30ff 	mov.w	r0, #4294967295
 800c020:	4770      	bx	lr
 800c022:	bf00      	nop
 800c024:	2001acdc 	.word	0x2001acdc
	...

0800c030 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 800c030:	b508      	push	{r3, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800c032:	2320      	movs	r3, #32
 800c034:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800c038:	4a06      	ldr	r2, [pc, #24]	; (800c054 <_dbg_check_leave_isr+0x24>)
 800c03a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800c03c:	2b00      	cmp	r3, #0
 800c03e:	dd01      	ble.n	800c044 <_dbg_check_leave_isr+0x14>
 800c040:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800c042:	b111      	cbz	r1, 800c04a <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 800c044:	4804      	ldr	r0, [pc, #16]	; (800c058 <_dbg_check_leave_isr+0x28>)
 800c046:	f7ff fd93 	bl	800bb70 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800c04a:	3b01      	subs	r3, #1
 800c04c:	6313      	str	r3, [r2, #48]	; 0x30
 800c04e:	f381 8811 	msr	BASEPRI, r1
 800c052:	bd08      	pop	{r3, pc}
 800c054:	2001acdc 	.word	0x2001acdc
 800c058:	080104dc 	.word	0x080104dc
 800c05c:	00000000 	.word	0x00000000

0800c060 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 800c060:	b508      	push	{r3, lr}
 800c062:	2320      	movs	r3, #32
 800c064:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800c068:	4a06      	ldr	r2, [pc, #24]	; (800c084 <_dbg_check_enter_isr+0x24>)
 800c06a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800c06c:	2b00      	cmp	r3, #0
 800c06e:	db01      	blt.n	800c074 <_dbg_check_enter_isr+0x14>
 800c070:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800c072:	b111      	cbz	r1, 800c07a <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 800c074:	4804      	ldr	r0, [pc, #16]	; (800c088 <_dbg_check_enter_isr+0x28>)
 800c076:	f7ff fd7b 	bl	800bb70 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800c07a:	3301      	adds	r3, #1
 800c07c:	6313      	str	r3, [r2, #48]	; 0x30
 800c07e:	f381 8811 	msr	BASEPRI, r1
 800c082:	bd08      	pop	{r3, pc}
 800c084:	2001acdc 	.word	0x2001acdc
 800c088:	080104e4 	.word	0x080104e4
 800c08c:	00000000 	.word	0x00000000

0800c090 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 800c090:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800c092:	4b06      	ldr	r3, [pc, #24]	; (800c0ac <_dbg_check_unlock_from_isr+0x1c>)
 800c094:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c096:	2a00      	cmp	r2, #0
 800c098:	dd05      	ble.n	800c0a6 <_dbg_check_unlock_from_isr+0x16>
 800c09a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c09c:	2a00      	cmp	r2, #0
 800c09e:	dd02      	ble.n	800c0a6 <_dbg_check_unlock_from_isr+0x16>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 800c0a0:	2200      	movs	r2, #0
 800c0a2:	635a      	str	r2, [r3, #52]	; 0x34
 800c0a4:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
 800c0a6:	4802      	ldr	r0, [pc, #8]	; (800c0b0 <_dbg_check_unlock_from_isr+0x20>)
 800c0a8:	f7ff fd62 	bl	800bb70 <chSysHalt>
 800c0ac:	2001acdc 	.word	0x2001acdc
 800c0b0:	080104ec 	.word	0x080104ec
	...

0800c0c0 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 800c0c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800c0c2:	4b06      	ldr	r3, [pc, #24]	; (800c0dc <_dbg_check_lock_from_isr+0x1c>)
 800c0c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c0c6:	2a00      	cmp	r2, #0
 800c0c8:	dd01      	ble.n	800c0ce <_dbg_check_lock_from_isr+0xe>
 800c0ca:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c0cc:	b112      	cbz	r2, 800c0d4 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 800c0ce:	4804      	ldr	r0, [pc, #16]	; (800c0e0 <_dbg_check_lock_from_isr+0x20>)
 800c0d0:	f7ff fd4e 	bl	800bb70 <chSysHalt>
  }
  _dbg_enter_lock();
 800c0d4:	2201      	movs	r2, #1
 800c0d6:	635a      	str	r2, [r3, #52]	; 0x34
 800c0d8:	bd08      	pop	{r3, pc}
 800c0da:	bf00      	nop
 800c0dc:	2001acdc 	.word	0x2001acdc
 800c0e0:	080104f4 	.word	0x080104f4
	...

0800c0f0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 800c0f0:	b538      	push	{r3, r4, r5, lr}
 800c0f2:	4604      	mov	r4, r0
 800c0f4:	2320      	movs	r3, #32
 800c0f6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800c0fa:	f7ff ffe1 	bl	800c0c0 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 800c0fe:	f894 3020 	ldrb.w	r3, [r4, #32]
 800c102:	2b07      	cmp	r3, #7
 800c104:	d810      	bhi.n	800c128 <wakeup+0x38>
 800c106:	e8df f003 	tbb	[pc, r3]
 800c10a:	0f15      	.short	0x0f15
 800c10c:	040a1b0f 	.word	0x040a1b0f
 800c110:	0a0f      	.short	0x0a0f
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800c112:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 800c114:	f7ff fd8c 	bl	800bc30 <chDbgCheckClassI>

  sp->cnt++;
 800c118:	68ab      	ldr	r3, [r5, #8]
 800c11a:	3301      	adds	r3, #1
 800c11c:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800c11e:	e894 000c 	ldmia.w	r4, {r2, r3}
 800c122:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800c124:	6822      	ldr	r2, [r4, #0]
 800c126:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800c128:	f04f 33ff 	mov.w	r3, #4294967295
 800c12c:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 800c12e:	4620      	mov	r0, r4
 800c130:	f7ff fe46 	bl	800bdc0 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800c134:	f7ff ffac 	bl	800c090 <_dbg_check_unlock_from_isr>
 800c138:	2300      	movs	r3, #0
 800c13a:	f383 8811 	msr	BASEPRI, r3
 800c13e:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800c140:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800c142:	2200      	movs	r2, #0
 800c144:	601a      	str	r2, [r3, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800c146:	f04f 33ff 	mov.w	r3, #4294967295
 800c14a:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 800c14c:	4620      	mov	r0, r4
 800c14e:	f7ff fe37 	bl	800bdc0 <chSchReadyI>
 800c152:	e7ef      	b.n	800c134 <wakeup+0x44>
	...

0800c160 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 800c160:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800c162:	4b05      	ldr	r3, [pc, #20]	; (800c178 <_dbg_check_unlock+0x18>)
 800c164:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c166:	b922      	cbnz	r2, 800c172 <_dbg_check_unlock+0x12>
 800c168:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800c16a:	2900      	cmp	r1, #0
 800c16c:	dd01      	ble.n	800c172 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800c16e:	635a      	str	r2, [r3, #52]	; 0x34
 800c170:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 800c172:	4802      	ldr	r0, [pc, #8]	; (800c17c <_dbg_check_unlock+0x1c>)
 800c174:	f7ff fcfc 	bl	800bb70 <chSysHalt>
 800c178:	2001acdc 	.word	0x2001acdc
 800c17c:	080104fc 	.word	0x080104fc

0800c180 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 800c180:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800c182:	4b05      	ldr	r3, [pc, #20]	; (800c198 <_dbg_check_lock+0x18>)
 800c184:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800c186:	b90a      	cbnz	r2, 800c18c <_dbg_check_lock+0xc>
 800c188:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c18a:	b112      	cbz	r2, 800c192 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 800c18c:	4803      	ldr	r0, [pc, #12]	; (800c19c <_dbg_check_lock+0x1c>)
 800c18e:	f7ff fcef 	bl	800bb70 <chSysHalt>
  }
  _dbg_enter_lock();
 800c192:	2201      	movs	r2, #1
 800c194:	635a      	str	r2, [r3, #52]	; 0x34
 800c196:	bd08      	pop	{r3, pc}
 800c198:	2001acdc 	.word	0x2001acdc
 800c19c:	08010504 	.word	0x08010504

0800c1a0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 800c1a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c1a2:	4605      	mov	r5, r0
 800c1a4:	2320      	movs	r3, #32
 800c1a6:	f383 8811 	msr	BASEPRI, r3
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 800c1aa:	4e43      	ldr	r6, [pc, #268]	; (800c2b8 <chMtxLock+0x118>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800c1ac:	f7ff ffe8 	bl	800c180 <_dbg_check_lock>
 800c1b0:	69b4      	ldr	r4, [r6, #24]

  chDbgCheckClassS();
 800c1b2:	f7ff fcfd 	bl	800bbb0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800c1b6:	b31d      	cbz	r5, 800c200 <chMtxLock+0x60>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800c1b8:	68a8      	ldr	r0, [r5, #8]
 800c1ba:	2800      	cmp	r0, #0
 800c1bc:	d06d      	beq.n	800c29a <chMtxLock+0xfa>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800c1be:	68a2      	ldr	r2, [r4, #8]
 800c1c0:	6883      	ldr	r3, [r0, #8]
 800c1c2:	429a      	cmp	r2, r3
 800c1c4:	d907      	bls.n	800c1d6 <chMtxLock+0x36>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800c1c6:	f890 3020 	ldrb.w	r3, [r0, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800c1ca:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800c1cc:	2b06      	cmp	r3, #6
 800c1ce:	d039      	beq.n	800c244 <chMtxLock+0xa4>
 800c1d0:	2b07      	cmp	r3, #7
 800c1d2:	d023      	beq.n	800c21c <chMtxLock+0x7c>
 800c1d4:	b1bb      	cbz	r3, 800c206 <chMtxLock+0x66>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800c1d6:	462b      	mov	r3, r5
 800c1d8:	e003      	b.n	800c1e2 <chMtxLock+0x42>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800c1da:	6899      	ldr	r1, [r3, #8]
 800c1dc:	68a2      	ldr	r2, [r4, #8]
 800c1de:	4291      	cmp	r1, r2
 800c1e0:	d302      	bcc.n	800c1e8 <chMtxLock+0x48>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800c1e2:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800c1e4:	429d      	cmp	r5, r3
 800c1e6:	d1f8      	bne.n	800c1da <chMtxLock+0x3a>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800c1e8:	685a      	ldr	r2, [r3, #4]
 800c1ea:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800c1ec:	6023      	str	r3, [r4, #0]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800c1ee:	2006      	movs	r0, #6
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800c1f0:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800c1f2:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 800c1f4:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 800c1f6:	f7ff fceb 	bl	800bbd0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 800c1fa:	68ab      	ldr	r3, [r5, #8]
 800c1fc:	429c      	cmp	r4, r3
 800c1fe:	d03a      	beq.n	800c276 <chMtxLock+0xd6>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 800c200:	482e      	ldr	r0, [pc, #184]	; (800c2bc <chMtxLock+0x11c>)
 800c202:	f7ff fcb5 	bl	800bb70 <chSysHalt>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800c206:	e890 000c 	ldmia.w	r0, {r2, r3}
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 800c20a:	2101      	movs	r1, #1
 800c20c:	f880 1020 	strb.w	r1, [r0, #32]
 800c210:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800c212:	6802      	ldr	r2, [r0, #0]
 800c214:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 800c216:	f7ff fdd3 	bl	800bdc0 <chSchReadyI>
 800c21a:	e7dc      	b.n	800c1d6 <chMtxLock+0x36>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800c21c:	e890 000a 	ldmia.w	r0, {r1, r3}
 800c220:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800c222:	6801      	ldr	r1, [r0, #0]
 800c224:	604b      	str	r3, [r1, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800c226:	6a47      	ldr	r7, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800c228:	463b      	mov	r3, r7
 800c22a:	e002      	b.n	800c232 <chMtxLock+0x92>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800c22c:	6899      	ldr	r1, [r3, #8]
 800c22e:	4291      	cmp	r1, r2
 800c230:	d302      	bcc.n	800c238 <chMtxLock+0x98>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800c232:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800c234:	429f      	cmp	r7, r3
 800c236:	d1f9      	bne.n	800c22c <chMtxLock+0x8c>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800c238:	685a      	ldr	r2, [r3, #4]
 800c23a:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800c23c:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800c23e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800c240:	6058      	str	r0, [r3, #4]
 800c242:	e7c8      	b.n	800c1d6 <chMtxLock+0x36>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800c244:	e890 000a 	ldmia.w	r0, {r1, r3}
 800c248:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800c24a:	6801      	ldr	r1, [r0, #0]
 800c24c:	604b      	str	r3, [r1, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800c24e:	6a47      	ldr	r7, [r0, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800c250:	463b      	mov	r3, r7
 800c252:	e002      	b.n	800c25a <chMtxLock+0xba>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800c254:	6899      	ldr	r1, [r3, #8]
 800c256:	4291      	cmp	r1, r2
 800c258:	d302      	bcc.n	800c260 <chMtxLock+0xc0>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800c25a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800c25c:	429f      	cmp	r7, r3
 800c25e:	d1f9      	bne.n	800c254 <chMtxLock+0xb4>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800c260:	685a      	ldr	r2, [r3, #4]
 800c262:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800c264:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800c266:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800c268:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800c26a:	68b8      	ldr	r0, [r7, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800c26c:	68a2      	ldr	r2, [r4, #8]
 800c26e:	6883      	ldr	r3, [r0, #8]
 800c270:	429a      	cmp	r2, r3
 800c272:	d8a8      	bhi.n	800c1c6 <chMtxLock+0x26>
 800c274:	e7af      	b.n	800c1d6 <chMtxLock+0x36>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 800c276:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c278:	429d      	cmp	r5, r3
 800c27a:	d1c1      	bne.n	800c200 <chMtxLock+0x60>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800c27c:	f7ff ff70 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800c280:	6833      	ldr	r3, [r6, #0]
 800c282:	4a0d      	ldr	r2, [pc, #52]	; (800c2b8 <chMtxLock+0x118>)
 800c284:	42b3      	cmp	r3, r6
 800c286:	d004      	beq.n	800c292 <chMtxLock+0xf2>
 800c288:	6992      	ldr	r2, [r2, #24]
 800c28a:	689b      	ldr	r3, [r3, #8]
 800c28c:	6892      	ldr	r2, [r2, #8]
 800c28e:	429a      	cmp	r2, r3
 800c290:	d30e      	bcc.n	800c2b0 <chMtxLock+0x110>
 800c292:	2300      	movs	r3, #0
 800c294:	f383 8811 	msr	BASEPRI, r3
 800c298:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 800c29a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800c29c:	60eb      	str	r3, [r5, #12]
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 800c29e:	60ac      	str	r4, [r5, #8]
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
 800c2a0:	63a5      	str	r5, [r4, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800c2a2:	f7ff ff5d 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800c2a6:	6833      	ldr	r3, [r6, #0]
 800c2a8:	4a03      	ldr	r2, [pc, #12]	; (800c2b8 <chMtxLock+0x118>)
 800c2aa:	42b3      	cmp	r3, r6
 800c2ac:	d1ec      	bne.n	800c288 <chMtxLock+0xe8>
 800c2ae:	e7f0      	b.n	800c292 <chMtxLock+0xf2>
 800c2b0:	4803      	ldr	r0, [pc, #12]	; (800c2c0 <chMtxLock+0x120>)
 800c2b2:	f7ff fc5d 	bl	800bb70 <chSysHalt>
 800c2b6:	bf00      	nop
 800c2b8:	2001acdc 	.word	0x2001acdc
 800c2bc:	080104b0 	.word	0x080104b0
 800c2c0:	0800ffa8 	.word	0x0800ffa8
	...

0800c2d0 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return              the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
 800c2d0:	b538      	push	{r3, r4, r5, lr}
 800c2d2:	4604      	mov	r4, r0
 800c2d4:	460d      	mov	r5, r1
 800c2d6:	2320      	movs	r3, #32
 800c2d8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800c2dc:	f7ff ff50 	bl	800c180 <_dbg_check_lock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800c2e0:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  systime_t time;

  chSysLock();
  time = chVTGetSystemTimeX();
  if (chVTIsTimeWithinX(time, prev, next)) {
 800c2e4:	1b2b      	subs	r3, r5, r4
 800c2e6:	6a51      	ldr	r1, [r2, #36]	; 0x24
 800c2e8:	1b0c      	subs	r4, r1, r4
 800c2ea:	429c      	cmp	r4, r3
 800c2ec:	d312      	bcc.n	800c314 <chThdSleepUntilWindowed+0x44>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800c2ee:	f7ff ff37 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800c2f2:	4b0d      	ldr	r3, [pc, #52]	; (800c328 <chThdSleepUntilWindowed+0x58>)
 800c2f4:	681a      	ldr	r2, [r3, #0]
 800c2f6:	429a      	cmp	r2, r3
 800c2f8:	d004      	beq.n	800c304 <chThdSleepUntilWindowed+0x34>
 800c2fa:	6999      	ldr	r1, [r3, #24]
 800c2fc:	6893      	ldr	r3, [r2, #8]
 800c2fe:	688a      	ldr	r2, [r1, #8]
 800c300:	429a      	cmp	r2, r3
 800c302:	d304      	bcc.n	800c30e <chThdSleepUntilWindowed+0x3e>
 800c304:	2300      	movs	r3, #0
 800c306:	f383 8811 	msr	BASEPRI, r3
    chThdSleepS(next - time);
  }
  chSysUnlock();

  return next;
}
 800c30a:	4628      	mov	r0, r5
 800c30c:	bd38      	pop	{r3, r4, r5, pc}
 800c30e:	4807      	ldr	r0, [pc, #28]	; (800c32c <chThdSleepUntilWindowed+0x5c>)
 800c310:	f7ff fc2e 	bl	800bb70 <chSysHalt>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800c314:	1a69      	subs	r1, r5, r1
 800c316:	d003      	beq.n	800c320 <chThdSleepUntilWindowed+0x50>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800c318:	2008      	movs	r0, #8
 800c31a:	f7ff fe41 	bl	800bfa0 <chSchGoSleepTimeoutS>
 800c31e:	e7e6      	b.n	800c2ee <chThdSleepUntilWindowed+0x1e>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800c320:	4803      	ldr	r0, [pc, #12]	; (800c330 <chThdSleepUntilWindowed+0x60>)
 800c322:	f7ff fc25 	bl	800bb70 <chSysHalt>
 800c326:	bf00      	nop
 800c328:	2001acdc 	.word	0x2001acdc
 800c32c:	0800f774 	.word	0x0800f774
 800c330:	0801058c 	.word	0x0801058c
	...

0800c340 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 800c340:	b510      	push	{r4, lr}
 800c342:	2320      	movs	r3, #32
 800c344:	4604      	mov	r4, r0
 800c346:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800c34a:	f7ff ff19 	bl	800c180 <_dbg_check_lock>
 800c34e:	b1ac      	cbz	r4, 800c37c <chThdSleep+0x3c>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800c350:	4621      	mov	r1, r4
 800c352:	2008      	movs	r0, #8
 800c354:	f7ff fe24 	bl	800bfa0 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800c358:	f7ff ff02 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800c35c:	4b09      	ldr	r3, [pc, #36]	; (800c384 <chThdSleep+0x44>)
 800c35e:	681a      	ldr	r2, [r3, #0]
 800c360:	429a      	cmp	r2, r3
 800c362:	d004      	beq.n	800c36e <chThdSleep+0x2e>
 800c364:	6999      	ldr	r1, [r3, #24]
 800c366:	6893      	ldr	r3, [r2, #8]
 800c368:	688a      	ldr	r2, [r1, #8]
 800c36a:	429a      	cmp	r2, r3
 800c36c:	d303      	bcc.n	800c376 <chThdSleep+0x36>
 800c36e:	2300      	movs	r3, #0
 800c370:	f383 8811 	msr	BASEPRI, r3
 800c374:	bd10      	pop	{r4, pc}
 800c376:	4804      	ldr	r0, [pc, #16]	; (800c388 <chThdSleep+0x48>)
 800c378:	f7ff fbfa 	bl	800bb70 <chSysHalt>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800c37c:	4803      	ldr	r0, [pc, #12]	; (800c38c <chThdSleep+0x4c>)
 800c37e:	f7ff fbf7 	bl	800bb70 <chSysHalt>
 800c382:	bf00      	nop
 800c384:	2001acdc 	.word	0x2001acdc
 800c388:	0800f774 	.word	0x0800f774
 800c38c:	0801058c 	.word	0x0801058c

0800c390 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 800c390:	b508      	push	{r3, lr}
 800c392:	4605      	mov	r5, r0
 800c394:	2320      	movs	r3, #32
 800c396:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800c39a:	f7ff fef1 	bl	800c180 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 800c39e:	4b10      	ldr	r3, [pc, #64]	; (800c3e0 <chThdExit+0x50>)
 800c3a0:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800c3a2:	6aa0      	ldr	r0, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 800c3a4:	6265      	str	r5, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800c3a6:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800c3aa:	4285      	cmp	r5, r0
 800c3ac:	d006      	beq.n	800c3bc <chThdExit+0x2c>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 800c3ae:	6803      	ldr	r3, [r0, #0]
 800c3b0:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 800c3b2:	f7ff fd05 	bl	800bdc0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800c3b6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800c3b8:	42a8      	cmp	r0, r5
 800c3ba:	d1f8      	bne.n	800c3ae <chThdExit+0x1e>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800c3bc:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 800c3c0:	b943      	cbnz	r3, 800c3d4 <chThdExit+0x44>
 800c3c2:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 800c3c6:	079b      	lsls	r3, r3, #30
 800c3c8:	d104      	bne.n	800c3d4 <chThdExit+0x44>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 800c3ca:	6963      	ldr	r3, [r4, #20]
 800c3cc:	6922      	ldr	r2, [r4, #16]
 800c3ce:	611a      	str	r2, [r3, #16]
 800c3d0:	6922      	ldr	r2, [r4, #16]
 800c3d2:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800c3d4:	200f      	movs	r0, #15
 800c3d6:	f7ff fbfb 	bl	800bbd0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800c3da:	4802      	ldr	r0, [pc, #8]	; (800c3e4 <chThdExit+0x54>)
 800c3dc:	f7ff fbc8 	bl	800bb70 <chSysHalt>
 800c3e0:	2001acdc 	.word	0x2001acdc
 800c3e4:	08010444 	.word	0x08010444
	...

0800c3f0 <chSysGetStatusAndLockX.part.1.lto_priv.137>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 800c3f0:	b508      	push	{r3, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800c3f2:	f3ef 8305 	mrs	r3, IPSR

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 800c3f6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c3fa:	b92b      	cbnz	r3, 800c408 <chSysGetStatusAndLockX.part.1.lto_priv.137+0x18>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800c3fc:	2320      	movs	r3, #32
 800c3fe:	f383 8811 	msr	BASEPRI, r3
 800c402:	f7ff febd 	bl	800c180 <_dbg_check_lock>
    else {
      chSysLock();
    }
  }
  return sts;
}
 800c406:	bd08      	pop	{r3, pc}
 800c408:	2320      	movs	r3, #32
 800c40a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800c40e:	f7ff fe57 	bl	800c0c0 <_dbg_check_lock_from_isr>
 800c412:	bd08      	pop	{r3, pc}
	...

0800c420 <chSysRestoreStatusX.part.2.lto_priv.138>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 800c420:	b508      	push	{r3, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800c422:	f3ef 8305 	mrs	r3, IPSR

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 800c426:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800c42a:	b983      	cbnz	r3, 800c44e <chSysRestoreStatusX.part.2.lto_priv.138+0x2e>
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 800c42c:	f7ff fcb0 	bl	800bd90 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800c430:	f7ff fe96 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800c434:	4b0a      	ldr	r3, [pc, #40]	; (800c460 <chSysRestoreStatusX.part.2.lto_priv.138+0x40>)
 800c436:	681a      	ldr	r2, [r3, #0]
 800c438:	429a      	cmp	r2, r3
 800c43a:	d004      	beq.n	800c446 <chSysRestoreStatusX.part.2.lto_priv.138+0x26>
 800c43c:	6999      	ldr	r1, [r3, #24]
 800c43e:	6893      	ldr	r3, [r2, #8]
 800c440:	688a      	ldr	r2, [r1, #8]
 800c442:	429a      	cmp	r2, r3
 800c444:	d309      	bcc.n	800c45a <chSysRestoreStatusX.part.2.lto_priv.138+0x3a>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800c446:	2300      	movs	r3, #0
 800c448:	f383 8811 	msr	BASEPRI, r3
 800c44c:	bd08      	pop	{r3, pc}
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800c44e:	f7ff fe1f 	bl	800c090 <_dbg_check_unlock_from_isr>
 800c452:	2300      	movs	r3, #0
 800c454:	f383 8811 	msr	BASEPRI, r3
 800c458:	bd08      	pop	{r3, pc}

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800c45a:	4802      	ldr	r0, [pc, #8]	; (800c464 <chSysRestoreStatusX.part.2.lto_priv.138+0x44>)
 800c45c:	f7ff fb88 	bl	800bb70 <chSysHalt>
 800c460:	2001acdc 	.word	0x2001acdc
 800c464:	0801048c 	.word	0x0801048c
	...

0800c470 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 800c470:	e7fe      	b.n	800c470 <BusFault_Handler>
 800c472:	bf00      	nop
	...

0800c480 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800c480:	b5f0      	push	{r4, r5, r6, r7, lr}
 800c482:	4f13      	ldr	r7, [pc, #76]	; (800c4d0 <__init_ram_areas+0x50>)
 800c484:	4d13      	ldr	r5, [pc, #76]	; (800c4d4 <__init_ram_areas+0x54>)
 800c486:	4c14      	ldr	r4, [pc, #80]	; (800c4d8 <__init_ram_areas+0x58>)
 800c488:	4b14      	ldr	r3, [pc, #80]	; (800c4dc <__init_ram_areas+0x5c>)
 800c48a:	4915      	ldr	r1, [pc, #84]	; (800c4e0 <__init_ram_areas+0x60>)
 800c48c:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 800c490:	2600      	movs	r6, #0
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800c492:	429c      	cmp	r4, r3
 800c494:	d911      	bls.n	800c4ba <__init_ram_areas+0x3a>
 800c496:	3904      	subs	r1, #4
 800c498:	461a      	mov	r2, r3
      *p = *tp;
 800c49a:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800c49e:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800c4a2:	4294      	cmp	r4, r2
 800c4a4:	d8f9      	bhi.n	800c49a <__init_ram_areas+0x1a>
 800c4a6:	43da      	mvns	r2, r3
 800c4a8:	4414      	add	r4, r2
 800c4aa:	f024 0403 	bic.w	r4, r4, #3
 800c4ae:	3404      	adds	r4, #4
 800c4b0:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800c4b2:	429d      	cmp	r5, r3
 800c4b4:	d903      	bls.n	800c4be <__init_ram_areas+0x3e>
      *p = 0;
 800c4b6:	f843 6b04 	str.w	r6, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800c4ba:	429d      	cmp	r5, r3
 800c4bc:	d8fb      	bhi.n	800c4b6 <__init_ram_areas+0x36>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800c4be:	4577      	cmp	r7, lr
 800c4c0:	d005      	beq.n	800c4ce <__init_ram_areas+0x4e>
 800c4c2:	6939      	ldr	r1, [r7, #16]
 800c4c4:	697b      	ldr	r3, [r7, #20]
 800c4c6:	69bc      	ldr	r4, [r7, #24]
 800c4c8:	69fd      	ldr	r5, [r7, #28]
 800c4ca:	3710      	adds	r7, #16
 800c4cc:	e7e1      	b.n	800c492 <__init_ram_areas+0x12>
 800c4ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c4d0:	0801050c 	.word	0x0801050c
 800c4d4:	2001b774 	.word	0x2001b774
 800c4d8:	2001b774 	.word	0x2001b774
 800c4dc:	2001b774 	.word	0x2001b774
 800c4e0:	08011a28 	.word	0x08011a28
	...

0800c4f0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 800c4f0:	e7fe      	b.n	800c4f0 <__default_exit>
 800c4f2:	bf00      	nop
	...

0800c500 <__late_init>:
 800c500:	4770      	bx	lr
 800c502:	bf00      	nop
	...

0800c510 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 800c510:	4770      	bx	lr
 800c512:	bf00      	nop
	...

0800c520 <adccb>:
#define DIVIDER_VUSB			200/64	/* VUSB -- 22KOhm -- ADC -- 10kOhm -- GND */

static adcsample_t samples[ADC_GRP1_NUM_CHANNELS*2]; // ADC sample buffer
uint16_t vcc_ref = VCC_REF_LOW;

void adccb(ADCDriver *adcp, adcsample_t *buffer, size_t n) {
 800c520:	4770      	bx	lr
 800c522:	bf00      	nop
	...

0800c530 <getTime>:

/**
  * Reads the time from the STM32 internal RTC
  * @return Date in Julian calendar format
  */
void getTime(ptime_t *date) {
 800c530:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c534:	4606      	mov	r6, r0
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c536:	f3ef 8711 	mrs	r7, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 800c53a:	b90f      	cbnz	r7, 800c540 <getTime+0x10>
 800c53c:	f7ff ff58 	bl	800c3f0 <chSysGetStatusAndLockX.part.1.lto_priv.137>
 800c540:	4b43      	ldr	r3, [pc, #268]	; (800c650 <getTime+0x120>)
 800c542:	681a      	ldr	r2, [r3, #0]
  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();

  /* Synchronization with the RTC and reading the registers, note
     DR must be read last.*/
  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0)
 800c544:	68d3      	ldr	r3, [r2, #12]
 800c546:	069b      	lsls	r3, r3, #26
 800c548:	d5fc      	bpl.n	800c544 <getTime+0x14>
    ;
#if STM32_RTC_HAS_SUBSECONDS
  ssr = rtcp->rtc->SSR;
 800c54a:	f8d2 8028 	ldr.w	r8, [r2, #40]	; 0x28
#endif /* STM32_RTC_HAS_SUBSECONDS */
  tr  = rtcp->rtc->TR;
 800c54e:	6814      	ldr	r4, [r2, #0]
  dr  = rtcp->rtc->DR;
 800c550:	6855      	ldr	r5, [r2, #4]
  cr  = rtcp->rtc->CR;
 800c552:	6893      	ldr	r3, [r2, #8]
  rtcp->rtc->ISR &= ~RTC_ISR_RSF;
 800c554:	68d3      	ldr	r3, [r2, #12]
 800c556:	f023 0320 	bic.w	r3, r3, #32
 800c55a:	60d3      	str	r3, [r2, #12]
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 800c55c:	b90f      	cbnz	r7, 800c562 <getTime+0x32>
 800c55e:	f7ff ff5f 	bl	800c420 <chSysRestoreStatusX.part.2.lto_priv.138>
 800c562:	483c      	ldr	r0, [pc, #240]	; (800c654 <getTime+0x124>)
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 800c564:	4f3c      	ldr	r7, [pc, #240]	; (800c658 <getTime+0x128>)
 800c566:	f8df c100 	ldr.w	ip, [pc, #256]	; 800c668 <getTime+0x138>
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800c56a:	4b3c      	ldr	r3, [pc, #240]	; (800c65c <getTime+0x12c>)
	date->minute = (timespec.millisecond%3600000) / 60000;
 800c56c:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 800c66c <getTime+0x13c>
 800c570:	f3c4 4103 	ubfx	r1, r4, #16, #4
 800c574:	fb00 f101 	mul.w	r1, r0, r1
 800c578:	f3c4 5201 	ubfx	r2, r4, #20, #2
 800c57c:	fb07 1102 	mla	r1, r7, r2, r1
 800c580:	f004 020f 	and.w	r2, r4, #15
 800c584:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 800c588:	fb07 1102 	mla	r1, r7, r2, r1
 800c58c:	f3c4 3202 	ubfx	r2, r4, #12, #3
 800c590:	fb0c 1c02 	mla	ip, ip, r2, r1
 800c594:	f3c4 2e03 	ubfx	lr, r4, #8, #4
 800c598:	f64e 2260 	movw	r2, #60000	; 0xea60
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800c59c:	f3c4 1102 	ubfx	r1, r4, #4, #3
 800c5a0:	fb03 f308 	mul.w	r3, r3, r8
 800c5a4:	fb02 c40e 	mla	r4, r2, lr, ip
 800c5a8:	f242 7210 	movw	r2, #10000	; 0x2710
 800c5ac:	fb02 4401 	mla	r4, r2, r1, r4
 800c5b0:	f503 2379 	add.w	r3, r3, #1019904	; 0xf9000
 800c5b4:	f024 4478 	bic.w	r4, r4, #4160749568	; 0xf8000000
 800c5b8:	f603 4318 	addw	r3, r3, #3096	; 0xc18
 800c5bc:	eb04 2293 	add.w	r2, r4, r3, lsr #10
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c5c0:	4927      	ldr	r1, [pc, #156]	; (800c660 <getTime+0x130>)
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800c5c2:	4c28      	ldr	r4, [pc, #160]	; (800c664 <getTime+0x134>)
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c5c4:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 800c670 <getTime+0x140>
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800c5c8:	f022 4378 	bic.w	r3, r2, #4160749568	; 0xf8000000
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c5cc:	fb81 2103 	smull	r2, r1, r1, r3
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800c5d0:	fb84 2403 	smull	r2, r4, r4, r3
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c5d4:	0989      	lsrs	r1, r1, #6
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800c5d6:	0d24      	lsrs	r4, r4, #20
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c5d8:	fb81 8908 	smull	r8, r9, r1, r8

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800c5dc:	fb00 3214 	mls	r2, r0, r4, r3
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800c5e0:	f3c5 5c03 	ubfx	ip, r5, #20, #4
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c5e4:	eb01 0e09 	add.w	lr, r1, r9
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800c5e8:	f3c5 3800 	ubfx	r8, r5, #12, #1
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800c5ec:	fb8a 0902 	smull	r0, r9, sl, r2
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800c5f0:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
 800c5f4:	f3c5 4003 	ubfx	r0, r5, #16, #4
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
	date->millisecond = timespec.millisecond % 1000;
 800c5f8:	fb07 3311 	mls	r3, r7, r1, r3
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800c5fc:	eb00 004c 	add.w	r0, r0, ip, lsl #1
	date->month = timespec.month;
 800c600:	ea4f 0788 	mov.w	r7, r8, lsl #2
	date->day = timespec.day;
 800c604:	f3c5 1c01 	ubfx	ip, r5, #4, #2
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800c608:	44b8      	add	r8, r7
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c60a:	ea4f 1e6e 	mov.w	lr, lr, asr #5
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800c60e:	f3c5 2703 	ubfx	r7, r5, #8, #4
	date->day = timespec.day;
 800c612:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
 800c616:	f005 050f 	and.w	r5, r5, #15
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c61a:	ebce 1e0e 	rsb	lr, lr, lr, lsl #4

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800c61e:	17d2      	asrs	r2, r2, #31
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800c620:	eb07 0748 	add.w	r7, r7, r8, lsl #1
	date->day = timespec.day;
 800c624:	eb05 054c 	add.w	r5, r5, ip, lsl #1
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800c628:	b2c0      	uxtb	r0, r0
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c62a:	eba1 018e 	sub.w	r1, r1, lr, lsl #2

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
 800c62e:	ebc2 32a9 	rsb	r2, r2, r9, asr #14
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800c632:	f007 070f 	and.w	r7, r7, #15
	date->day = timespec.day;
 800c636:	f005 051f 	and.w	r5, r5, #31
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800c63a:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
 800c63e:	71b1      	strb	r1, [r6, #6]
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
	date->day = timespec.day;
	date->hour = timespec.millisecond / 3600000;
 800c640:	7134      	strb	r4, [r6, #4]
	date->minute = (timespec.millisecond%3600000) / 60000;
 800c642:	7172      	strb	r2, [r6, #5]
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
	date->month = timespec.month;
 800c644:	70b7      	strb	r7, [r6, #2]
	date->day = timespec.day;
 800c646:	70f5      	strb	r5, [r6, #3]
	date->hour = timespec.millisecond / 3600000;
	date->minute = (timespec.millisecond%3600000) / 60000;
	date->second = (timespec.millisecond / 1000) % 60;
	date->millisecond = timespec.millisecond % 1000;
 800c648:	8133      	strh	r3, [r6, #8]
  */
void getTime(ptime_t *date) {
	RTCDateTime timespec;
	rtcGetTime(&RTCD1, &timespec);

	date->year = timespec.year + 2000;
 800c64a:	8030      	strh	r0, [r6, #0]
	date->month = timespec.month;
	date->day = timespec.day;
 800c64c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c650:	2001997c 	.word	0x2001997c
 800c654:	0036ee80 	.word	0x0036ee80
 800c658:	02255100 	.word	0x02255100
 800c65c:	fffffc18 	.word	0xfffffc18
 800c660:	10624dd3 	.word	0x10624dd3
 800c664:	4a90be59 	.word	0x4a90be59
 800c668:	000927c0 	.word	0x000927c0
 800c66c:	45e7b273 	.word	0x45e7b273
 800c670:	88888889 	.word	0x88888889
	...

0800c680 <I2C_read8>:
	I2C_unlock();
	return ret;
}

bool I2C_read8(uint8_t address, uint8_t reg, uint8_t *val)
{
 800c680:	b5f0      	push	{r4, r5, r6, r7, lr}
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c682:	4c0d      	ldr	r4, [pc, #52]	; (800c6b8 <I2C_read8+0x38>)
	I2C_unlock();
	return ret;
}

bool I2C_read8(uint8_t address, uint8_t reg, uint8_t *val)
{
 800c684:	b085      	sub	sp, #20
 800c686:	4607      	mov	r7, r0
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c688:	4620      	mov	r0, r4
	I2C_unlock();
	return ret;
}

bool I2C_read8(uint8_t address, uint8_t reg, uint8_t *val)
{
 800c68a:	460d      	mov	r5, r1
 800c68c:	4616      	mov	r6, r2
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c68e:	f7ff fd87 	bl	800c1a0 <chMtxLock>
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800c692:	2201      	movs	r2, #1
 800c694:	9200      	str	r2, [sp, #0]
 800c696:	ab02      	add	r3, sp, #8
 800c698:	a903      	add	r1, sp, #12
 800c69a:	4638      	mov	r0, r7
	return I2C_send(address, txbuf, length, NULL, 0, MS2ST(100));
}

bool I2C_read8_locked(uint8_t address, uint8_t reg, uint8_t *val)
{
	uint8_t txbuf[] = {reg};
 800c69c:	f88d 500c 	strb.w	r5, [sp, #12]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800c6a0:	f001 f8ae 	bl	800d800 <i2cSendDriver.constprop.20>
bool I2C_read8_locked(uint8_t address, uint8_t reg, uint8_t *val)
{
	uint8_t txbuf[] = {reg};
	uint8_t rxbuf[1];
	bool ret = I2C_send(address, txbuf, 1, rxbuf, 1, MS2ST(100));
	*val = rxbuf[0];
 800c6a4:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800c6a8:	7033      	strb	r3, [r6, #0]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800c6aa:	4605      	mov	r5, r0
/**
  * Unlocks all other I2C threads to access I2C
  */
void I2C_unlock(void)
{
	chMtxUnlock(&pi2c_mtx);
 800c6ac:	4620      	mov	r0, r4
 800c6ae:	f7fc ff67 	bl	8009580 <chMtxUnlock>
{
	I2C_lock();
	bool ret = I2C_read8_locked(address, reg, val);
	I2C_unlock();
	return ret;
}
 800c6b2:	4628      	mov	r0, r5
 800c6b4:	b005      	add	sp, #20
 800c6b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c6b8:	2001aa30 	.word	0x2001aa30
 800c6bc:	00000000 	.word	0x00000000

0800c6c0 <I2C_write8>:
}

// I2C Mutex unlocked access functions

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
 800c6c0:	b5f0      	push	{r4, r5, r6, r7, lr}
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c6c2:	4c0d      	ldr	r4, [pc, #52]	; (800c6f8 <I2C_write8+0x38>)
}

// I2C Mutex unlocked access functions

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
 800c6c4:	b085      	sub	sp, #20
 800c6c6:	4607      	mov	r7, r0
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c6c8:	4620      	mov	r0, r4
}

// I2C Mutex unlocked access functions

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
 800c6ca:	460e      	mov	r6, r1
 800c6cc:	4615      	mov	r5, r2
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c6ce:	f7ff fd67 	bl	800c1a0 <chMtxLock>
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800c6d2:	2300      	movs	r3, #0
 800c6d4:	9300      	str	r3, [sp, #0]
 800c6d6:	2202      	movs	r2, #2
 800c6d8:	a903      	add	r1, sp, #12
 800c6da:	4638      	mov	r0, r7

// I2C Mutex locked access functions

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
{
	uint8_t txbuf[] = {reg, value};
 800c6dc:	f88d 500d 	strb.w	r5, [sp, #13]
 800c6e0:	f88d 600c 	strb.w	r6, [sp, #12]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800c6e4:	f001 f88c 	bl	800d800 <i2cSendDriver.constprop.20>
 800c6e8:	4605      	mov	r5, r0

bool I2C_write8(uint8_t address, uint8_t reg, uint8_t value)
{
	I2C_lock();
	bool ret = I2C_write8_locked(address, reg, value);
	chMtxUnlock(&pi2c_mtx);
 800c6ea:	4620      	mov	r0, r4
 800c6ec:	f7fc ff48 	bl	8009580 <chMtxUnlock>
	return ret;
}
 800c6f0:	4628      	mov	r0, r5
 800c6f2:	b005      	add	sp, #20
 800c6f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c6f6:	bf00      	nop
 800c6f8:	2001aa30 	.word	0x2001aa30
 800c6fc:	00000000 	.word	0x00000000

0800c700 <I2C_read16_locked>:
	*val = rxbuf[0];
	return ret;
}

bool I2C_read16_locked(uint8_t address, uint8_t reg, uint16_t *val)
{
 800c700:	b510      	push	{r4, lr}
 800c702:	b084      	sub	sp, #16
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800c704:	2302      	movs	r3, #2
	*val = rxbuf[0];
	return ret;
}

bool I2C_read16_locked(uint8_t address, uint8_t reg, uint16_t *val)
{
 800c706:	4614      	mov	r4, r2
	uint8_t txbuf[] = {reg};
 800c708:	f88d 1008 	strb.w	r1, [sp, #8]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800c70c:	9300      	str	r3, [sp, #0]
 800c70e:	2201      	movs	r2, #1
 800c710:	ab03      	add	r3, sp, #12
 800c712:	a902      	add	r1, sp, #8
 800c714:	f001 f874 	bl	800d800 <i2cSendDriver.constprop.20>
bool I2C_read16_locked(uint8_t address, uint8_t reg, uint16_t *val)
{
	uint8_t txbuf[] = {reg};
	uint8_t rxbuf[2];
	bool ret = I2C_send(address, txbuf, 1, rxbuf, 2, MS2ST(100));
	*val =  (rxbuf[0] << 8) | rxbuf[1];
 800c718:	f89d 200c 	ldrb.w	r2, [sp, #12]
 800c71c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 800c720:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800c724:	8023      	strh	r3, [r4, #0]
	return ret;
}
 800c726:	b004      	add	sp, #16
 800c728:	bd10      	pop	{r4, pc}
 800c72a:	bf00      	nop
 800c72c:	0000      	movs	r0, r0
	...

0800c730 <I2C_read16>:
	I2C_unlock();
	return ret;
}

bool I2C_read16(uint8_t address, uint8_t reg, uint16_t *val)
{
 800c730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c732:	4c09      	ldr	r4, [pc, #36]	; (800c758 <I2C_read16+0x28>)
	I2C_unlock();
	return ret;
}

bool I2C_read16(uint8_t address, uint8_t reg, uint16_t *val)
{
 800c734:	4605      	mov	r5, r0
 800c736:	460e      	mov	r6, r1
 800c738:	4617      	mov	r7, r2
/**
  * Locks all other I2C threads to access I2C
  */
void I2C_lock(void)
{
	chMtxLock(&pi2c_mtx);
 800c73a:	4620      	mov	r0, r4
 800c73c:	f7ff fd30 	bl	800c1a0 <chMtxLock>
}

bool I2C_read16(uint8_t address, uint8_t reg, uint16_t *val)
{
	I2C_lock();
	bool ret = I2C_read16_locked(address, reg, val);
 800c740:	463a      	mov	r2, r7
 800c742:	4631      	mov	r1, r6
 800c744:	4628      	mov	r0, r5
 800c746:	f7ff ffdb 	bl	800c700 <I2C_read16_locked>
 800c74a:	4605      	mov	r5, r0
/**
  * Unlocks all other I2C threads to access I2C
  */
void I2C_unlock(void)
{
	chMtxUnlock(&pi2c_mtx);
 800c74c:	4620      	mov	r0, r4
 800c74e:	f7fc ff17 	bl	8009580 <chMtxUnlock>
{
	I2C_lock();
	bool ret = I2C_read16_locked(address, reg, val);
	I2C_unlock();
	return ret;
}
 800c752:	4628      	mov	r0, r5
 800c754:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c756:	bf00      	nop
 800c758:	2001aa30 	.word	0x2001aa30
 800c75c:	00000000 	.word	0x00000000

0800c760 <ax25_send_flag>:
			packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
	}
}

void ax25_send_flag(ax25_t *packet)
{
 800c760:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
 800c764:	2200      	movs	r2, #0
 800c766:	8903      	ldrh	r3, [r0, #8]
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
      return;
    if((byte >> i) & 1)
 800c768:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
    else
      packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800c76c:	2501      	movs	r5, #1
 800c76e:	e00c      	b.n	800c78a <ax25_send_flag+0x2a>
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
      return;
    if((byte >> i) & 1)
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
 800c770:	6843      	ldr	r3, [r0, #4]
 800c772:	f813 100e 	ldrb.w	r1, [r3, lr]
 800c776:	4321      	orrs	r1, r4
 800c778:	f803 100e 	strb.w	r1, [r3, lr]

void ax25_send_flag(ax25_t *packet)
{
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
 800c77c:	8903      	ldrh	r3, [r0, #8]
 800c77e:	3201      	adds	r2, #1
 800c780:	3301      	adds	r3, #1
 800c782:	b29b      	uxth	r3, r3
 800c784:	2a08      	cmp	r2, #8
 800c786:	8103      	strh	r3, [r0, #8]
 800c788:	d017      	beq.n	800c7ba <ax25_send_flag+0x5a>
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800c78a:	8946      	ldrh	r6, [r0, #10]
      return;
    if((byte >> i) & 1)
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
 800c78c:	f003 0107 	and.w	r1, r3, #7
 800c790:	fa05 f401 	lsl.w	r4, r5, r1
void ax25_send_flag(ax25_t *packet)
{
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800c794:	ebb3 0fc6 	cmp.w	r3, r6, lsl #3
      return;
    if((byte >> i) & 1)
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
 800c798:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
      return;
    if((byte >> i) & 1)
 800c79c:	fa4c f802 	asr.w	r8, ip, r2
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
    else
      packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800c7a0:	4621      	mov	r1, r4
void ax25_send_flag(ax25_t *packet)
{
  unsigned char byte = 0x7e;
  int i;
  for(i=0; i<8; i++, packet->size++) {
    if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800c7a2:	da0a      	bge.n	800c7ba <ax25_send_flag+0x5a>
      return;
    if((byte >> i) & 1)
 800c7a4:	f018 0f01 	tst.w	r8, #1
 800c7a8:	d1e2      	bne.n	800c770 <ax25_send_flag+0x10>
      packet->data[packet->size >> 3] |= (1 << (packet->size & 7));
    else
      packet->data[packet->size >> 3] &= ~(1 << (packet->size & 7));
 800c7aa:	6844      	ldr	r4, [r0, #4]
 800c7ac:	f814 300e 	ldrb.w	r3, [r4, lr]
 800c7b0:	ea23 0101 	bic.w	r1, r3, r1
 800c7b4:	f804 100e 	strb.w	r1, [r4, lr]
 800c7b8:	e7e0      	b.n	800c77c <ax25_send_flag+0x1c>
 800c7ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c7be:	bf00      	nop

0800c7c0 <send_byte.lto_priv.140>:
	lfsr = (lfsr << 1) | (x & 1);
	return x;
}

static void send_byte(ax25_t *packet, char byte)
{
 800c7c0:	b5f0      	push	{r4, r5, r6, r7, lr}
	int i;
	for(i=0; i<8; i++) {
 800c7c2:	2400      	movs	r4, #0
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);

		packet->size++;
		packet->ones_in_a_row = 0;
 800c7c4:	4626      	mov	r6, r4
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800c7c6:	2501      	movs	r5, #1
	data[size >> 3] &= ~(1 << (size & 7)); \
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
 800c7c8:	8983      	ldrh	r3, [r0, #12]

static void send_byte(ax25_t *packet, char byte)
{
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
 800c7ca:	fa41 f204 	asr.w	r2, r1, r4
	data[size >> 3] &= ~(1 << (size & 7)); \
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
 800c7ce:	f002 0201 	and.w	r2, r2, #1
 800c7d2:	4053      	eors	r3, r2
	if(packet->crc & 1)
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800c7d4:	085f      	lsrs	r7, r3, #1
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
	if(packet->crc & 1)
 800c7d6:	f013 0f01 	tst.w	r3, #1
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800c7da:	f487 4704 	eor.w	r7, r7, #33792	; 0x8400
	data[size >> 3] &= ~(1 << (size & 7)); \
}

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
 800c7de:	8183      	strh	r3, [r0, #12]
	if(packet->crc & 1)
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800c7e0:	f087 0708 	eor.w	r7, r7, #8
	else
		packet->crc = packet->crc >> 1;
 800c7e4:	bf06      	itte	eq
 800c7e6:	085b      	lsreq	r3, r3, #1
 800c7e8:	8183      	strheq	r3, [r0, #12]

static void update_crc(ax25_t *packet, char bit)
{
	packet->crc ^= bit;
	if(packet->crc & 1)
		packet->crc = (packet->crc >> 1) ^ 0x8408;  // X-modem CRC poly
 800c7ea:	8187      	strhne	r7, [r0, #12]
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800c7ec:	8903      	ldrh	r3, [r0, #8]
static void send_byte(ax25_t *packet, char byte)
{
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
 800c7ee:	b1da      	cbz	r2, 800c828 <send_byte.lto_priv.140+0x68>
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800c7f0:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
				return;

			AX25_WRITE_BIT(packet->data, packet->size);
 800c7f4:	f003 0207 	and.w	r2, r3, #7
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800c7f8:	ebb3 0fce 	cmp.w	r3, lr, lsl #3
				return;

			AX25_WRITE_BIT(packet->data, packet->size);
 800c7fc:	ea4f 07d3 	mov.w	r7, r3, lsr #3
 800c800:	fa05 f202 	lsl.w	r2, r5, r2
	int i;
	for(i=0; i<8; i++) {
		update_crc(packet, (byte >> i) & 1);
		if((byte >> i) & 1) {
			// Next bit is a '1'
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
 800c804:	da2a      	bge.n	800c85c <send_byte.lto_priv.140+0x9c>
				return;

			AX25_WRITE_BIT(packet->data, packet->size);
 800c806:	f8d0 e004 	ldr.w	lr, [r0, #4]
 800c80a:	f81e 3007 	ldrb.w	r3, [lr, r7]
 800c80e:	431a      	orrs	r2, r3
 800c810:	f80e 2007 	strb.w	r2, [lr, r7]

			packet->size++;
			packet->ones_in_a_row++;
 800c814:	7802      	ldrb	r2, [r0, #0]
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
				return;

			AX25_WRITE_BIT(packet->data, packet->size);

			packet->size++;
 800c816:	8903      	ldrh	r3, [r0, #8]
			packet->ones_in_a_row++;
 800c818:	3201      	adds	r2, #1
 800c81a:	b2d2      	uxtb	r2, r2
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
				return;

			AX25_WRITE_BIT(packet->data, packet->size);

			packet->size++;
 800c81c:	3301      	adds	r3, #1
 800c81e:	b29b      	uxth	r3, r3
			packet->ones_in_a_row++;
			if(packet->ones_in_a_row < 5)
 800c820:	2a04      	cmp	r2, #4
			if(packet->size >= packet->max_size * 8)  // Prevent buffer overrun
				return;

			AX25_WRITE_BIT(packet->data, packet->size);

			packet->size++;
 800c822:	8103      	strh	r3, [r0, #8]
			packet->ones_in_a_row++;
 800c824:	7002      	strb	r2, [r0, #0]
			if(packet->ones_in_a_row < 5)
 800c826:	d916      	bls.n	800c856 <send_byte.lto_priv.140+0x96>
				continue;
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
 800c828:	f8b0 e00a 	ldrh.w	lr, [r0, #10]
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800c82c:	f003 0207 	and.w	r2, r3, #7
			packet->ones_in_a_row++;
			if(packet->ones_in_a_row < 5)
				continue;
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
 800c830:	ebb3 0fce 	cmp.w	r3, lr, lsl #3
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800c834:	ea4f 07d3 	mov.w	r7, r3, lsr #3
 800c838:	fa05 f202 	lsl.w	r2, r5, r2
			packet->ones_in_a_row++;
			if(packet->ones_in_a_row < 5)
				continue;
		}
		// Next bit is a '0' or a zero padding after 5 ones in a row
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
 800c83c:	da0e      	bge.n	800c85c <send_byte.lto_priv.140+0x9c>
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);
 800c83e:	f8d0 e004 	ldr.w	lr, [r0, #4]
 800c842:	f81e 3007 	ldrb.w	r3, [lr, r7]
 800c846:	ea23 0202 	bic.w	r2, r3, r2
 800c84a:	f80e 2007 	strb.w	r2, [lr, r7]

		packet->size++;
 800c84e:	8903      	ldrh	r3, [r0, #8]
		packet->ones_in_a_row = 0;
 800c850:	7006      	strb	r6, [r0, #0]
		if(packet->size >= packet->max_size * 8)    // Prevent buffer overrun
			return;

		AX25_CLEAR_BIT(packet->data, packet->size);

		packet->size++;
 800c852:	3301      	adds	r3, #1
 800c854:	8103      	strh	r3, [r0, #8]
}

static void send_byte(ax25_t *packet, char byte)
{
	int i;
	for(i=0; i<8; i++) {
 800c856:	3401      	adds	r4, #1
 800c858:	2c08      	cmp	r4, #8
 800c85a:	d1b5      	bne.n	800c7c8 <send_byte.lto_priv.140+0x8>
 800c85c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800c85e:	bf00      	nop

0800c860 <ax25_send_path>:
	// Protocol ID: 0xf0 = no layer 3 data
	send_byte(packet, 0xf0);
}

void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
 800c860:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c864:	4688      	mov	r8, r1
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800c866:	7809      	ldrb	r1, [r1, #0]
	// Protocol ID: 0xf0 = no layer 3 data
	send_byte(packet, 0xf0);
}

void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
 800c868:	4605      	mov	r5, r0
 800c86a:	4616      	mov	r6, r2
 800c86c:	461f      	mov	r7, r3
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800c86e:	b301      	cbz	r1, 800c8b2 <ax25_send_path+0x52>
 800c870:	2400      	movs	r4, #0
 800c872:	3401      	adds	r4, #1
		send_byte(packet, callsign[j] << 1);
 800c874:	0049      	lsls	r1, r1, #1
void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800c876:	b2e4      	uxtb	r4, r4
		send_byte(packet, callsign[j] << 1);
 800c878:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 800c87c:	4628      	mov	r0, r5
 800c87e:	f7ff ff9f 	bl	800c7c0 <send_byte.lto_priv.140>
void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800c882:	f818 1004 	ldrb.w	r1, [r8, r4]
 800c886:	2900      	cmp	r1, #0
 800c888:	d1f3      	bne.n	800c872 <ax25_send_path+0x12>
		send_byte(packet, callsign[j] << 1);
	}

	// Transmit pad
	for( ; j < 6; j++)
 800c88a:	2c05      	cmp	r4, #5
 800c88c:	d807      	bhi.n	800c89e <ax25_send_path+0x3e>
 800c88e:	3401      	adds	r4, #1
		send_byte(packet, ' ' << 1);
 800c890:	2140      	movs	r1, #64	; 0x40
 800c892:	4628      	mov	r0, r5
	for(j = 0; callsign[j]; j++) {
		send_byte(packet, callsign[j] << 1);
	}

	// Transmit pad
	for( ; j < 6; j++)
 800c894:	b2e4      	uxtb	r4, r4
		send_byte(packet, ' ' << 1);
 800c896:	f7ff ff93 	bl	800c7c0 <send_byte.lto_priv.140>
	for(j = 0; callsign[j]; j++) {
		send_byte(packet, callsign[j] << 1);
	}

	// Transmit pad
	for( ; j < 6; j++)
 800c89a:	2c06      	cmp	r4, #6
 800c89c:	d1f7      	bne.n	800c88e <ax25_send_path+0x2e>
		send_byte(packet, ' ' << 1);

	// Transmit SSID. Termination signaled with last bit = 1
	send_byte(packet, ('0' + ssid) << 1 | (last & 0x1));
 800c89e:	f106 0130 	add.w	r1, r6, #48	; 0x30
 800c8a2:	ea47 0141 	orr.w	r1, r7, r1, lsl #1
 800c8a6:	4628      	mov	r0, r5
 800c8a8:	b2c9      	uxtb	r1, r1
}
 800c8aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	// Transmit pad
	for( ; j < 6; j++)
		send_byte(packet, ' ' << 1);

	// Transmit SSID. Termination signaled with last bit = 1
	send_byte(packet, ('0' + ssid) << 1 | (last & 0x1));
 800c8ae:	f7ff bf87 	b.w	800c7c0 <send_byte.lto_priv.140>
void ax25_send_path(ax25_t *packet, const char *callsign, uint8_t ssid, bool last)
{
	uint8_t j;

	// Transmit callsign
	for(j = 0; callsign[j]; j++) {
 800c8b2:	460c      	mov	r4, r1
 800c8b4:	e7eb      	b.n	800c88e <ax25_send_path+0x2e>
 800c8b6:	bf00      	nop
	...

0800c8c0 <ssdv_outbits.lto_priv.142>:
}

/*****************************************************************************/

static char ssdv_outbits(ssdv_t *s, uint16_t bits, uint8_t length)
{
 800c8c0:	b470      	push	{r4, r5, r6}
	uint8_t b;
	
	if(length)
 800c8c2:	2a00      	cmp	r2, #0
 800c8c4:	d134      	bne.n	800c930 <ssdv_outbits.lto_priv.142+0x70>
 800c8c6:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
 800c8ca:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
		s->out_len--;
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
		{
			s->outbits &= (1 << s->outlen) - 1;
 800c8cc:	2501      	movs	r5, #1
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800c8ce:	2b07      	cmp	r3, #7
	{
		b = s->outbits >> (s->outlen - 8);
 800c8d0:	f1a3 0208 	sub.w	r2, r3, #8
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800c8d4:	d926      	bls.n	800c924 <ssdv_outbits.lto_priv.142+0x64>
 800c8d6:	2900      	cmp	r1, #0
 800c8d8:	d039      	beq.n	800c94e <ssdv_outbits.lto_priv.142+0x8e>
	{
		b = s->outbits >> (s->outlen - 8);
 800c8da:	6c43      	ldr	r3, [r0, #68]	; 0x44
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
 800c8dc:	6b81      	ldr	r1, [r0, #56]	; 0x38
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
	{
		b = s->outbits >> (s->outlen - 8);
 800c8de:	fa23 f202 	lsr.w	r2, r3, r2
 800c8e2:	b2d2      	uxtb	r2, r2
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
 800c8e4:	1c4b      	adds	r3, r1, #1
 800c8e6:	6383      	str	r3, [r0, #56]	; 0x38
 800c8e8:	700a      	strb	r2, [r1, #0]
		s->outlen -= 8;
 800c8ea:	f890 4048 	ldrb.w	r4, [r0, #72]	; 0x48
		s->out_len--;
 800c8ee:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
 800c8f0:	f890 6040 	ldrb.w	r6, [r0, #64]	; 0x40
	{
		b = s->outbits >> (s->outlen - 8);
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
		s->outlen -= 8;
 800c8f4:	f1a4 0308 	sub.w	r3, r4, #8
 800c8f8:	b2db      	uxtb	r3, r3
		s->out_len--;
 800c8fa:	3901      	subs	r1, #1
	{
		b = s->outbits >> (s->outlen - 8);
		
		/* Put the byte into the output buffer */
		*(s->outp++) = b;
		s->outlen -= 8;
 800c8fc:	f880 3048 	strb.w	r3, [r0, #72]	; 0x48
		s->out_len--;
 800c900:	63c1      	str	r1, [r0, #60]	; 0x3c
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
 800c902:	2e00      	cmp	r6, #0
 800c904:	d0e3      	beq.n	800c8ce <ssdv_outbits.lto_priv.142+0xe>
 800c906:	2aff      	cmp	r2, #255	; 0xff
 800c908:	d1e1      	bne.n	800c8ce <ssdv_outbits.lto_priv.142+0xe>
		{
			s->outbits &= (1 << s->outlen) - 1;
 800c90a:	6c42      	ldr	r2, [r0, #68]	; 0x44
			s->outlen += 8;
 800c90c:	f880 4048 	strb.w	r4, [r0, #72]	; 0x48
		s->out_len--;
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
		{
			s->outbits &= (1 << s->outlen) - 1;
 800c910:	fa05 f303 	lsl.w	r3, r5, r3
 800c914:	3b01      	subs	r3, #1
 800c916:	401a      	ands	r2, r3
			s->outlen += 8;
 800c918:	4623      	mov	r3, r4
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800c91a:	2b07      	cmp	r3, #7
		s->out_len--;
		
		/* Insert stuffing byte if needed */
		if(s->out_stuff && b == 0xFF)
		{
			s->outbits &= (1 << s->outlen) - 1;
 800c91c:	6442      	str	r2, [r0, #68]	; 0x44
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
	{
		b = s->outbits >> (s->outlen - 8);
 800c91e:	f1a3 0208 	sub.w	r2, r3, #8
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
		s->outlen += length;
	}
	
	while(s->outlen >= 8 && s->out_len > 0)
 800c922:	d8d8      	bhi.n	800c8d6 <ssdv_outbits.lto_priv.142+0x16>
			s->outbits &= (1 << s->outlen) - 1;
			s->outlen += 8;
		}
	}
	
	return(s->out_len ? SSDV_OK : SSDV_BUFFER_FULL);
 800c924:	2900      	cmp	r1, #0
 800c926:	bf0c      	ite	eq
 800c928:	2003      	moveq	r0, #3
 800c92a:	2000      	movne	r0, #0
}
 800c92c:	bc70      	pop	{r4, r5, r6}
 800c92e:	4770      	bx	lr
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800c930:	2501      	movs	r5, #1
 800c932:	6c44      	ldr	r4, [r0, #68]	; 0x44
		s->outlen += length;
 800c934:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800c938:	4095      	lsls	r5, r2
 800c93a:	3d01      	subs	r5, #1
 800c93c:	4029      	ands	r1, r5
 800c93e:	4094      	lsls	r4, r2
		s->outlen += length;
 800c940:	4413      	add	r3, r2
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800c942:	430c      	orrs	r4, r1
		s->outlen += length;
 800c944:	b2db      	uxtb	r3, r3
	uint8_t b;
	
	if(length)
	{
		s->outbits <<= length;
		s->outbits |= bits & ((1 << length) - 1);
 800c946:	6444      	str	r4, [r0, #68]	; 0x44
		s->outlen += length;
 800c948:	f880 3048 	strb.w	r3, [r0, #72]	; 0x48
 800c94c:	e7bd      	b.n	800c8ca <ssdv_outbits.lto_priv.142+0xa>
			s->outbits &= (1 << s->outlen) - 1;
			s->outlen += 8;
		}
	}
	
	return(s->out_len ? SSDV_OK : SSDV_BUFFER_FULL);
 800c94e:	2003      	movs	r0, #3
}
 800c950:	bc70      	pop	{r4, r5, r6}
 800c952:	4770      	bx	lr
	...

0800c960 <ssdv_outbits_sync.lto_priv.143>:

static char ssdv_outbits_sync(ssdv_t *s)
{
	uint8_t b = s->outlen % 8;
 800c960:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
	if(b) return(ssdv_outbits(s, 0xFF, 8 - b));
 800c964:	f012 0207 	ands.w	r2, r2, #7
 800c968:	d101      	bne.n	800c96e <ssdv_outbits_sync.lto_priv.143+0xe>
	return(SSDV_OK);
}
 800c96a:	4610      	mov	r0, r2
 800c96c:	4770      	bx	lr
}

static char ssdv_outbits_sync(ssdv_t *s)
{
	uint8_t b = s->outlen % 8;
	if(b) return(ssdv_outbits(s, 0xFF, 8 - b));
 800c96e:	f1c2 0208 	rsb	r2, r2, #8
 800c972:	b2d2      	uxtb	r2, r2
 800c974:	21ff      	movs	r1, #255	; 0xff
 800c976:	f7ff bfa3 	b.w	800c8c0 <ssdv_outbits.lto_priv.142>
 800c97a:	bf00      	nop
 800c97c:	0000      	movs	r0, r0
	...

0800c980 <log_error>:

static error_t error_log[ERRORLOG_SIZE];	// Error log ring memory
static uint8_t error_id;					// Incremental ID for ring memory

void log_error(char *file, uint16_t line)
{
 800c980:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if(error_id == ERRORLOG_SIZE)
 800c984:	f8df 9074 	ldr.w	r9, [pc, #116]	; 800c9fc <log_error+0x7c>
 800c988:	f899 8000 	ldrb.w	r8, [r9]
 800c98c:	f1b8 0f19 	cmp.w	r8, #25
 800c990:	d029      	beq.n	800c9e6 <log_error+0x66>
 800c992:	4606      	mov	r6, r0
 800c994:	460f      	mov	r7, r1
 800c996:	4d15      	ldr	r5, [pc, #84]	; (800c9ec <log_error+0x6c>)
		return; // No memory left

	// Find file ID
	error_log[error_id].error = 1; // Assign default error file (if file not found)
 800c998:	4815      	ldr	r0, [pc, #84]	; (800c9f0 <log_error+0x70>)
	for(uint8_t i=1; i<sizeof(fileIDs); i++)
 800c99a:	2401      	movs	r4, #1
 800c99c:	e003      	b.n	800c9a6 <log_error+0x26>
 800c99e:	3401      	adds	r4, #1
 800c9a0:	f855 0f04 	ldr.w	r0, [r5, #4]!
 800c9a4:	b2e4      	uxtb	r4, r4
		if(!strcmp(fileIDs[i], file)) {
 800c9a6:	4631      	mov	r1, r6
 800c9a8:	f7f4 fd7e 	bl	80014a8 <strcmp>
 800c9ac:	2800      	cmp	r0, #0
 800c9ae:	d1f6      	bne.n	800c99e <log_error+0x1e>
 800c9b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
 800c9b4:	490f      	ldr	r1, [pc, #60]	; (800c9f4 <log_error+0x74>)
 800c9b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800c9b8:	480f      	ldr	r0, [pc, #60]	; (800c9f8 <log_error+0x78>)
 800c9ba:	f502 531c 	add.w	r3, r2, #9984	; 0x2700
 800c9be:	330f      	adds	r3, #15
 800c9c0:	fba0 2303 	umull	r2, r3, r0, r3
	error_log[error_id].error |= (line & 0x3FF);
 800c9c4:	3401      	adds	r4, #1
 800c9c6:	f3c7 0709 	ubfx	r7, r7, #0, #10
 800c9ca:	eb01 00c8 	add.w	r0, r1, r8, lsl #3

	error_id++; // Increment counter
 800c9ce:	f108 0201 	add.w	r2, r8, #1
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
	error_log[error_id].error |= (line & 0x3FF);
 800c9d2:	ea47 2484 	orr.w	r4, r7, r4, lsl #10
		if(!strcmp(fileIDs[i], file)) {
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
 800c9d6:	0b5b      	lsrs	r3, r3, #13
	error_log[error_id].error |= (line & 0x3FF);

	error_id++; // Increment counter
 800c9d8:	f889 2000 	strb.w	r2, [r9]
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
	error_log[error_id].error |= (line & 0x3FF);
 800c9dc:	8084      	strh	r4, [r0, #4]
		if(!strcmp(fileIDs[i], file)) {
			error_log[error_id].error = ((i+1) << 10);
			break;
		}

	error_log[error_id].time = ST2S(chVTGetSystemTimeX());
 800c9de:	f841 3038 	str.w	r3, [r1, r8, lsl #3]
 800c9e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c9e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800c9ea:	bf00      	nop
 800c9ec:	0801059c 	.word	0x0801059c
 800c9f0:	0800f15c 	.word	0x0800f15c
 800c9f4:	2001b5c8 	.word	0x2001b5c8
 800c9f8:	d1b71759 	.word	0xd1b71759
 800c9fc:	2001b5c4 	.word	0x2001b5c4

0800ca00 <ssdv_have_marker.lto_priv.141>:
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
}

static char ssdv_have_marker(ssdv_t *s)
{
	switch(s->marker)
 800ca00:	f8b0 304a 	ldrh.w	r3, [r0, #74]	; 0x4a
 800ca04:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
 800ca08:	3bc0      	subs	r3, #192	; 0xc0
	uint8_t l = 0x00;
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
}

static char ssdv_have_marker(ssdv_t *s)
{
 800ca0a:	4602      	mov	r2, r0
	switch(s->marker)
 800ca0c:	2b1d      	cmp	r3, #29
 800ca0e:	d874      	bhi.n	800cafa <ssdv_have_marker.lto_priv.141+0xfa>
 800ca10:	e8df f003 	tbb	[pc, r3]
 800ca14:	73297368 	.word	0x73297368
 800ca18:	73737368 	.word	0x73737368
 800ca1c:	73737373 	.word	0x73737373
 800ca20:	73737373 	.word	0x73737373
 800ca24:	14141414 	.word	0x14141414
 800ca28:	14141414 	.word	0x14141414
 800ca2c:	68680f73 	.word	0x68680f73
 800ca30:	6873      	.short	0x6873
		/* Don't do progressive images! */
		TRACE_ERROR("SSDV > Progressive images not supported");
		return(SSDV_ERROR);
	
	case J_EOI:
		s->state = S_EOI;
 800ca32:	2305      	movs	r3, #5
 800ca34:	f880 3049 	strb.w	r3, [r0, #73]	; 0x49
		s->in_skip = s->marker_len;
		s->state   = S_MARKER;
		break;
	}
	
	return(SSDV_OK);
 800ca38:	2000      	movs	r0, #0
 800ca3a:	4770      	bx	lr
	case J_RST3:
	case J_RST4:
	case J_RST5:
	case J_RST6:
	case J_RST7:
		s->dc[0]  = s->dc[1]  = s->dc[2]  = 0;
 800ca3c:	2000      	movs	r0, #0
		s->mcupart = s->acpart = s->component = 0;
		s->acrle = s->accrle = 0;
		s->workbits = s->worklen = 0;
		s->state = S_HUFF;
 800ca3e:	2303      	movs	r3, #3
	case J_RST3:
	case J_RST4:
	case J_RST5:
	case J_RST6:
	case J_RST7:
		s->dc[0]  = s->dc[1]  = s->dc[2]  = 0;
 800ca40:	6650      	str	r0, [r2, #100]	; 0x64
 800ca42:	6610      	str	r0, [r2, #96]	; 0x60
 800ca44:	65d0      	str	r0, [r2, #92]	; 0x5c
		s->mcupart = s->acpart = s->component = 0;
 800ca46:	f882 0056 	strb.w	r0, [r2, #86]	; 0x56
 800ca4a:	f882 0059 	strb.w	r0, [r2, #89]	; 0x59
 800ca4e:	f882 0058 	strb.w	r0, [r2, #88]	; 0x58
		s->acrle = s->accrle = 0;
 800ca52:	f882 0075 	strb.w	r0, [r2, #117]	; 0x75
 800ca56:	f882 0074 	strb.w	r0, [r2, #116]	; 0x74
		s->workbits = s->worklen = 0;
 800ca5a:	f882 0030 	strb.w	r0, [r2, #48]	; 0x30
 800ca5e:	62d0      	str	r0, [r2, #44]	; 0x2c
		s->state = S_HUFF;
 800ca60:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
 800ca64:	4770      	bx	lr
	uint8_t l = 0x00;
	for(; n > 0; n--) *(s++) = (l = l * 245 + 45);
}

static char ssdv_have_marker(ssdv_t *s)
{
 800ca66:	b570      	push	{r4, r5, r6, lr}
		s->state           = S_MARKER_DATA;
		break;
	
	case J_SOF2:
		/* Don't do progressive images! */
		TRACE_ERROR("SSDV > Progressive images not supported");
 800ca68:	482c      	ldr	r0, [pc, #176]	; (800cb1c <ssdv_have_marker.lto_priv.141+0x11c>)
 800ca6a:	4e2d      	ldr	r6, [pc, #180]	; (800cb20 <ssdv_have_marker.lto_priv.141+0x120>)
 800ca6c:	f7ff fb98 	bl	800c1a0 <chMtxLock>
 800ca70:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800ca74:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800ca78:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800ca7a:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800ca7c:	4b29      	ldr	r3, [pc, #164]	; (800cb24 <ssdv_have_marker.lto_priv.141+0x124>)
 800ca7e:	492a      	ldr	r1, [pc, #168]	; (800cb28 <ssdv_have_marker.lto_priv.141+0x128>)
 800ca80:	482a      	ldr	r0, [pc, #168]	; (800cb2c <ssdv_have_marker.lto_priv.141+0x12c>)
 800ca82:	fb05 f404 	mul.w	r4, r5, r4
 800ca86:	fba6 e404 	umull	lr, r4, r6, r4
 800ca8a:	0b64      	lsrs	r4, r4, #13
 800ca8c:	fba3 e304 	umull	lr, r3, r3, r4
 800ca90:	fba6 6202 	umull	r6, r2, r6, r2
 800ca94:	099b      	lsrs	r3, r3, #6
 800ca96:	fb05 4313 	mls	r3, r5, r3, r4
 800ca9a:	0b52      	lsrs	r2, r2, #13
 800ca9c:	f7fd fdf8 	bl	800a690 <chprintf.constprop.26>
 800caa0:	4a23      	ldr	r2, [pc, #140]	; (800cb30 <ssdv_have_marker.lto_priv.141+0x130>)
 800caa2:	4924      	ldr	r1, [pc, #144]	; (800cb34 <ssdv_have_marker.lto_priv.141+0x134>)
 800caa4:	4821      	ldr	r0, [pc, #132]	; (800cb2c <ssdv_have_marker.lto_priv.141+0x12c>)
 800caa6:	f7fd fdf3 	bl	800a690 <chprintf.constprop.26>
 800caaa:	f240 2362 	movw	r3, #610	; 0x262
 800caae:	4a22      	ldr	r2, [pc, #136]	; (800cb38 <ssdv_have_marker.lto_priv.141+0x138>)
 800cab0:	4922      	ldr	r1, [pc, #136]	; (800cb3c <ssdv_have_marker.lto_priv.141+0x13c>)
 800cab2:	481e      	ldr	r0, [pc, #120]	; (800cb2c <ssdv_have_marker.lto_priv.141+0x12c>)
 800cab4:	f7fd fdec 	bl	800a690 <chprintf.constprop.26>
 800cab8:	4921      	ldr	r1, [pc, #132]	; (800cb40 <ssdv_have_marker.lto_priv.141+0x140>)
 800caba:	481c      	ldr	r0, [pc, #112]	; (800cb2c <ssdv_have_marker.lto_priv.141+0x12c>)
 800cabc:	f7fd fde8 	bl	800a690 <chprintf.constprop.26>
 800cac0:	4920      	ldr	r1, [pc, #128]	; (800cb44 <ssdv_have_marker.lto_priv.141+0x144>)
 800cac2:	481a      	ldr	r0, [pc, #104]	; (800cb2c <ssdv_have_marker.lto_priv.141+0x12c>)
 800cac4:	f7fd fde4 	bl	800a690 <chprintf.constprop.26>
 800cac8:	491f      	ldr	r1, [pc, #124]	; (800cb48 <ssdv_have_marker.lto_priv.141+0x148>)
 800caca:	4818      	ldr	r0, [pc, #96]	; (800cb2c <ssdv_have_marker.lto_priv.141+0x12c>)
 800cacc:	f7fd fde0 	bl	800a690 <chprintf.constprop.26>
 800cad0:	4812      	ldr	r0, [pc, #72]	; (800cb1c <ssdv_have_marker.lto_priv.141+0x11c>)
 800cad2:	f7fc fd55 	bl	8009580 <chMtxUnlock>
 800cad6:	f240 2162 	movw	r1, #610	; 0x262
 800cada:	4817      	ldr	r0, [pc, #92]	; (800cb38 <ssdv_have_marker.lto_priv.141+0x138>)
 800cadc:	f7ff ff50 	bl	800c980 <log_error>
		return(SSDV_ERROR);
 800cae0:	20ff      	movs	r0, #255	; 0xff
 800cae2:	bd70      	pop	{r4, r5, r6, pc}
	case J_SOS:
	case J_DRI:
	case J_DHT:
	case J_DQT:
		/* Copy the data before processing */
		if(s->marker_len > TBL_LEN + HBUFF_LEN - s->stbl_len)
 800cae4:	f8b0 12cc 	ldrh.w	r1, [r0, #716]	; 0x2cc
 800cae8:	f8b0 004c 	ldrh.w	r0, [r0, #76]	; 0x4c
 800caec:	f5c1 730c 	rsb	r3, r1, #560	; 0x230
 800caf0:	3302      	adds	r3, #2
 800caf2:	4298      	cmp	r0, r3
 800caf4:	dd08      	ble.n	800cb08 <ssdv_have_marker.lto_priv.141+0x108>
		{
			/* Not enough memory ... shouldn't happen! */
			return(SSDV_ERROR);
 800caf6:	20ff      	movs	r0, #255	; 0xff
 800caf8:	4770      	bx	lr
		s->state = S_HUFF;
		break;
	
	default:
		/* Ignore other marks, skipping any associated data */
		s->in_skip = s->marker_len;
 800cafa:	f8b0 304c 	ldrh.w	r3, [r0, #76]	; 0x4c
 800cafe:	6283      	str	r3, [r0, #40]	; 0x28
		s->state   = S_MARKER;
 800cb00:	2000      	movs	r0, #0
 800cb02:	f882 0049 	strb.w	r0, [r2, #73]	; 0x49
 800cb06:	4770      	bx	lr
		{
			/* Not enough memory ... shouldn't happen! */
			return(SSDV_ERROR);
		}
		
		s->marker_data     = &s->stbls[s->stbl_len];
 800cb08:	4411      	add	r1, r2
 800cb0a:	3181      	adds	r1, #129	; 0x81
		s->marker_data_len = 0;
 800cb0c:	2000      	movs	r0, #0
		s->state           = S_MARKER_DATA;
 800cb0e:	2302      	movs	r3, #2
		{
			/* Not enough memory ... shouldn't happen! */
			return(SSDV_ERROR);
		}
		
		s->marker_data     = &s->stbls[s->stbl_len];
 800cb10:	6511      	str	r1, [r2, #80]	; 0x50
		s->marker_data_len = 0;
 800cb12:	f8a2 0054 	strh.w	r0, [r2, #84]	; 0x54
		s->state           = S_MARKER_DATA;
 800cb16:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
 800cb1a:	4770      	bx	lr
 800cb1c:	2001b720 	.word	0x2001b720
 800cb20:	d1b71759 	.word	0xd1b71759
 800cb24:	10624dd3 	.word	0x10624dd3
 800cb28:	0800ea50 	.word	0x0800ea50
 800cb2c:	2001ac28 	.word	0x2001ac28
 800cb30:	0800ea5c 	.word	0x0800ea5c
 800cb34:	0800ea64 	.word	0x0800ea64
 800cb38:	0800eabb 	.word	0x0800eabb
 800cb3c:	0800ea7c 	.word	0x0800ea7c
 800cb40:	0800f1e0 	.word	0x0800f1e0
 800cb44:	08010620 	.word	0x08010620
 800cb48:	0800eaa8 	.word	0x0800eaa8
 800cb4c:	00000000 	.word	0x00000000

0800cb50 <ssdv_out_jpeg_int.lto_priv.144>:
	if(b) return(ssdv_outbits(s, 0xFF, 8 - b));
	return(SSDV_OK);
}

static char ssdv_out_jpeg_int(ssdv_t *s, uint8_t rle, int value)
{
 800cb50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cb54:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 800cb58:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
 800cb5c:	b083      	sub	sp, #12
 800cb5e:	4616      	mov	r6, r2
 800cb60:	4605      	mov	r5, r0
 800cb62:	460f      	mov	r7, r1
{
	*bits = value;
	
	/* Calculate the number of bits */
	if(value < 0) value = -value;
	for(*width = 0; value; value >>= 1) (*width)++;
 800cb64:	2b00      	cmp	r3, #0
 800cb66:	f000 809b 	beq.w	800cca0 <ssdv_out_jpeg_int.lto_priv.144+0x150>
 800cb6a:	2400      	movs	r4, #0
 800cb6c:	3401      	adds	r4, #1
 800cb6e:	105b      	asrs	r3, r3, #1
 800cb70:	b2e4      	uxtb	r4, r4
 800cb72:	d1fb      	bne.n	800cb6c <ssdv_out_jpeg_int.lto_priv.144+0x1c>
 800cb74:	f004 030f 	and.w	r3, r4, #15
	
	/* Fix negative values */
	if(*bits < 0) *bits = -*bits ^ ((1 << *width) - 1);
 800cb78:	2e00      	cmp	r6, #0
 800cb7a:	f2c0 8089 	blt.w	800cc90 <ssdv_out_jpeg_int.lto_priv.144+0x140>
 800cb7e:	46b0      	mov	r8, r6
{
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	dht = DDHT;
 800cb80:	f895 2059 	ldrb.w	r2, [r5, #89]	; 0x59
 800cb84:	f895 1056 	ldrb.w	r1, [r5, #86]	; 0x56
 800cb88:	3200      	adds	r2, #0
 800cb8a:	bf18      	it	ne
 800cb8c:	2201      	movne	r2, #1
 800cb8e:	0052      	lsls	r2, r2, #1
 800cb90:	2900      	cmp	r1, #0
 800cb92:	bf18      	it	ne
 800cb94:	3201      	addne	r2, #1
 800cb96:	f502 729e 	add.w	r2, r2, #316	; 0x13c
	int intbits;
	uint8_t hufflen = 0, intlen;
	int r;
	
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
 800cb9a:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
{
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	dht = DDHT;
 800cb9e:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
	int intbits;
	uint8_t hufflen = 0, intlen;
	int r;
	
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
 800cba2:	fa5f fe83 	uxtb.w	lr, r3
	uint16_t code = 0;
	uint8_t cw, n;
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
 800cba6:	f102 0011 	add.w	r0, r2, #17
 800cbaa:	4691      	mov	r9, r2
	return(SSDV_ERROR);
}

static inline char jpeg_dht_lookup_symbol(ssdv_t *s, uint8_t symbol, uint16_t *bits, uint8_t *width)
{
	uint16_t code = 0;
 800cbac:	2100      	movs	r1, #0
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 800cbae:	2201      	movs	r2, #1
	{
		for(n = dht[cw]; n > 0; n--)
 800cbb0:	f819 3f01 	ldrb.w	r3, [r9, #1]!
 800cbb4:	b1b3      	cbz	r3, 800cbe4 <ssdv_out_jpeg_int.lto_priv.144+0x94>
		{
			if(*ss == symbol)
 800cbb6:	f890 c000 	ldrb.w	ip, [r0]
 800cbba:	45f4      	cmp	ip, lr
 800cbbc:	d05a      	beq.n	800cc74 <ssdv_out_jpeg_int.lto_priv.144+0x124>
 800cbbe:	f103 3cff 	add.w	ip, r3, #4294967295
 800cbc2:	fa5f fc8c 	uxtb.w	ip, ip
 800cbc6:	f10c 0c01 	add.w	ip, ip, #1
 800cbca:	4484      	add	ip, r0
 800cbcc:	1c43      	adds	r3, r0, #1
 800cbce:	e002      	b.n	800cbd6 <ssdv_out_jpeg_int.lto_priv.144+0x86>
 800cbd0:	7800      	ldrb	r0, [r0, #0]
 800cbd2:	4570      	cmp	r0, lr
 800cbd4:	d04e      	beq.n	800cc74 <ssdv_out_jpeg_int.lto_priv.144+0x124>
				/* Found a match */
				*bits = code;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 800cbd6:	3101      	adds	r1, #1
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
	{
		for(n = dht[cw]; n > 0; n--)
 800cbd8:	459c      	cmp	ip, r3
				/* Found a match */
				*bits = code;
				*width = cw;
				return(SSDV_OK);
			}
			ss++; code++;
 800cbda:	4618      	mov	r0, r3
 800cbdc:	b289      	uxth	r1, r1
 800cbde:	f103 0301 	add.w	r3, r3, #1
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
	{
		for(n = dht[cw]; n > 0; n--)
 800cbe2:	d1f5      	bne.n	800cbd0 <ssdv_out_jpeg_int.lto_priv.144+0x80>
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 800cbe4:	3201      	adds	r2, #1
 800cbe6:	b2d2      	uxtb	r2, r2
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 800cbe8:	0049      	lsls	r1, r1, #1
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 800cbea:	2a11      	cmp	r2, #17
				return(SSDV_OK);
			}
			ss++; code++;
		}
		
		code <<= 1;
 800cbec:	b289      	uxth	r1, r1
	uint8_t *dht, *ss;
	
	dht = DDHT;
	ss = &dht[17];
	
	for(cw = 1; cw <= 16; cw++)
 800cbee:	d1df      	bne.n	800cbb0 <ssdv_out_jpeg_int.lto_priv.144+0x60>
	int r;
	
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
	
	if(r != SSDV_OK) TRACE_ERROR("SSDV > jpeg_dht_lookup_symbol: %i (%i:%i)", r, value, rle);
 800cbf0:	482c      	ldr	r0, [pc, #176]	; (800cca4 <ssdv_out_jpeg_int.lto_priv.144+0x154>)
 800cbf2:	f7ff fad5 	bl	800c1a0 <chMtxLock>
 800cbf6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800cbfa:	f8df e0d4 	ldr.w	lr, [pc, #212]	; 800ccd0 <ssdv_out_jpeg_int.lto_priv.144+0x180>
 800cbfe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800cc00:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800cc02:	4b29      	ldr	r3, [pc, #164]	; (800cca8 <ssdv_out_jpeg_int.lto_priv.144+0x158>)
 800cc04:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800cc08:	fb00 f101 	mul.w	r1, r0, r1
 800cc0c:	fbae c101 	umull	ip, r1, lr, r1
 800cc10:	0b49      	lsrs	r1, r1, #13
 800cc12:	fba3 c301 	umull	ip, r3, r3, r1
 800cc16:	fbae e202 	umull	lr, r2, lr, r2
 800cc1a:	099b      	lsrs	r3, r3, #6
 800cc1c:	fb00 1313 	mls	r3, r0, r3, r1
 800cc20:	0b52      	lsrs	r2, r2, #13
 800cc22:	4922      	ldr	r1, [pc, #136]	; (800ccac <ssdv_out_jpeg_int.lto_priv.144+0x15c>)
 800cc24:	4822      	ldr	r0, [pc, #136]	; (800ccb0 <ssdv_out_jpeg_int.lto_priv.144+0x160>)
 800cc26:	f7fd fd33 	bl	800a690 <chprintf.constprop.26>
 800cc2a:	4a22      	ldr	r2, [pc, #136]	; (800ccb4 <ssdv_out_jpeg_int.lto_priv.144+0x164>)
 800cc2c:	4922      	ldr	r1, [pc, #136]	; (800ccb8 <ssdv_out_jpeg_int.lto_priv.144+0x168>)
 800cc2e:	4820      	ldr	r0, [pc, #128]	; (800ccb0 <ssdv_out_jpeg_int.lto_priv.144+0x160>)
 800cc30:	f7fd fd2e 	bl	800a690 <chprintf.constprop.26>
 800cc34:	f44f 73b1 	mov.w	r3, #354	; 0x162
 800cc38:	4a20      	ldr	r2, [pc, #128]	; (800ccbc <ssdv_out_jpeg_int.lto_priv.144+0x16c>)
 800cc3a:	4921      	ldr	r1, [pc, #132]	; (800ccc0 <ssdv_out_jpeg_int.lto_priv.144+0x170>)
 800cc3c:	481c      	ldr	r0, [pc, #112]	; (800ccb0 <ssdv_out_jpeg_int.lto_priv.144+0x160>)
 800cc3e:	f7fd fd27 	bl	800a690 <chprintf.constprop.26>
 800cc42:	4920      	ldr	r1, [pc, #128]	; (800ccc4 <ssdv_out_jpeg_int.lto_priv.144+0x174>)
 800cc44:	481a      	ldr	r0, [pc, #104]	; (800ccb0 <ssdv_out_jpeg_int.lto_priv.144+0x160>)
 800cc46:	f7fd fd23 	bl	800a690 <chprintf.constprop.26>
 800cc4a:	22ff      	movs	r2, #255	; 0xff
 800cc4c:	4633      	mov	r3, r6
 800cc4e:	491e      	ldr	r1, [pc, #120]	; (800ccc8 <ssdv_out_jpeg_int.lto_priv.144+0x178>)
 800cc50:	9700      	str	r7, [sp, #0]
 800cc52:	4817      	ldr	r0, [pc, #92]	; (800ccb0 <ssdv_out_jpeg_int.lto_priv.144+0x160>)
 800cc54:	f7fd fd1c 	bl	800a690 <chprintf.constprop.26>
 800cc58:	491c      	ldr	r1, [pc, #112]	; (800cccc <ssdv_out_jpeg_int.lto_priv.144+0x17c>)
 800cc5a:	4815      	ldr	r0, [pc, #84]	; (800ccb0 <ssdv_out_jpeg_int.lto_priv.144+0x160>)
 800cc5c:	f7fd fd18 	bl	800a690 <chprintf.constprop.26>
 800cc60:	4810      	ldr	r0, [pc, #64]	; (800cca4 <ssdv_out_jpeg_int.lto_priv.144+0x154>)
 800cc62:	f7fc fc8d 	bl	8009580 <chMtxUnlock>
 800cc66:	f44f 71b1 	mov.w	r1, #354	; 0x162
 800cc6a:	4814      	ldr	r0, [pc, #80]	; (800ccbc <ssdv_out_jpeg_int.lto_priv.144+0x16c>)
 800cc6c:	f7ff fe88 	bl	800c980 <log_error>
	return(SSDV_OK);
}

static char ssdv_out_jpeg_int(ssdv_t *s, uint8_t rle, int value)
{
	uint16_t huffbits = 0;
 800cc70:	2100      	movs	r1, #0
	int intbits;
	uint8_t hufflen = 0, intlen;
 800cc72:	460a      	mov	r2, r1
	jpeg_encode_int(value, &intbits, &intlen);
	r = jpeg_dht_lookup_symbol(s, (rle << 4) | (intlen & 0x0F), &huffbits, &hufflen);
	
	if(r != SSDV_OK) TRACE_ERROR("SSDV > jpeg_dht_lookup_symbol: %i (%i:%i)", r, value, rle);
	
	ssdv_outbits(s, huffbits, hufflen);
 800cc74:	4628      	mov	r0, r5
 800cc76:	f7ff fe23 	bl	800c8c0 <ssdv_outbits.lto_priv.142>
	if(intlen) ssdv_outbits(s, intbits, intlen);
 800cc7a:	b12c      	cbz	r4, 800cc88 <ssdv_out_jpeg_int.lto_priv.144+0x138>
 800cc7c:	4622      	mov	r2, r4
 800cc7e:	fa1f f188 	uxth.w	r1, r8
 800cc82:	4628      	mov	r0, r5
 800cc84:	f7ff fe1c 	bl	800c8c0 <ssdv_outbits.lto_priv.142>
	
	return(SSDV_OK);
}
 800cc88:	2000      	movs	r0, #0
 800cc8a:	b003      	add	sp, #12
 800cc8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	/* Calculate the number of bits */
	if(value < 0) value = -value;
	for(*width = 0; value; value >>= 1) (*width)++;
	
	/* Fix negative values */
	if(*bits < 0) *bits = -*bits ^ ((1 << *width) - 1);
 800cc90:	2201      	movs	r2, #1
 800cc92:	40a2      	lsls	r2, r4
 800cc94:	3a01      	subs	r2, #1
 800cc96:	f1c6 0800 	rsb	r8, r6, #0
 800cc9a:	ea82 0808 	eor.w	r8, r2, r8
 800cc9e:	e76f      	b.n	800cb80 <ssdv_out_jpeg_int.lto_priv.144+0x30>
{
	*bits = value;
	
	/* Calculate the number of bits */
	if(value < 0) value = -value;
	for(*width = 0; value; value >>= 1) (*width)++;
 800cca0:	461c      	mov	r4, r3
 800cca2:	e769      	b.n	800cb78 <ssdv_out_jpeg_int.lto_priv.144+0x28>
 800cca4:	2001b720 	.word	0x2001b720
 800cca8:	10624dd3 	.word	0x10624dd3
 800ccac:	0800ea50 	.word	0x0800ea50
 800ccb0:	2001ac28 	.word	0x2001ac28
 800ccb4:	0800ea5c 	.word	0x0800ea5c
 800ccb8:	0800ea64 	.word	0x0800ea64
 800ccbc:	0800eabb 	.word	0x0800eabb
 800ccc0:	0800ea7c 	.word	0x0800ea7c
 800ccc4:	0800f1e0 	.word	0x0800f1e0
 800ccc8:	08010648 	.word	0x08010648
 800cccc:	0800eaa8 	.word	0x0800eaa8
 800ccd0:	d1b71759 	.word	0xd1b71759
	...

0800cce0 <doConversion>:
{
	adcStop(&ADCD1);
}

void doConversion(void)
{
 800cce0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800cce2:	2320      	movs	r3, #32
 800cce4:	f383 8811 	msr	BASEPRI, r3
void adcStart(ADCDriver *adcp, const ADCConfig *config) {

  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 800cce8:	4c66      	ldr	r4, [pc, #408]	; (800ce84 <doConversion+0x1a4>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800ccea:	f7ff fa49 	bl	800c180 <_dbg_check_lock>
 800ccee:	7825      	ldrb	r5, [r4, #0]
 800ccf0:	1e6b      	subs	r3, r5, #1
 800ccf2:	2b01      	cmp	r3, #1
 800ccf4:	d902      	bls.n	800ccfc <doConversion+0x1c>
 800ccf6:	4864      	ldr	r0, [pc, #400]	; (800ce88 <doConversion+0x1a8>)
 800ccf8:	f7fe ff3a 	bl	800bb70 <chSysHalt>
                "invalid state");
  adcp->config = config;
 800ccfc:	2300      	movs	r3, #0
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 800ccfe:	2d01      	cmp	r5, #1
 800cd00:	6063      	str	r3, [r4, #4]
 800cd02:	d07f      	beq.n	800ce04 <doConversion+0x124>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cd04:	4d61      	ldr	r5, [pc, #388]	; (800ce8c <doConversion+0x1ac>)
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 800cd06:	2302      	movs	r3, #2
 800cd08:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800cd0a:	f7ff fa29 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cd0e:	682b      	ldr	r3, [r5, #0]
 800cd10:	42ab      	cmp	r3, r5
 800cd12:	d004      	beq.n	800cd1e <doConversion+0x3e>
 800cd14:	69aa      	ldr	r2, [r5, #24]
 800cd16:	689b      	ldr	r3, [r3, #8]
 800cd18:	6892      	ldr	r2, [r2, #8]
 800cd1a:	429a      	cmp	r2, r3
 800cd1c:	d326      	bcc.n	800cd6c <doConversion+0x8c>
 800cd1e:	2300      	movs	r3, #0
 800cd20:	f383 8811 	msr	BASEPRI, r3
 *          temperature sensor and internal reference voltage.
 * @note    This is an STM32-only functionality.
 */
void adcSTM32EnableTSVREFE(void) {

  ADC->CCR |= ADC_CCR_TSVREFE;
 800cd24:	4a5a      	ldr	r2, [pc, #360]	; (800ce90 <doConversion+0x1b0>)

void initADC(void)
{
	adcStart(&ADCD1, NULL);
	adcSTM32EnableTSVREFE();
	palSetPadMode(PORT(ADC_VSOL), PIN(ADC_VSOL), PAL_MODE_INPUT_ANALOG);	// Solar panels
 800cd26:	485b      	ldr	r0, [pc, #364]	; (800ce94 <doConversion+0x1b4>)
 800cd28:	6853      	ldr	r3, [r2, #4]
 800cd2a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800cd2e:	6053      	str	r3, [r2, #4]
 800cd30:	2108      	movs	r1, #8
 800cd32:	2203      	movs	r2, #3
 800cd34:	f7fd f9fc 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(ADC_VBAT), PIN(ADC_VBAT), PAL_MODE_INPUT_ANALOG);	// Battery
 800cd38:	2203      	movs	r2, #3
 800cd3a:	2120      	movs	r1, #32
 800cd3c:	4856      	ldr	r0, [pc, #344]	; (800ce98 <doConversion+0x1b8>)
 800cd3e:	f7fd f9f7 	bl	800a130 <_pal_lld_setgroupmode>
	palSetPadMode(PORT(ADC_VUSB), PIN(ADC_VUSB), PAL_MODE_INPUT_ANALOG);	// USB
 800cd42:	2203      	movs	r2, #3
 800cd44:	2180      	movs	r1, #128	; 0x80
 800cd46:	4853      	ldr	r0, [pc, #332]	; (800ce94 <doConversion+0x1b4>)
 800cd48:	f7fd f9f2 	bl	800a130 <_pal_lld_setgroupmode>
 800cd4c:	2320      	movs	r3, #32
 800cd4e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800cd52:	f7ff fa15 	bl	800c180 <_dbg_check_lock>
void adcStartConversionI(ADCDriver *adcp,
                         const ADCConversionGroup *grpp,
                         adcsample_t *samples,
                         size_t depth) {

  osalDbgCheckClassI();
 800cd56:	f7fe ff6b 	bl	800bc30 <chDbgCheckClassI>
  osalDbgCheck((adcp != NULL) && (grpp != NULL) && (samples != NULL) &&
               (depth > 0U) && ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((adcp->state == ADC_READY) ||
 800cd5a:	7823      	ldrb	r3, [r4, #0]
 800cd5c:	2b02      	cmp	r3, #2
 800cd5e:	d008      	beq.n	800cd72 <doConversion+0x92>
 800cd60:	3b04      	subs	r3, #4
 800cd62:	2b01      	cmp	r3, #1
 800cd64:	d905      	bls.n	800cd72 <doConversion+0x92>
 800cd66:	484d      	ldr	r0, [pc, #308]	; (800ce9c <doConversion+0x1bc>)
 800cd68:	f7fe ff02 	bl	800bb70 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cd6c:	484c      	ldr	r0, [pc, #304]	; (800cea0 <doConversion+0x1c0>)
 800cd6e:	f7fe feff 	bl	800bb70 <chSysHalt>
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800cd72:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 800cd74:	484b      	ldr	r0, [pc, #300]	; (800cea4 <doConversion+0x1c4>)
 800cd76:	681a      	ldr	r2, [r3, #0]
  uint32_t mode;
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
 800cd78:	6b21      	ldr	r1, [r4, #48]	; 0x30
 800cd7a:	6120      	str	r0, [r4, #16]
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 800cd7c:	4b4a      	ldr	r3, [pc, #296]	; (800cea8 <doConversion+0x1c8>)
 800cd7e:	60a3      	str	r3, [r4, #8]
  adcp->depth    = depth;
 800cd80:	2701      	movs	r7, #1
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800cd82:	2004      	movs	r0, #4
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 800cd84:	2603      	movs	r6, #3
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
 800cd86:	60e7      	str	r7, [r4, #12]
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 800cd88:	7026      	strb	r6, [r4, #0]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800cd8a:	60d3      	str	r3, [r2, #12]
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 800cd8c:	6050      	str	r0, [r2, #4]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
 800cd8e:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(adcp->dmastp);
 800cd90:	6811      	ldr	r1, [r2, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800cd92:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
 800cd94:	f8df e134 	ldr.w	lr, [pc, #308]	; 800cecc <doConversion+0x1ec>
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800cd98:	4844      	ldr	r0, [pc, #272]	; (800ceac <doConversion+0x1cc>)
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;
 800cd9a:	4f45      	ldr	r7, [pc, #276]	; (800ceb0 <doConversion+0x1d0>)

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800cd9c:	4e45      	ldr	r6, [pc, #276]	; (800ceb4 <doConversion+0x1d4>)
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 800cd9e:	f041 0101 	orr.w	r1, r1, #1
 800cda2:	6011      	str	r1, [r2, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800cda4:	2200      	movs	r2, #0
  adcp->adc->SMPR1 = grpp->smpr1;
 800cda6:	f44f 11cc 	mov.w	r1, #1671168	; 0x198000
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 800cdaa:	601a      	str	r2, [r3, #0]
  adcp->adc->SMPR1 = grpp->smpr1;
 800cdac:	60d9      	str	r1, [r3, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
 800cdae:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
 800cdb2:	f8c3 e010 	str.w	lr, [r3, #16]
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
 800cdb6:	62d9      	str	r1, [r3, #44]	; 0x2c

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800cdb8:	f240 3103 	movw	r1, #771	; 0x303
  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SQR1  = grpp->sqr1 | ADC_SQR1_NUM_CH(grpp->num_channels);
  adcp->adc->SQR2  = grpp->sqr2;
 800cdbc:	631a      	str	r2, [r3, #48]	; 0x30
  adcp->adc->SQR3  = grpp->sqr3;
 800cdbe:	635f      	str	r7, [r3, #52]	; 0x34

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 800cdc0:	605e      	str	r6, [r3, #4]

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800cdc2:	6099      	str	r1, [r3, #8]

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800cdc4:	6098      	str	r0, [r3, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800cdc6:	f7ff f9cb 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800cdca:	682b      	ldr	r3, [r5, #0]
 800cdcc:	4a2f      	ldr	r2, [pc, #188]	; (800ce8c <doConversion+0x1ac>)
 800cdce:	42ab      	cmp	r3, r5
 800cdd0:	d004      	beq.n	800cddc <doConversion+0xfc>
 800cdd2:	6992      	ldr	r2, [r2, #24]
 800cdd4:	689b      	ldr	r3, [r3, #8]
 800cdd6:	6892      	ldr	r2, [r2, #8]
 800cdd8:	429a      	cmp	r2, r3
 800cdda:	d3c7      	bcc.n	800cd6c <doConversion+0x8c>
 800cddc:	2600      	movs	r6, #0
 800cdde:	f386 8811 	msr	BASEPRI, r6

void doConversion(void)
{
	initADC();
	adcStartConversion(&ADCD1, &adcgrpcfg, samples, 1);
	chThdSleepMilliseconds(35); // Wait until conversion is finished
 800cde2:	f44f 70af 	mov.w	r0, #350	; 0x15e
 800cde6:	f7ff faab 	bl	800c340 <chThdSleep>
 800cdea:	2320      	movs	r3, #32
 800cdec:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800cdf0:	f7ff f9c6 	bl	800c180 <_dbg_check_lock>

  osalDbgCheck(adcp != NULL);

  osalSysLock();

  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 800cdf4:	7823      	ldrb	r3, [r4, #0]
 800cdf6:	4f23      	ldr	r7, [pc, #140]	; (800ce84 <doConversion+0x1a4>)
 800cdf8:	1e5a      	subs	r2, r3, #1
 800cdfa:	2a01      	cmp	r2, #1
 800cdfc:	d921      	bls.n	800ce42 <doConversion+0x162>
 800cdfe:	482e      	ldr	r0, [pc, #184]	; (800ceb8 <doConversion+0x1d8>)
 800ce00:	f7fe feb6 	bl	800bb70 <chSysHalt>
  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
 800ce04:	4623      	mov	r3, r4
 800ce06:	4a2d      	ldr	r2, [pc, #180]	; (800cebc <doConversion+0x1dc>)
 800ce08:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800ce0a:	2106      	movs	r1, #6
 800ce0c:	f7fd fa38 	bl	800a280 <dmaStreamAllocate>
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
 800ce10:	b9a0      	cbnz	r0, 800ce3c <doConversion+0x15c>
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800ce12:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800ce14:	4a2a      	ldr	r2, [pc, #168]	; (800cec0 <doConversion+0x1e0>)
 800ce16:	681b      	ldr	r3, [r3, #0]
      rccEnableADC1(FALSE);
 800ce18:	4e2a      	ldr	r6, [pc, #168]	; (800cec4 <doConversion+0x1e4>)
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 800ce1a:	609a      	str	r2, [r3, #8]
      rccEnableADC1(FALSE);
 800ce1c:	6c73      	ldr	r3, [r6, #68]	; 0x44
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800ce1e:	491c      	ldr	r1, [pc, #112]	; (800ce90 <doConversion+0x1b0>)
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800ce20:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
 800ce22:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ce26:	6473      	str	r3, [r6, #68]	; 0x44
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* This is a common register but apparently it requires that at least one
       of the ADCs is clocked in order to allow writing, see bug 3575297.*/
    ADC->CCR = (ADC->CCR & (ADC_CCR_TSVREFE | ADC_CCR_VBATE)) |
 800ce28:	684b      	ldr	r3, [r1, #4]
 800ce2a:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 800ce2e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800ce32:	604b      	str	r3, [r1, #4]
               (STM32_ADC_ADCPRE << 16);

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 800ce34:	6050      	str	r0, [r2, #4]
    adcp->adc->CR2 = 0;
 800ce36:	6090      	str	r0, [r2, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 800ce38:	6095      	str	r5, [r2, #8]
 800ce3a:	e763      	b.n	800cd04 <doConversion+0x24>
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
                            STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
 800ce3c:	4822      	ldr	r0, [pc, #136]	; (800cec8 <doConversion+0x1e8>)
 800ce3e:	f7fe fe97 	bl	800bb70 <chSysHalt>
 * @notapi
 */
void adc_lld_stop(ADCDriver *adcp) {

  /* If in ready state then disables the ADC clock.*/
  if (adcp->state == ADC_READY) {
 800ce42:	2b02      	cmp	r3, #2
 800ce44:	d012      	beq.n	800ce6c <doConversion+0x18c>
                "invalid state");

  adc_lld_stop(adcp);
  adcp->config = NULL;
 800ce46:	2200      	movs	r2, #0
  adcp->state  = ADC_STOP;
 800ce48:	2301      	movs	r3, #1

  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");

  adc_lld_stop(adcp);
  adcp->config = NULL;
 800ce4a:	6062      	str	r2, [r4, #4]
  adcp->state  = ADC_STOP;
 800ce4c:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800ce4e:	f7ff f987 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800ce52:	682b      	ldr	r3, [r5, #0]
 800ce54:	4a0d      	ldr	r2, [pc, #52]	; (800ce8c <doConversion+0x1ac>)
 800ce56:	42ab      	cmp	r3, r5
 800ce58:	d004      	beq.n	800ce64 <doConversion+0x184>
 800ce5a:	6992      	ldr	r2, [r2, #24]
 800ce5c:	689b      	ldr	r3, [r3, #8]
 800ce5e:	6892      	ldr	r2, [r2, #8]
 800ce60:	429a      	cmp	r2, r3
 800ce62:	d383      	bcc.n	800cd6c <doConversion+0x8c>
 800ce64:	2300      	movs	r3, #0
 800ce66:	f383 8811 	msr	BASEPRI, r3
 800ce6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dmaStreamRelease(adcp->dmastp);
 800ce6c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800ce6e:	f7fd f9c7 	bl	800a200 <dmaStreamRelease>
    adcp->adc->CR1 = 0;
 800ce72:	6abb      	ldr	r3, [r7, #40]	; 0x28
    adcp->adc->CR2 = 0;

#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp)
      rccDisableADC1(FALSE);
 800ce74:	4a13      	ldr	r2, [pc, #76]	; (800cec4 <doConversion+0x1e4>)
void adc_lld_stop(ADCDriver *adcp) {

  /* If in ready state then disables the ADC clock.*/
  if (adcp->state == ADC_READY) {
    dmaStreamRelease(adcp->dmastp);
    adcp->adc->CR1 = 0;
 800ce76:	605e      	str	r6, [r3, #4]
    adcp->adc->CR2 = 0;
 800ce78:	609e      	str	r6, [r3, #8]

#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp)
      rccDisableADC1(FALSE);
 800ce7a:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800ce7c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800ce80:	6453      	str	r3, [r2, #68]	; 0x44
 800ce82:	e7e0      	b.n	800ce46 <doConversion+0x166>
 800ce84:	2001a9e8 	.word	0x2001a9e8
 800ce88:	080105f0 	.word	0x080105f0
 800ce8c:	2001acdc 	.word	0x2001acdc
 800ce90:	40012300 	.word	0x40012300
 800ce94:	40020000 	.word	0x40020000
 800ce98:	40020800 	.word	0x40020800
 800ce9c:	0801060c 	.word	0x0801060c
 800cea0:	080105e4 	.word	0x080105e4
 800cea4:	080106bc 	.word	0x080106bc
 800cea8:	2001b690 	.word	0x2001b690
 800ceac:	40000303 	.word	0x40000303
 800ceb0:	00083ce3 	.word	0x00083ce3
 800ceb4:	04000100 	.word	0x04000100
 800ceb8:	080106e4 	.word	0x080106e4
 800cebc:	08009de1 	.word	0x08009de1
 800cec0:	4001204c 	.word	0x4001204c
 800cec4:	40023800 	.word	0x40023800
 800cec8:	080105fc 	.word	0x080105fc
 800cecc:	00600600 	.word	0x00600600

0800ced0 <getSolarVoltageMV>:

	return vbat;
}

uint16_t getSolarVoltageMV(void)
{
 800ced0:	b508      	push	{r3, lr}
	doConversion();
 800ced2:	f7ff ff05 	bl	800cce0 <doConversion>
	return samples[0] * vcc_ref * DIVIDER_VSOL / 4096;
 800ced6:	4a06      	ldr	r2, [pc, #24]	; (800cef0 <getSolarVoltageMV+0x20>)
 800ced8:	4b06      	ldr	r3, [pc, #24]	; (800cef4 <getSolarVoltageMV+0x24>)
 800ceda:	8810      	ldrh	r0, [r2, #0]
 800cedc:	881a      	ldrh	r2, [r3, #0]
 800cede:	23c8      	movs	r3, #200	; 0xc8
 800cee0:	fb02 f000 	mul.w	r0, r2, r0
 800cee4:	fb03 f000 	mul.w	r0, r3, r0
 800cee8:	1480      	asrs	r0, r0, #18
}
 800ceea:	b280      	uxth	r0, r0
 800ceec:	bd08      	pop	{r3, pc}
 800ceee:	bf00      	nop
 800cef0:	2001b690 	.word	0x2001b690
 800cef4:	20000800 	.word	0x20000800
	...

0800cf00 <getBatteryVoltageMV>:
	chThdSleepMilliseconds(35); // Wait until conversion is finished
	deinitADC();
}

uint16_t getBatteryVoltageMV(void)
{
 800cf00:	b510      	push	{r4, lr}
 800cf02:	b082      	sub	sp, #8
	doConversion();
 800cf04:	f7ff feec 	bl	800cce0 <doConversion>
	uint16_t vbat = samples[2] * vcc_ref * DIVIDER_VBAT / 4096;
 800cf08:	4a13      	ldr	r2, [pc, #76]	; (800cf58 <getBatteryVoltageMV+0x58>)
 800cf0a:	4b14      	ldr	r3, [pc, #80]	; (800cf5c <getBatteryVoltageMV+0x5c>)
 800cf0c:	8894      	ldrh	r4, [r2, #4]
 800cf0e:	881a      	ldrh	r2, [r3, #0]
 800cf10:	23c8      	movs	r3, #200	; 0xc8
 800cf12:	fb02 f404 	mul.w	r4, r2, r4
 800cf16:	fb03 f404 	mul.w	r4, r3, r4
 800cf1a:	14a4      	asrs	r4, r4, #18
 800cf1c:	b2a4      	uxth	r4, r4

	// Get voltage from PAC1720 (PAC1720 returns false redings below 2.35V)
	if(vbat >= 2400)
 800cf1e:	f5b4 6f16 	cmp.w	r4, #2400	; 0x960
 800cf22:	d202      	bcs.n	800cf2a <getBatteryVoltageMV+0x2a>
		if(vbat_pac) // Apply it if valid
			vbat = vbat_pac;
	}

	return vbat;
}
 800cf24:	4620      	mov	r0, r4
 800cf26:	b002      	add	sp, #8
 800cf28:	bd10      	pop	{r4, pc}
	return ret;
}

uint16_t pac1720_getBatteryVoltage(void) {
	uint16_t val;
	if(!I2C_read16(PAC1720_ADDRESS, PAC1720_CH2_VSOURCE_HIGH, &val))
 800cf2a:	f10d 0206 	add.w	r2, sp, #6
 800cf2e:	2113      	movs	r1, #19
 800cf30:	204c      	movs	r0, #76	; 0x4c
 800cf32:	f7ff fbfd 	bl	800c730 <I2C_read16>
 800cf36:	2800      	cmp	r0, #0
 800cf38:	d0f4      	beq.n	800cf24 <getBatteryVoltageMV+0x24>
		return 0; // PAC1720 not available (maybe Vcc too low)

	return (val >> 5) * 20000 / 0x400;
 800cf3a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800cf3e:	f644 6220 	movw	r2, #20000	; 0x4e20
 800cf42:	095b      	lsrs	r3, r3, #5
 800cf44:	fb02 f303 	mul.w	r3, r2, r3
 800cf48:	129b      	asrs	r3, r3, #10
 800cf4a:	b29a      	uxth	r2, r3

	// Get voltage from PAC1720 (PAC1720 returns false redings below 2.35V)
	if(vbat >= 2400)
	{
		uint16_t vbat_pac = pac1720_getBatteryVoltage(); // Get value from PAC1720
		if(vbat_pac) // Apply it if valid
 800cf4c:	2b00      	cmp	r3, #0
 800cf4e:	bf18      	it	ne
 800cf50:	4614      	movne	r4, r2
			vbat = vbat_pac;
	}

	return vbat;
}
 800cf52:	4620      	mov	r0, r4
 800cf54:	b002      	add	sp, #8
 800cf56:	bd10      	pop	{r4, pc}
 800cf58:	2001b690 	.word	0x2001b690
 800cf5c:	20000800 	.word	0x20000800

0800cf60 <I2C_read16_LE.constprop.18>:

bool I2C_read16_LE(uint8_t address, uint8_t reg, uint16_t *val) {
 800cf60:	b510      	push	{r4, lr}
 800cf62:	460c      	mov	r4, r1
	bool ret = I2C_read16_locked(address, reg, val);
 800cf64:	460a      	mov	r2, r1
 800cf66:	4601      	mov	r1, r0
 800cf68:	2077      	movs	r0, #119	; 0x77
 800cf6a:	f7ff fbc9 	bl	800c700 <I2C_read16_locked>
	*val = (*val >> 8) | (*val << 8);
 800cf6e:	8822      	ldrh	r2, [r4, #0]
 800cf70:	0213      	lsls	r3, r2, #8
 800cf72:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
 800cf76:	8023      	strh	r3, [r4, #0]
	return ret;
}
 800cf78:	bd10      	pop	{r4, pc}
 800cf7a:	bf00      	nop
 800cf7c:	0000      	movs	r0, r0
	...

0800cf80 <BME280_getPressure.constprop.19>:
/**
  * Reads the barometric pressure
  * @param Values to be sampled
  * @return Pressure in Pa * 10
  */
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
 800cf80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int64_t var1, var2, p;
	uint16_t tmp;

	uint64_t sum = 0;
 800cf84:	2100      	movs	r1, #0
/**
  * Reads the barometric pressure
  * @param Values to be sampled
  * @return Pressure in Pa * 10
  */
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
 800cf86:	b09f      	sub	sp, #124	; 0x7c
	int64_t var1, var2, p;
	uint16_t tmp;

	uint64_t sum = 0;
 800cf88:	2200      	movs	r2, #0
 800cf8a:	e9cd 1218 	strd	r1, r2, [sp, #96]	; 0x60
/**
  * Reads the barometric pressure
  * @param Values to be sampled
  * @return Pressure in Pa * 10
  */
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
 800cf8e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800cf92:	4682      	mov	sl, r0
 800cf94:	469b      	mov	fp, r3
	uint16_t tmp;

	uint64_t sum = 0;
	for(uint16_t i=0; i<means; i++) {
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
 800cf96:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 800cf9a:	21f7      	movs	r1, #247	; 0xf7
 800cf9c:	f89a 0000 	ldrb.w	r0, [sl]
 800cfa0:	f7ff fbc6 	bl	800c730 <I2C_read16>
		adc_P = tmp;
 800cfa4:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
 800cfa8:	f89a 0000 	ldrb.w	r0, [sl]

	uint64_t sum = 0;
	for(uint16_t i=0; i<means; i++) {
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
 800cfac:	931b      	str	r3, [sp, #108]	; 0x6c
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
 800cfae:	f10d 0276 	add.w	r2, sp, #118	; 0x76
 800cfb2:	21f9      	movs	r1, #249	; 0xf9
 800cfb4:	f7ff fb64 	bl	800c680 <I2C_read8>
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
 800cfb8:	f8da 2004 	ldr.w	r2, [sl, #4]
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800cfbc:	f9ba 4012 	ldrsh.w	r4, [sl, #18]

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800cfc0:	f9ba 0010 	ldrsh.w	r0, [sl, #16]
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
 800cfc4:	f89d e076 	ldrb.w	lr, [sp, #118]	; 0x76
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
 800cfc8:	17d3      	asrs	r3, r2, #31
 800cfca:	f5b2 32fa 	subs.w	r2, r2, #128000	; 0x1f400
 800cfce:	f143 33ff 	adc.w	r3, r3, #4294967295
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800cfd2:	fba2 8902 	umull	r8, r9, r2, r2
 800cfd6:	fb02 f103 	mul.w	r1, r2, r3
 800cfda:	eb09 0941 	add.w	r9, r9, r1, lsl #1
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800cfde:	fb00 f703 	mul.w	r7, r0, r3
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800cfe2:	17e5      	asrs	r5, r4, #31

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800cfe4:	17c1      	asrs	r1, r0, #31
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800cfe6:	fb04 f609 	mul.w	r6, r4, r9

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800cfea:	fb02 7701 	mla	r7, r2, r1, r7
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800cfee:	fb08 6605 	mla	r6, r8, r5, r6

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800cff2:	fba0 0102 	umull	r0, r1, r0, r2
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800cff6:	fba4 4508 	umull	r4, r5, r4, r8
 800cffa:	4435      	add	r5, r6

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800cffc:	4439      	add	r1, r7
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800cffe:	0a26      	lsrs	r6, r4, #8
 800d000:	9604      	str	r6, [sp, #16]

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d002:	030e      	lsls	r6, r1, #12
 800d004:	9601      	str	r6, [sp, #4]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d006:	9e04      	ldr	r6, [sp, #16]
 800d008:	ea46 6605 	orr.w	r6, r6, r5, lsl #24
 800d00c:	9604      	str	r6, [sp, #16]

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d00e:	9e01      	ldr	r6, [sp, #4]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d010:	122c      	asrs	r4, r5, #8

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d012:	ea46 5610 	orr.w	r6, r6, r0, lsr #20
 800d016:	0300      	lsls	r0, r0, #12
 800d018:	9601      	str	r6, [sp, #4]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d01a:	9405      	str	r4, [sp, #20]
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d01c:	f9ba 6016 	ldrsh.w	r6, [sl, #22]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
 800d020:	9000      	str	r0, [sp, #0]
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d022:	e9dd 4500 	ldrd	r4, r5, [sp]
 800d026:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d02a:	17f7      	asrs	r7, r6, #31
 800d02c:	fb06 f303 	mul.w	r3, r6, r3
 800d030:	fb02 3307 	mla	r3, r2, r7, r3
 800d034:	fba6 6702 	umull	r6, r7, r6, r2
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d038:	1900      	adds	r0, r0, r4
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d03a:	441f      	add	r7, r3
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d03c:	4169      	adcs	r1, r5
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d03e:	047a      	lsls	r2, r7, #17
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d040:	1c04      	adds	r4, r0, #0
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d042:	9203      	str	r2, [sp, #12]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d044:	f541 4500 	adc.w	r5, r1, #32768	; 0x8000
 800d048:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d04c:	9803      	ldr	r0, [sp, #12]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d04e:	f8ba 400e 	ldrh.w	r4, [sl, #14]
 800d052:	9916      	ldr	r1, [sp, #88]	; 0x58
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800d054:	f9ba 2018 	ldrsh.w	r2, [sl, #24]
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d058:	ea40 30d6 	orr.w	r0, r0, r6, lsr #15
 800d05c:	9003      	str	r0, [sp, #12]
 800d05e:	0470      	lsls	r0, r6, #17
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d060:	fba1 6704 	umull	r6, r7, r1, r4
 800d064:	9917      	ldr	r1, [sp, #92]	; 0x5c
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d066:	9002      	str	r0, [sp, #8]
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d068:	fb04 7701 	mla	r7, r4, r1, r7
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d06c:	f9ba 0014 	ldrsh.w	r0, [sl, #20]
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
 800d070:	991b      	ldr	r1, [sp, #108]	; 0x6c
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d072:	00c0      	lsls	r0, r0, #3
		int32_t adc_P;
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
 800d074:	ea4e 2e01 	orr.w	lr, lr, r1, lsl #8
		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d078:	17f9      	asrs	r1, r7, #31
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d07a:	9013      	str	r0, [sp, #76]	; 0x4c
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d07c:	9115      	str	r1, [sp, #84]	; 0x54
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d07e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800d082:	17d3      	asrs	r3, r2, #31
 800d084:	fb02 f409 	mul.w	r4, r2, r9
 800d088:	fb08 4403 	mla	r4, r8, r3, r4
 800d08c:	fba2 2308 	umull	r2, r3, r2, r8
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d090:	1880      	adds	r0, r0, r2
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
 800d092:	4423      	add	r3, r4
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d094:	4159      	adcs	r1, r3
 800d096:	460b      	mov	r3, r1
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d098:	2100      	movs	r1, #0
 800d09a:	9112      	str	r1, [sp, #72]	; 0x48
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
 800d09c:	4602      	mov	r2, r0
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d09e:	107d      	asrs	r5, r7, #1
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d0a0:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;
 800d0a4:	9514      	str	r5, [sp, #80]	; 0x50

		if (var1 == 0)
 800d0a6:	e9dd 6714 	ldrd	r6, r7, [sp, #80]	; 0x50
		adc_P >>= 4;

		var1 = ((int64_t)handle->t_fine) - 128000;
		var2 = var1 * var1 * (int64_t)handle->calib.dig_P6;
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
 800d0aa:	1880      	adds	r0, r0, r2
 800d0ac:	4159      	adcs	r1, r3
 800d0ae:	4602      	mov	r2, r0
 800d0b0:	460b      	mov	r3, r1
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;

		if (var1 == 0)
 800d0b2:	4630      	mov	r0, r6
 800d0b4:	4639      	mov	r1, r7
 800d0b6:	4301      	orrs	r1, r0
		I2C_read16(handle->address, BME280_REGISTER_PRESSUREDATA, &tmp);
		adc_P = tmp;
		I2C_read8(handle->address, BME280_REGISTER_PRESSUREDATA+2, (uint8_t*)&tmp);
		adc_P <<= 8;
		adc_P |= tmp & 0xFF;
		adc_P >>= 4;
 800d0b8:	ea4f 1e2e 	mov.w	lr, lr, asr #4
		var2 = var2 + ((var1*(int64_t)handle->calib.dig_P5)<<17);
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;

		if (var1 == 0)
 800d0bc:	f000 8098 	beq.w	800d1f0 <BME280_getPressure.constprop.19+0x270>
			return 0;  // avoid exception caused by division by zero

		p = 1048576 - adc_P;
		p = (((p<<31) - var2)*3125) / var1;
 800d0c0:	f5ce 1e80 	rsb	lr, lr, #1048576	; 0x100000
 800d0c4:	4670      	mov	r0, lr
 800d0c6:	17c1      	asrs	r1, r0, #31
 800d0c8:	07c9      	lsls	r1, r1, #31
 800d0ca:	ea41 015e 	orr.w	r1, r1, lr, lsr #1
 800d0ce:	9107      	str	r1, [sp, #28]
 800d0d0:	ea4f 71ce 	mov.w	r1, lr, lsl #31
 800d0d4:	9106      	str	r1, [sp, #24]
 800d0d6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800d0da:	1a80      	subs	r0, r0, r2
 800d0dc:	4602      	mov	r2, r0
 800d0de:	eb61 0103 	sbc.w	r1, r1, r3
 800d0e2:	1800      	adds	r0, r0, r0
 800d0e4:	460b      	mov	r3, r1
 800d0e6:	4149      	adcs	r1, r1
 800d0e8:	1880      	adds	r0, r0, r2
 800d0ea:	4159      	adcs	r1, r3
 800d0ec:	018c      	lsls	r4, r1, #6
 800d0ee:	ea44 6490 	orr.w	r4, r4, r0, lsr #26
 800d0f2:	9409      	str	r4, [sp, #36]	; 0x24
 800d0f4:	0184      	lsls	r4, r0, #6
 800d0f6:	9408      	str	r4, [sp, #32]
 800d0f8:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 800d0fc:	1824      	adds	r4, r4, r0
 800d0fe:	414d      	adcs	r5, r1
 800d100:	4620      	mov	r0, r4
 800d102:	00ac      	lsls	r4, r5, #2
 800d104:	0085      	lsls	r5, r0, #2
 800d106:	ea44 7490 	orr.w	r4, r4, r0, lsr #30
 800d10a:	18a8      	adds	r0, r5, r2
 800d10c:	eb44 0103 	adc.w	r1, r4, r3
 800d110:	008c      	lsls	r4, r1, #2
 800d112:	0085      	lsls	r5, r0, #2
 800d114:	ea44 7490 	orr.w	r4, r4, r0, lsr #30
 800d118:	18a8      	adds	r0, r5, r2
 800d11a:	eb44 0103 	adc.w	r1, r4, r3
 800d11e:	4632      	mov	r2, r6
 800d120:	463b      	mov	r3, r7
 800d122:	f7f3 ff39 	bl	8000f98 <__aeabi_ldivmod>
		var1 = (((int64_t)handle->calib.dig_P9) * (p>>13) * (p>>13)) >> 25;
		var2 = (((int64_t)handle->calib.dig_P8) * p) >> 19;

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
 800d126:	f9ba 201e 	ldrsh.w	r2, [sl, #30]
		if (var1 == 0)
			return 0;  // avoid exception caused by division by zero

		p = 1048576 - adc_P;
		p = (((p<<31) - var2)*3125) / var1;
		var1 = (((int64_t)handle->calib.dig_P9) * (p>>13) * (p>>13)) >> 25;
 800d12a:	134e      	asrs	r6, r1, #13
 800d12c:	0b47      	lsrs	r7, r0, #13
 800d12e:	ea47 47c1 	orr.w	r7, r7, r1, lsl #19
		var2 = (((int64_t)handle->calib.dig_P8) * p) >> 19;

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
 800d132:	fb02 f406 	mul.w	r4, r2, r6
 800d136:	17d3      	asrs	r3, r2, #31
 800d138:	fb07 4403 	mla	r4, r7, r3, r4
 800d13c:	fba2 2307 	umull	r2, r3, r2, r7
 800d140:	4423      	add	r3, r4
 800d142:	fb02 f606 	mul.w	r6, r2, r6
 800d146:	f9ba 401c 	ldrsh.w	r4, [sl, #28]
 800d14a:	fb07 6603 	mla	r6, r7, r3, r6
 800d14e:	fba2 2307 	umull	r2, r3, r2, r7
 800d152:	4433      	add	r3, r6
 800d154:	fb04 f701 	mul.w	r7, r4, r1
 800d158:	17e5      	asrs	r5, r4, #31
 800d15a:	0e56      	lsrs	r6, r2, #25
 800d15c:	fb00 7705 	mla	r7, r0, r5, r7
 800d160:	ea46 16c3 	orr.w	r6, r6, r3, lsl #7
 800d164:	fba4 4500 	umull	r4, r5, r4, r0
 800d168:	443d      	add	r5, r7
 800d16a:	960a      	str	r6, [sp, #40]	; 0x28
 800d16c:	165b      	asrs	r3, r3, #25
 800d16e:	0ce6      	lsrs	r6, r4, #19
 800d170:	930b      	str	r3, [sp, #44]	; 0x2c
 800d172:	ea46 3345 	orr.w	r3, r6, r5, lsl #13
 800d176:	930c      	str	r3, [sp, #48]	; 0x30
 800d178:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 800d17c:	1812      	adds	r2, r2, r0
 800d17e:	414b      	adcs	r3, r1
 800d180:	4619      	mov	r1, r3
 800d182:	14eb      	asrs	r3, r5, #19
 800d184:	930d      	str	r3, [sp, #52]	; 0x34
 800d186:	e9dd 340c 	ldrd	r3, r4, [sp, #48]	; 0x30
 800d18a:	189b      	adds	r3, r3, r2
 800d18c:	f9ba 201a 	ldrsh.w	r2, [sl, #26]
 800d190:	414c      	adcs	r4, r1
 800d192:	4618      	mov	r0, r3
 800d194:	4621      	mov	r1, r4
 800d196:	17d3      	asrs	r3, r2, #31
 800d198:	0a04      	lsrs	r4, r0, #8
 800d19a:	940e      	str	r4, [sp, #56]	; 0x38
 800d19c:	011c      	lsls	r4, r3, #4
 800d19e:	9411      	str	r4, [sp, #68]	; 0x44
 800d1a0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 800d1a2:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
 800d1a6:	940e      	str	r4, [sp, #56]	; 0x38
 800d1a8:	9c11      	ldr	r4, [sp, #68]	; 0x44
 800d1aa:	1209      	asrs	r1, r1, #8
 800d1ac:	ea44 7412 	orr.w	r4, r4, r2, lsr #28
 800d1b0:	0112      	lsls	r2, r2, #4
 800d1b2:	f10b 33ff 	add.w	r3, fp, #4294967295
 800d1b6:	910f      	str	r1, [sp, #60]	; 0x3c
 800d1b8:	9210      	str	r2, [sp, #64]	; 0x40
 800d1ba:	9411      	str	r4, [sp, #68]	; 0x44
 800d1bc:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 800d1c0:	fa1f fb83 	uxth.w	fp, r3
 800d1c4:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 800d1c8:	1812      	adds	r2, r2, r0
 800d1ca:	414b      	adcs	r3, r1
 800d1cc:	e9dd 0118 	ldrd	r0, r1, [sp, #96]	; 0x60
 800d1d0:	1880      	adds	r0, r0, r2
 800d1d2:	4159      	adcs	r1, r3
 800d1d4:	e9cd 0118 	strd	r0, r1, [sp, #96]	; 0x60
uint32_t BME280_getPressure(bme280_t *handle, uint16_t means) {
	int64_t var1, var2, p;
	uint16_t tmp;

	uint64_t sum = 0;
	for(uint16_t i=0; i<means; i++) {
 800d1d8:	f1bb 0f00 	cmp.w	fp, #0
 800d1dc:	f47f aedb 	bne.w	800cf96 <BME280_getPressure.constprop.19+0x16>
		var2 = (((int64_t)handle->calib.dig_P8) * p) >> 19;

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
	}

	return sum/(means*26);
 800d1e0:	f44f 52d0 	mov.w	r2, #6656	; 0x1a00
 800d1e4:	2300      	movs	r3, #0
 800d1e6:	f7f3 ff27 	bl	8001038 <__aeabi_uldivmod>
}
 800d1ea:	b01f      	add	sp, #124	; 0x7c
 800d1ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		var2 = var2 + (((int64_t)handle->calib.dig_P4)<<35);
		var1 = ((var1 * var1 * (int64_t)handle->calib.dig_P3)>>8) + ((var1 * (int64_t)handle->calib.dig_P2)<<12);
		var1 = (((((int64_t)1)<<47)+var1))*((int64_t)handle->calib.dig_P1)>>33;

		if (var1 == 0)
			return 0;  // avoid exception caused by division by zero
 800d1f0:	9812      	ldr	r0, [sp, #72]	; 0x48

		sum += ((p + var1 + var2) >> 8) + (((int64_t)handle->calib.dig_P7)<<4);
	}

	return sum/(means*26);
}
 800d1f2:	b01f      	add	sp, #124	; 0x7c
 800d1f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0800d200 <BME280_Init.constprop.17>:
}

/**
  * Initializes BME280 and reads calibration data
  */
void BME280_Init(bme280_t *handle, uint8_t address)
 800d200:	b530      	push	{r4, r5, lr}
{
	uint8_t tmp1;
	uint8_t tmp2;

	handle->address = address;
 800d202:	4601      	mov	r1, r0
 800d204:	2577      	movs	r5, #119	; 0x77
}

/**
  * Initializes BME280 and reads calibration data
  */
void BME280_Init(bme280_t *handle, uint8_t address)
 800d206:	b083      	sub	sp, #12
 800d208:	4604      	mov	r4, r0
{
	uint8_t tmp1;
	uint8_t tmp2;

	handle->address = address;
 800d20a:	f801 5b08 	strb.w	r5, [r1], #8

	I2C_read16_LE(address, BME280_REGISTER_DIG_T1, &handle->calib.dig_T1);
 800d20e:	2088      	movs	r0, #136	; 0x88
 800d210:	f7ff fea6 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_T2, &handle->calib.dig_T2);
 800d214:	f104 010a 	add.w	r1, r4, #10
 800d218:	208a      	movs	r0, #138	; 0x8a
 800d21a:	f7ff fea1 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_T3, &handle->calib.dig_T3);
 800d21e:	f104 010c 	add.w	r1, r4, #12
 800d222:	208c      	movs	r0, #140	; 0x8c
 800d224:	f7ff fe9c 	bl	800cf60 <I2C_read16_LE.constprop.18>

	I2C_read16_LE(address, BME280_REGISTER_DIG_P1, &handle->calib.dig_P1);
 800d228:	f104 010e 	add.w	r1, r4, #14
 800d22c:	208e      	movs	r0, #142	; 0x8e
 800d22e:	f7ff fe97 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P2, &handle->calib.dig_P2);
 800d232:	f104 0110 	add.w	r1, r4, #16
 800d236:	2090      	movs	r0, #144	; 0x90
 800d238:	f7ff fe92 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P3, &handle->calib.dig_P3);
 800d23c:	f104 0112 	add.w	r1, r4, #18
 800d240:	2092      	movs	r0, #146	; 0x92
 800d242:	f7ff fe8d 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P4, &handle->calib.dig_P4);
 800d246:	f104 0114 	add.w	r1, r4, #20
 800d24a:	2094      	movs	r0, #148	; 0x94
 800d24c:	f7ff fe88 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P5, &handle->calib.dig_P5);
 800d250:	f104 0116 	add.w	r1, r4, #22
 800d254:	2096      	movs	r0, #150	; 0x96
 800d256:	f7ff fe83 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P6, &handle->calib.dig_P6);
 800d25a:	f104 0118 	add.w	r1, r4, #24
 800d25e:	2098      	movs	r0, #152	; 0x98
 800d260:	f7ff fe7e 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P7, &handle->calib.dig_P7);
 800d264:	f104 011a 	add.w	r1, r4, #26
 800d268:	209a      	movs	r0, #154	; 0x9a
 800d26a:	f7ff fe79 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P8, &handle->calib.dig_P8);
 800d26e:	f104 011c 	add.w	r1, r4, #28
 800d272:	209c      	movs	r0, #156	; 0x9c
 800d274:	f7ff fe74 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_P9, &handle->calib.dig_P9);
 800d278:	f104 011e 	add.w	r1, r4, #30
 800d27c:	209e      	movs	r0, #158	; 0x9e
 800d27e:	f7ff fe6f 	bl	800cf60 <I2C_read16_LE.constprop.18>

	I2C_read8(address, BME280_REGISTER_DIG_H1, &handle->calib.dig_H1);
 800d282:	f104 0220 	add.w	r2, r4, #32
 800d286:	4628      	mov	r0, r5
 800d288:	21a1      	movs	r1, #161	; 0xa1
 800d28a:	f7ff f9f9 	bl	800c680 <I2C_read8>
	I2C_readS16_LE(address, BME280_REGISTER_DIG_H2, &handle->calib.dig_H2);
 800d28e:	f104 0122 	add.w	r1, r4, #34	; 0x22
 800d292:	20e1      	movs	r0, #225	; 0xe1
 800d294:	f7ff fe64 	bl	800cf60 <I2C_read16_LE.constprop.18>
	I2C_read8(address, BME280_REGISTER_DIG_H3, &handle->calib.dig_H3);
 800d298:	f104 0224 	add.w	r2, r4, #36	; 0x24
 800d29c:	4628      	mov	r0, r5
 800d29e:	21e3      	movs	r1, #227	; 0xe3
 800d2a0:	f7ff f9ee 	bl	800c680 <I2C_read8>

	I2C_read8(address, BME280_REGISTER_DIG_H4, &tmp1);
 800d2a4:	f10d 0206 	add.w	r2, sp, #6
 800d2a8:	4628      	mov	r0, r5
 800d2aa:	21e4      	movs	r1, #228	; 0xe4
 800d2ac:	f7ff f9e8 	bl	800c680 <I2C_read8>
	I2C_read8(address, BME280_REGISTER_DIG_H5, &tmp2);
 800d2b0:	f10d 0207 	add.w	r2, sp, #7
 800d2b4:	4628      	mov	r0, r5
 800d2b6:	21e5      	movs	r1, #229	; 0xe5
 800d2b8:	f7ff f9e2 	bl	800c680 <I2C_read8>
	handle->calib.dig_H4 = (((int8_t)tmp1) << 4) | (tmp2 & 0x0F);
 800d2bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d2c0:	f99d 2006 	ldrsb.w	r2, [sp, #6]
 800d2c4:	f003 030f 	and.w	r3, r3, #15
 800d2c8:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800d2cc:	84e3      	strh	r3, [r4, #38]	; 0x26

	I2C_read8(address, BME280_REGISTER_DIG_H6, &tmp1);
 800d2ce:	f10d 0206 	add.w	r2, sp, #6
 800d2d2:	4628      	mov	r0, r5
 800d2d4:	21e7      	movs	r1, #231	; 0xe7
 800d2d6:	f7ff f9d3 	bl	800c680 <I2C_read8>
	I2C_read8(address, BME280_REGISTER_DIG_H5, &tmp2);
 800d2da:	f10d 0207 	add.w	r2, sp, #7
 800d2de:	4628      	mov	r0, r5
 800d2e0:	21e5      	movs	r1, #229	; 0xe5
 800d2e2:	f7ff f9cd 	bl	800c680 <I2C_read8>
	handle->calib.dig_H5 = (((int8_t)tmp1) << 4) | (tmp2 >> 4 & 0x0F);
 800d2e6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800d2ea:	f99d 2006 	ldrsb.w	r2, [sp, #6]
 800d2ee:	091b      	lsrs	r3, r3, #4
 800d2f0:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800d2f4:	8523      	strh	r3, [r4, #40]	; 0x28

	I2C_read8(address, BME280_REGISTER_DIG_H6, (uint8_t*)&handle->calib.dig_H6);
 800d2f6:	f104 022a 	add.w	r2, r4, #42	; 0x2a
 800d2fa:	4628      	mov	r0, r5
 800d2fc:	21e7      	movs	r1, #231	; 0xe7
 800d2fe:	f7ff f9bf 	bl	800c680 <I2C_read8>

	I2C_write8(address, BME280_REGISTER_CONTROLHUMID, 0x03); // Set before CONTROL (DS 5.4.3)
 800d302:	4628      	mov	r0, r5
 800d304:	2203      	movs	r2, #3
 800d306:	21f2      	movs	r1, #242	; 0xf2
 800d308:	f7ff f9da 	bl	800c6c0 <I2C_write8>
	I2C_write8(address, BME280_REGISTER_CONTROL, 0x3F);
 800d30c:	223f      	movs	r2, #63	; 0x3f
 800d30e:	21f4      	movs	r1, #244	; 0xf4
 800d310:	4628      	mov	r0, r5
 800d312:	f7ff f9d5 	bl	800c6c0 <I2C_write8>
	chThdSleepMilliseconds(50); // Wait for BME280
 800d316:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800d31a:	f7ff f811 	bl	800c340 <chThdSleep>

	BME280_getTemperature(handle); // Set t_fine
 800d31e:	4620      	mov	r0, r4
 800d320:	f7fb f89e 	bl	8008460 <BME280_getTemperature>
}
 800d324:	b003      	add	sp, #12
 800d326:	bd30      	pop	{r4, r5, pc}
	...

0800d330 <gps_receive_ack.constprop.14>:
 * waits for transmission of an ACK/NAK message from the GPS.
 *
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
 800d330:	b5f0      	push	{r4, r5, r6, r7, lr}
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
 800d332:	4b23      	ldr	r3, [pc, #140]	; (800d3c0 <gps_receive_ack.constprop.14+0x90>)
 * waits for transmission of an ACK/NAK message from the GPS.
 *
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
 800d334:	b085      	sub	sp, #20
 800d336:	4604      	mov	r4, r0
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
 800d338:	6859      	ldr	r1, [r3, #4]
 800d33a:	6818      	ldr	r0, [r3, #0]
 800d33c:	466a      	mov	r2, sp
 800d33e:	c203      	stmia	r2!, {r0, r1}
	uint8_t nak[] = {0xB5, 0x62, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00};
 800d340:	f853 0f08 	ldr.w	r0, [r3, #8]!
	ack[6] = class_id;
	nak[6] = class_id;
	ack[7] = msg_id;
 800d344:	f88d 4007 	strb.w	r4, [sp, #7]
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
	uint8_t nak[] = {0xB5, 0x62, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00};
 800d348:	6859      	ldr	r1, [r3, #4]
 800d34a:	4613      	mov	r3, r2
 800d34c:	c303      	stmia	r3!, {r0, r1}
 800d34e:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
	ack[6] = class_id;
 800d352:	2306      	movs	r3, #6
	nak[6] = class_id;
	ack[7] = msg_id;
	nak[7] = msg_id;
 800d354:	f88d 400f 	strb.w	r4, [sp, #15]
	int match_count = 0;
	int msg_ack = 0;
	uint8_t rx_byte;
	uint8_t ack[] = {0xB5, 0x62, 0x05, 0x01, 0x02, 0x00, 0x00, 0x00};
	uint8_t nak[] = {0xB5, 0x62, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00};
	ack[6] = class_id;
 800d358:	f88d 3006 	strb.w	r3, [sp, #6]
	nak[6] = class_id;
 800d35c:	f88d 300e 	strb.w	r3, [sp, #14]
 800d360:	6a75      	ldr	r5, [r6, #36]	; 0x24
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
	int match_count = 0;
	int msg_ack = 0;
 800d362:	2700      	movs	r7, #0
	nak[6] = class_id;
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
 800d364:	f505 551c 	add.w	r5, r5, #9984	; 0x2700
 800d368:	3510      	adds	r5, #16
 *
 * returns 1 if ACK was received, 0 if NAK was received
 *
 */
uint8_t gps_receive_ack(uint8_t class_id, uint8_t msg_id, uint16_t timeout) {
	int match_count = 0;
 800d36a:	463c      	mov	r4, r7
 800d36c:	6a73      	ldr	r3, [r6, #36]	; 0x24
	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 800d36e:	4815      	ldr	r0, [pc, #84]	; (800d3c4 <gps_receive_ack.constprop.14+0x94>)
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d370:	429d      	cmp	r5, r3
 800d372:	d314      	bcc.n	800d39e <gps_receive_ack.constprop.14+0x6e>
 800d374:	6a71      	ldr	r1, [r6, #36]	; 0x24

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 800d376:	1a69      	subs	r1, r5, r1
 800d378:	f7fc f86a 	bl	8009450 <iqGetTimeout>

		// Process one byte
		if (rx_byte == ack[match_count] || rx_byte == nak[match_count]) {
 800d37c:	ab04      	add	r3, sp, #16
 800d37e:	4423      	add	r3, r4
	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 800d380:	b2c0      	uxtb	r0, r0

		// Process one byte
		if (rx_byte == ack[match_count] || rx_byte == nak[match_count]) {
 800d382:	f813 2c10 	ldrb.w	r2, [r3, #-16]
 800d386:	4290      	cmp	r0, r2
 800d388:	d00c      	beq.n	800d3a4 <gps_receive_ack.constprop.14+0x74>
 800d38a:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 800d38e:	4283      	cmp	r3, r0
 800d390:	d008      	beq.n	800d3a4 <gps_receive_ack.constprop.14+0x74>
 800d392:	6a73      	ldr	r3, [r6, #36]	; 0x24
	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {

		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());
 800d394:	480b      	ldr	r0, [pc, #44]	; (800d3c4 <gps_receive_ack.constprop.14+0x94>)
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d396:	429d      	cmp	r5, r3
			if (match_count == 7) { 
				return msg_ack;
			}
			match_count++;
		} else {
			match_count = 0;
 800d398:	f04f 0400 	mov.w	r4, #0
	ack[7] = msg_id;
	nak[7] = msg_id;

	// runs until ACK/NAK packet is received
	systime_t sTimeout = chVTGetSystemTimeX() + MS2ST(timeout);
	while(chVTGetSystemTimeX() <= sTimeout) {
 800d39c:	d2ea      	bcs.n	800d374 <gps_receive_ack.constprop.14+0x44>
			match_count = 0;
		}

	}

	return false;
 800d39e:	2000      	movs	r0, #0
}
 800d3a0:	b005      	add	sp, #20
 800d3a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		// Receive one byte
		rx_byte = sdGetTimeout(&SD5, sTimeout - chVTGetSystemTimeX());

		// Process one byte
		if (rx_byte == ack[match_count] || rx_byte == nak[match_count]) {
			if (match_count == 3) {	/* test ACK/NAK byte */
 800d3a4:	2c03      	cmp	r4, #3
 800d3a6:	d003      	beq.n	800d3b0 <gps_receive_ack.constprop.14+0x80>
					msg_ack = 1;
				} else {
					msg_ack = 0;
				}
			}
			if (match_count == 7) { 
 800d3a8:	2c07      	cmp	r4, #7
 800d3aa:	d006      	beq.n	800d3ba <gps_receive_ack.constprop.14+0x8a>
				return msg_ack;
			}
			match_count++;
 800d3ac:	3401      	adds	r4, #1
 800d3ae:	e7dd      	b.n	800d36c <gps_receive_ack.constprop.14+0x3c>
		if (rx_byte == ack[match_count] || rx_byte == nak[match_count]) {
			if (match_count == 3) {	/* test ACK/NAK byte */
				if (rx_byte == ack[match_count]) {
					msg_ack = 1;
				} else {
					msg_ack = 0;
 800d3b0:	1a87      	subs	r7, r0, r2
 800d3b2:	fab7 f787 	clz	r7, r7
 800d3b6:	097f      	lsrs	r7, r7, #5
 800d3b8:	e7f8      	b.n	800d3ac <gps_receive_ack.constprop.14+0x7c>
				}
			}
			if (match_count == 7) { 
				return msg_ack;
 800d3ba:	b2f8      	uxtb	r0, r7
		}

	}

	return false;
}
 800d3bc:	b005      	add	sp, #20
 800d3be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d3c0:	0800e82c 	.word	0x0800e82c
 800d3c4:	2001b6b0 	.word	0x2001b6b0
	...

0800d3d0 <radioTune.constprop.10>:
 * Tunes the radio and activates transmission.
 * @param frequency Transmission frequency in Hz
 * @param shift Shift of FSK in Hz
 * @param level Transmission power level in dBm
 */
bool radioTune(uint32_t frequency, uint16_t shift, int8_t level, uint16_t size) {
 800d3d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d3d4:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
 800d3d8:	b08b      	sub	sp, #44	; 0x2c
 800d3da:	4683      	mov	fp, r0
	// Tracing
	TRACE_INFO("SI   > Tune Si4464");
 800d3dc:	48c6      	ldr	r0, [pc, #792]	; (800d6f8 <radioTune.constprop.10+0x328>)
 800d3de:	4ec7      	ldr	r6, [pc, #796]	; (800d6fc <radioTune.constprop.10+0x32c>)
 800d3e0:	f8df 9370 	ldr.w	r9, [pc, #880]	; 800d754 <radioTune.constprop.10+0x384>
 * Tunes the radio and activates transmission.
 * @param frequency Transmission frequency in Hz
 * @param shift Shift of FSK in Hz
 * @param level Transmission power level in dBm
 */
bool radioTune(uint32_t frequency, uint16_t shift, int8_t level, uint16_t size) {
 800d3e4:	460f      	mov	r7, r1
 800d3e6:	4692      	mov	sl, r2
	// Tracing
	TRACE_INFO("SI   > Tune Si4464");
 800d3e8:	f7fe feda 	bl	800c1a0 <chMtxLock>
 800d3ec:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800d3f0:	f8d8 4024 	ldr.w	r4, [r8, #36]	; 0x24
 800d3f4:	49c2      	ldr	r1, [pc, #776]	; (800d700 <radioTune.constprop.10+0x330>)
 800d3f6:	48c3      	ldr	r0, [pc, #780]	; (800d704 <radioTune.constprop.10+0x334>)
 800d3f8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800d3fc:	fb05 f404 	mul.w	r4, r5, r4
 800d400:	fba6 3404 	umull	r3, r4, r6, r4
 800d404:	0b64      	lsrs	r4, r4, #13
 800d406:	fba9 e304 	umull	lr, r3, r9, r4
 800d40a:	fba6 e202 	umull	lr, r2, r6, r2
 800d40e:	099b      	lsrs	r3, r3, #6
 800d410:	fb05 4313 	mls	r3, r5, r3, r4
 800d414:	0b52      	lsrs	r2, r2, #13
 800d416:	f7fd f93b 	bl	800a690 <chprintf.constprop.26>
 800d41a:	4abb      	ldr	r2, [pc, #748]	; (800d708 <radioTune.constprop.10+0x338>)
 800d41c:	49bb      	ldr	r1, [pc, #748]	; (800d70c <radioTune.constprop.10+0x33c>)
 800d41e:	48b9      	ldr	r0, [pc, #740]	; (800d704 <radioTune.constprop.10+0x334>)
 800d420:	f7fd f936 	bl	800a690 <chprintf.constprop.26>
 800d424:	f44f 73a0 	mov.w	r3, #320	; 0x140
 800d428:	4ab9      	ldr	r2, [pc, #740]	; (800d710 <radioTune.constprop.10+0x340>)
 800d42a:	49ba      	ldr	r1, [pc, #744]	; (800d714 <radioTune.constprop.10+0x344>)
 800d42c:	48b5      	ldr	r0, [pc, #724]	; (800d704 <radioTune.constprop.10+0x334>)
 800d42e:	f7fd f92f 	bl	800a690 <chprintf.constprop.26>
 800d432:	49b9      	ldr	r1, [pc, #740]	; (800d718 <radioTune.constprop.10+0x348>)
 800d434:	48b3      	ldr	r0, [pc, #716]	; (800d704 <radioTune.constprop.10+0x334>)
 800d436:	f7fd f92b 	bl	800a690 <chprintf.constprop.26>
 800d43a:	49b8      	ldr	r1, [pc, #736]	; (800d71c <radioTune.constprop.10+0x34c>)
 800d43c:	48b1      	ldr	r0, [pc, #708]	; (800d704 <radioTune.constprop.10+0x334>)
 800d43e:	f7fd f927 	bl	800a690 <chprintf.constprop.26>
 800d442:	49b7      	ldr	r1, [pc, #732]	; (800d720 <radioTune.constprop.10+0x350>)
 800d444:	48af      	ldr	r0, [pc, #700]	; (800d704 <radioTune.constprop.10+0x334>)
 800d446:	f7fd f923 	bl	800a690 <chprintf.constprop.26>
 800d44a:	48ab      	ldr	r0, [pc, #684]	; (800d6f8 <radioTune.constprop.10+0x328>)
 800d44c:	f7fc f898 	bl	8009580 <chMtxUnlock>

	if(!RADIO_WITHIN_FREQ_RANGE(frequency)) {
 800d450:	4bb4      	ldr	r3, [pc, #720]	; (800d724 <radioTune.constprop.10+0x354>)
 800d452:	4ab5      	ldr	r2, [pc, #724]	; (800d728 <radioTune.constprop.10+0x358>)
 800d454:	445b      	add	r3, fp
 800d456:	4293      	cmp	r3, r2
 800d458:	f200 80d1 	bhi.w	800d5fe <radioTune.constprop.10+0x22e>
}

void setFrequency(uint32_t freq, uint16_t shift) {
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
 800d45c:	4bb3      	ldr	r3, [pc, #716]	; (800d72c <radioTune.constprop.10+0x35c>)
 800d45e:	459b      	cmp	fp, r3
 800d460:	d816      	bhi.n	800d490 <radioTune.constprop.10+0xc0>
	if(freq < 525000000UL) {outdiv = 8;  band = 2;};
 800d462:	4bb3      	ldr	r3, [pc, #716]	; (800d730 <radioTune.constprop.10+0x360>)
 800d464:	459b      	cmp	fp, r3
 800d466:	f200 81ac 	bhi.w	800d7c2 <radioTune.constprop.10+0x3f2>
	if(freq < 353000000UL) {outdiv = 12; band = 3;};
 800d46a:	4bb2      	ldr	r3, [pc, #712]	; (800d734 <radioTune.constprop.10+0x364>)
 800d46c:	459b      	cmp	fp, r3
 800d46e:	f200 81af 	bhi.w	800d7d0 <radioTune.constprop.10+0x400>
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
 800d472:	4bb1      	ldr	r3, [pc, #708]	; (800d738 <radioTune.constprop.10+0x368>)
 800d474:	459b      	cmp	fp, r3
 800d476:	f200 81b2 	bhi.w	800d7de <radioTune.constprop.10+0x40e>
	if(freq < 177000000UL) {outdiv = 24; band = 5;};
 800d47a:	4bb0      	ldr	r3, [pc, #704]	; (800d73c <radioTune.constprop.10+0x36c>)
 800d47c:	f8df 82d8 	ldr.w	r8, [pc, #728]	; 800d758 <radioTune.constprop.10+0x388>
 800d480:	459b      	cmp	fp, r3
 800d482:	f200 8199 	bhi.w	800d7b8 <radioTune.constprop.10+0x3e8>
 800d486:	2318      	movs	r3, #24
 800d488:	f8c8 3000 	str.w	r3, [r8]
 800d48c:	230d      	movs	r3, #13
 800d48e:	e002      	b.n	800d496 <radioTune.constprop.10+0xc6>
 800d490:	f8df 82c4 	ldr.w	r8, [pc, #708]	; 800d758 <radioTune.constprop.10+0x388>
}

void setFrequency(uint32_t freq, uint16_t shift) {
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
 800d494:	2308      	movs	r3, #8
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
	if(freq < 177000000UL) {outdiv = 24; band = 5;};

	// Set the band parameter
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
 800d496:	2251      	movs	r2, #81	; 0x51
	Si4464_write(set_band_property_command, 5);
 800d498:	2105      	movs	r1, #5
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
	if(freq < 177000000UL) {outdiv = 24; band = 5;};

	// Set the band parameter
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
 800d49a:	2611      	movs	r6, #17
 800d49c:	f04f 0920 	mov.w	r9, #32
 800d4a0:	2401      	movs	r4, #1
	Si4464_write(set_band_property_command, 5);
 800d4a2:	a803      	add	r0, sp, #12
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
	if(freq < 177000000UL) {outdiv = 24; band = 5;};

	// Set the band parameter
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
 800d4a4:	f88d 200f 	strb.w	r2, [sp, #15]
 800d4a8:	f88d 3010 	strb.w	r3, [sp, #16]
 800d4ac:	f88d 400e 	strb.w	r4, [sp, #14]
 800d4b0:	f88d 600c 	strb.w	r6, [sp, #12]
 800d4b4:	f88d 900d 	strb.w	r9, [sp, #13]
	Si4464_write(set_band_property_command, 5);
 800d4b8:	f7fb f87a 	bl	80085b0 <Si4464_write>
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
 800d4bc:	4658      	mov	r0, fp
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
 800d4be:	f8d8 5000 	ldr.w	r5, [r8]
 800d4c2:	4b9f      	ldr	r3, [pc, #636]	; (800d740 <radioTune.constprop.10+0x370>)
 800d4c4:	fbb3 f3f5 	udiv	r3, r3, r5
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
 800d4c8:	fbbb f4f3 	udiv	r4, fp, r3
 800d4cc:	9301      	str	r3, [sp, #4]
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
 800d4ce:	f7f3 fb9b 	bl	8000c08 <__aeabi_ui2f>
 800d4d2:	9b01      	ldr	r3, [sp, #4]
 800d4d4:	4683      	mov	fp, r0
 800d4d6:	4618      	mov	r0, r3
 800d4d8:	f7f3 fb96 	bl	8000c08 <__aeabi_ui2f>
 800d4dc:	4601      	mov	r1, r0
 800d4de:	4658      	mov	r0, fp
 800d4e0:	f7f3 fc9e 	bl	8000e20 <__aeabi_fdiv>
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
 800d4e4:	3c01      	subs	r4, #1
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
 800d4e6:	4683      	mov	fp, r0
 800d4e8:	4620      	mov	r0, r4
 800d4ea:	f7f3 fb8d 	bl	8000c08 <__aeabi_ui2f>
 800d4ee:	4601      	mov	r1, r0
 800d4f0:	4658      	mov	r0, fp
 800d4f2:	f7f3 fad7 	bl	8000aa4 <__aeabi_fsub>
 800d4f6:	f04f 4192 	mov.w	r1, #1224736768	; 0x49000000
 800d4fa:	f7f3 fbdd 	bl	8000cb8 <__aeabi_fmul>
 800d4fe:	f7f3 fd2b 	bl	8000f58 <__aeabi_f2uiz>

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800d502:	04ed      	lsls	r5, r5, #19
 800d504:	4b8f      	ldr	r3, [pc, #572]	; (800d744 <radioTune.constprop.10+0x374>)
 800d506:	f88d 4020 	strb.w	r4, [sp, #32]
 800d50a:	fb07 f505 	mul.w	r5, r7, r5
 800d50e:	fba3 3505 	umull	r3, r5, r3, r5
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
	uint32_t m2 = m >> 16;
	uint32_t m1 = (m - m2 * 0x10000) >> 8;
 800d512:	b283      	uxth	r3, r0
 800d514:	0a1a      	lsrs	r2, r3, #8

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800d516:	2140      	movs	r1, #64	; 0x40
	uint32_t n = ((uint32_t)(freq / f_pfd)) - 1;
	float ratio = (float)freq / (float)f_pfd;
	float rest  = ratio - (float)n;

	uint32_t m = (uint32_t)(rest * 524288UL);
	uint32_t m2 = m >> 16;
 800d518:	0c04      	lsrs	r4, r0, #16

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800d51a:	0e6d      	lsrs	r5, r5, #25
	Si4464_write(set_frequency_property_command, 10);
 800d51c:	a807      	add	r0, sp, #28

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800d51e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 800d522:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
 800d526:	2300      	movs	r3, #0
 800d528:	2204      	movs	r2, #4
 800d52a:	f88d 101d 	strb.w	r1, [sp, #29]
	Si4464_write(set_frequency_property_command, 10);
 800d52e:	210a      	movs	r1, #10

	uint32_t channel_increment = 524288 * outdiv * shift / (2 * OSC_FREQ);
	uint8_t c1 = channel_increment / 0x100;
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
 800d530:	f88d 201e 	strb.w	r2, [sp, #30]
 800d534:	f88d 301f 	strb.w	r3, [sp, #31]
 800d538:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 800d53c:	f88d 5025 	strb.w	r5, [sp, #37]	; 0x25
 800d540:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
 800d544:	f88d 601c 	strb.w	r6, [sp, #28]
	Si4464_write(set_frequency_property_command, 10);
 800d548:	f7fb f832 	bl	80085b0 <Si4464_write>

	uint32_t x = ((((uint32_t)1 << 19) * outdiv * 1300.0)/(2*OSC_FREQ))*2;
 800d54c:	f8d8 0000 	ldr.w	r0, [r8]
	uint32_t sy_sel = 8;
	uint8_t set_band_property_command[] = {0x11, 0x20, 0x01, 0x51, (band + sy_sel)};
	Si4464_write(set_band_property_command, 5);

	// Set the PLL parameters
	uint32_t f_pfd = 2 * OSC_FREQ / outdiv;
 800d550:	f8df b204 	ldr.w	fp, [pc, #516]	; 800d758 <radioTune.constprop.10+0x388>
	uint8_t c0 = channel_increment - (0x100 * c1);

	uint8_t set_frequency_property_command[] = {0x11, 0x40, 0x04, 0x00, n, m2, m1, m0, c1, c0};
	Si4464_write(set_frequency_property_command, 10);

	uint32_t x = ((((uint32_t)1 << 19) * outdiv * 1300.0)/(2*OSC_FREQ))*2;
 800d554:	04c0      	lsls	r0, r0, #19
 800d556:	f7f2 fff9 	bl	800054c <__aeabi_ui2d>
 800d55a:	a363      	add	r3, pc, #396	; (adr r3, 800d6e8 <radioTune.constprop.10+0x318>)
 800d55c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d560:	f7f3 f86a 	bl	8000638 <__aeabi_dmul>
 800d564:	a362      	add	r3, pc, #392	; (adr r3, 800d6f0 <radioTune.constprop.10+0x320>)
 800d566:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d56a:	f7f3 f98f 	bl	800088c <__aeabi_ddiv>
 800d56e:	4602      	mov	r2, r0
 800d570:	460b      	mov	r3, r1
 800d572:	f7f2 feaf 	bl	80002d4 <__adddf3>
 800d576:	f7f3 fa71 	bl	8000a5c <__aeabi_d2uiz>
	uint8_t x2 = (x >> 16) & 0xFF;
	uint8_t x1 = (x >>  8) & 0xFF;
	uint8_t x0 = (x >>  0) & 0xFF;
	uint8_t set_deviation[] = {0x11, 0x20, 0x03, 0x0a, x2, x1, x0};
 800d57a:	2503      	movs	r5, #3
 800d57c:	0c02      	lsrs	r2, r0, #16
 800d57e:	0a03      	lsrs	r3, r0, #8
 800d580:	240a      	movs	r4, #10
 800d582:	f88d 001a 	strb.w	r0, [sp, #26]
	Si4464_write(set_deviation, 7);
 800d586:	2107      	movs	r1, #7
 800d588:	a805      	add	r0, sp, #20

	uint32_t x = ((((uint32_t)1 << 19) * outdiv * 1300.0)/(2*OSC_FREQ))*2;
	uint8_t x2 = (x >> 16) & 0xFF;
	uint8_t x1 = (x >>  8) & 0xFF;
	uint8_t x0 = (x >>  0) & 0xFF;
	uint8_t set_deviation[] = {0x11, 0x20, 0x03, 0x0a, x2, x1, x0};
 800d58a:	f88d 6014 	strb.w	r6, [sp, #20]
 800d58e:	f88d 9015 	strb.w	r9, [sp, #21]
 800d592:	f88d 2018 	strb.w	r2, [sp, #24]
 800d596:	f88d 3019 	strb.w	r3, [sp, #25]
 800d59a:	f88d 5016 	strb.w	r5, [sp, #22]
 800d59e:	f88d 4017 	strb.w	r4, [sp, #23]
	Si4464_write(set_deviation, 7);
 800d5a2:	f7fb f805 	bl	80085b0 <Si4464_write>
}

void setShift(uint16_t shift) {
	if(!shift)
 800d5a6:	2f00      	cmp	r7, #0
 800d5a8:	f040 80d8 	bne.w	800d75c <radioTune.constprop.10+0x38c>
	Si4464_write(use_2gfsk, 5);
}

void setPowerLevel(int8_t level) {
	// Set the Power
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
 800d5ac:	2211      	movs	r2, #17
 800d5ae:	2322      	movs	r3, #34	; 0x22
 800d5b0:	2401      	movs	r4, #1
 800d5b2:	4650      	mov	r0, sl
 800d5b4:	f88d 201c 	strb.w	r2, [sp, #28]
 800d5b8:	f88d 301d 	strb.w	r3, [sp, #29]
 800d5bc:	f88d 401e 	strb.w	r4, [sp, #30]
 800d5c0:	f88d 401f 	strb.w	r4, [sp, #31]
 800d5c4:	f7fa ff84 	bl	80084d0 <dBm2powerLvl>
	Si4464_write(set_pa_pwr_lvl_property_command, 5);
 800d5c8:	2105      	movs	r1, #5
	Si4464_write(use_2gfsk, 5);
}

void setPowerLevel(int8_t level) {
	// Set the Power
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
 800d5ca:	f88d 0020 	strb.w	r0, [sp, #32]
	Si4464_write(set_pa_pwr_lvl_property_command, 5);
 800d5ce:	a807      	add	r0, sp, #28
 800d5d0:	f7fa ffee 	bl	80085b0 <Si4464_write>
}

void startTx(uint16_t size) {
	uint8_t change_state_command[] = {0x31, 0x00, 0x30, (size >> 8) & 0x1F, size & 0xFF};
 800d5d4:	2531      	movs	r5, #49	; 0x31
 800d5d6:	2300      	movs	r3, #0
	Si4464_write(change_state_command, 5);
 800d5d8:	a807      	add	r0, sp, #28
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
	Si4464_write(set_pa_pwr_lvl_property_command, 5);
}

void startTx(uint16_t size) {
	uint8_t change_state_command[] = {0x31, 0x00, 0x30, (size >> 8) & 0x1F, size & 0xFF};
 800d5da:	2230      	movs	r2, #48	; 0x30
	Si4464_write(change_state_command, 5);
 800d5dc:	2105      	movs	r1, #5
	uint8_t set_pa_pwr_lvl_property_command[] = {0x11, 0x22, 0x01, 0x01, dBm2powerLvl(level)};
	Si4464_write(set_pa_pwr_lvl_property_command, 5);
}

void startTx(uint16_t size) {
	uint8_t change_state_command[] = {0x31, 0x00, 0x30, (size >> 8) & 0x1F, size & 0xFF};
 800d5de:	f88d 501c 	strb.w	r5, [sp, #28]
 800d5e2:	f88d 301d 	strb.w	r3, [sp, #29]
 800d5e6:	f88d 301f 	strb.w	r3, [sp, #31]
 800d5ea:	f88d 3020 	strb.w	r3, [sp, #32]
 800d5ee:	f88d 201e 	strb.w	r2, [sp, #30]
	Si4464_write(change_state_command, 5);
 800d5f2:	f7fa ffdd 	bl	80085b0 <Si4464_write>
	setFrequency(frequency, shift);	// Set frequency
	setShift(shift);					// Set shift
	setPowerLevel(level);			// Set power level

	startTx(size);
	return true;
 800d5f6:	4620      	mov	r0, r4
}
 800d5f8:	b00b      	add	sp, #44	; 0x2c
 800d5fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
bool radioTune(uint32_t frequency, uint16_t shift, int8_t level, uint16_t size) {
	// Tracing
	TRACE_INFO("SI   > Tune Si4464");

	if(!RADIO_WITHIN_FREQ_RANGE(frequency)) {
		TRACE_ERROR("SI   > Frequency out of range");
 800d5fe:	483e      	ldr	r0, [pc, #248]	; (800d6f8 <radioTune.constprop.10+0x328>)
 800d600:	f7fe fdce 	bl	800c1a0 <chMtxLock>
 800d604:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800d608:	f8d8 4024 	ldr.w	r4, [r8, #36]	; 0x24
 800d60c:	493c      	ldr	r1, [pc, #240]	; (800d700 <radioTune.constprop.10+0x330>)
 800d60e:	483d      	ldr	r0, [pc, #244]	; (800d704 <radioTune.constprop.10+0x334>)
 800d610:	fb05 f404 	mul.w	r4, r5, r4
 800d614:	fba6 3404 	umull	r3, r4, r6, r4
 800d618:	0b64      	lsrs	r4, r4, #13
 800d61a:	fba9 7304 	umull	r7, r3, r9, r4
 800d61e:	fba6 7202 	umull	r7, r2, r6, r2
 800d622:	099b      	lsrs	r3, r3, #6
 800d624:	fb05 4313 	mls	r3, r5, r3, r4
 800d628:	0b52      	lsrs	r2, r2, #13
 800d62a:	f7fd f831 	bl	800a690 <chprintf.constprop.26>
 800d62e:	4a46      	ldr	r2, [pc, #280]	; (800d748 <radioTune.constprop.10+0x378>)
 800d630:	4936      	ldr	r1, [pc, #216]	; (800d70c <radioTune.constprop.10+0x33c>)
 800d632:	4834      	ldr	r0, [pc, #208]	; (800d704 <radioTune.constprop.10+0x334>)
 800d634:	f7fd f82c 	bl	800a690 <chprintf.constprop.26>
 800d638:	f240 1343 	movw	r3, #323	; 0x143
 800d63c:	4a34      	ldr	r2, [pc, #208]	; (800d710 <radioTune.constprop.10+0x340>)
 800d63e:	4935      	ldr	r1, [pc, #212]	; (800d714 <radioTune.constprop.10+0x344>)
 800d640:	4830      	ldr	r0, [pc, #192]	; (800d704 <radioTune.constprop.10+0x334>)
 800d642:	f7fd f825 	bl	800a690 <chprintf.constprop.26>
 800d646:	4934      	ldr	r1, [pc, #208]	; (800d718 <radioTune.constprop.10+0x348>)
 800d648:	482e      	ldr	r0, [pc, #184]	; (800d704 <radioTune.constprop.10+0x334>)
 800d64a:	f7fd f821 	bl	800a690 <chprintf.constprop.26>
 800d64e:	493f      	ldr	r1, [pc, #252]	; (800d74c <radioTune.constprop.10+0x37c>)
 800d650:	482c      	ldr	r0, [pc, #176]	; (800d704 <radioTune.constprop.10+0x334>)
 800d652:	f7fd f81d 	bl	800a690 <chprintf.constprop.26>
 800d656:	4932      	ldr	r1, [pc, #200]	; (800d720 <radioTune.constprop.10+0x350>)
 800d658:	482a      	ldr	r0, [pc, #168]	; (800d704 <radioTune.constprop.10+0x334>)
 800d65a:	f7fd f819 	bl	800a690 <chprintf.constprop.26>
 800d65e:	4826      	ldr	r0, [pc, #152]	; (800d6f8 <radioTune.constprop.10+0x328>)
 800d660:	f7fb ff8e 	bl	8009580 <chMtxUnlock>
 800d664:	f240 1143 	movw	r1, #323	; 0x143
 800d668:	4829      	ldr	r0, [pc, #164]	; (800d710 <radioTune.constprop.10+0x340>)
 800d66a:	f7ff f989 	bl	800c980 <log_error>
		TRACE_ERROR("SI   > abort transmission");
 800d66e:	4822      	ldr	r0, [pc, #136]	; (800d6f8 <radioTune.constprop.10+0x328>)
 800d670:	f7fe fd96 	bl	800c1a0 <chMtxLock>
 800d674:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 800d678:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 800d67c:	4920      	ldr	r1, [pc, #128]	; (800d700 <radioTune.constprop.10+0x330>)
 800d67e:	4821      	ldr	r0, [pc, #132]	; (800d704 <radioTune.constprop.10+0x334>)
 800d680:	fb05 f303 	mul.w	r3, r5, r3
 800d684:	fba6 4303 	umull	r4, r3, r6, r3
 800d688:	0b5b      	lsrs	r3, r3, #13
 800d68a:	fba9 4903 	umull	r4, r9, r9, r3
 800d68e:	ea4f 1999 	mov.w	r9, r9, lsr #6
 800d692:	fba6 4202 	umull	r4, r2, r6, r2
 800d696:	fb05 3319 	mls	r3, r5, r9, r3
 800d69a:	0b52      	lsrs	r2, r2, #13
 800d69c:	f7fc fff8 	bl	800a690 <chprintf.constprop.26>
 800d6a0:	4a29      	ldr	r2, [pc, #164]	; (800d748 <radioTune.constprop.10+0x378>)
 800d6a2:	491a      	ldr	r1, [pc, #104]	; (800d70c <radioTune.constprop.10+0x33c>)
 800d6a4:	4817      	ldr	r0, [pc, #92]	; (800d704 <radioTune.constprop.10+0x334>)
 800d6a6:	f7fc fff3 	bl	800a690 <chprintf.constprop.26>
 800d6aa:	f44f 73a2 	mov.w	r3, #324	; 0x144
 800d6ae:	4a18      	ldr	r2, [pc, #96]	; (800d710 <radioTune.constprop.10+0x340>)
 800d6b0:	4918      	ldr	r1, [pc, #96]	; (800d714 <radioTune.constprop.10+0x344>)
 800d6b2:	4814      	ldr	r0, [pc, #80]	; (800d704 <radioTune.constprop.10+0x334>)
 800d6b4:	f7fc ffec 	bl	800a690 <chprintf.constprop.26>
 800d6b8:	4917      	ldr	r1, [pc, #92]	; (800d718 <radioTune.constprop.10+0x348>)
 800d6ba:	4812      	ldr	r0, [pc, #72]	; (800d704 <radioTune.constprop.10+0x334>)
 800d6bc:	f7fc ffe8 	bl	800a690 <chprintf.constprop.26>
 800d6c0:	4923      	ldr	r1, [pc, #140]	; (800d750 <radioTune.constprop.10+0x380>)
 800d6c2:	4810      	ldr	r0, [pc, #64]	; (800d704 <radioTune.constprop.10+0x334>)
 800d6c4:	f7fc ffe4 	bl	800a690 <chprintf.constprop.26>
 800d6c8:	4915      	ldr	r1, [pc, #84]	; (800d720 <radioTune.constprop.10+0x350>)
 800d6ca:	480e      	ldr	r0, [pc, #56]	; (800d704 <radioTune.constprop.10+0x334>)
 800d6cc:	f7fc ffe0 	bl	800a690 <chprintf.constprop.26>
 800d6d0:	4809      	ldr	r0, [pc, #36]	; (800d6f8 <radioTune.constprop.10+0x328>)
 800d6d2:	f7fb ff55 	bl	8009580 <chMtxUnlock>
 800d6d6:	f44f 71a2 	mov.w	r1, #324	; 0x144
 800d6da:	480d      	ldr	r0, [pc, #52]	; (800d710 <radioTune.constprop.10+0x340>)
 800d6dc:	f7ff f950 	bl	800c980 <log_error>
		return false;
 800d6e0:	2000      	movs	r0, #0
	setShift(shift);					// Set shift
	setPowerLevel(level);			// Set power level

	startTx(size);
	return true;
}
 800d6e2:	b00b      	add	sp, #44	; 0x2c
 800d6e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d6e8:	00000000 	.word	0x00000000
 800d6ec:	40945000 	.word	0x40945000
 800d6f0:	40000000 	.word	0x40000000
 800d6f4:	4188cbc7 	.word	0x4188cbc7
 800d6f8:	2001b720 	.word	0x2001b720
 800d6fc:	d1b71759 	.word	0xd1b71759
 800d700:	0800ea50 	.word	0x0800ea50
 800d704:	2001ac28 	.word	0x2001ac28
 800d708:	0800f1dc 	.word	0x0800f1dc
 800d70c:	0800ea64 	.word	0x0800ea64
 800d710:	0800fe2c 	.word	0x0800fe2c
 800d714:	0800ea7c 	.word	0x0800ea7c
 800d718:	0800f1e0 	.word	0x0800f1e0
 800d71c:	08010700 	.word	0x08010700
 800d720:	0800eaa8 	.word	0x0800eaa8
 800d724:	f8e83440 	.word	0xf8e83440
 800d728:	377deec0 	.word	0x377deec0
 800d72c:	2a05723f 	.word	0x2a05723f
 800d730:	1f4add3f 	.word	0x1f4add3f
 800d734:	150a5a3f 	.word	0x150a5a3f
 800d738:	0e3ed9bf 	.word	0x0e3ed9bf
 800d73c:	0a8cce3f 	.word	0x0a8cce3f
 800d740:	031978e8 	.word	0x031978e8
 800d744:	a5301875 	.word	0xa5301875
 800d748:	0800ea5c 	.word	0x0800ea5c
 800d74c:	08010714 	.word	0x08010714
 800d750:	08010734 	.word	0x08010734
 800d754:	10624dd3 	.word	0x10624dd3
 800d758:	2001b6a0 	.word	0x2001b6a0
		return;

	float units_per_hz = (( 0x40000 * outdiv ) / (float)OSC_FREQ);

	// Set deviation for 2FSK
	uint32_t modem_freq_dev = (uint32_t)(units_per_hz * shift / 2.0 );
 800d75c:	f8db 0000 	ldr.w	r0, [fp]
 800d760:	0480      	lsls	r0, r0, #18
 800d762:	f7f3 fa51 	bl	8000c08 <__aeabi_ui2f>
 800d766:	4921      	ldr	r1, [pc, #132]	; (800d7ec <radioTune.constprop.10+0x41c>)
 800d768:	f7f3 fb5a 	bl	8000e20 <__aeabi_fdiv>
 800d76c:	4680      	mov	r8, r0
 800d76e:	4638      	mov	r0, r7
 800d770:	f7f3 fa4e 	bl	8000c10 <__aeabi_i2f>
 800d774:	4601      	mov	r1, r0
 800d776:	4640      	mov	r0, r8
 800d778:	f7f3 fa9e 	bl	8000cb8 <__aeabi_fmul>
 800d77c:	f7f2 ff08 	bl	8000590 <__aeabi_f2d>
 800d780:	2200      	movs	r2, #0
 800d782:	4b1b      	ldr	r3, [pc, #108]	; (800d7f0 <radioTune.constprop.10+0x420>)
 800d784:	f7f2 ff58 	bl	8000638 <__aeabi_dmul>
 800d788:	f7f3 f968 	bl	8000a5c <__aeabi_d2uiz>
	uint8_t modem_freq_dev_0 = 0xFF & modem_freq_dev;
	uint8_t modem_freq_dev_1 = 0xFF & (modem_freq_dev >> 8);
	uint8_t modem_freq_dev_2 = 0xFF & (modem_freq_dev >> 16);

	uint8_t set_modem_freq_dev_command[] = {0x11, 0x20, 0x03, 0x0A, modem_freq_dev_2, modem_freq_dev_1, modem_freq_dev_0};
	Si4464_write(set_modem_freq_dev_command, 7);
 800d78c:	2107      	movs	r1, #7
		return;

	float units_per_hz = (( 0x40000 * outdiv ) / (float)OSC_FREQ);

	// Set deviation for 2FSK
	uint32_t modem_freq_dev = (uint32_t)(units_per_hz * shift / 2.0 );
 800d78e:	4603      	mov	r3, r0
	uint8_t modem_freq_dev_0 = 0xFF & modem_freq_dev;
	uint8_t modem_freq_dev_1 = 0xFF & (modem_freq_dev >> 8);
	uint8_t modem_freq_dev_2 = 0xFF & (modem_freq_dev >> 16);

	uint8_t set_modem_freq_dev_command[] = {0x11, 0x20, 0x03, 0x0A, modem_freq_dev_2, modem_freq_dev_1, modem_freq_dev_0};
 800d790:	0c07      	lsrs	r7, r0, #16
 800d792:	0a02      	lsrs	r2, r0, #8
	Si4464_write(set_modem_freq_dev_command, 7);
 800d794:	a807      	add	r0, sp, #28
	uint32_t modem_freq_dev = (uint32_t)(units_per_hz * shift / 2.0 );
	uint8_t modem_freq_dev_0 = 0xFF & modem_freq_dev;
	uint8_t modem_freq_dev_1 = 0xFF & (modem_freq_dev >> 8);
	uint8_t modem_freq_dev_2 = 0xFF & (modem_freq_dev >> 16);

	uint8_t set_modem_freq_dev_command[] = {0x11, 0x20, 0x03, 0x0A, modem_freq_dev_2, modem_freq_dev_1, modem_freq_dev_0};
 800d796:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
 800d79a:	f88d 601c 	strb.w	r6, [sp, #28]
 800d79e:	f88d 901d 	strb.w	r9, [sp, #29]
 800d7a2:	f88d 501e 	strb.w	r5, [sp, #30]
 800d7a6:	f88d 401f 	strb.w	r4, [sp, #31]
 800d7aa:	f88d 7020 	strb.w	r7, [sp, #32]
 800d7ae:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
	Si4464_write(set_modem_freq_dev_command, 7);
 800d7b2:	f7fa fefd 	bl	80085b0 <Si4464_write>
 800d7b6:	e6f9      	b.n	800d5ac <radioTune.constprop.10+0x1dc>
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
	if(freq < 525000000UL) {outdiv = 8;  band = 2;};
	if(freq < 353000000UL) {outdiv = 12; band = 3;};
	if(freq < 239000000UL) {outdiv = 16; band = 4;};
 800d7b8:	2310      	movs	r3, #16
 800d7ba:	f8c8 3000 	str.w	r3, [r8]
 800d7be:	230c      	movs	r3, #12
 800d7c0:	e669      	b.n	800d496 <radioTune.constprop.10+0xc6>
}

void setFrequency(uint32_t freq, uint16_t shift) {
	// Set the output divider according to recommended ranges given in Si4464 datasheet
	uint32_t band = 0;
	if(freq < 705000000UL) {outdiv = 6;  band = 1;};
 800d7c2:	f8df 8030 	ldr.w	r8, [pc, #48]	; 800d7f4 <radioTune.constprop.10+0x424>
 800d7c6:	2306      	movs	r3, #6
 800d7c8:	f8c8 3000 	str.w	r3, [r8]
 800d7cc:	2309      	movs	r3, #9
 800d7ce:	e662      	b.n	800d496 <radioTune.constprop.10+0xc6>
	if(freq < 525000000UL) {outdiv = 8;  band = 2;};
 800d7d0:	f8df 8020 	ldr.w	r8, [pc, #32]	; 800d7f4 <radioTune.constprop.10+0x424>
 800d7d4:	2308      	movs	r3, #8
 800d7d6:	f8c8 3000 	str.w	r3, [r8]
 800d7da:	230a      	movs	r3, #10
 800d7dc:	e65b      	b.n	800d496 <radioTune.constprop.10+0xc6>
	if(freq < 353000000UL) {outdiv = 12; band = 3;};
 800d7de:	f8df 8014 	ldr.w	r8, [pc, #20]	; 800d7f4 <radioTune.constprop.10+0x424>
 800d7e2:	230c      	movs	r3, #12
 800d7e4:	f8c8 3000 	str.w	r3, [r8]
 800d7e8:	230b      	movs	r3, #11
 800d7ea:	e654      	b.n	800d496 <radioTune.constprop.10+0xc6>
 800d7ec:	4bc65e3a 	.word	0x4bc65e3a
 800d7f0:	3fe00000 	.word	0x3fe00000
 800d7f4:	2001b6a0 	.word	0x2001b6a0
	...

0800d800 <i2cSendDriver.constprop.20>:
	STD_DUTY_CYCLE,
};

mutex_t pi2c_mtx;

bool i2cSendDriver(I2CDriver *driver, uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout) {
 800d800:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	i2cAcquireBus(driver);
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800d804:	b284      	uxth	r4, r0
	STD_DUTY_CYCLE,
};

mutex_t pi2c_mtx;

bool i2cSendDriver(I2CDriver *driver, uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout) {
 800d806:	4605      	mov	r5, r0
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800d808:	48a2      	ldr	r0, [pc, #648]	; (800da94 <i2cSendDriver.constprop.20+0x294>)
 800d80a:	460f      	mov	r7, r1
 800d80c:	4616      	mov	r6, r2
 800d80e:	4698      	mov	r8, r3
 800d810:	f7fe fcc6 	bl	800c1a0 <chMtxLock>
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 800d814:	2c00      	cmp	r4, #0
 800d816:	d069      	beq.n	800d8ec <i2cSendDriver.constprop.20+0xec>
 800d818:	2e00      	cmp	r6, #0
 800d81a:	d067      	beq.n	800d8ec <i2cSendDriver.constprop.20+0xec>
 800d81c:	2f00      	cmp	r7, #0
 800d81e:	d065      	beq.n	800d8ec <i2cSendDriver.constprop.20+0xec>
 800d820:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d822:	2b00      	cmp	r3, #0
 800d824:	d15f      	bne.n	800d8e6 <i2cSendDriver.constprop.20+0xe6>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 800d826:	f8df 927c 	ldr.w	r9, [pc, #636]	; 800daa4 <i2cSendDriver.constprop.20+0x2a4>
 800d82a:	f899 3000 	ldrb.w	r3, [r9]
 800d82e:	2b02      	cmp	r3, #2
 800d830:	d15c      	bne.n	800d8ec <i2cSendDriver.constprop.20+0xec>
 800d832:	2320      	movs	r3, #32
 800d834:	f383 8811 	msr	BASEPRI, r3
 800d838:	f8df a264 	ldr.w	sl, [pc, #612]	; 800daa0 <i2cSendDriver.constprop.20+0x2a0>
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800d83c:	f7fe fca0 	bl	800c180 <_dbg_check_lock>

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 800d840:	0064      	lsls	r4, r4, #1

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 800d842:	2303      	movs	r3, #3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800d844:	2200      	movs	r2, #0
  i2cp->state = I2C_ACTIVE_TX;
 800d846:	f889 3000 	strb.w	r3, [r9]
 800d84a:	f8a9 4020 	strh.w	r4, [r9, #32]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800d84e:	f8c9 2008 	str.w	r2, [r9, #8]
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 800d852:	f8d9 b034 	ldr.w	fp, [r9, #52]	; 0x34
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800d856:	f7fe fc83 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800d85a:	f8da 3000 	ldr.w	r3, [sl]
 800d85e:	4553      	cmp	r3, sl
 800d860:	d005      	beq.n	800d86e <i2cSendDriver.constprop.20+0x6e>
 800d862:	f8da 2018 	ldr.w	r2, [sl, #24]
 800d866:	689b      	ldr	r3, [r3, #8]
 800d868:	6892      	ldr	r2, [r2, #8]
 800d86a:	429a      	cmp	r2, r3
 800d86c:	d341      	bcc.n	800d8f2 <i2cSendDriver.constprop.20+0xf2>
 800d86e:	2300      	movs	r3, #0
 800d870:	f383 8811 	msr	BASEPRI, r3

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800d874:	f8d9 2030 	ldr.w	r2, [r9, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800d878:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800d87c:	6812      	ldr	r2, [r2, #0]
 800d87e:	f8d9 1028 	ldr.w	r1, [r9, #40]	; 0x28
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800d882:	681b      	ldr	r3, [r3, #0]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800d884:	6011      	str	r1, [r2, #0]
 800d886:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800d88a:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 800d88e:	60d7      	str	r7, [r2, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 800d890:	6056      	str	r6, [r2, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800d892:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800d894:	6019      	str	r1, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 800d896:	f8c3 800c 	str.w	r8, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800d89a:	605a      	str	r2, [r3, #4]
 800d89c:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800d89e:	f8df 8200 	ldr.w	r8, [pc, #512]	; 800daa0 <i2cSendDriver.constprop.20+0x2a0>
 800d8a2:	2620      	movs	r6, #32
 800d8a4:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800d8a8:	f7fe fc6a 	bl	800c180 <_dbg_check_lock>
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 800d8ac:	f8db 3018 	ldr.w	r3, [fp, #24]
 800d8b0:	079a      	lsls	r2, r3, #30
 800d8b2:	d403      	bmi.n	800d8bc <i2cSendDriver.constprop.20+0xbc>
 800d8b4:	f8db 3000 	ldr.w	r3, [fp]
 800d8b8:	059b      	lsls	r3, r3, #22
 800d8ba:	d53d      	bpl.n	800d938 <i2cSendDriver.constprop.20+0x138>
 800d8bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 800d8be:	1bdb      	subs	r3, r3, r7
 800d8c0:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 800d8c4:	d218      	bcs.n	800d8f8 <i2cSendDriver.constprop.20+0xf8>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800d8c6:	f7fe fc4b 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800d8ca:	f8da 3000 	ldr.w	r3, [sl]
 800d8ce:	4553      	cmp	r3, sl
 800d8d0:	d005      	beq.n	800d8de <i2cSendDriver.constprop.20+0xde>
 800d8d2:	f8d8 2018 	ldr.w	r2, [r8, #24]
 800d8d6:	689b      	ldr	r3, [r3, #8]
 800d8d8:	6892      	ldr	r2, [r2, #8]
 800d8da:	429a      	cmp	r2, r3
 800d8dc:	d309      	bcc.n	800d8f2 <i2cSendDriver.constprop.20+0xf2>
 800d8de:	2300      	movs	r3, #0
 800d8e0:	f383 8811 	msr	BASEPRI, r3
 800d8e4:	e7de      	b.n	800d8a4 <i2cSendDriver.constprop.20+0xa4>
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 800d8e6:	f1b8 0f00 	cmp.w	r8, #0
 800d8ea:	d19c      	bne.n	800d826 <i2cSendDriver.constprop.20+0x26>
 800d8ec:	486a      	ldr	r0, [pc, #424]	; (800da98 <i2cSendDriver.constprop.20+0x298>)
 800d8ee:	f7fe f93f 	bl	800bb70 <chSysHalt>
 800d8f2:	486a      	ldr	r0, [pc, #424]	; (800da9c <i2cSendDriver.constprop.20+0x29c>)
 800d8f4:	f7fe f93c 	bl	800bb70 <chSysHalt>
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 800d8f8:	2305      	movs	r3, #5
 800d8fa:	f889 3000 	strb.w	r3, [r9]
 800d8fe:	f04f 34ff 	mov.w	r4, #4294967295
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800d902:	f7fe fc2d 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800d906:	f8da 3000 	ldr.w	r3, [sl]
 800d90a:	4a65      	ldr	r2, [pc, #404]	; (800daa0 <i2cSendDriver.constprop.20+0x2a0>)
 800d90c:	4553      	cmp	r3, sl
 800d90e:	d004      	beq.n	800d91a <i2cSendDriver.constprop.20+0x11a>
 800d910:	6992      	ldr	r2, [r2, #24]
 800d912:	689b      	ldr	r3, [r3, #8]
 800d914:	6892      	ldr	r2, [r2, #8]
 800d916:	429a      	cmp	r2, r3
 800d918:	d322      	bcc.n	800d960 <i2cSendDriver.constprop.20+0x160>
 800d91a:	2300      	movs	r3, #0
 800d91c:	f383 8811 	msr	BASEPRI, r3
	i2cAcquireBus(driver);
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
	if(i2c_status == MSG_TIMEOUT) { // Restart I2C at timeout
 800d920:	1c60      	adds	r0, r4, #1
 800d922:	d070      	beq.n	800da06 <i2cSendDriver.constprop.20+0x206>
		TRACE_ERROR("I2C  > TIMEOUT > RESTART (ADDR 0x%02x)", addr);
		i2cStop(driver);
		i2cStart(driver, &_i2cfg);
	} else if(i2c_status == MSG_RESET && addr != 0x4C) { // Prevent PAC1720 to produce message while it doesnt work below 2.5V
 800d924:	1ca3      	adds	r3, r4, #2
 800d926:	d01e      	beq.n	800d966 <i2cSendDriver.constprop.20+0x166>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800d928:	485a      	ldr	r0, [pc, #360]	; (800da94 <i2cSendDriver.constprop.20+0x294>)
 800d92a:	f7fb fe29 	bl	8009580 <chMtxUnlock>
		TRACE_ERROR("I2C  > RESET (ADDR 0x%02x)", addr);
	}
	i2cReleaseBus(driver);
	return i2c_status == MSG_OK;
}
 800d92e:	fab4 f084 	clz	r0, r4
 800d932:	0940      	lsrs	r0, r0, #5
 800d934:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800d938:	f8db 3004 	ldr.w	r3, [fp, #4]
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 800d93c:	f8d9 201c 	ldr.w	r2, [r9, #28]
 800d940:	4e58      	ldr	r6, [pc, #352]	; (800daa4 <i2cSendDriver.constprop.20+0x2a4>)
 800d942:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800d946:	f8cb 3004 	str.w	r3, [fp, #4]
  dp->CR1 |= I2C_CR1_START;
 800d94a:	f8db 3000 	ldr.w	r3, [fp]
 800d94e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800d952:	f8cb 3000 	str.w	r3, [fp]
 800d956:	2a00      	cmp	r2, #0
 800d958:	d043      	beq.n	800d9e2 <i2cSendDriver.constprop.20+0x1e2>
 800d95a:	4853      	ldr	r0, [pc, #332]	; (800daa8 <i2cSendDriver.constprop.20+0x2a8>)
 800d95c:	f7fe f908 	bl	800bb70 <chSysHalt>
 800d960:	4852      	ldr	r0, [pc, #328]	; (800daac <i2cSendDriver.constprop.20+0x2ac>)
 800d962:	f7fe f905 	bl	800bb70 <chSysHalt>
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
	if(i2c_status == MSG_TIMEOUT) { // Restart I2C at timeout
		TRACE_ERROR("I2C  > TIMEOUT > RESTART (ADDR 0x%02x)", addr);
		i2cStop(driver);
		i2cStart(driver, &_i2cfg);
	} else if(i2c_status == MSG_RESET && addr != 0x4C) { // Prevent PAC1720 to produce message while it doesnt work below 2.5V
 800d966:	2d4c      	cmp	r5, #76	; 0x4c
 800d968:	d0de      	beq.n	800d928 <i2cSendDriver.constprop.20+0x128>
		TRACE_ERROR("I2C  > RESET (ADDR 0x%02x)", addr);
 800d96a:	4851      	ldr	r0, [pc, #324]	; (800dab0 <i2cSendDriver.constprop.20+0x2b0>)
 800d96c:	4f51      	ldr	r7, [pc, #324]	; (800dab4 <i2cSendDriver.constprop.20+0x2b4>)
 800d96e:	f7fe fc17 	bl	800c1a0 <chMtxLock>
 800d972:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800d976:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 800d97a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800d97c:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800d97e:	4b4e      	ldr	r3, [pc, #312]	; (800dab8 <i2cSendDriver.constprop.20+0x2b8>)
 800d980:	494e      	ldr	r1, [pc, #312]	; (800dabc <i2cSendDriver.constprop.20+0x2bc>)
 800d982:	fb06 f000 	mul.w	r0, r6, r0
 800d986:	fba7 e000 	umull	lr, r0, r7, r0
 800d98a:	0b40      	lsrs	r0, r0, #13
 800d98c:	fba3 e300 	umull	lr, r3, r3, r0
 800d990:	fba7 7202 	umull	r7, r2, r7, r2
 800d994:	099b      	lsrs	r3, r3, #6
 800d996:	fb06 0313 	mls	r3, r6, r3, r0
 800d99a:	0b52      	lsrs	r2, r2, #13
 800d99c:	4848      	ldr	r0, [pc, #288]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800d99e:	f7fc fe77 	bl	800a690 <chprintf.constprop.26>
 800d9a2:	4a48      	ldr	r2, [pc, #288]	; (800dac4 <i2cSendDriver.constprop.20+0x2c4>)
 800d9a4:	4948      	ldr	r1, [pc, #288]	; (800dac8 <i2cSendDriver.constprop.20+0x2c8>)
 800d9a6:	4846      	ldr	r0, [pc, #280]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800d9a8:	f7fc fe72 	bl	800a690 <chprintf.constprop.26>
 800d9ac:	2319      	movs	r3, #25
 800d9ae:	4a47      	ldr	r2, [pc, #284]	; (800dacc <i2cSendDriver.constprop.20+0x2cc>)
 800d9b0:	4947      	ldr	r1, [pc, #284]	; (800dad0 <i2cSendDriver.constprop.20+0x2d0>)
 800d9b2:	4843      	ldr	r0, [pc, #268]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800d9b4:	f7fc fe6c 	bl	800a690 <chprintf.constprop.26>
 800d9b8:	4946      	ldr	r1, [pc, #280]	; (800dad4 <i2cSendDriver.constprop.20+0x2d4>)
 800d9ba:	4841      	ldr	r0, [pc, #260]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800d9bc:	f7fc fe68 	bl	800a690 <chprintf.constprop.26>
 800d9c0:	462a      	mov	r2, r5
 800d9c2:	4945      	ldr	r1, [pc, #276]	; (800dad8 <i2cSendDriver.constprop.20+0x2d8>)
 800d9c4:	483e      	ldr	r0, [pc, #248]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800d9c6:	f7fc fe63 	bl	800a690 <chprintf.constprop.26>
 800d9ca:	4944      	ldr	r1, [pc, #272]	; (800dadc <i2cSendDriver.constprop.20+0x2dc>)
 800d9cc:	483c      	ldr	r0, [pc, #240]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800d9ce:	f7fc fe5f 	bl	800a690 <chprintf.constprop.26>
 800d9d2:	4837      	ldr	r0, [pc, #220]	; (800dab0 <i2cSendDriver.constprop.20+0x2b0>)
 800d9d4:	f7fb fdd4 	bl	8009580 <chMtxUnlock>
 800d9d8:	2119      	movs	r1, #25
 800d9da:	483c      	ldr	r0, [pc, #240]	; (800dacc <i2cSendDriver.constprop.20+0x2cc>)
 800d9dc:	f7fe ffd0 	bl	800c980 <log_error>
 800d9e0:	e7a2      	b.n	800d928 <i2cSendDriver.constprop.20+0x128>

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 800d9e2:	4633      	mov	r3, r6
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800d9e4:	f8da 2018 	ldr.w	r2, [sl, #24]
 800d9e8:	f843 2f1c 	str.w	r2, [r3, #28]!
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800d9ec:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 800d9f0:	6253      	str	r3, [r2, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800d9f2:	2003      	movs	r0, #3
 800d9f4:	f7fe fad4 	bl	800bfa0 <chSchGoSleepTimeoutS>
  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 800d9f8:	1c47      	adds	r7, r0, #1
 800d9fa:	4604      	mov	r4, r0
 800d9fc:	f43f af7c 	beq.w	800d8f8 <i2cSendDriver.constprop.20+0xf8>
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 800da00:	2302      	movs	r3, #2
 800da02:	7033      	strb	r3, [r6, #0]
 800da04:	e77d      	b.n	800d902 <i2cSendDriver.constprop.20+0x102>

bool i2cSendDriver(I2CDriver *driver, uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout) {
	i2cAcquireBus(driver);
	msg_t i2c_status = i2cMasterTransmitTimeout(driver, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
	if(i2c_status == MSG_TIMEOUT) { // Restart I2C at timeout
		TRACE_ERROR("I2C  > TIMEOUT > RESTART (ADDR 0x%02x)", addr);
 800da06:	482a      	ldr	r0, [pc, #168]	; (800dab0 <i2cSendDriver.constprop.20+0x2b0>)
 800da08:	f7fe fbca 	bl	800c1a0 <chMtxLock>
 800da0c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800da10:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800da14:	6a4f      	ldr	r7, [r1, #36]	; 0x24
 800da16:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 800da18:	4829      	ldr	r0, [pc, #164]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800da1a:	4928      	ldr	r1, [pc, #160]	; (800dabc <i2cSendDriver.constprop.20+0x2bc>)
 800da1c:	fb03 f606 	mul.w	r6, r3, r6
 800da20:	f242 7210 	movw	r2, #10000	; 0x2710
 800da24:	fbb6 f6f2 	udiv	r6, r6, r2
 800da28:	fbb7 f2f2 	udiv	r2, r7, r2
 800da2c:	fbb6 f7f3 	udiv	r7, r6, r3
 800da30:	fb03 6317 	mls	r3, r3, r7, r6
 800da34:	f7fc fe2c 	bl	800a690 <chprintf.constprop.26>
 800da38:	4a22      	ldr	r2, [pc, #136]	; (800dac4 <i2cSendDriver.constprop.20+0x2c4>)
 800da3a:	4923      	ldr	r1, [pc, #140]	; (800dac8 <i2cSendDriver.constprop.20+0x2c8>)
 800da3c:	4820      	ldr	r0, [pc, #128]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800da3e:	f7fc fe27 	bl	800a690 <chprintf.constprop.26>
 800da42:	2315      	movs	r3, #21
 800da44:	4a21      	ldr	r2, [pc, #132]	; (800dacc <i2cSendDriver.constprop.20+0x2cc>)
 800da46:	4922      	ldr	r1, [pc, #136]	; (800dad0 <i2cSendDriver.constprop.20+0x2d0>)
 800da48:	481d      	ldr	r0, [pc, #116]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800da4a:	f7fc fe21 	bl	800a690 <chprintf.constprop.26>
 800da4e:	4921      	ldr	r1, [pc, #132]	; (800dad4 <i2cSendDriver.constprop.20+0x2d4>)
 800da50:	481b      	ldr	r0, [pc, #108]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800da52:	f7fc fe1d 	bl	800a690 <chprintf.constprop.26>
 800da56:	462a      	mov	r2, r5
 800da58:	4921      	ldr	r1, [pc, #132]	; (800dae0 <i2cSendDriver.constprop.20+0x2e0>)
 800da5a:	4819      	ldr	r0, [pc, #100]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800da5c:	f7fc fe18 	bl	800a690 <chprintf.constprop.26>
 800da60:	491e      	ldr	r1, [pc, #120]	; (800dadc <i2cSendDriver.constprop.20+0x2dc>)
 800da62:	4817      	ldr	r0, [pc, #92]	; (800dac0 <i2cSendDriver.constprop.20+0x2c0>)
 800da64:	f7fc fe14 	bl	800a690 <chprintf.constprop.26>
 800da68:	4811      	ldr	r0, [pc, #68]	; (800dab0 <i2cSendDriver.constprop.20+0x2b0>)
 800da6a:	f7fb fd89 	bl	8009580 <chMtxUnlock>
 800da6e:	2115      	movs	r1, #21
 800da70:	4816      	ldr	r0, [pc, #88]	; (800dacc <i2cSendDriver.constprop.20+0x2cc>)
 800da72:	f7fe ff85 	bl	800c980 <log_error>
 800da76:	2320      	movs	r3, #32
 800da78:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800da7c:	f7fe fb80 	bl	800c180 <_dbg_check_lock>

  osalDbgCheck(i2cp != NULL);

  osalSysLock();

  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 800da80:	f899 3000 	ldrb.w	r3, [r9]
 800da84:	1e5a      	subs	r2, r3, #1
 800da86:	2a01      	cmp	r2, #1
 800da88:	d92e      	bls.n	800dae8 <i2cSendDriver.constprop.20+0x2e8>
 800da8a:	2b05      	cmp	r3, #5
 800da8c:	d02e      	beq.n	800daec <i2cSendDriver.constprop.20+0x2ec>
 800da8e:	4815      	ldr	r0, [pc, #84]	; (800dae4 <i2cSendDriver.constprop.20+0x2e4>)
 800da90:	f7fe f86e 	bl	800bb70 <chSysHalt>
 800da94:	2001acb0 	.word	0x2001acb0
 800da98:	08010794 	.word	0x08010794
 800da9c:	080106ec 	.word	0x080106ec
 800daa0:	2001acdc 	.word	0x2001acdc
 800daa4:	2001aca4 	.word	0x2001aca4
 800daa8:	080107b0 	.word	0x080107b0
 800daac:	080101a8 	.word	0x080101a8
 800dab0:	2001b720 	.word	0x2001b720
 800dab4:	d1b71759 	.word	0xd1b71759
 800dab8:	10624dd3 	.word	0x10624dd3
 800dabc:	0800ea50 	.word	0x0800ea50
 800dac0:	2001ac28 	.word	0x2001ac28
 800dac4:	0800ea5c 	.word	0x0800ea5c
 800dac8:	0800ea64 	.word	0x0800ea64
 800dacc:	0800f8bc 	.word	0x0800f8bc
 800dad0:	0800ea7c 	.word	0x0800ea7c
 800dad4:	0800f1e0 	.word	0x0800f1e0
 800dad8:	08010778 	.word	0x08010778
 800dadc:	0800eaa8 	.word	0x0800eaa8
 800dae0:	08010750 	.word	0x08010750
 800dae4:	080106f8 	.word	0x080106f8
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 800dae8:	2b01      	cmp	r3, #1
 800daea:	d03f      	beq.n	800db6c <i2cSendDriver.constprop.20+0x36c>
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800daec:	f8d9 0030 	ldr.w	r0, [r9, #48]	; 0x30
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800daf0:	f8d9 3034 	ldr.w	r3, [r9, #52]	; 0x34
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800daf4:	6802      	ldr	r2, [r0, #0]
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 800daf6:	2100      	movs	r1, #0
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 800daf8:	f44f 4500 	mov.w	r5, #32768	; 0x8000
 800dafc:	601d      	str	r5, [r3, #0]
  dp->CR1 = 0;
 800dafe:	6019      	str	r1, [r3, #0]
  dp->CR2 = 0;
 800db00:	6059      	str	r1, [r3, #4]
  dp->SR1 = 0;
 800db02:	6159      	str	r1, [r3, #20]

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800db04:	6813      	ldr	r3, [r2, #0]
 800db06:	f023 031f 	bic.w	r3, r3, #31
 800db0a:	6013      	str	r3, [r2, #0]
 800db0c:	6813      	ldr	r3, [r2, #0]
 800db0e:	07d9      	lsls	r1, r3, #31
 800db10:	d4fc      	bmi.n	800db0c <i2cSendDriver.constprop.20+0x30c>
 800db12:	7a01      	ldrb	r1, [r0, #8]
  dmaStreamDisable(i2cp->dmarx);
 800db14:	f8d9 202c 	ldr.w	r2, [r9, #44]	; 0x2c
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800db18:	6845      	ldr	r5, [r0, #4]
 800db1a:	233d      	movs	r3, #61	; 0x3d
 800db1c:	fa03 f101 	lsl.w	r1, r3, r1
  dmaStreamDisable(i2cp->dmarx);
 800db20:	6813      	ldr	r3, [r2, #0]
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 800db22:	6029      	str	r1, [r5, #0]
  dmaStreamDisable(i2cp->dmarx);
 800db24:	6819      	ldr	r1, [r3, #0]
 800db26:	f021 011f 	bic.w	r1, r1, #31
 800db2a:	6019      	str	r1, [r3, #0]
 800db2c:	681d      	ldr	r5, [r3, #0]
 800db2e:	f015 0501 	ands.w	r5, r5, #1
 800db32:	d1fb      	bne.n	800db2c <i2cSendDriver.constprop.20+0x32c>
 800db34:	7a11      	ldrb	r1, [r2, #8]
 800db36:	6852      	ldr	r2, [r2, #4]
 800db38:	233d      	movs	r3, #61	; 0x3d
 800db3a:	408b      	lsls	r3, r1
 800db3c:	6013      	str	r3, [r2, #0]
  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
    dmaStreamRelease(i2cp->dmatx);
 800db3e:	f7fc fb5f 	bl	800a200 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 800db42:	f8d9 002c 	ldr.w	r0, [r9, #44]	; 0x2c
 800db46:	f7fc fb5b 	bl	800a200 <dmaStreamRelease>
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800db4a:	4b15      	ldr	r3, [pc, #84]	; (800dba0 <i2cSendDriver.constprop.20+0x3a0>)

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      nvicDisableVector(I2C1_EV_IRQn);
      nvicDisableVector(I2C1_ER_IRQn);
      rccDisableI2C1(FALSE);
 800db4c:	4a15      	ldr	r2, [pc, #84]	; (800dba4 <i2cSendDriver.constprop.20+0x3a4>)
 800db4e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800db52:	2101      	movs	r1, #1
 800db54:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800db58:	f883 531f 	strb.w	r5, [r3, #799]	; 0x31f
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 800db5c:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800db60:	f883 5320 	strb.w	r5, [r3, #800]	; 0x320
 800db64:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800db66:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800db6a:	6413      	str	r3, [r2, #64]	; 0x40
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2c_lld_stop(i2cp);
  i2cp->config = NULL;
 800db6c:	2200      	movs	r2, #0
  i2cp->state  = I2C_STOP;
 800db6e:	2301      	movs	r3, #1

  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2c_lld_stop(i2cp);
  i2cp->config = NULL;
 800db70:	f8c9 2004 	str.w	r2, [r9, #4]
  i2cp->state  = I2C_STOP;
 800db74:	f889 3000 	strb.w	r3, [r9]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800db78:	f7fe faf2 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800db7c:	f8da 3000 	ldr.w	r3, [sl]
 800db80:	4a09      	ldr	r2, [pc, #36]	; (800dba8 <i2cSendDriver.constprop.20+0x3a8>)
 800db82:	4553      	cmp	r3, sl
 800db84:	d005      	beq.n	800db92 <i2cSendDriver.constprop.20+0x392>
 800db86:	6992      	ldr	r2, [r2, #24]
 800db88:	689b      	ldr	r3, [r3, #8]
 800db8a:	6892      	ldr	r2, [r2, #8]
 800db8c:	429a      	cmp	r2, r3
 800db8e:	f4ff aee7 	bcc.w	800d960 <i2cSendDriver.constprop.20+0x160>
 800db92:	2300      	movs	r3, #0
 800db94:	f383 8811 	msr	BASEPRI, r3
		i2cStop(driver);
		i2cStart(driver, &_i2cfg);
 800db98:	f7fc fe52 	bl	800a840 <i2cStart.constprop.66>
 800db9c:	e6c4      	b.n	800d928 <i2cSendDriver.constprop.20+0x128>
 800db9e:	bf00      	nop
 800dba0:	e000e100 	.word	0xe000e100
 800dba4:	40023800 	.word	0x40023800
 800dba8:	2001acdc 	.word	0x2001acdc
 800dbac:	00000000 	.word	0x00000000

0800dbb0 <I2C_write8_locked.constprop.1>:
	chMtxObjectInit(&pi2c_mtx);
}

// I2C Mutex locked access functions

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
 800dbb0:	b500      	push	{lr}
 800dbb2:	b085      	sub	sp, #20
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800dbb4:	2300      	movs	r3, #0

// I2C Mutex locked access functions

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
{
	uint8_t txbuf[] = {reg, value};
 800dbb6:	f88d 000c 	strb.w	r0, [sp, #12]
 800dbba:	f88d 100d 	strb.w	r1, [sp, #13]
	return i2c_status == MSG_OK;
}

bool I2C_send(uint8_t addr, uint8_t *txbuf, uint32_t txbytes, uint8_t *rxbuf, uint32_t rxbytes, systime_t timeout)
{
	return i2cSendDriver(&I2CD1, addr, txbuf, txbytes, rxbuf, rxbytes, timeout);
 800dbbe:	9300      	str	r3, [sp, #0]
 800dbc0:	2202      	movs	r2, #2
 800dbc2:	a903      	add	r1, sp, #12
 800dbc4:	2030      	movs	r0, #48	; 0x30
 800dbc6:	f7ff fe1b 	bl	800d800 <i2cSendDriver.constprop.20>

bool I2C_write8_locked(uint8_t address, uint8_t reg, uint8_t value)
{
	uint8_t txbuf[] = {reg, value};
	return I2C_send(address, txbuf, 2, NULL, 0, MS2ST(100));
}
 800dbca:	b005      	add	sp, #20
 800dbcc:	f85d fb04 	ldr.w	pc, [sp], #4

0800dbd0 <isPointInPolygon>:
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 800dbd0:	b3b9      	cbz	r1, 800dc42 <isPointInPolygon+0x72>
  * Determines is location is located in polygon
  * @param poly Polygon
  * @param lat Latitude
  * @param lat Longitude
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
 800dbd2:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800dbd6:	4684      	mov	ip, r0
 800dbd8:	f101 38ff 	add.w	r8, r1, #4294967295
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 800dbdc:	2400      	movs	r4, #0
 800dbde:	4620      	mov	r0, r4
 800dbe0:	f85c 6038 	ldr.w	r6, [ip, r8, lsl #3]
 800dbe4:	46e6      	mov	lr, ip
 800dbe6:	e01d      	b.n	800dc24 <isPointInPolygon+0x54>
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 800dbe8:	42b2      	cmp	r2, r6
 800dbea:	da13      	bge.n	800dc14 <isPointInPolygon+0x44>
 800dbec:	eb0c 08c8 	add.w	r8, ip, r8, lsl #3
 800dbf0:	1b57      	subs	r7, r2, r5
 800dbf2:	f8d8 9004 	ldr.w	r9, [r8, #4]
 800dbf6:	f8de 8004 	ldr.w	r8, [lr, #4]
 800dbfa:	ebc8 0909 	rsb	r9, r8, r9
 800dbfe:	1b76      	subs	r6, r6, r5
 800dc00:	fb07 f709 	mul.w	r7, r7, r9
 800dc04:	fb97 f6f6 	sdiv	r6, r7, r6
 800dc08:	4446      	add	r6, r8
 800dc0a:	429e      	cmp	r6, r3
			c = !c;
 800dc0c:	bfc4      	itt	gt
 800dc0e:	f080 0001 	eorgt.w	r0, r0, #1
 800dc12:	b2c0      	uxtbgt	r0, r0
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 800dc14:	1c67      	adds	r7, r4, #1
 800dc16:	42b9      	cmp	r1, r7
 800dc18:	f10e 0e08 	add.w	lr, lr, #8
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 800dc1c:	462e      	mov	r6, r5
 800dc1e:	46a0      	mov	r8, r4
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 800dc20:	d00d      	beq.n	800dc3e <isPointInPolygon+0x6e>
 800dc22:	463c      	mov	r4, r7
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 800dc24:	f85c 5034 	ldr.w	r5, [ip, r4, lsl #3]
 800dc28:	4295      	cmp	r5, r2
 800dc2a:	dddd      	ble.n	800dbe8 <isPointInPolygon+0x18>
 800dc2c:	42b2      	cmp	r2, r6
 800dc2e:	dadd      	bge.n	800dbec <isPointInPolygon+0x1c>
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 800dc30:	1c67      	adds	r7, r4, #1
 800dc32:	42b9      	cmp	r1, r7
 800dc34:	f10e 0e08 	add.w	lr, lr, #8
		if((((poly[i].lat <= lat) && (lat < poly[j].lat)) || ((poly[j].lat <= lat) && (lat < poly[i].lat))) && (lon < (poly[j].lon - poly[i].lon) * (lat - poly[i].lat) / (poly[j].lat - poly[i].lat) + poly[i].lon))
 800dc38:	462e      	mov	r6, r5
 800dc3a:	46a0      	mov	r8, r4
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
	uint32_t j = size-1;

	for(uint32_t i=0; i<size; i++) {
 800dc3c:	d1f1      	bne.n	800dc22 <isPointInPolygon+0x52>
 800dc3e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  * @param poly Polygon
  * @param lat Latitude
  * @param lat Longitude
  */
bool isPointInPolygon(const coord_t *poly, uint32_t size, int32_t lat, int32_t lon) {
	bool c = false;
 800dc42:	4608      	mov	r0, r1
			c = !c;
		j = i;
	}

	return c;
}
 800dc44:	4770      	bx	lr
 800dc46:	bf00      	nop
	...

0800dc50 <getAPRSRegionFrequency2m>:
/**
  * Returns APRS region specific frequency determined by GPS location. It will
  * use the APRS default frequency set in the config file if no GPS fix has
  * been received.
  */
uint32_t getAPRSRegionFrequency2m(void) {
 800dc50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
/**
  * Returns most recent track point witch is complete.
  */
trackPoint_t* getLastTrackPoint(void)
{
	return lastTrackPoint;
 800dc52:	4b36      	ldr	r3, [pc, #216]	; (800dd2c <getAPRSRegionFrequency2m+0xdc>)
	// Use this frequency for the rest of the world (unset regions, 144.800 MHz)
	uint32_t freq = APRS_FREQ_OTHER;

	// Position unknown
	if(!point->gps_lat && !point->gps_lon)
		freq = 0; // Use default frequency set in config file
 800dc54:	4c36      	ldr	r4, [pc, #216]	; (800dd30 <getAPRSRegionFrequency2m+0xe0>)
 800dc56:	681b      	ldr	r3, [r3, #0]

	// Use this frequency for the rest of the world (unset regions, 144.800 MHz)
	uint32_t freq = APRS_FREQ_OTHER;

	// Position unknown
	if(!point->gps_lat && !point->gps_lon)
 800dc58:	691d      	ldr	r5, [r3, #16]
 800dc5a:	695e      	ldr	r6, [r3, #20]
 800dc5c:	b915      	cbnz	r5, 800dc64 <getAPRSRegionFrequency2m+0x14>
		freq = 0; // Use default frequency set in config file
 800dc5e:	2e00      	cmp	r6, #0
 800dc60:	bf08      	it	eq
 800dc62:	2400      	moveq	r4, #0
  * Determines if point is located in America
  * @param lat Latitude in deg*10000000
  * @param lat Longitude in deg*10000000
  */
bool isPointInAmerica(int32_t lat, int32_t lon) {
	return isPointInPolygon(america, sizeof(america)/sizeof(america[0]), lat, lon);
 800dc64:	4633      	mov	r3, r6
 800dc66:	462a      	mov	r2, r5
 800dc68:	211b      	movs	r1, #27
 800dc6a:	4832      	ldr	r0, [pc, #200]	; (800dd34 <getAPRSRegionFrequency2m+0xe4>)
	
	// America 144.390 MHz
	if(isPointInAmerica(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_AMERICA;
 800dc6c:	4f32      	ldr	r7, [pc, #200]	; (800dd38 <getAPRSRegionFrequency2m+0xe8>)
 800dc6e:	f7ff ffaf 	bl	800dbd0 <isPointInPolygon>
}
bool isPointInChina(int32_t lat, int32_t lon) {
	return isPointInPolygon(china, sizeof(china)/sizeof(china[0]), lat, lon);
 800dc72:	4633      	mov	r3, r6
 800dc74:	2800      	cmp	r0, #0
 800dc76:	bf18      	it	ne
 800dc78:	463c      	movne	r4, r7
 800dc7a:	462a      	mov	r2, r5
 800dc7c:	2183      	movs	r1, #131	; 0x83
 800dc7e:	482f      	ldr	r0, [pc, #188]	; (800dd3c <getAPRSRegionFrequency2m+0xec>)
 800dc80:	f7ff ffa6 	bl	800dbd0 <isPointInPolygon>

	// China 144.640 MHz
	if(isPointInChina(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_CHINA;
 800dc84:	4a2e      	ldr	r2, [pc, #184]	; (800dd40 <getAPRSRegionFrequency2m+0xf0>)
}
bool isPointInJapan(int32_t lat, int32_t lon) {
	return isPointInPolygon(japan, sizeof(japan)/sizeof(japan[0]), lat, lon);
 800dc86:	4633      	mov	r3, r6
 800dc88:	2800      	cmp	r0, #0
 800dc8a:	bf18      	it	ne
 800dc8c:	4614      	movne	r4, r2
 800dc8e:	210f      	movs	r1, #15
 800dc90:	462a      	mov	r2, r5
 800dc92:	482c      	ldr	r0, [pc, #176]	; (800dd44 <getAPRSRegionFrequency2m+0xf4>)
 800dc94:	f7ff ff9c 	bl	800dbd0 <isPointInPolygon>

	// Japan 144.660 MHz
	if(isPointInJapan(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_JAPAN;
 800dc98:	4a2b      	ldr	r2, [pc, #172]	; (800dd48 <getAPRSRegionFrequency2m+0xf8>)
}
bool isPointInSouthkorea(int32_t lat, int32_t lon) {
	return isPointInPolygon(southkorea, sizeof(southkorea)/sizeof(southkorea[0]), lat, lon);
 800dc9a:	4633      	mov	r3, r6
 800dc9c:	2800      	cmp	r0, #0
 800dc9e:	bf18      	it	ne
 800dca0:	4614      	movne	r4, r2
 800dca2:	210a      	movs	r1, #10
 800dca4:	462a      	mov	r2, r5
 800dca6:	4829      	ldr	r0, [pc, #164]	; (800dd4c <getAPRSRegionFrequency2m+0xfc>)
 800dca8:	f7ff ff92 	bl	800dbd0 <isPointInPolygon>

	// Southkorea 144.620 MHz
	if(isPointInSouthkorea(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_SOUTHKOREA;
 800dcac:	4a28      	ldr	r2, [pc, #160]	; (800dd50 <getAPRSRegionFrequency2m+0x100>)
}
bool isPointInSoutheastAsia(int32_t lat, int32_t lon) {
	return isPointInPolygon(southeastAsia, sizeof(southeastAsia)/sizeof(southeastAsia[0]), lat, lon);
 800dcae:	4633      	mov	r3, r6
 800dcb0:	2800      	cmp	r0, #0
 800dcb2:	bf18      	it	ne
 800dcb4:	4614      	movne	r4, r2
 800dcb6:	2124      	movs	r1, #36	; 0x24
 800dcb8:	462a      	mov	r2, r5
 800dcba:	4826      	ldr	r0, [pc, #152]	; (800dd54 <getAPRSRegionFrequency2m+0x104>)
 800dcbc:	f7ff ff88 	bl	800dbd0 <isPointInPolygon>
}
bool isPointInAustralia(int32_t lat, int32_t lon) {
	return isPointInPolygon(australia, sizeof(australia)/sizeof(australia[0]), lat, lon);
 800dcc0:	4633      	mov	r3, r6

	// Southkorea 144.620 MHz
	if(isPointInSoutheastAsia(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_SOUTHEASTASIA;
 800dcc2:	2800      	cmp	r0, #0
 800dcc4:	bf18      	it	ne
 800dcc6:	463c      	movne	r4, r7
 800dcc8:	462a      	mov	r2, r5
 800dcca:	211c      	movs	r1, #28
 800dccc:	4822      	ldr	r0, [pc, #136]	; (800dd58 <getAPRSRegionFrequency2m+0x108>)
 800dcce:	f7ff ff7f 	bl	800dbd0 <isPointInPolygon>

	// Australia 145.175 MHz
	if(isPointInAustralia(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_AUSTRALIA;
 800dcd2:	4a22      	ldr	r2, [pc, #136]	; (800dd5c <getAPRSRegionFrequency2m+0x10c>)
}
bool isPointInNewZealand(int32_t lat, int32_t lon) {
	return isPointInPolygon(newzealand, sizeof(newzealand)/sizeof(newzealand[0]), lat, lon)
 800dcd4:	4633      	mov	r3, r6
 800dcd6:	2800      	cmp	r0, #0
 800dcd8:	bf18      	it	ne
 800dcda:	4614      	movne	r4, r2
 800dcdc:	2110      	movs	r1, #16
 800dcde:	462a      	mov	r2, r5
 800dce0:	481f      	ldr	r0, [pc, #124]	; (800dd60 <getAPRSRegionFrequency2m+0x110>)
 800dce2:	f7ff ff75 	bl	800dbd0 <isPointInPolygon>
		|| isPointInPolygon(newzealand2, sizeof(newzealand2)/sizeof(newzealand2[0]), lat, lon);
 800dce6:	b9f8      	cbnz	r0, 800dd28 <getAPRSRegionFrequency2m+0xd8>
 800dce8:	4633      	mov	r3, r6
 800dcea:	462a      	mov	r2, r5
 800dcec:	2104      	movs	r1, #4
 800dcee:	481d      	ldr	r0, [pc, #116]	; (800dd64 <getAPRSRegionFrequency2m+0x114>)
 800dcf0:	f7ff ff6e 	bl	800dbd0 <isPointInPolygon>

	// Australia 144.575 MHz
	if(isPointInNewZealand(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_NEWZEALAND;
 800dcf4:	4b1c      	ldr	r3, [pc, #112]	; (800dd68 <getAPRSRegionFrequency2m+0x118>)
 800dcf6:	2800      	cmp	r0, #0
 800dcf8:	bf18      	it	ne
 800dcfa:	461c      	movne	r4, r3
}
bool isPointInArgentina(int32_t lat, int32_t lon) { // Also includes Uruguay and Paraguay
	return isPointInPolygon(argentina, sizeof(argentina)/sizeof(argentina[0]), lat, lon);
 800dcfc:	4633      	mov	r3, r6
 800dcfe:	462a      	mov	r2, r5
 800dd00:	2182      	movs	r1, #130	; 0x82
 800dd02:	481a      	ldr	r0, [pc, #104]	; (800dd6c <getAPRSRegionFrequency2m+0x11c>)
 800dd04:	f7ff ff64 	bl	800dbd0 <isPointInPolygon>

	// Argentina/Paraguay/Uruguay 144.930 MHz
	if(isPointInArgentina(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_ARGENTINA;
 800dd08:	4919      	ldr	r1, [pc, #100]	; (800dd70 <getAPRSRegionFrequency2m+0x120>)
}
bool isPointInBrazil(int32_t lat, int32_t lon) {
	return isPointInPolygon(brazil, sizeof(brazil)/sizeof(brazil[0]), lat, lon);
 800dd0a:	4633      	mov	r3, r6
 800dd0c:	2800      	cmp	r0, #0
 800dd0e:	bf18      	it	ne
 800dd10:	460c      	movne	r4, r1
 800dd12:	462a      	mov	r2, r5
 800dd14:	219e      	movs	r1, #158	; 0x9e
 800dd16:	4817      	ldr	r0, [pc, #92]	; (800dd74 <getAPRSRegionFrequency2m+0x124>)
 800dd18:	f7ff ff5a 	bl	800dbd0 <isPointInPolygon>

	// Brazil 145.575 MHz
	if(isPointInBrazil(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_BRAZIL;
 800dd1c:	4b16      	ldr	r3, [pc, #88]	; (800dd78 <getAPRSRegionFrequency2m+0x128>)

	return freq;
}
 800dd1e:	2800      	cmp	r0, #0
 800dd20:	bf0c      	ite	eq
 800dd22:	4620      	moveq	r0, r4
 800dd24:	4618      	movne	r0, r3
 800dd26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(isPointInAustralia(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_AUSTRALIA;

	// Australia 144.575 MHz
	if(isPointInNewZealand(point->gps_lat, point->gps_lon))
		freq = APRS_FREQ_NEWZEALAND;
 800dd28:	4c0f      	ldr	r4, [pc, #60]	; (800dd68 <getAPRSRegionFrequency2m+0x118>)
 800dd2a:	e7e7      	b.n	800dcfc <getAPRSRegionFrequency2m+0xac>
 800dd2c:	2001b730 	.word	0x2001b730
 800dd30:	08a17900 	.word	0x08a17900
 800dd34:	080118e8 	.word	0x080118e8
 800dd38:	089b3770 	.word	0x089b3770
 800dd3c:	08010e90 	.word	0x08010e90
 800dd40:	089f0800 	.word	0x089f0800
 800dd44:	080107c8 	.word	0x080107c8
 800dd48:	089f5620 	.word	0x089f5620
 800dd4c:	080119c0 	.word	0x080119c0
 800dd50:	089eb9e0 	.word	0x089eb9e0
 800dd54:	080117a8 	.word	0x080117a8
 800dd58:	08010d30 	.word	0x08010d30
 800dd5c:	08a731d8 	.word	0x08a731d8
 800dd60:	08010e10 	.word	0x08010e10
 800dd64:	080118c8 	.word	0x080118c8
 800dd68:	089e0a18 	.word	0x089e0a18
 800dd6c:	080112a8 	.word	0x080112a8
 800dd70:	08a374d0 	.word	0x08a374d0
 800dd74:	08010840 	.word	0x08010840
 800dd78:	08ad4c58 	.word	0x08ad4c58
 800dd7c:	00000000 	.word	0x00000000

0800dd80 <Vector11C>:
  * Fast interrupt handler for AFSK (1200baud) modulation. It has has the
  * highest priority in order to provide an accurate low jitter modulation.
  */
CH_FAST_IRQ_HANDLER(STM32_TIM7_HANDLER)
{
	if(tim_msg->mod == MOD_AFSK) {
 800dd80:	4b3a      	ldr	r3, [pc, #232]	; (800de6c <Vector11C+0xec>)
 800dd82:	681a      	ldr	r2, [r3, #0]
 800dd84:	f892 3209 	ldrb.w	r3, [r2, #521]	; 0x209
 800dd88:	2b04      	cmp	r3, #4
/**
  * Fast interrupt handler for AFSK (1200baud) modulation. It has has the
  * highest priority in order to provide an accurate low jitter modulation.
  */
CH_FAST_IRQ_HANDLER(STM32_TIM7_HANDLER)
{
 800dd8a:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(tim_msg->mod == MOD_AFSK) {
 800dd8c:	d007      	beq.n	800dd9e <Vector11C+0x1e>
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
			packet_pos++;
		}

	} else if(tim_msg->mod == MOD_2GFSK) {
 800dd8e:	2b02      	cmp	r3, #2
 800dd90:	d030      	beq.n	800ddf4 <Vector11C+0x74>

		//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));

	}

	TIM7->SR &= ~STM32_TIM_SR_UIF;						// Reset interrupt flag
 800dd92:	4a37      	ldr	r2, [pc, #220]	; (800de70 <Vector11C+0xf0>)
 800dd94:	6913      	ldr	r3, [r2, #16]
 800dd96:	f023 0301 	bic.w	r3, r3, #1
 800dd9a:	6113      	str	r3, [r2, #16]
 800dd9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  */
CH_FAST_IRQ_HANDLER(STM32_TIM7_HANDLER)
{
	if(tim_msg->mod == MOD_AFSK) {

		if(packet_pos == tim_msg->bin_len) { // Packet transmission finished
 800dd9e:	4d35      	ldr	r5, [pc, #212]	; (800de74 <Vector11C+0xf4>)
 800dda0:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 800dda4:	6828      	ldr	r0, [r5, #0]
 800dda6:	4283      	cmp	r3, r0
 800dda8:	d047      	beq.n	800de3a <Vector11C+0xba>
			TIM7->CR1 &= ~STM32_TIM_CR1_CEN;	// Disable timer
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
			return;
		}

		if(current_sample_in_baud == 0) {
 800ddaa:	4c33      	ldr	r4, [pc, #204]	; (800de78 <Vector11C+0xf8>)
 800ddac:	6821      	ldr	r1, [r4, #0]
 800ddae:	2900      	cmp	r1, #0
 800ddb0:	d03c      	beq.n	800de2c <Vector11C+0xac>
 800ddb2:	4b32      	ldr	r3, [pc, #200]	; (800de7c <Vector11C+0xfc>)
 800ddb4:	781a      	ldrb	r2, [r3, #0]
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 800ddb6:	4f32      	ldr	r7, [pc, #200]	; (800de80 <Vector11C+0x100>)
		MOD_GPIO_SET((phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 800ddb8:	4e32      	ldr	r6, [pc, #200]	; (800de84 <Vector11C+0x104>)
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 800ddba:	683b      	ldr	r3, [r7, #0]
				current_byte = current_byte / 2;
			}
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;
 800ddbc:	f012 0f01 	tst.w	r2, #1
 800ddc0:	f240 4ec3 	movw	lr, #1219	; 0x4c3
 800ddc4:	f640 02bb 	movw	r2, #2235	; 0x8bb
 800ddc8:	bf18      	it	ne
 800ddca:	4672      	movne	r2, lr

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 800ddcc:	441a      	add	r2, r3
		MOD_GPIO_SET((phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 800ddce:	0c13      	lsrs	r3, r2, #16
 800ddd0:	f013 0f01 	tst.w	r3, #1
 800ddd4:	ea4f 2383 	mov.w	r3, r3, lsl #10
		}

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
 800ddd8:	603a      	str	r2, [r7, #0]
		MOD_GPIO_SET((phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 800ddda:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800ddde:	bf14      	ite	ne
 800dde0:	2200      	movne	r2, #0
 800dde2:	f04f 6280 	moveq.w	r2, #67108864	; 0x4000000

		current_sample_in_baud++;
 800dde6:	3101      	adds	r1, #1

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
		MOD_GPIO_SET((phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 800dde8:	4313      	orrs	r3, r2

		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
 800ddea:	296b      	cmp	r1, #107	; 0x6b

		// Toggle tone (1200 <> 2200)
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
		MOD_GPIO_SET((phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)
 800ddec:	61b3      	str	r3, [r6, #24]

		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
 800ddee:	d02e      	beq.n	800de4e <Vector11C+0xce>
		phase_delta = (current_byte & 1) ? PHASE_DELTA_1200 : PHASE_DELTA_2200;

		phase += phase_delta;								// Add delta-phase (delta-phase tone dependent)
		MOD_GPIO_SET((phase >> 16) & 1);		// Set modulaton pin (connected to Si4464)

		current_sample_in_baud++;
 800ddf0:	6021      	str	r1, [r4, #0]
 800ddf2:	e7ce      	b.n	800dd92 <Vector11C+0x12>
			packet_pos++;
		}

	} else if(tim_msg->mod == MOD_2GFSK) {

		if(gfsk_bit >= tim_msg->bin_len) { // Packet transmission finished
 800ddf4:	4824      	ldr	r0, [pc, #144]	; (800de88 <Vector11C+0x108>)
 800ddf6:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 800ddfa:	6801      	ldr	r1, [r0, #0]
 800ddfc:	428b      	cmp	r3, r1
 800ddfe:	d91c      	bls.n	800de3a <Vector11C+0xba>
			TIM7->CR1 &= ~STM32_TIM_CR1_CEN;	// Disable timer
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
			return;
		}

		if((gfsk_bit & 7) == 0) { // Load up next byte
 800de00:	074b      	lsls	r3, r1, #29
 800de02:	d129      	bne.n	800de58 <Vector11C+0xd8>
			current_byte = tim_msg->msg[gfsk_bit >> 3];
 800de04:	08cb      	lsrs	r3, r1, #3
 800de06:	4c1d      	ldr	r4, [pc, #116]	; (800de7c <Vector11C+0xfc>)
 800de08:	5cd3      	ldrb	r3, [r2, r3]
 800de0a:	7023      	strb	r3, [r4, #0]
		} else {
			current_byte = current_byte / 2; // Load next bit
		}

		MOD_GPIO_SET(current_byte & 0x1);
 800de0c:	f013 0f01 	tst.w	r3, #1
 800de10:	ea4f 2383 	mov.w	r3, r3, lsl #10
 800de14:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800de18:	bf14      	ite	ne
 800de1a:	2200      	movne	r2, #0
 800de1c:	f04f 6280 	moveq.w	r2, #67108864	; 0x4000000
 800de20:	4c18      	ldr	r4, [pc, #96]	; (800de84 <Vector11C+0x104>)
		gfsk_bit++;
 800de22:	3101      	adds	r1, #1
			current_byte = tim_msg->msg[gfsk_bit >> 3];
		} else {
			current_byte = current_byte / 2; // Load next bit
		}

		MOD_GPIO_SET(current_byte & 0x1);
 800de24:	4313      	orrs	r3, r2
 800de26:	61a3      	str	r3, [r4, #24]
		gfsk_bit++;
 800de28:	6001      	str	r1, [r0, #0]
 800de2a:	e7b2      	b.n	800dd92 <Vector11C+0x12>
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
			return;
		}

		if(current_sample_in_baud == 0) {
			if((packet_pos & 7) == 0) { // Load up next byte
 800de2c:	0746      	lsls	r6, r0, #29
 800de2e:	d118      	bne.n	800de62 <Vector11C+0xe2>
				current_byte = tim_msg->msg[packet_pos >> 3];
 800de30:	08c3      	lsrs	r3, r0, #3
 800de32:	4e12      	ldr	r6, [pc, #72]	; (800de7c <Vector11C+0xfc>)
 800de34:	5cd2      	ldrb	r2, [r2, r3]
 800de36:	7032      	strb	r2, [r6, #0]
 800de38:	e7bd      	b.n	800ddb6 <Vector11C+0x36>
		}

	} else if(tim_msg->mod == MOD_2GFSK) {

		if(gfsk_bit >= tim_msg->bin_len) { // Packet transmission finished
			TIM7->CR1 &= ~STM32_TIM_CR1_CEN;	// Disable timer
 800de3a:	4b0d      	ldr	r3, [pc, #52]	; (800de70 <Vector11C+0xf0>)
 800de3c:	681a      	ldr	r2, [r3, #0]
 800de3e:	f022 0201 	bic.w	r2, r2, #1
 800de42:	601a      	str	r2, [r3, #0]
			TIM7->SR &= ~STM32_TIM_SR_UIF;		// Reset interrupt flag
 800de44:	691a      	ldr	r2, [r3, #16]
 800de46:	f022 0201 	bic.w	r2, r2, #1
 800de4a:	611a      	str	r2, [r3, #16]
 800de4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
			packet_pos++;
 800de4e:	3001      	adds	r0, #1

		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
 800de50:	2300      	movs	r3, #0
			packet_pos++;
 800de52:	6028      	str	r0, [r5, #0]

		current_sample_in_baud++;

		if(current_sample_in_baud == SAMPLES_PER_BAUD) {	// Old bit consumed, load next bit
			//palTogglePad(PORT(LED_2YELLOW), PIN(LED_2YELLOW));
			current_sample_in_baud = 0;
 800de54:	6023      	str	r3, [r4, #0]
 800de56:	e79c      	b.n	800dd92 <Vector11C+0x12>
		}

		if((gfsk_bit & 7) == 0) { // Load up next byte
			current_byte = tim_msg->msg[gfsk_bit >> 3];
		} else {
			current_byte = current_byte / 2; // Load next bit
 800de58:	4a08      	ldr	r2, [pc, #32]	; (800de7c <Vector11C+0xfc>)
 800de5a:	7813      	ldrb	r3, [r2, #0]
 800de5c:	085b      	lsrs	r3, r3, #1
 800de5e:	7013      	strb	r3, [r2, #0]
 800de60:	e7d4      	b.n	800de0c <Vector11C+0x8c>

		if(current_sample_in_baud == 0) {
			if((packet_pos & 7) == 0) { // Load up next byte
				current_byte = tim_msg->msg[packet_pos >> 3];
			} else { // Load up next bit
				current_byte = current_byte / 2;
 800de62:	4b06      	ldr	r3, [pc, #24]	; (800de7c <Vector11C+0xfc>)
 800de64:	781a      	ldrb	r2, [r3, #0]
 800de66:	0852      	lsrs	r2, r2, #1
 800de68:	701a      	strb	r2, [r3, #0]
 800de6a:	e7a4      	b.n	800ddb6 <Vector11C+0x36>
 800de6c:	2001b748 	.word	0x2001b748
 800de70:	40001400 	.word	0x40001400
 800de74:	2001b734 	.word	0x2001b734
 800de78:	2001b740 	.word	0x2001b740
 800de7c:	2001b73c 	.word	0x2001b73c
 800de80:	2001b770 	.word	0x2001b770
 800de84:	40020c00 	.word	0x40020c00
 800de88:	2001b738 	.word	0x2001b738
 800de8c:	00000000 	.word	0x00000000

0800de90 <led_cb.lto_priv.120>:
  * LED blinking routine
  * RED LED blinks: One or more modules crashed (software watchdog) INFO: Due to hardware bug, the LED cannot be used (pin = OSC_OUT => must be left floating)
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
 800de90:	b510      	push	{r4, lr}
	// Switch LEDs
	palWritePad(PORT(IO_LED3), PIN(IO_LED3), (bool)led_sw);	// Show I'M ALIVE
 800de92:	b348      	cbz	r0, 800dee8 <led_cb.lto_priv.120+0x58>
 800de94:	4a1a      	ldr	r2, [pc, #104]	; (800df00 <led_cb.lto_priv.120+0x70>)
	if(error) {
 800de96:	4b1b      	ldr	r3, [pc, #108]	; (800df04 <led_cb.lto_priv.120+0x74>)
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(IO_LED3), PIN(IO_LED3), (bool)led_sw);	// Show I'M ALIVE
 800de98:	f44f 7180 	mov.w	r1, #256	; 0x100
 800de9c:	6191      	str	r1, [r2, #24]
	if(error) {
 800de9e:	781b      	ldrb	r3, [r3, #0]
 800dea0:	b9f3      	cbnz	r3, 800dee0 <led_cb.lto_priv.120+0x50>
		palWritePad(PORT(IO_LED1), PIN(IO_LED1), (bool)led_sw);	// Show error
	} else {
		palSetPad(PORT(IO_LED1), PIN(IO_LED1));	// Shut off error
 800dea2:	4b19      	ldr	r3, [pc, #100]	; (800df08 <led_cb.lto_priv.120+0x78>)
 800dea4:	2202      	movs	r2, #2
 800dea6:	831a      	strh	r2, [r3, #24]
	}

	led_sw = (void*)!led_sw; // Set next state
 800dea8:	fab0 f480 	clz	r4, r0
 800deac:	0964      	lsrs	r4, r4, #5
 800deae:	2320      	movs	r3, #32
 800deb0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800deb4:	f7fe f904 	bl	800c0c0 <_dbg_check_lock_from_isr>
 800deb8:	f7fd feba 	bl	800bc30 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 800debc:	4813      	ldr	r0, [pc, #76]	; (800df0c <led_cb.lto_priv.120+0x7c>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800debe:	68c3      	ldr	r3, [r0, #12]
 800dec0:	b10b      	cbz	r3, 800dec6 <led_cb.lto_priv.120+0x36>
    chVTDoResetI(vtp);
 800dec2:	f7fd ffbd 	bl	800be40 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800dec6:	4623      	mov	r3, r4
 800dec8:	4a11      	ldr	r2, [pc, #68]	; (800df10 <led_cb.lto_priv.120+0x80>)
 800deca:	4810      	ldr	r0, [pc, #64]	; (800df0c <led_cb.lto_priv.120+0x7c>)
 800decc:	f241 3188 	movw	r1, #5000	; 0x1388
 800ded0:	f7fd fffe 	bl	800bed0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800ded4:	f7fe f8dc 	bl	800c090 <_dbg_check_unlock_from_isr>
 800ded8:	2300      	movs	r3, #0
 800deda:	f383 8811 	msr	BASEPRI, r3
 800dede:	bd10      	pop	{r4, pc}
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(IO_LED3), PIN(IO_LED3), (bool)led_sw);	// Show I'M ALIVE
	if(error) {
 800dee0:	2202      	movs	r2, #2
		palWritePad(PORT(IO_LED1), PIN(IO_LED1), (bool)led_sw);	// Show error
 800dee2:	4b09      	ldr	r3, [pc, #36]	; (800df08 <led_cb.lto_priv.120+0x78>)
 800dee4:	619a      	str	r2, [r3, #24]
 800dee6:	e7df      	b.n	800dea8 <led_cb.lto_priv.120+0x18>
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(IO_LED3), PIN(IO_LED3), (bool)led_sw);	// Show I'M ALIVE
 800dee8:	4a05      	ldr	r2, [pc, #20]	; (800df00 <led_cb.lto_priv.120+0x70>)
	if(error) {
 800deea:	4b06      	ldr	r3, [pc, #24]	; (800df04 <led_cb.lto_priv.120+0x74>)
  * GREEN LED blinks: I'm alive! (STM32 crashed if not blinking)
  * YELLOW LED: Camera takes a photo (See image.c)
  */
static void led_cb(void *led_sw) {
	// Switch LEDs
	palWritePad(PORT(IO_LED3), PIN(IO_LED3), (bool)led_sw);	// Show I'M ALIVE
 800deec:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 800def0:	6191      	str	r1, [r2, #24]
	if(error) {
 800def2:	781b      	ldrb	r3, [r3, #0]
 800def4:	2b00      	cmp	r3, #0
 800def6:	d0d4      	beq.n	800dea2 <led_cb.lto_priv.120+0x12>
 800def8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800defc:	e7f1      	b.n	800dee2 <led_cb.lto_priv.120+0x52>
 800defe:	bf00      	nop
 800df00:	40021000 	.word	0x40021000
 800df04:	2001aa40 	.word	0x2001aa40
 800df08:	40020400 	.word	0x40020400
 800df0c:	20019960 	.word	0x20019960
 800df10:	0800de91 	.word	0x0800de91
	...

0800df20 <serial_cb>:
static uint32_t txi;		// Bitcounter of current byte
static uint32_t txj;		// Bytecounter
static radioMSG_t *fsk_msg;	// Current message
static virtual_timer_t vt;

static void serial_cb(void *arg) {
 800df20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	(void)arg;

	switch(txs)
 800df22:	4a52      	ldr	r2, [pc, #328]	; (800e06c <serial_cb+0x14c>)
 800df24:	7811      	ldrb	r1, [r2, #0]
 800df26:	1f8b      	subs	r3, r1, #6
 800df28:	2b03      	cmp	r3, #3
 800df2a:	f200 8085 	bhi.w	800e038 <serial_cb+0x118>
 800df2e:	e8df f003 	tbb	[pc, r3]
 800df32:	6b52      	.short	0x6b52
 800df34:	0236      	.short	0x0236
				txs = 9;
			}
			break;

		case 9:
			if(fsk_msg->fsk_config->stopbits == 2)
 800df36:	4c4e      	ldr	r4, [pc, #312]	; (800e070 <serial_cb+0x150>)
 800df38:	6823      	ldr	r3, [r4, #0]
 800df3a:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 800df3e:	785b      	ldrb	r3, [r3, #1]
 800df40:	2b02      	cmp	r3, #2
 800df42:	f000 808c 	beq.w	800e05e <serial_cb+0x13e>
				MOD_GPIO_SET(HIGH); // Stop Bit
			txs = 7;
 800df46:	2307      	movs	r3, #7
 800df48:	7013      	strb	r3, [r2, #0]
 800df4a:	2320      	movs	r3, #32
 800df4c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800df50:	f7fe f8b6 	bl	800c0c0 <_dbg_check_lock_from_isr>
	}

	// Reload timer
	if(txs) {
		chSysLockFromISR();
		uint32_t delay = US2ST(1000000/fsk_msg->fsk_config->baud);
 800df54:	6823      	ldr	r3, [r4, #0]
 800df56:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
 800df5a:	889c      	ldrh	r4, [r3, #4]
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800df5c:	f7fd fe68 	bl	800bc30 <chDbgCheckClassI>

  return (bool)(vtp->func != NULL);
 800df60:	4844      	ldr	r0, [pc, #272]	; (800e074 <serial_cb+0x154>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800df62:	68c3      	ldr	r3, [r0, #12]
 800df64:	b10b      	cbz	r3, 800df6a <serial_cb+0x4a>
    chVTDoResetI(vtp);
 800df66:	f7fd ff6b 	bl	800be40 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800df6a:	f242 7210 	movw	r2, #10000	; 0x2710
 800df6e:	4b42      	ldr	r3, [pc, #264]	; (800e078 <serial_cb+0x158>)
 800df70:	fb93 f3f4 	sdiv	r3, r3, r4
 800df74:	fb02 f303 	mul.w	r3, r2, r3
 800df78:	f503 2374 	add.w	r3, r3, #999424	; 0xf4000
 800df7c:	493f      	ldr	r1, [pc, #252]	; (800e07c <serial_cb+0x15c>)
 800df7e:	4a40      	ldr	r2, [pc, #256]	; (800e080 <serial_cb+0x160>)
 800df80:	483c      	ldr	r0, [pc, #240]	; (800e074 <serial_cb+0x154>)
 800df82:	f203 233f 	addw	r3, r3, #575	; 0x23f
 800df86:	fba1 3103 	umull	r3, r1, r1, r3
 800df8a:	0c89      	lsrs	r1, r1, #18
 800df8c:	2300      	movs	r3, #0
 800df8e:	f7fd ff9f 	bl	800bed0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800df92:	f7fe f87d 	bl	800c090 <_dbg_check_unlock_from_isr>
 800df96:	2300      	movs	r3, #0
 800df98:	f383 8811 	msr	BASEPRI, r3
 800df9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				MOD_GPIO_SET(HIGH);
			}
			break;

		case 8:
			if(txi < fsk_msg->fsk_config->bits) {
 800df9e:	4c34      	ldr	r4, [pc, #208]	; (800e070 <serial_cb+0x150>)
 800dfa0:	4938      	ldr	r1, [pc, #224]	; (800e084 <serial_cb+0x164>)
 800dfa2:	6820      	ldr	r0, [r4, #0]
 800dfa4:	680b      	ldr	r3, [r1, #0]
 800dfa6:	f8d0 0210 	ldr.w	r0, [r0, #528]	; 0x210
 800dfaa:	7800      	ldrb	r0, [r0, #0]
 800dfac:	4298      	cmp	r0, r3
 800dfae:	d94d      	bls.n	800e04c <serial_cb+0x12c>
				txi++;
				MOD_GPIO_SET(txc & 1);
 800dfb0:	4e35      	ldr	r6, [pc, #212]	; (800e088 <serial_cb+0x168>)
 800dfb2:	4f36      	ldr	r7, [pc, #216]	; (800e08c <serial_cb+0x16c>)
 800dfb4:	7832      	ldrb	r2, [r6, #0]
 800dfb6:	0290      	lsls	r0, r2, #10
 800dfb8:	f012 0f01 	tst.w	r2, #1
 800dfbc:	f400 6580 	and.w	r5, r0, #1024	; 0x400
 800dfc0:	bf14      	ite	ne
 800dfc2:	2000      	movne	r0, #0
 800dfc4:	f04f 6080 	moveq.w	r0, #67108864	; 0x4000000
			}
			break;

		case 8:
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
 800dfc8:	3301      	adds	r3, #1
				MOD_GPIO_SET(txc & 1);
 800dfca:	4328      	orrs	r0, r5
				txc = txc >> 1;
 800dfcc:	0852      	lsrs	r2, r2, #1
			}
			break;

		case 8:
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
 800dfce:	600b      	str	r3, [r1, #0]
				MOD_GPIO_SET(txc & 1);
 800dfd0:	61b8      	str	r0, [r7, #24]
				txc = txc >> 1;
 800dfd2:	7032      	strb	r2, [r6, #0]
 800dfd4:	e7b9      	b.n	800df4a <serial_cb+0x2a>

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 800dfd6:	4c26      	ldr	r4, [pc, #152]	; (800e070 <serial_cb+0x150>)
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 800dfd8:	4e2d      	ldr	r6, [pc, #180]	; (800e090 <serial_cb+0x170>)
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 800dfda:	6823      	ldr	r3, [r4, #0]
 800dfdc:	4d2d      	ldr	r5, [pc, #180]	; (800e094 <serial_cb+0x174>)
 800dfde:	f8d3 1210 	ldr.w	r1, [r3, #528]	; 0x210
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 800dfe2:	6830      	ldr	r0, [r6, #0]
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 800dfe4:	884b      	ldrh	r3, [r1, #2]
 800dfe6:	8889      	ldrh	r1, [r1, #4]
 800dfe8:	fb01 f303 	mul.w	r3, r1, r3
 800dfec:	fb85 5103 	smull	r5, r1, r5, r3
 800dff0:	17db      	asrs	r3, r3, #31
 800dff2:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 800dff6:	1c41      	adds	r1, r0, #1
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 800dff8:	4299      	cmp	r1, r3
	(void)arg;

	switch(txs)
	{
		case 6: // TX-delay
			txj++;
 800dffa:	6031      	str	r1, [r6, #0]
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
 800dffc:	d9a5      	bls.n	800df4a <serial_cb+0x2a>
				txj = 0;
 800dffe:	2100      	movs	r1, #0
				txs = 7;
 800e000:	2307      	movs	r3, #7
	switch(txs)
	{
		case 6: // TX-delay
			txj++;
			if(txj > (uint32_t)(fsk_msg->fsk_config->predelay * fsk_msg->fsk_config->baud / 1000)) {
				txj = 0;
 800e002:	6031      	str	r1, [r6, #0]
				txs = 7;
 800e004:	7013      	strb	r3, [r2, #0]
 800e006:	e7a0      	b.n	800df4a <serial_cb+0x2a>
			}
			break;

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
 800e008:	4c19      	ldr	r4, [pc, #100]	; (800e070 <serial_cb+0x150>)
 800e00a:	4921      	ldr	r1, [pc, #132]	; (800e090 <serial_cb+0x170>)
 800e00c:	6820      	ldr	r0, [r4, #0]
 800e00e:	680b      	ldr	r3, [r1, #0]
 800e010:	f8d0 5200 	ldr.w	r5, [r0, #512]	; 0x200
 800e014:	ebb3 0fd5 	cmp.w	r3, r5, lsr #3
 800e018:	d210      	bcs.n	800e03c <serial_cb+0x11c>
				txc = fsk_msg->msg[txj]; // Select char
 800e01a:	4f1b      	ldr	r7, [pc, #108]	; (800e088 <serial_cb+0x168>)
 800e01c:	5cc0      	ldrb	r0, [r0, r3]
				txj++;
				MOD_GPIO_SET(LOW); // Start Bit (Synchronizing)
 800e01e:	4e1b      	ldr	r6, [pc, #108]	; (800e08c <serial_cb+0x16c>)
				txi = 0;
 800e020:	4d18      	ldr	r5, [pc, #96]	; (800e084 <serial_cb+0x164>)
			}
			break;

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
				txc = fsk_msg->msg[txj]; // Select char
 800e022:	7038      	strb	r0, [r7, #0]
				txj++;
 800e024:	3301      	adds	r3, #1
 800e026:	600b      	str	r3, [r1, #0]
				MOD_GPIO_SET(LOW); // Start Bit (Synchronizing)
 800e028:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
				txi = 0;
 800e02c:	2000      	movs	r0, #0
				txs = 8;
 800e02e:	2308      	movs	r3, #8

		case 7: // Transmit a single char
			if(txj < fsk_msg->bin_len/8) {
				txc = fsk_msg->msg[txj]; // Select char
				txj++;
				MOD_GPIO_SET(LOW); // Start Bit (Synchronizing)
 800e030:	61b7      	str	r7, [r6, #24]
				txi = 0;
 800e032:	6028      	str	r0, [r5, #0]
				txs = 8;
 800e034:	7013      	strb	r3, [r2, #0]
 800e036:	e788      	b.n	800df4a <serial_cb+0x2a>
				MOD_GPIO_SET(HIGH); // Stop Bit
			txs = 7;
	}

	// Reload timer
	if(txs) {
 800e038:	b9b1      	cbnz	r1, 800e068 <serial_cb+0x148>
 800e03a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				txi = 0;
				txs = 8;
			} else {
				txj = 0;
				txs = 0; // Finished to transmit string
				MOD_GPIO_SET(HIGH);
 800e03c:	4813      	ldr	r0, [pc, #76]	; (800e08c <serial_cb+0x16c>)
				txj++;
				MOD_GPIO_SET(LOW); // Start Bit (Synchronizing)
				txi = 0;
				txs = 8;
			} else {
				txj = 0;
 800e03e:	2300      	movs	r3, #0
				txs = 0; // Finished to transmit string
				MOD_GPIO_SET(HIGH);
 800e040:	f44f 6480 	mov.w	r4, #1024	; 0x400
				txj++;
				MOD_GPIO_SET(LOW); // Start Bit (Synchronizing)
				txi = 0;
				txs = 8;
			} else {
				txj = 0;
 800e044:	600b      	str	r3, [r1, #0]
				txs = 0; // Finished to transmit string
 800e046:	7013      	strb	r3, [r2, #0]
				MOD_GPIO_SET(HIGH);
 800e048:	6184      	str	r4, [r0, #24]
 800e04a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
				MOD_GPIO_SET(txc & 1);
				txc = txc >> 1;
			} else {
				MOD_GPIO_SET(HIGH); // Stop Bit
 800e04c:	4d0f      	ldr	r5, [pc, #60]	; (800e08c <serial_cb+0x16c>)
 800e04e:	f44f 6680 	mov.w	r6, #1024	; 0x400
				txi = 0;
 800e052:	2000      	movs	r0, #0
				txs = 9;
 800e054:	2309      	movs	r3, #9
			if(txi < fsk_msg->fsk_config->bits) {
				txi++;
				MOD_GPIO_SET(txc & 1);
				txc = txc >> 1;
			} else {
				MOD_GPIO_SET(HIGH); // Stop Bit
 800e056:	61ae      	str	r6, [r5, #24]
				txi = 0;
 800e058:	6008      	str	r0, [r1, #0]
				txs = 9;
 800e05a:	7013      	strb	r3, [r2, #0]
 800e05c:	e775      	b.n	800df4a <serial_cb+0x2a>
			}
			break;

		case 9:
			if(fsk_msg->fsk_config->stopbits == 2)
				MOD_GPIO_SET(HIGH); // Stop Bit
 800e05e:	4b0b      	ldr	r3, [pc, #44]	; (800e08c <serial_cb+0x16c>)
 800e060:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800e064:	6199      	str	r1, [r3, #24]
 800e066:	e76e      	b.n	800df46 <serial_cb+0x26>
 800e068:	4c01      	ldr	r4, [pc, #4]	; (800e070 <serial_cb+0x150>)
 800e06a:	e76e      	b.n	800df4a <serial_cb+0x2a>
 800e06c:	2001b76c 	.word	0x2001b76c
 800e070:	2001b744 	.word	0x2001b744
 800e074:	2001b758 	.word	0x2001b758
 800e078:	000f4240 	.word	0x000f4240
 800e07c:	431bde83 	.word	0x431bde83
 800e080:	0800df21 	.word	0x0800df21
 800e084:	2001b74c 	.word	0x2001b74c
 800e088:	2001b76d 	.word	0x2001b76d
 800e08c:	40020c00 	.word	0x40020c00
 800e090:	2001b750 	.word	0x2001b750
 800e094:	10624dd3 	.word	0x10624dd3
	...

0800e0a0 <flashSectorSize.part.1.lto_priv.135>:

size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
    else if (sector == 4)
 800e0a0:	2804      	cmp	r0, #4
 800e0a2:	d006      	beq.n	800e0b2 <flashSectorSize.part.1.lto_priv.135+0x12>
        return 64 * 1024;
    else if (sector >= 5 && sector <= 11)
 800e0a4:	3805      	subs	r0, #5
        return 128 * 1024;
    return 0;
 800e0a6:	2806      	cmp	r0, #6
 800e0a8:	bf94      	ite	ls
 800e0aa:	f44f 3000 	movls.w	r0, #131072	; 0x20000
 800e0ae:	2000      	movhi	r0, #0
 800e0b0:	4770      	bx	lr
size_t flashSectorSize(flashsector_t sector)
{
    if (sector <= 3)
        return 16 * 1024;
    else if (sector == 4)
        return 64 * 1024;
 800e0b2:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    else if (sector >= 5 && sector <= 11)
        return 128 * 1024;
    return 0;
}
 800e0b6:	4770      	bx	lr
	...

0800e0c0 <transmitOnRadio>:
}

/**
  * Sends radio message into message box. This method will return false if message box is full.
  */
bool transmitOnRadio(radioMSG_t *msg) {
 800e0c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e0c4:	4604      	mov	r4, r0
 800e0c6:	b084      	sub	sp, #16
	// Lock radio
	chMtxLock(&radio_mtx);
 800e0c8:	48a1      	ldr	r0, [pc, #644]	; (800e350 <transmitOnRadio+0x290>)
 800e0ca:	f7fe f869 	bl	800c1a0 <chMtxLock>

	if(inRadioBand(msg->freq)) { // Radio found
 800e0ce:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
 800e0d2:	4ba0      	ldr	r3, [pc, #640]	; (800e354 <transmitOnRadio+0x294>)
 800e0d4:	4aa0      	ldr	r2, [pc, #640]	; (800e358 <transmitOnRadio+0x298>)
 800e0d6:	440b      	add	r3, r1
 800e0d8:	4293      	cmp	r3, r2
 800e0da:	d861      	bhi.n	800e1a0 <transmitOnRadio+0xe0>

		// Lock interference mutex
		chMtxLock(&interference_mtx);
 800e0dc:	489f      	ldr	r0, [pc, #636]	; (800e35c <transmitOnRadio+0x29c>)

		TRACE_INFO(	"RAD  > Transmit %d.%03d MHz, %d dBm (%d), %s, %d bits",
 800e0de:	4ea0      	ldr	r6, [pc, #640]	; (800e360 <transmitOnRadio+0x2a0>)
	chMtxLock(&radio_mtx);

	if(inRadioBand(msg->freq)) { // Radio found

		// Lock interference mutex
		chMtxLock(&interference_mtx);
 800e0e0:	f7fe f85e 	bl	800c1a0 <chMtxLock>

		TRACE_INFO(	"RAD  > Transmit %d.%03d MHz, %d dBm (%d), %s, %d bits",
 800e0e4:	489f      	ldr	r0, [pc, #636]	; (800e364 <transmitOnRadio+0x2a4>)
 800e0e6:	f7fe f85b 	bl	800c1a0 <chMtxLock>
 800e0ea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e0ee:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 800e0f2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e0f4:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 800e0f6:	4b9c      	ldr	r3, [pc, #624]	; (800e368 <transmitOnRadio+0x2a8>)
 800e0f8:	499c      	ldr	r1, [pc, #624]	; (800e36c <transmitOnRadio+0x2ac>)
 800e0fa:	489d      	ldr	r0, [pc, #628]	; (800e370 <transmitOnRadio+0x2b0>)
 800e0fc:	fb07 f505 	mul.w	r5, r7, r5
 800e100:	fba3 e505 	umull	lr, r5, r3, r5
 800e104:	0b6d      	lsrs	r5, r5, #13
 800e106:	fba3 3202 	umull	r3, r2, r3, r2
 800e10a:	fba6 e305 	umull	lr, r3, r6, r5
 800e10e:	099b      	lsrs	r3, r3, #6
 800e110:	fb07 5313 	mls	r3, r7, r3, r5
 800e114:	0b52      	lsrs	r2, r2, #13
 800e116:	f7fc fabb 	bl	800a690 <chprintf.constprop.26>
 800e11a:	4a96      	ldr	r2, [pc, #600]	; (800e374 <transmitOnRadio+0x2b4>)
 800e11c:	4996      	ldr	r1, [pc, #600]	; (800e378 <transmitOnRadio+0x2b8>)
 800e11e:	4894      	ldr	r0, [pc, #592]	; (800e370 <transmitOnRadio+0x2b0>)
 800e120:	f7fc fab6 	bl	800a690 <chprintf.constprop.26>
 800e124:	f240 1345 	movw	r3, #325	; 0x145
 800e128:	4a94      	ldr	r2, [pc, #592]	; (800e37c <transmitOnRadio+0x2bc>)
 800e12a:	4995      	ldr	r1, [pc, #596]	; (800e380 <transmitOnRadio+0x2c0>)
 800e12c:	4890      	ldr	r0, [pc, #576]	; (800e370 <transmitOnRadio+0x2b0>)
 800e12e:	f7fc faaf 	bl	800a690 <chprintf.constprop.26>
 800e132:	4994      	ldr	r1, [pc, #592]	; (800e384 <transmitOnRadio+0x2c4>)
 800e134:	488e      	ldr	r0, [pc, #568]	; (800e370 <transmitOnRadio+0x2b0>)
 800e136:	f7fc faab 	bl	800a690 <chprintf.constprop.26>
 800e13a:	f994 7208 	ldrsb.w	r7, [r4, #520]	; 0x208
 800e13e:	f8d4 5204 	ldr.w	r5, [r4, #516]	; 0x204
 800e142:	4638      	mov	r0, r7
 800e144:	f7fa f9c4 	bl	80084d0 <dBm2powerLvl>
 800e148:	4a8f      	ldr	r2, [pc, #572]	; (800e388 <transmitOnRadio+0x2c8>)
 800e14a:	9001      	str	r0, [sp, #4]
 800e14c:	fba2 1205 	umull	r1, r2, r2, r5
 800e150:	4b8e      	ldr	r3, [pc, #568]	; (800e38c <transmitOnRadio+0x2cc>)
 800e152:	f894 0209 	ldrb.w	r0, [r4, #521]	; 0x209
 800e156:	498e      	ldr	r1, [pc, #568]	; (800e390 <transmitOnRadio+0x2d0>)
 800e158:	9700      	str	r7, [sp, #0]
 800e15a:	0c92      	lsrs	r2, r2, #18
 800e15c:	fb03 5312 	mls	r3, r3, r2, r5
 800e160:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 800e164:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 800e168:	9103      	str	r1, [sp, #12]
 800e16a:	fba6 5303 	umull	r5, r3, r6, r3
 800e16e:	099b      	lsrs	r3, r3, #6
 800e170:	9002      	str	r0, [sp, #8]
 800e172:	4988      	ldr	r1, [pc, #544]	; (800e394 <transmitOnRadio+0x2d4>)
 800e174:	487e      	ldr	r0, [pc, #504]	; (800e370 <transmitOnRadio+0x2b0>)
 800e176:	f7fc fa8b 	bl	800a690 <chprintf.constprop.26>
 800e17a:	4987      	ldr	r1, [pc, #540]	; (800e398 <transmitOnRadio+0x2d8>)
 800e17c:	487c      	ldr	r0, [pc, #496]	; (800e370 <transmitOnRadio+0x2b0>)
 800e17e:	f7fc fa87 	bl	800a690 <chprintf.constprop.26>
 800e182:	4878      	ldr	r0, [pc, #480]	; (800e364 <transmitOnRadio+0x2a4>)
 800e184:	f7fb f9fc 	bl	8009580 <chMtxUnlock>
		#if RADIO_BOOST
		// Switch voltage to 3.2V for transmission (increases output power by ~6dB)
		boost_voltage(HIGH);
		#endif
		
		switch(msg->mod) {
 800e188:	f894 3209 	ldrb.w	r3, [r4, #521]	; 0x209
 800e18c:	2b04      	cmp	r3, #4
 800e18e:	f200 80a2 	bhi.w	800e2d6 <transmitOnRadio+0x216>
 800e192:	e8df f013 	tbh	[pc, r3, lsl #1]
 800e196:	011b      	.short	0x011b
 800e198:	019b0158 	.word	0x019b0158
 800e19c:	00a60064 	.word	0x00a60064

		chMtxUnlock(&interference_mtx); // Heavy interference finished (HF)

	} else { // Error

		TRACE_ERROR("RAD  > No radio available for this frequency, %d.%03d MHz, %d dBm (%d), %s, %d bits",
 800e1a0:	4870      	ldr	r0, [pc, #448]	; (800e364 <transmitOnRadio+0x2a4>)
 800e1a2:	4e6f      	ldr	r6, [pc, #444]	; (800e360 <transmitOnRadio+0x2a0>)
 800e1a4:	f7fd fffc 	bl	800c1a0 <chMtxLock>
 800e1a8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e1ac:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 800e1b0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e1b2:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 800e1b4:	4b6c      	ldr	r3, [pc, #432]	; (800e368 <transmitOnRadio+0x2a8>)
 800e1b6:	496d      	ldr	r1, [pc, #436]	; (800e36c <transmitOnRadio+0x2ac>)
 800e1b8:	486d      	ldr	r0, [pc, #436]	; (800e370 <transmitOnRadio+0x2b0>)
 800e1ba:	fb07 f505 	mul.w	r5, r7, r5
 800e1be:	fba3 e505 	umull	lr, r5, r3, r5
 800e1c2:	0b6d      	lsrs	r5, r5, #13
 800e1c4:	fba3 3202 	umull	r3, r2, r3, r2
 800e1c8:	fba6 e305 	umull	lr, r3, r6, r5
 800e1cc:	099b      	lsrs	r3, r3, #6
 800e1ce:	fb07 5313 	mls	r3, r7, r3, r5
 800e1d2:	0b52      	lsrs	r2, r2, #13
 800e1d4:	f7fc fa5c 	bl	800a690 <chprintf.constprop.26>
 800e1d8:	4a70      	ldr	r2, [pc, #448]	; (800e39c <transmitOnRadio+0x2dc>)
 800e1da:	4967      	ldr	r1, [pc, #412]	; (800e378 <transmitOnRadio+0x2b8>)
 800e1dc:	4864      	ldr	r0, [pc, #400]	; (800e370 <transmitOnRadio+0x2b0>)
 800e1de:	f7fc fa57 	bl	800a690 <chprintf.constprop.26>
 800e1e2:	f44f 73b9 	mov.w	r3, #370	; 0x172
 800e1e6:	4a65      	ldr	r2, [pc, #404]	; (800e37c <transmitOnRadio+0x2bc>)
 800e1e8:	4965      	ldr	r1, [pc, #404]	; (800e380 <transmitOnRadio+0x2c0>)
 800e1ea:	4861      	ldr	r0, [pc, #388]	; (800e370 <transmitOnRadio+0x2b0>)
 800e1ec:	f7fc fa50 	bl	800a690 <chprintf.constprop.26>
 800e1f0:	4964      	ldr	r1, [pc, #400]	; (800e384 <transmitOnRadio+0x2c4>)
 800e1f2:	485f      	ldr	r0, [pc, #380]	; (800e370 <transmitOnRadio+0x2b0>)
 800e1f4:	f7fc fa4c 	bl	800a690 <chprintf.constprop.26>
 800e1f8:	f994 7208 	ldrsb.w	r7, [r4, #520]	; 0x208
 800e1fc:	f8d4 5204 	ldr.w	r5, [r4, #516]	; 0x204
 800e200:	4638      	mov	r0, r7
 800e202:	f7fa f965 	bl	80084d0 <dBm2powerLvl>
 800e206:	4a60      	ldr	r2, [pc, #384]	; (800e388 <transmitOnRadio+0x2c8>)
 800e208:	9001      	str	r0, [sp, #4]
 800e20a:	fba2 1205 	umull	r1, r2, r2, r5
 800e20e:	4b5f      	ldr	r3, [pc, #380]	; (800e38c <transmitOnRadio+0x2cc>)
 800e210:	f894 e209 	ldrb.w	lr, [r4, #521]	; 0x209
 800e214:	485e      	ldr	r0, [pc, #376]	; (800e390 <transmitOnRadio+0x2d0>)
 800e216:	f8d4 1200 	ldr.w	r1, [r4, #512]	; 0x200
 800e21a:	f850 002e 	ldr.w	r0, [r0, lr, lsl #2]
 800e21e:	9002      	str	r0, [sp, #8]
 800e220:	0c92      	lsrs	r2, r2, #18
 800e222:	fb03 5312 	mls	r3, r3, r2, r5
 800e226:	fba6 4303 	umull	r4, r3, r6, r3
 800e22a:	099b      	lsrs	r3, r3, #6
 800e22c:	9103      	str	r1, [sp, #12]
 800e22e:	9700      	str	r7, [sp, #0]
 800e230:	495b      	ldr	r1, [pc, #364]	; (800e3a0 <transmitOnRadio+0x2e0>)
 800e232:	484f      	ldr	r0, [pc, #316]	; (800e370 <transmitOnRadio+0x2b0>)
 800e234:	f7fc fa2c 	bl	800a690 <chprintf.constprop.26>
 800e238:	4957      	ldr	r1, [pc, #348]	; (800e398 <transmitOnRadio+0x2d8>)
 800e23a:	484d      	ldr	r0, [pc, #308]	; (800e370 <transmitOnRadio+0x2b0>)
 800e23c:	f7fc fa28 	bl	800a690 <chprintf.constprop.26>
 800e240:	4848      	ldr	r0, [pc, #288]	; (800e364 <transmitOnRadio+0x2a4>)
 800e242:	f7fb f99d 	bl	8009580 <chMtxUnlock>
 800e246:	f44f 71b9 	mov.w	r1, #370	; 0x172
 800e24a:	484c      	ldr	r0, [pc, #304]	; (800e37c <transmitOnRadio+0x2bc>)
 800e24c:	f7fe fb98 	bl	800c980 <log_error>
		);

	}

	// Unlock radio
	chMtxUnlock(&radio_mtx);
 800e250:	483f      	ldr	r0, [pc, #252]	; (800e350 <transmitOnRadio+0x290>)
 800e252:	f7fb f995 	bl	8009580 <chMtxUnlock>

	return true;
}
 800e256:	2001      	movs	r0, #1
 800e258:	b004      	add	sp, #16
 800e25a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if(!isRadioInitialized())
					initOOK(msg);
				sendOOK(msg);
				break;
			case MOD_DOMINOEX16:
				TRACE_ERROR("RAD  > Unimplemented modulation DominoEX16"); // TODO: Implement this
 800e25e:	4841      	ldr	r0, [pc, #260]	; (800e364 <transmitOnRadio+0x2a4>)
 800e260:	4e41      	ldr	r6, [pc, #260]	; (800e368 <transmitOnRadio+0x2a8>)
 800e262:	f7fd ff9d 	bl	800c1a0 <chMtxLock>
 800e266:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800e26a:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800e26e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800e270:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 800e272:	4b3b      	ldr	r3, [pc, #236]	; (800e360 <transmitOnRadio+0x2a0>)
 800e274:	493d      	ldr	r1, [pc, #244]	; (800e36c <transmitOnRadio+0x2ac>)
 800e276:	483e      	ldr	r0, [pc, #248]	; (800e370 <transmitOnRadio+0x2b0>)
 800e278:	fb05 f404 	mul.w	r4, r5, r4
 800e27c:	fba6 7404 	umull	r7, r4, r6, r4
 800e280:	0b64      	lsrs	r4, r4, #13
 800e282:	fba3 7304 	umull	r7, r3, r3, r4
 800e286:	fba6 6202 	umull	r6, r2, r6, r2
 800e28a:	099b      	lsrs	r3, r3, #6
 800e28c:	fb05 4313 	mls	r3, r5, r3, r4
 800e290:	0b52      	lsrs	r2, r2, #13
 800e292:	f7fc f9fd 	bl	800a690 <chprintf.constprop.26>
 800e296:	4a41      	ldr	r2, [pc, #260]	; (800e39c <transmitOnRadio+0x2dc>)
 800e298:	4937      	ldr	r1, [pc, #220]	; (800e378 <transmitOnRadio+0x2b8>)
 800e29a:	4835      	ldr	r0, [pc, #212]	; (800e370 <transmitOnRadio+0x2b0>)
 800e29c:	f7fc f9f8 	bl	800a690 <chprintf.constprop.26>
 800e2a0:	f44f 73b0 	mov.w	r3, #352	; 0x160
 800e2a4:	4a35      	ldr	r2, [pc, #212]	; (800e37c <transmitOnRadio+0x2bc>)
 800e2a6:	4936      	ldr	r1, [pc, #216]	; (800e380 <transmitOnRadio+0x2c0>)
 800e2a8:	4831      	ldr	r0, [pc, #196]	; (800e370 <transmitOnRadio+0x2b0>)
 800e2aa:	f7fc f9f1 	bl	800a690 <chprintf.constprop.26>
 800e2ae:	4935      	ldr	r1, [pc, #212]	; (800e384 <transmitOnRadio+0x2c4>)
 800e2b0:	482f      	ldr	r0, [pc, #188]	; (800e370 <transmitOnRadio+0x2b0>)
 800e2b2:	f7fc f9ed 	bl	800a690 <chprintf.constprop.26>
 800e2b6:	493b      	ldr	r1, [pc, #236]	; (800e3a4 <transmitOnRadio+0x2e4>)
 800e2b8:	482d      	ldr	r0, [pc, #180]	; (800e370 <transmitOnRadio+0x2b0>)
 800e2ba:	f7fc f9e9 	bl	800a690 <chprintf.constprop.26>
 800e2be:	4936      	ldr	r1, [pc, #216]	; (800e398 <transmitOnRadio+0x2d8>)
 800e2c0:	482b      	ldr	r0, [pc, #172]	; (800e370 <transmitOnRadio+0x2b0>)
 800e2c2:	f7fc f9e5 	bl	800a690 <chprintf.constprop.26>
 800e2c6:	4827      	ldr	r0, [pc, #156]	; (800e364 <transmitOnRadio+0x2a4>)
 800e2c8:	f7fb f95a 	bl	8009580 <chMtxUnlock>
 800e2cc:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800e2d0:	482a      	ldr	r0, [pc, #168]	; (800e37c <transmitOnRadio+0x2bc>)
 800e2d2:	f7fe fb55 	bl	800c980 <log_error>
				break;
		}

		radioShutdown(); // Shutdown radio for reinitialization
 800e2d6:	f7fa f943 	bl	8008560 <radioShutdown>
		#if RADIO_BOOST
		// Switch voltage back to 1.85V
		boost_voltage(LOW);
		#endif

		chMtxUnlock(&interference_mtx); // Heavy interference finished (HF)
 800e2da:	4820      	ldr	r0, [pc, #128]	; (800e35c <transmitOnRadio+0x29c>)
 800e2dc:	f7fb f950 	bl	8009580 <chMtxUnlock>
 800e2e0:	e7b6      	b.n	800e250 <transmitOnRadio+0x190>
		return 127;
	}
}

bool isRadioInitialized(void) {
	return initialized;
 800e2e2:	4b31      	ldr	r3, [pc, #196]	; (800e3a8 <transmitOnRadio+0x2e8>)
				break;
			case MOD_2GFSK:
				send2GFSK(msg);
				break;
			case MOD_AFSK:
				if(!isRadioInitialized())
 800e2e4:	781d      	ldrb	r5, [r3, #0]
 800e2e6:	2d00      	cmp	r5, #0
 800e2e8:	f000 814e 	beq.w	800e588 <transmitOnRadio+0x4c8>
static uint8_t current_byte = 0;
static radioMSG_t *tim_msg;
static uint32_t gfsk_bit = 0;

void sendAFSK(radioMSG_t *msg) {
	tim_msg = msg;
 800e2ec:	4b2f      	ldr	r3, [pc, #188]	; (800e3ac <transmitOnRadio+0x2ec>)

	phase_delta = PHASE_DELTA_1200;
	phase = 0;
 800e2ee:	4e30      	ldr	r6, [pc, #192]	; (800e3b0 <transmitOnRadio+0x2f0>)
	packet_pos = 0;
 800e2f0:	4d30      	ldr	r5, [pc, #192]	; (800e3b4 <transmitOnRadio+0x2f4>)
	current_sample_in_baud = 0;
 800e2f2:	4931      	ldr	r1, [pc, #196]	; (800e3b8 <transmitOnRadio+0x2f8>)
	current_byte = 0;
 800e2f4:	4a31      	ldr	r2, [pc, #196]	; (800e3bc <transmitOnRadio+0x2fc>)
static uint8_t current_byte = 0;
static radioMSG_t *tim_msg;
static uint32_t gfsk_bit = 0;

void sendAFSK(radioMSG_t *msg) {
	tim_msg = msg;
 800e2f6:	601c      	str	r4, [r3, #0]
	packet_pos = 0;
	current_sample_in_baud = 0;
	current_byte = 0;

	uint32_t initial_interval = 100; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 800e2f8:	4831      	ldr	r0, [pc, #196]	; (800e3c0 <transmitOnRadio+0x300>)
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 800e2fa:	4c32      	ldr	r4, [pc, #200]	; (800e3c4 <transmitOnRadio+0x304>)

void sendAFSK(radioMSG_t *msg) {
	tim_msg = msg;

	phase_delta = PHASE_DELTA_1200;
	phase = 0;
 800e2fc:	2300      	movs	r3, #0
 800e2fe:	6033      	str	r3, [r6, #0]
	packet_pos = 0;
 800e300:	602b      	str	r3, [r5, #0]
	current_sample_in_baud = 0;
 800e302:	600b      	str	r3, [r1, #0]
	current_byte = 0;
 800e304:	7013      	strb	r3, [r2, #0]

	uint32_t initial_interval = 100; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 800e306:	6c02      	ldr	r2, [r0, #64]	; 0x40

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800e308:	4b2f      	ldr	r3, [pc, #188]	; (800e3c8 <transmitOnRadio+0x308>)
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
	TIM7->PSC = 1;
 800e30a:	2501      	movs	r5, #1
	packet_pos = 0;
	current_sample_in_baud = 0;
	current_byte = 0;

	uint32_t initial_interval = 100; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 800e30c:	f042 0220 	orr.w	r2, r2, #32
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800e310:	f44f 0100 	mov.w	r1, #8388608	; 0x800000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800e314:	2710      	movs	r7, #16
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 800e316:	2664      	movs	r6, #100	; 0x64
	packet_pos = 0;
	current_sample_in_baud = 0;
	current_byte = 0;

	uint32_t initial_interval = 100; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 800e318:	6402      	str	r2, [r0, #64]	; 0x40
 800e31a:	f883 7337 	strb.w	r7, [r3, #823]	; 0x337
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800e31e:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800e322:	6059      	str	r1, [r3, #4]
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 800e324:	62e6      	str	r6, [r4, #44]	; 0x2c
	TIM7->PSC = 1;
 800e326:	62a5      	str	r5, [r4, #40]	; 0x28
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
 800e328:	6823      	ldr	r3, [r4, #0]
 800e32a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e32e:	6023      	str	r3, [r4, #0]
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
 800e330:	68e3      	ldr	r3, [r4, #12]
 800e332:	432b      	orrs	r3, r5
 800e334:	60e3      	str	r3, [r4, #12]
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */
 800e336:	6823      	ldr	r3, [r4, #0]
 800e338:	432b      	orrs	r3, r5
 800e33a:	6023      	str	r3, [r4, #0]

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 800e33c:	6823      	ldr	r3, [r4, #0]
 800e33e:	07da      	lsls	r2, r3, #31
 800e340:	d5c9      	bpl.n	800e2d6 <transmitOnRadio+0x216>
		chThdSleepMilliseconds(10);
 800e342:	2064      	movs	r0, #100	; 0x64
 800e344:	f7fd fffc 	bl	800c340 <chThdSleep>
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 800e348:	6823      	ldr	r3, [r4, #0]
 800e34a:	07db      	lsls	r3, r3, #31
 800e34c:	d4f9      	bmi.n	800e342 <transmitOnRadio+0x282>
 800e34e:	e7c2      	b.n	800e2d6 <transmitOnRadio+0x216>
 800e350:	20019950 	.word	0x20019950
 800e354:	f76abc00 	.word	0xf76abc00
 800e358:	003d0900 	.word	0x003d0900
 800e35c:	2001aa1c 	.word	0x2001aa1c
 800e360:	10624dd3 	.word	0x10624dd3
 800e364:	2001b720 	.word	0x2001b720
 800e368:	d1b71759 	.word	0xd1b71759
 800e36c:	0800ea50 	.word	0x0800ea50
 800e370:	2001ac28 	.word	0x2001ac28
 800e374:	0800f1dc 	.word	0x0800f1dc
 800e378:	0800ea64 	.word	0x0800ea64
 800e37c:	080106ac 	.word	0x080106ac
 800e380:	0800ea7c 	.word	0x0800ea7c
 800e384:	0800f1e0 	.word	0x0800f1e0
 800e388:	431bde83 	.word	0x431bde83
 800e38c:	000f4240 	.word	0x000f4240
 800e390:	080116b8 	.word	0x080116b8
 800e394:	080116cc 	.word	0x080116cc
 800e398:	0800eaa8 	.word	0x0800eaa8
 800e39c:	0800ea5c 	.word	0x0800ea5c
 800e3a0:	08011730 	.word	0x08011730
 800e3a4:	08011704 	.word	0x08011704
 800e3a8:	2001b754 	.word	0x2001b754
 800e3ac:	2001b748 	.word	0x2001b748
 800e3b0:	2001b770 	.word	0x2001b770
 800e3b4:	2001b734 	.word	0x2001b734
 800e3b8:	2001b740 	.word	0x2001b740
 800e3bc:	2001b73c 	.word	0x2001b73c
 800e3c0:	40023800 	.word	0x40023800
 800e3c4:	40001400 	.word	0x40001400
 800e3c8:	e000e100 	.word	0xe000e100
 800e3cc:	4b74      	ldr	r3, [pc, #464]	; (800e5a0 <transmitOnRadio+0x4e0>)
				if(!isRadioInitialized())
					initAFSK(msg);
				sendAFSK(msg);
				break;
			case MOD_OOK:
				if(!isRadioInitialized())
 800e3ce:	781d      	ldrb	r5, [r3, #0]
 800e3d0:	2d00      	cmp	r5, #0
 800e3d2:	f000 80ce 	beq.w	800e572 <transmitOnRadio+0x4b2>
 800e3d6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  */
void sendOOK(radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 800e3da:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 800e3de:	6a50      	ldr	r0, [r2, #36]	; 0x24
 800e3e0:	2b00      	cmp	r3, #0
 800e3e2:	f43f af78 	beq.w	800e2d6 <transmitOnRadio+0x216>
		MOD_GPIO_SET((msg->msg[bit/8] >> (bit%8)) & 0x1);
 800e3e6:	4f6f      	ldr	r7, [pc, #444]	; (800e5a4 <transmitOnRadio+0x4e4>)
		bit++;

		time = chThdSleepUntilWindowed(time, time + MS2ST(1200 / msg->ook_config->speed));
 800e3e8:	4e6f      	ldr	r6, [pc, #444]	; (800e5a8 <transmitOnRadio+0x4e8>)
  */
void sendOOK(radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 800e3ea:	f04f 0800 	mov.w	r8, #0
		MOD_GPIO_SET((msg->msg[bit/8] >> (bit%8)) & 0x1);
		bit++;

		time = chThdSleepUntilWindowed(time, time + MS2ST(1200 / msg->ook_config->speed));
 800e3ee:	f44f 6596 	mov.w	r5, #1200	; 0x4b0
void sendOOK(radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
		MOD_GPIO_SET((msg->msg[bit/8] >> (bit%8)) & 0x1);
 800e3f2:	ea4f 03d8 	mov.w	r3, r8, lsr #3
 800e3f6:	f008 0207 	and.w	r2, r8, #7
 800e3fa:	5ce3      	ldrb	r3, [r4, r3]
 800e3fc:	4113      	asrs	r3, r2
 800e3fe:	f013 0f01 	tst.w	r3, #1
 800e402:	ea4f 2383 	mov.w	r3, r3, lsl #10
 800e406:	bf0c      	ite	eq
 800e408:	f04f 6280 	moveq.w	r2, #67108864	; 0x4000000
 800e40c:	2200      	movne	r2, #0
 800e40e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800e412:	4313      	orrs	r3, r2
 800e414:	61bb      	str	r3, [r7, #24]
		bit++;

		time = chThdSleepUntilWindowed(time, time + MS2ST(1200 / msg->ook_config->speed));
 800e416:	f8d4 220c 	ldr.w	r2, [r4, #524]	; 0x20c
 800e41a:	f242 7310 	movw	r3, #10000	; 0x2710
 800e41e:	7811      	ldrb	r1, [r2, #0]
 800e420:	fb95 f1f1 	sdiv	r1, r5, r1
 800e424:	fb03 f101 	mul.w	r1, r3, r1
 800e428:	f201 31e7 	addw	r1, r1, #999	; 0x3e7
 800e42c:	fba6 3101 	umull	r3, r1, r6, r1
 800e430:	eb00 1191 	add.w	r1, r0, r1, lsr #6
 800e434:	f7fd ff4c 	bl	800c2d0 <chThdSleepUntilWindowed>
  */
void sendOOK(radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 800e438:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
		MOD_GPIO_SET((msg->msg[bit/8] >> (bit%8)) & 0x1);
		bit++;
 800e43c:	f108 0801 	add.w	r8, r8, #1
  */
void sendOOK(radioMSG_t *msg) {
	// Transmit data
	uint32_t bit = 0;
	systime_t time = chVTGetSystemTimeX();
	while(bit < msg->bin_len) {
 800e440:	4598      	cmp	r8, r3
 800e442:	d3d6      	bcc.n	800e3f2 <transmitOnRadio+0x332>
 800e444:	e747      	b.n	800e2d6 <transmitOnRadio+0x216>
 800e446:	4b56      	ldr	r3, [pc, #344]	; (800e5a0 <transmitOnRadio+0x4e0>)
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 800e448:	4e58      	ldr	r6, [pc, #352]	; (800e5ac <transmitOnRadio+0x4ec>)
		boost_voltage(HIGH);
		#endif
		
		switch(msg->mod) {
			case MOD_2FSK:
				if(!isRadioInitialized())
 800e44a:	781b      	ldrb	r3, [r3, #0]
 800e44c:	2b00      	cmp	r3, #0
 800e44e:	d07e      	beq.n	800e54e <transmitOnRadio+0x48e>
	radioTune(msg->freq, msg->fsk_config->shift, msg->power, 0);
}

void send2FSK(radioMSG_t *msg) {
	// Prepare serial machine states
	txs = 6;
 800e450:	4d57      	ldr	r5, [pc, #348]	; (800e5b0 <transmitOnRadio+0x4f0>)
	txc = 0;
 800e452:	4f58      	ldr	r7, [pc, #352]	; (800e5b4 <transmitOnRadio+0x4f4>)
	txi = 0;
 800e454:	4858      	ldr	r0, [pc, #352]	; (800e5b8 <transmitOnRadio+0x4f8>)
	txj = 0;
 800e456:	4959      	ldr	r1, [pc, #356]	; (800e5bc <transmitOnRadio+0x4fc>)
	fsk_msg = msg;
 800e458:	4a59      	ldr	r2, [pc, #356]	; (800e5c0 <transmitOnRadio+0x500>)
	radioTune(msg->freq, msg->fsk_config->shift, msg->power, 0);
}

void send2FSK(radioMSG_t *msg) {
	// Prepare serial machine states
	txs = 6;
 800e45a:	2306      	movs	r3, #6
 800e45c:	702b      	strb	r3, [r5, #0]
	txc = 0;
 800e45e:	2300      	movs	r3, #0
 800e460:	703b      	strb	r3, [r7, #0]
	txi = 0;
 800e462:	6003      	str	r3, [r0, #0]
	txj = 0;
 800e464:	600b      	str	r3, [r1, #0]
	fsk_msg = msg;
 800e466:	6014      	str	r4, [r2, #0]
 800e468:	2320      	movs	r3, #32
 800e46a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800e46e:	f7fd fe87 	bl	800c180 <_dbg_check_lock>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 800e472:	f7fd fbdd 	bl	800bc30 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800e476:	68f3      	ldr	r3, [r6, #12]
 800e478:	b113      	cbz	r3, 800e480 <transmitOnRadio+0x3c0>
    chVTDoResetI(vtp);
 800e47a:	484c      	ldr	r0, [pc, #304]	; (800e5ac <transmitOnRadio+0x4ec>)
 800e47c:	f7fd fce0 	bl	800be40 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 800e480:	2300      	movs	r3, #0
 800e482:	4a50      	ldr	r2, [pc, #320]	; (800e5c4 <transmitOnRadio+0x504>)
 800e484:	4849      	ldr	r0, [pc, #292]	; (800e5ac <transmitOnRadio+0x4ec>)
 800e486:	2101      	movs	r1, #1
 800e488:	f7fd fd22 	bl	800bed0 <chVTDoSetI>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800e48c:	f7fd fe68 	bl	800c160 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800e490:	4b4d      	ldr	r3, [pc, #308]	; (800e5c8 <transmitOnRadio+0x508>)
 800e492:	681a      	ldr	r2, [r3, #0]
 800e494:	429a      	cmp	r2, r3
 800e496:	d004      	beq.n	800e4a2 <transmitOnRadio+0x3e2>
 800e498:	6999      	ldr	r1, [r3, #24]
 800e49a:	6893      	ldr	r3, [r2, #8]
 800e49c:	688a      	ldr	r2, [r1, #8]
 800e49e:	429a      	cmp	r2, r3
 800e4a0:	d352      	bcc.n	800e548 <transmitOnRadio+0x488>
 800e4a2:	2300      	movs	r3, #0
 800e4a4:	f383 8811 	msr	BASEPRI, r3

	// Modulate
	chVTSet(&vt, 1, serial_cb, NULL);	// Start timer
	while(txs)
 800e4a8:	782b      	ldrb	r3, [r5, #0]
 800e4aa:	2b00      	cmp	r3, #0
 800e4ac:	f43f af13 	beq.w	800e2d6 <transmitOnRadio+0x216>
		chThdSleepMilliseconds(1);		// Wait for routine to finish
 800e4b0:	200a      	movs	r0, #10
 800e4b2:	f7fd ff45 	bl	800c340 <chThdSleep>
	txj = 0;
	fsk_msg = msg;

	// Modulate
	chVTSet(&vt, 1, serial_cb, NULL);	// Start timer
	while(txs)
 800e4b6:	782b      	ldrb	r3, [r5, #0]
 800e4b8:	2b00      	cmp	r3, #0
 800e4ba:	f43f af0c 	beq.w	800e2d6 <transmitOnRadio+0x216>
		chThdSleepMilliseconds(1);		// Wait for routine to finish
 800e4be:	200a      	movs	r0, #10
 800e4c0:	f7fd ff3e 	bl	800c340 <chThdSleep>
	txj = 0;
	fsk_msg = msg;

	// Modulate
	chVTSet(&vt, 1, serial_cb, NULL);	// Start timer
	while(txs)
 800e4c4:	782b      	ldrb	r3, [r5, #0]
 800e4c6:	2b00      	cmp	r3, #0
 800e4c8:	d1f2      	bne.n	800e4b0 <transmitOnRadio+0x3f0>
 800e4ca:	e704      	b.n	800e2d6 <transmitOnRadio+0x216>
}

void send2GFSK(radioMSG_t *msg) {
	tim_msg = msg;
	gfsk_bit = 0;
	current_byte = 0;
 800e4cc:	4b3f      	ldr	r3, [pc, #252]	; (800e5cc <transmitOnRadio+0x50c>)
	while(txs)
		chThdSleepMilliseconds(1);		// Wait for routine to finish
}

void send2GFSK(radioMSG_t *msg) {
	tim_msg = msg;
 800e4ce:	4940      	ldr	r1, [pc, #256]	; (800e5d0 <transmitOnRadio+0x510>)
	gfsk_bit = 0;
 800e4d0:	4a40      	ldr	r2, [pc, #256]	; (800e5d4 <transmitOnRadio+0x514>)
	while(txs)
		chThdSleepMilliseconds(1);		// Wait for routine to finish
}

void send2GFSK(radioMSG_t *msg) {
	tim_msg = msg;
 800e4d2:	600c      	str	r4, [r1, #0]
	gfsk_bit = 0;
 800e4d4:	2500      	movs	r5, #0
	current_byte = 0;

	// Initialize radio and tune
	Si4464_Init(MOD_2GFSK);
 800e4d6:	2002      	movs	r0, #2
}

void send2GFSK(radioMSG_t *msg) {
	tim_msg = msg;
	gfsk_bit = 0;
	current_byte = 0;
 800e4d8:	701d      	strb	r5, [r3, #0]
		chThdSleepMilliseconds(1);		// Wait for routine to finish
}

void send2GFSK(radioMSG_t *msg) {
	tim_msg = msg;
	gfsk_bit = 0;
 800e4da:	6015      	str	r5, [r2, #0]
	current_byte = 0;

	// Initialize radio and tune
	Si4464_Init(MOD_2GFSK);
 800e4dc:	f7fa f8a8 	bl	8008630 <Si4464_Init>
	radioTune(msg->freq, 0, msg->power, 0);
 800e4e0:	4629      	mov	r1, r5
 800e4e2:	f994 2208 	ldrsb.w	r2, [r4, #520]	; 0x208
 800e4e6:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
	chThdSleepMilliseconds(30);

	uint32_t initial_interval = 1355; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 800e4ea:	4c3b      	ldr	r4, [pc, #236]	; (800e5d8 <transmitOnRadio+0x518>)
	gfsk_bit = 0;
	current_byte = 0;

	// Initialize radio and tune
	Si4464_Init(MOD_2GFSK);
	radioTune(msg->freq, 0, msg->power, 0);
 800e4ec:	f7fe ff70 	bl	800d3d0 <radioTune.constprop.10>
	chThdSleepMilliseconds(30);
 800e4f0:	f44f 7096 	mov.w	r0, #300	; 0x12c
 800e4f4:	f7fd ff24 	bl	800c340 <chThdSleep>

	uint32_t initial_interval = 1355; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 800e4f8:	4838      	ldr	r0, [pc, #224]	; (800e5dc <transmitOnRadio+0x51c>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800e4fa:	4b39      	ldr	r3, [pc, #228]	; (800e5e0 <transmitOnRadio+0x520>)
 800e4fc:	6c02      	ldr	r2, [r0, #64]	; 0x40
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
	TIM7->PSC = 1;
 800e4fe:	2501      	movs	r5, #1
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800e500:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
	Si4464_Init(MOD_2GFSK);
	radioTune(msg->freq, 0, msg->power, 0);
	chThdSleepMilliseconds(30);

	uint32_t initial_interval = 1355; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 800e504:	f042 0220 	orr.w	r2, r2, #32

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800e508:	2710      	movs	r7, #16
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 800e50a:	f240 564b 	movw	r6, #1355	; 0x54b
	Si4464_Init(MOD_2GFSK);
	radioTune(msg->freq, 0, msg->power, 0);
	chThdSleepMilliseconds(30);

	uint32_t initial_interval = 1355; // in timer ticks
	RCC->APB1ENR |= RCC_APB1ENR_TIM7EN;
 800e50e:	6402      	str	r2, [r0, #64]	; 0x40
 800e510:	f883 7337 	strb.w	r7, [r3, #823]	; 0x337
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800e514:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800e518:	6059      	str	r1, [r3, #4]
	nvicEnableVector(TIM7_IRQn, 1/*priority*/);
	TIM7->ARR = initial_interval; /* Timer's period */
 800e51a:	62e6      	str	r6, [r4, #44]	; 0x2c
	TIM7->PSC = 1;
 800e51c:	62a5      	str	r5, [r4, #40]	; 0x28
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
 800e51e:	6823      	ldr	r3, [r4, #0]
 800e520:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800e524:	6023      	str	r3, [r4, #0]
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
 800e526:	68e3      	ldr	r3, [r4, #12]
 800e528:	432b      	orrs	r3, r5
 800e52a:	60e3      	str	r3, [r4, #12]
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */
 800e52c:	6823      	ldr	r3, [r4, #0]
 800e52e:	432b      	orrs	r3, r5
 800e530:	6023      	str	r3, [r4, #0]

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 800e532:	6823      	ldr	r3, [r4, #0]
 800e534:	07d8      	lsls	r0, r3, #31
 800e536:	f57f aece 	bpl.w	800e2d6 <transmitOnRadio+0x216>
		chThdSleepMilliseconds(10);
 800e53a:	2064      	movs	r0, #100	; 0x64
 800e53c:	f7fd ff00 	bl	800c340 <chThdSleep>
	TIM7->CR1 &= ~STM32_TIM_CR1_ARPE; /* ARR register is NOT buffered, allows to update timer's period on-fly. */
	TIM7->DIER |= STM32_TIM_DIER_UIE; /* Interrupt enable */
	TIM7->CR1 |= STM32_TIM_CR1_CEN; /* Counter enable */

	// Block execution while timer is running
	while(TIM7->CR1 & STM32_TIM_CR1_CEN)
 800e540:	6823      	ldr	r3, [r4, #0]
 800e542:	07d9      	lsls	r1, r3, #31
 800e544:	d4f9      	bmi.n	800e53a <transmitOnRadio+0x47a>
 800e546:	e6c6      	b.n	800e2d6 <transmitOnRadio+0x216>
 800e548:	4826      	ldr	r0, [pc, #152]	; (800e5e4 <transmitOnRadio+0x524>)
 800e54a:	f7fd fb11 	bl	800bb70 <chSysHalt>
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 800e54e:	60f3      	str	r3, [r6, #12]
void init2FSK(radioMSG_t *msg) {
	// Initialize virtual timer
	chVTObjectInit(&vt);

	// Initialize radio and tune
	Si4464_Init(MOD_2FSK);
 800e550:	2001      	movs	r0, #1
 800e552:	f7fa f86d 	bl	8008630 <Si4464_Init>
	MOD_GPIO_SET(HIGH);
 800e556:	4b13      	ldr	r3, [pc, #76]	; (800e5a4 <transmitOnRadio+0x4e4>)
 800e558:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800e55c:	619a      	str	r2, [r3, #24]
	radioTune(msg->freq, msg->fsk_config->shift, msg->power, 0);
 800e55e:	f8d4 3210 	ldr.w	r3, [r4, #528]	; 0x210
 800e562:	f994 2208 	ldrsb.w	r2, [r4, #520]	; 0x208
 800e566:	88d9      	ldrh	r1, [r3, #6]
 800e568:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
 800e56c:	f7fe ff30 	bl	800d3d0 <radioTune.constprop.10>
 800e570:	e76e      	b.n	800e450 <transmitOnRadio+0x390>
	TIM7->SR &= ~STM32_TIM_SR_UIF;						// Reset interrupt flag
}

void initOOK(radioMSG_t *msg) {
	// Initialize radio and tune
	Si4464_Init(MOD_OOK);
 800e572:	4628      	mov	r0, r5
 800e574:	f7fa f85c 	bl	8008630 <Si4464_Init>
	radioTune(msg->freq, 0, msg->power, 0);
 800e578:	4629      	mov	r1, r5
 800e57a:	f994 2208 	ldrsb.w	r2, [r4, #520]	; 0x208
 800e57e:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
 800e582:	f7fe ff25 	bl	800d3d0 <radioTune.constprop.10>
 800e586:	e726      	b.n	800e3d6 <transmitOnRadio+0x316>

mutex_t radio_mtx;                             // Radio mutex

void initAFSK(radioMSG_t *msg) {
	// Initialize radio and tune
	Si4464_Init(MOD_AFSK);
 800e588:	2004      	movs	r0, #4
 800e58a:	f7fa f851 	bl	8008630 <Si4464_Init>
	radioTune(msg->freq, 0, msg->power, 0);
 800e58e:	4629      	mov	r1, r5
 800e590:	f994 2208 	ldrsb.w	r2, [r4, #520]	; 0x208
 800e594:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
 800e598:	f7fe ff1a 	bl	800d3d0 <radioTune.constprop.10>
 800e59c:	e6a6      	b.n	800e2ec <transmitOnRadio+0x22c>
 800e59e:	bf00      	nop
 800e5a0:	2001b754 	.word	0x2001b754
 800e5a4:	40020c00 	.word	0x40020c00
 800e5a8:	10624dd3 	.word	0x10624dd3
 800e5ac:	2001b758 	.word	0x2001b758
 800e5b0:	2001b76c 	.word	0x2001b76c
 800e5b4:	2001b76d 	.word	0x2001b76d
 800e5b8:	2001b74c 	.word	0x2001b74c
 800e5bc:	2001b750 	.word	0x2001b750
 800e5c0:	2001b744 	.word	0x2001b744
 800e5c4:	0800df21 	.word	0x0800df21
 800e5c8:	2001acdc 	.word	0x2001acdc
 800e5cc:	2001b73c 	.word	0x2001b73c
 800e5d0:	2001b748 	.word	0x2001b748
 800e5d4:	2001b738 	.word	0x2001b738
 800e5d8:	40001400 	.word	0x40001400
 800e5dc:	40023800 	.word	0x40023800
 800e5e0:	e000e100 	.word	0xe000e100
 800e5e4:	08011a10 	.word	0x08011a10

0800e5e8 <memmove>:
 800e5e8:	4288      	cmp	r0, r1
 800e5ea:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e5ec:	d90d      	bls.n	800e60a <memmove+0x22>
 800e5ee:	188b      	adds	r3, r1, r2
 800e5f0:	4298      	cmp	r0, r3
 800e5f2:	d20a      	bcs.n	800e60a <memmove+0x22>
 800e5f4:	1881      	adds	r1, r0, r2
 800e5f6:	2a00      	cmp	r2, #0
 800e5f8:	d051      	beq.n	800e69e <memmove+0xb6>
 800e5fa:	1a9a      	subs	r2, r3, r2
 800e5fc:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800e600:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800e604:	4293      	cmp	r3, r2
 800e606:	d1f9      	bne.n	800e5fc <memmove+0x14>
 800e608:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e60a:	2a0f      	cmp	r2, #15
 800e60c:	d948      	bls.n	800e6a0 <memmove+0xb8>
 800e60e:	ea41 0300 	orr.w	r3, r1, r0
 800e612:	079b      	lsls	r3, r3, #30
 800e614:	d146      	bne.n	800e6a4 <memmove+0xbc>
 800e616:	f100 0410 	add.w	r4, r0, #16
 800e61a:	f101 0310 	add.w	r3, r1, #16
 800e61e:	4615      	mov	r5, r2
 800e620:	f853 6c10 	ldr.w	r6, [r3, #-16]
 800e624:	f844 6c10 	str.w	r6, [r4, #-16]
 800e628:	f853 6c0c 	ldr.w	r6, [r3, #-12]
 800e62c:	f844 6c0c 	str.w	r6, [r4, #-12]
 800e630:	f853 6c08 	ldr.w	r6, [r3, #-8]
 800e634:	f844 6c08 	str.w	r6, [r4, #-8]
 800e638:	3d10      	subs	r5, #16
 800e63a:	f853 6c04 	ldr.w	r6, [r3, #-4]
 800e63e:	f844 6c04 	str.w	r6, [r4, #-4]
 800e642:	2d0f      	cmp	r5, #15
 800e644:	f103 0310 	add.w	r3, r3, #16
 800e648:	f104 0410 	add.w	r4, r4, #16
 800e64c:	d8e8      	bhi.n	800e620 <memmove+0x38>
 800e64e:	f1a2 0310 	sub.w	r3, r2, #16
 800e652:	f023 030f 	bic.w	r3, r3, #15
 800e656:	f002 0e0f 	and.w	lr, r2, #15
 800e65a:	3310      	adds	r3, #16
 800e65c:	f1be 0f03 	cmp.w	lr, #3
 800e660:	4419      	add	r1, r3
 800e662:	4403      	add	r3, r0
 800e664:	d921      	bls.n	800e6aa <memmove+0xc2>
 800e666:	1f1e      	subs	r6, r3, #4
 800e668:	460d      	mov	r5, r1
 800e66a:	4674      	mov	r4, lr
 800e66c:	3c04      	subs	r4, #4
 800e66e:	f855 7b04 	ldr.w	r7, [r5], #4
 800e672:	f846 7f04 	str.w	r7, [r6, #4]!
 800e676:	2c03      	cmp	r4, #3
 800e678:	d8f8      	bhi.n	800e66c <memmove+0x84>
 800e67a:	f1ae 0404 	sub.w	r4, lr, #4
 800e67e:	f024 0403 	bic.w	r4, r4, #3
 800e682:	3404      	adds	r4, #4
 800e684:	4423      	add	r3, r4
 800e686:	4421      	add	r1, r4
 800e688:	f002 0203 	and.w	r2, r2, #3
 800e68c:	b162      	cbz	r2, 800e6a8 <memmove+0xc0>
 800e68e:	3b01      	subs	r3, #1
 800e690:	440a      	add	r2, r1
 800e692:	f811 4b01 	ldrb.w	r4, [r1], #1
 800e696:	f803 4f01 	strb.w	r4, [r3, #1]!
 800e69a:	428a      	cmp	r2, r1
 800e69c:	d1f9      	bne.n	800e692 <memmove+0xaa>
 800e69e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e6a0:	4603      	mov	r3, r0
 800e6a2:	e7f3      	b.n	800e68c <memmove+0xa4>
 800e6a4:	4603      	mov	r3, r0
 800e6a6:	e7f2      	b.n	800e68e <memmove+0xa6>
 800e6a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e6aa:	4672      	mov	r2, lr
 800e6ac:	e7ee      	b.n	800e68c <memmove+0xa4>
 800e6ae:	bf00      	nop

0800e6b0 <memset>:
 800e6b0:	b470      	push	{r4, r5, r6}
 800e6b2:	0784      	lsls	r4, r0, #30
 800e6b4:	d046      	beq.n	800e744 <memset+0x94>
 800e6b6:	1e54      	subs	r4, r2, #1
 800e6b8:	2a00      	cmp	r2, #0
 800e6ba:	d041      	beq.n	800e740 <memset+0x90>
 800e6bc:	b2cd      	uxtb	r5, r1
 800e6be:	4603      	mov	r3, r0
 800e6c0:	e002      	b.n	800e6c8 <memset+0x18>
 800e6c2:	1e62      	subs	r2, r4, #1
 800e6c4:	b3e4      	cbz	r4, 800e740 <memset+0x90>
 800e6c6:	4614      	mov	r4, r2
 800e6c8:	f803 5b01 	strb.w	r5, [r3], #1
 800e6cc:	079a      	lsls	r2, r3, #30
 800e6ce:	d1f8      	bne.n	800e6c2 <memset+0x12>
 800e6d0:	2c03      	cmp	r4, #3
 800e6d2:	d92e      	bls.n	800e732 <memset+0x82>
 800e6d4:	b2cd      	uxtb	r5, r1
 800e6d6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800e6da:	2c0f      	cmp	r4, #15
 800e6dc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800e6e0:	d919      	bls.n	800e716 <memset+0x66>
 800e6e2:	f103 0210 	add.w	r2, r3, #16
 800e6e6:	4626      	mov	r6, r4
 800e6e8:	3e10      	subs	r6, #16
 800e6ea:	2e0f      	cmp	r6, #15
 800e6ec:	f842 5c10 	str.w	r5, [r2, #-16]
 800e6f0:	f842 5c0c 	str.w	r5, [r2, #-12]
 800e6f4:	f842 5c08 	str.w	r5, [r2, #-8]
 800e6f8:	f842 5c04 	str.w	r5, [r2, #-4]
 800e6fc:	f102 0210 	add.w	r2, r2, #16
 800e700:	d8f2      	bhi.n	800e6e8 <memset+0x38>
 800e702:	f1a4 0210 	sub.w	r2, r4, #16
 800e706:	f022 020f 	bic.w	r2, r2, #15
 800e70a:	f004 040f 	and.w	r4, r4, #15
 800e70e:	3210      	adds	r2, #16
 800e710:	2c03      	cmp	r4, #3
 800e712:	4413      	add	r3, r2
 800e714:	d90d      	bls.n	800e732 <memset+0x82>
 800e716:	461e      	mov	r6, r3
 800e718:	4622      	mov	r2, r4
 800e71a:	3a04      	subs	r2, #4
 800e71c:	2a03      	cmp	r2, #3
 800e71e:	f846 5b04 	str.w	r5, [r6], #4
 800e722:	d8fa      	bhi.n	800e71a <memset+0x6a>
 800e724:	1f22      	subs	r2, r4, #4
 800e726:	f022 0203 	bic.w	r2, r2, #3
 800e72a:	3204      	adds	r2, #4
 800e72c:	4413      	add	r3, r2
 800e72e:	f004 0403 	and.w	r4, r4, #3
 800e732:	b12c      	cbz	r4, 800e740 <memset+0x90>
 800e734:	b2c9      	uxtb	r1, r1
 800e736:	441c      	add	r4, r3
 800e738:	f803 1b01 	strb.w	r1, [r3], #1
 800e73c:	42a3      	cmp	r3, r4
 800e73e:	d1fb      	bne.n	800e738 <memset+0x88>
 800e740:	bc70      	pop	{r4, r5, r6}
 800e742:	4770      	bx	lr
 800e744:	4614      	mov	r4, r2
 800e746:	4603      	mov	r3, r0
 800e748:	e7c2      	b.n	800e6d0 <memset+0x20>
 800e74a:	bf00      	nop
